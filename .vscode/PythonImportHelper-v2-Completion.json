[
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "listdir",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "lstat",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "stat",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "strerror",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "listdir",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "version_info",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "copytree",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "process_command_files",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "process_command_files",
        "description": "process_command_files",
        "detail": "process_command_files",
        "documentation": {}
    },
    {
        "label": "java_command_file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "java_command_file",
        "description": "java_command_file",
        "detail": "java_command_file",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "islink",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "ENOENT",
        "importPath": "errno",
        "description": "errno",
        "isExtraImport": true,
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "shlex",
        "description": "shlex",
        "isExtraImport": true,
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "Formatter",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "digits",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "urllib2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib2",
        "description": "urllib2",
        "detail": "urllib2",
        "documentation": {}
    },
    {
        "label": "retry",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "retry",
        "description": "retry",
        "detail": "retry",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "chain",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "fetch_from",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fetch_from",
        "description": "fetch_from",
        "detail": "fetch_from",
        "documentation": {}
    },
    {
        "label": "process_whole_archive_option",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "process_whole_archive_option",
        "description": "process_whole_archive_option",
        "detail": "process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "ProcessWholeArchiveOption",
        "importPath": "process_whole_archive_option",
        "description": "process_whole_archive_option",
        "isExtraImport": true,
        "detail": "process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "ProcessWholeArchiveOption",
        "importPath": "process_whole_archive_option",
        "description": "process_whole_archive_option",
        "isExtraImport": true,
        "detail": "process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "ProcessWholeArchiveOption",
        "importPath": "process_whole_archive_option",
        "description": "process_whole_archive_option",
        "isExtraImport": true,
        "detail": "process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "fix_py2",
        "importPath": "fix_py2_protobuf",
        "description": "fix_py2_protobuf",
        "isExtraImport": true,
        "detail": "fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "fix_py2",
        "importPath": "fix_py2_protobuf",
        "description": "fix_py2_protobuf",
        "isExtraImport": true,
        "detail": "fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "fix_py2",
        "importPath": "fix_py2_protobuf",
        "description": "fix_py2_protobuf",
        "isExtraImport": true,
        "detail": "fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "pipes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pipes",
        "description": "pipes",
        "detail": "pipes",
        "documentation": {}
    },
    {
        "label": "thinlto_cache",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "thinlto_cache",
        "description": "thinlto_cache",
        "detail": "thinlto_cache",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "marshal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "marshal",
        "description": "marshal",
        "detail": "marshal",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "T",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "KT",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "VT",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "runtime_checkable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_IFDIR",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_IFLNK",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "S_IFREG",
        "importPath": "stat",
        "description": "stat",
        "isExtraImport": true,
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "urlsafe_b64encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "yatest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yatest",
        "description": "yatest",
        "detail": "yatest",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "read_csv",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "DataFrame",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "read_csv",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "DataFrame",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "Series",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "pandas",
        "description": "pandas",
        "isExtraImport": true,
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "exp",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "config",
        "description": "config",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "CATBOOST_TEST_DATA_DIR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "CATBOOST_TEST_DATA_DIR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "CATBOOST_APP_PATH",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "experiment_lib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "experiment_lib",
        "description": "experiment_lib",
        "detail": "experiment_lib",
        "documentation": {}
    },
    {
        "label": "catboost",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "catboost",
        "description": "catboost",
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoost",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoost",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoost",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoost",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostRegressor",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostRanker",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "CatBoostError",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "EFeaturesSelectionAlgorithm",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "EFeaturesSelectionGrouping",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "EFstrType",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "FeaturesData",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "cv",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "metrics",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "sum_models",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "train",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "sample_gaussian_process",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "_have_equal_features",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "to_regressor",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "to_classifier",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "to_ranker",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "MultiTargetCustomMetric",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "MultiTargetCustomObjective",
        "importPath": "catboost",
        "description": "catboost",
        "isExtraImport": true,
        "detail": "catboost",
        "documentation": {}
    },
    {
        "label": "scipy.stats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "PicklingError",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "HIGHEST_PROTOCOL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "hp",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "fmin",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "tpe",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "Trials",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "STATUS_OK",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "STATUS_FAIL",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "hp",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "fmin",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "tpe",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "Trials",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "STATUS_OK",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "STATUS_FAIL",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "hp",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "hp",
        "importPath": "hyperopt",
        "description": "hyperopt",
        "isExtraImport": true,
        "detail": "hyperopt",
        "documentation": {}
    },
    {
        "label": "TimeSeriesSplit",
        "importPath": "sklearn.model_selection._split",
        "description": "sklearn.model_selection._split",
        "isExtraImport": true,
        "detail": "sklearn.model_selection._split",
        "documentation": {}
    },
    {
        "label": "lightgbm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lightgbm",
        "description": "lightgbm",
        "detail": "lightgbm",
        "documentation": {}
    },
    {
        "label": "xgboost",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xgboost",
        "description": "xgboost",
        "detail": "xgboost",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomizedSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "TimeSeriesSplit",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "ParameterGrid",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "ParameterGrid",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "KFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "calendar",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "calendar",
        "description": "calendar",
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "timeit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "timeit",
        "description": "timeit",
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "default_timer",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "experiment",
        "description": "experiment",
        "isExtraImport": true,
        "detail": "experiment",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "experiment",
        "description": "experiment",
        "isExtraImport": true,
        "detail": "experiment",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "experiment",
        "description": "experiment",
        "isExtraImport": true,
        "detail": "experiment",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "experiment",
        "description": "experiment",
        "isExtraImport": true,
        "detail": "experiment",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "experiment",
        "description": "experiment",
        "isExtraImport": true,
        "detail": "experiment",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "pickle,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle.",
        "description": "pickle.",
        "detail": "pickle.",
        "documentation": {}
    },
    {
        "label": "CatCounter",
        "importPath": "cat_counter",
        "description": "cat_counter",
        "isExtraImport": true,
        "detail": "cat_counter",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utils",
        "description": "utils",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_dataset",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "mean_ndcg",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ndcg",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "make_scorer",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "r2_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "ndcg_score",
        "importPath": "ndcg_kaggle",
        "description": "ndcg_kaggle",
        "isExtraImport": true,
        "detail": "ndcg_kaggle",
        "documentation": {}
    },
    {
        "label": "load_svmlight_file",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "cmp_to_key",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "EXPERIMENTS",
        "importPath": "experiments",
        "description": "experiments",
        "isExtraImport": true,
        "detail": "experiments",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "experiments",
        "description": "experiments",
        "isExtraImport": true,
        "detail": "experiments",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "learners",
        "description": "learners",
        "isExtraImport": true,
        "detail": "learners",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "learners",
        "description": "learners",
        "isExtraImport": true,
        "detail": "learners",
        "documentation": {}
    },
    {
        "label": "get_experiment_stats",
        "importPath": "generate_report",
        "description": "generate_report",
        "isExtraImport": true,
        "detail": "generate_report",
        "documentation": {}
    },
    {
        "label": "print_all_in_one_table",
        "importPath": "generate_report",
        "description": "generate_report",
        "isExtraImport": true,
        "detail": "generate_report",
        "documentation": {}
    },
    {
        "label": "bz2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bz2",
        "description": "bz2",
        "detail": "bz2",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "sklearn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sklearn",
        "description": "sklearn",
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "datasets",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "metrics",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "get_dataset",
        "importPath": "data_loader",
        "description": "data_loader",
        "isExtraImport": true,
        "detail": "data_loader",
        "documentation": {}
    },
    {
        "label": "DATASET_CHARACTERISTIC",
        "importPath": "data_loader",
        "description": "data_loader",
        "isExtraImport": true,
        "detail": "data_loader",
        "documentation": {}
    },
    {
        "label": "parse_log",
        "importPath": "log_parser",
        "description": "log_parser",
        "isExtraImport": true,
        "detail": "log_parser",
        "documentation": {}
    },
    {
        "label": "Track",
        "importPath": "log_parser",
        "description": "log_parser",
        "isExtraImport": true,
        "detail": "log_parser",
        "documentation": {}
    },
    {
        "label": "read_results",
        "importPath": "log_parser",
        "description": "log_parser",
        "isExtraImport": true,
        "detail": "log_parser",
        "documentation": {}
    },
    {
        "label": "read_results",
        "importPath": "log_parser",
        "description": "log_parser",
        "isExtraImport": true,
        "detail": "log_parser",
        "documentation": {}
    },
    {
        "label": "distutils.spawn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils.spawn",
        "description": "distutils.spawn",
        "detail": "distutils.spawn",
        "documentation": {}
    },
    {
        "label": "distutils.dir_util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils.dir_util",
        "description": "distutils.dir_util",
        "detail": "distutils.dir_util",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "data_file",
        "importPath": "catboost_pytest_lib",
        "description": "catboost_pytest_lib",
        "isExtraImport": true,
        "detail": "catboost_pytest_lib",
        "documentation": {}
    },
    {
        "label": "load_pool_features_as_df",
        "importPath": "catboost_pytest_lib",
        "description": "catboost_pytest_lib",
        "isExtraImport": true,
        "detail": "catboost_pytest_lib",
        "documentation": {}
    },
    {
        "label": "filecmp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "filecmp",
        "description": "filecmp",
        "detail": "filecmp",
        "documentation": {}
    },
    {
        "label": "yatest.common",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yatest.common",
        "description": "yatest.common",
        "detail": "yatest.common",
        "documentation": {}
    },
    {
        "label": "ExecutionTimeoutError",
        "importPath": "yatest.common",
        "description": "yatest.common",
        "isExtraImport": true,
        "detail": "yatest.common",
        "documentation": {}
    },
    {
        "label": "ExecutionError",
        "importPath": "yatest.common",
        "description": "yatest.common",
        "isExtraImport": true,
        "detail": "yatest.common",
        "documentation": {}
    },
    {
        "label": "yatest.common.runtime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yatest.common.runtime",
        "description": "yatest.common.runtime",
        "detail": "yatest.common.runtime",
        "documentation": {}
    },
    {
        "label": "yatest_lib.ya",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yatest_lib.ya",
        "description": "yatest_lib.ya",
        "detail": "yatest_lib.ya",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "yatest_lib.tools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yatest_lib.tools",
        "description": "yatest_lib.tools",
        "detail": "yatest_lib.tools",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "catboost.utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "read_cd",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "eval_metric",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "create_cd",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "read_cd",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_roc_curve",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "select_threshold",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "quantize",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "DataMetaInfo",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "TargetStats",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "compute_training_options",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "create_cd",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "calculate_quantization_grid",
        "importPath": "catboost.utils",
        "description": "catboost.utils",
        "isExtraImport": true,
        "detail": "catboost.utils",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "shap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shap",
        "description": "shap",
        "detail": "shap",
        "documentation": {}
    },
    {
        "label": "data_file",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "execute_dist_train",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "is_open_source",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "apply_catboost",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "compare_evals_with_precision",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "compare_fit_evals_with_precision",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "compare_evals",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "data_file",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "execute_catboost_fit",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "execute_dist_train",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "format_crossvalidation",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "generate_concatenated_random_labeled_dataset",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "get_catboost_binary_path",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_dsv_diff_tool",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "is_canonical_test_run",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "permute_dataset_columns",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "remove_time_from_json",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "data_file",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_dsv_diff_tool",
        "importPath": "lib",
        "description": "lib",
        "isExtraImport": true,
        "detail": "lib",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "unique",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "EnumMeta",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntFlag",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "display",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "display",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "display",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "RLock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Lock",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Unicode",
        "importPath": "traitlets",
        "description": "traitlets",
        "isExtraImport": true,
        "detail": "traitlets",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "traitlets",
        "description": "traitlets",
        "isExtraImport": true,
        "detail": "traitlets",
        "documentation": {}
    },
    {
        "label": "default",
        "importPath": "traitlets",
        "description": "traitlets",
        "isExtraImport": true,
        "detail": "traitlets",
        "documentation": {}
    },
    {
        "label": "DOMWidget",
        "importPath": "ipywidgets",
        "description": "ipywidgets",
        "isExtraImport": true,
        "detail": "ipywidgets",
        "documentation": {}
    },
    {
        "label": "Layout",
        "importPath": "ipywidgets",
        "description": "ipywidgets",
        "isExtraImport": true,
        "detail": "ipywidgets",
        "documentation": {}
    },
    {
        "label": "widget_serialization",
        "importPath": "ipywidgets",
        "description": "ipywidgets",
        "isExtraImport": true,
        "detail": "ipywidgets",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "iteritems",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "string_types",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "integer_types",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "byref",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "POINTER",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_int",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_char",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_char_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "py_object",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ssize_t",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "byref",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_int",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_char_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "py_object",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ssize_t",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_char_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "py_object",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "cdll",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_char_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_void_p",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_size_t",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "CFUNCTYPE",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "pythonapi",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "POINTER",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_long",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "byref",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_ulong",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "WinDLL",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "c_int",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "POINTER",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "byref",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "scipy.sparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "common_helpers",
        "description": "common_helpers",
        "isExtraImport": true,
        "detail": "common_helpers",
        "documentation": {}
    },
    {
        "label": "FileLock",
        "importPath": "filelock",
        "description": "filelock",
        "isExtraImport": true,
        "detail": "filelock",
        "documentation": {}
    },
    {
        "label": "HnswEstimator",
        "importPath": "catboost.hnsw",
        "description": "catboost.hnsw",
        "isExtraImport": true,
        "detail": "catboost.hnsw",
        "documentation": {}
    },
    {
        "label": "EDistance",
        "importPath": "catboost.hnsw",
        "description": "catboost.hnsw",
        "isExtraImport": true,
        "detail": "catboost.hnsw",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "TextIOWrapper",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "is_maximizable_metric",
        "importPath": "catboost.core",
        "description": "catboost.core",
        "isExtraImport": true,
        "detail": "catboost.core",
        "documentation": {}
    },
    {
        "label": "is_minimizable_metric",
        "importPath": "catboost.core",
        "description": "catboost.core",
        "isExtraImport": true,
        "detail": "catboost.core",
        "documentation": {}
    },
    {
        "label": "CatboostEvaluation",
        "importPath": "catboost.eval.catboost_evaluation",
        "description": "catboost.eval.catboost_evaluation",
        "isExtraImport": true,
        "detail": "catboost.eval.catboost_evaluation",
        "documentation": {}
    },
    {
        "label": "EvalType",
        "importPath": "catboost.eval.catboost_evaluation",
        "description": "catboost.eval.catboost_evaluation",
        "isExtraImport": true,
        "detail": "catboost.eval.catboost_evaluation",
        "documentation": {}
    },
    {
        "label": "carry",
        "importPath": "catboost.carry",
        "description": "catboost.carry",
        "isExtraImport": true,
        "detail": "catboost.carry",
        "documentation": {}
    },
    {
        "label": "uplift",
        "importPath": "catboost.carry",
        "description": "catboost.carry",
        "isExtraImport": true,
        "detail": "catboost.carry",
        "documentation": {}
    },
    {
        "label": "SparseArray",
        "importPath": "pandas.arrays",
        "description": "pandas.arrays",
        "isExtraImport": true,
        "detail": "pandas.arrays",
        "documentation": {}
    },
    {
        "label": "scipy.special",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.special",
        "description": "scipy.special",
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "_pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_pickle",
        "description": "_pickle",
        "detail": "_pickle",
        "documentation": {}
    },
    {
        "label": "_float_or_nan",
        "importPath": "catboost._catboost",
        "description": "catboost._catboost",
        "isExtraImport": true,
        "detail": "catboost._catboost",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "distutils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils",
        "description": "distutils",
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "distutils",
        "description": "distutils",
        "isExtraImport": true,
        "detail": "distutils",
        "documentation": {}
    },
    {
        "label": "bdist",
        "importPath": "distutils.command.bdist",
        "description": "distutils.command.bdist",
        "isExtraImport": true,
        "detail": "distutils.command.bdist",
        "documentation": {}
    },
    {
        "label": "install_data",
        "importPath": "distutils.command.install_data",
        "description": "distutils.command.install_data",
        "isExtraImport": true,
        "detail": "distutils.command.install_data",
        "documentation": {}
    },
    {
        "label": "setuptools.command.build",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools.command.build",
        "description": "setuptools.command.build",
        "detail": "setuptools.command.build",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "setuptools.command.build",
        "description": "setuptools.command.build",
        "isExtraImport": true,
        "detail": "setuptools.command.build",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "setuptools.command.build_ext",
        "description": "setuptools.command.build_ext",
        "isExtraImport": true,
        "detail": "setuptools.command.build_ext",
        "documentation": {}
    },
    {
        "label": "develop",
        "importPath": "setuptools.command.develop",
        "description": "setuptools.command.develop",
        "isExtraImport": true,
        "detail": "setuptools.command.develop",
        "documentation": {}
    },
    {
        "label": "install",
        "importPath": "setuptools.command.install",
        "description": "setuptools.command.install",
        "isExtraImport": true,
        "detail": "setuptools.command.install",
        "documentation": {}
    },
    {
        "label": "sdist",
        "importPath": "setuptools.command.sdist",
        "description": "setuptools.command.sdist",
        "isExtraImport": true,
        "detail": "setuptools.command.sdist",
        "documentation": {}
    },
    {
        "label": "bdist_wheel",
        "importPath": "wheel.bdist_wheel",
        "description": "wheel.bdist_wheel",
        "isExtraImport": true,
        "detail": "wheel.bdist_wheel",
        "documentation": {}
    },
    {
        "label": "catboost_classifier_test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "catboost_classifier_test",
        "description": "catboost_classifier_test",
        "detail": "catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "catboost_regressor_test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "catboost_regressor_test",
        "description": "catboost_regressor_test",
        "detail": "catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "feature_importance_test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "feature_importance_test",
        "description": "feature_importance_test",
        "detail": "feature_importance_test",
        "documentation": {}
    },
    {
        "label": "socketserver",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socketserver",
        "description": "socketserver",
        "detail": "socketserver",
        "documentation": {}
    },
    {
        "label": "test_helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "test_helpers",
        "description": "test_helpers",
        "detail": "test_helpers",
        "documentation": {}
    },
    {
        "label": "pool_test_helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pool_test_helpers",
        "description": "pool_test_helpers",
        "detail": "pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "pyspark.ml",
        "description": "pyspark.ml",
        "isExtraImport": true,
        "detail": "pyspark.ml",
        "documentation": {}
    },
    {
        "label": "PipelineModel",
        "importPath": "pyspark.ml",
        "description": "pyspark.ml",
        "isExtraImport": true,
        "detail": "pyspark.ml",
        "documentation": {}
    },
    {
        "label": "Pipeline",
        "importPath": "pyspark.ml",
        "description": "pyspark.ml",
        "isExtraImport": true,
        "detail": "pyspark.ml",
        "documentation": {}
    },
    {
        "label": "PipelineModel",
        "importPath": "pyspark.ml",
        "description": "pyspark.ml",
        "isExtraImport": true,
        "detail": "pyspark.ml",
        "documentation": {}
    },
    {
        "label": "pyspark.ml.evaluation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyspark.ml.evaluation",
        "description": "pyspark.ml.evaluation",
        "detail": "pyspark.ml.evaluation",
        "documentation": {}
    },
    {
        "label": "StringIndexer",
        "importPath": "pyspark.ml.feature",
        "description": "pyspark.ml.feature",
        "isExtraImport": true,
        "detail": "pyspark.ml.feature",
        "documentation": {}
    },
    {
        "label": "VectorAssembler",
        "importPath": "pyspark.ml.feature",
        "description": "pyspark.ml.feature",
        "isExtraImport": true,
        "detail": "pyspark.ml.feature",
        "documentation": {}
    },
    {
        "label": "StringIndexer",
        "importPath": "pyspark.ml.feature",
        "description": "pyspark.ml.feature",
        "isExtraImport": true,
        "detail": "pyspark.ml.feature",
        "documentation": {}
    },
    {
        "label": "VectorAssembler",
        "importPath": "pyspark.ml.feature",
        "description": "pyspark.ml.feature",
        "isExtraImport": true,
        "detail": "pyspark.ml.feature",
        "documentation": {}
    },
    {
        "label": "Vectors",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "VectorUDT",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "Vectors",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "VectorUDT",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "Vectors",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "VectorUDT",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "Vectors",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "VectorUDT",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.ml.linalg",
        "description": "pyspark.ml.linalg",
        "isExtraImport": true,
        "detail": "pyspark.ml.linalg",
        "documentation": {}
    },
    {
        "label": "pyspark.ml.tuning",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyspark.ml.tuning",
        "description": "pyspark.ml.tuning",
        "detail": "pyspark.ml.tuning",
        "documentation": {}
    },
    {
        "label": "Row",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "Row",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "Row",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "Row",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "SparkSession",
        "importPath": "pyspark.sql",
        "description": "pyspark.sql",
        "isExtraImport": true,
        "detail": "pyspark.sql",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.sql.types",
        "description": "pyspark.sql.types",
        "isExtraImport": true,
        "detail": "pyspark.sql.types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "pyspark.ml.param",
        "description": "pyspark.ml.param",
        "isExtraImport": true,
        "detail": "pyspark.ml.param",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "generate",
        "description": "generate",
        "detail": "generate",
        "documentation": {}
    },
    {
        "label": "webdav.client",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webdav.client",
        "description": "webdav.client",
        "detail": "webdav.client",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack_from",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack_from",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractproperty",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "RawConfigParser",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "SafeConfigParser",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "SectionProxy",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "Interpolation",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "BasicInterpolation",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "ExtendedInterpolation",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "LegacyInterpolation",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "NoSectionError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "DuplicateSectionError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "DuplicateOptionError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "NoOptionError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationMissingOptionError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationSyntaxError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "InterpolationDepthError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "ParsingError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "MissingSectionHeaderError",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "ConverterMapping",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "DEFAULTSECT",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "MAX_INTERPOLATION_DEPTH",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "Error",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "_UNSET",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "_default_dict",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "_ChainMap",
        "importPath": "backports.configparser",
        "description": "backports.configparser",
        "isExtraImport": true,
        "detail": "backports.configparser",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "SkipTest",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "_functools",
        "description": "_functools",
        "isExtraImport": true,
        "detail": "_functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "_functools",
        "description": "_functools",
        "isExtraImport": true,
        "detail": "_functools",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "proxy",
        "importPath": "weakref",
        "description": "weakref",
        "isExtraImport": true,
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "__builtin__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__builtin__",
        "description": "__builtin__",
        "detail": "__builtin__",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "CodeType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "CodeType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "ModuleType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "MethodType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "_base",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "_base",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Queue",
        "description": "Queue",
        "detail": "Queue",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "scandir",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scandir",
        "description": "scandir",
        "detail": "scandir",
        "documentation": {}
    },
    {
        "label": "signal,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal.",
        "description": "signal.",
        "detail": "signal.",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "exceptions",
        "description": "exceptions",
        "detail": "exceptions",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "test_support",
        "importPath": "test",
        "description": "test",
        "isExtraImport": true,
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "subprocess32",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess32",
        "description": "subprocess32",
        "detail": "subprocess32",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "select",
        "description": "select",
        "detail": "select",
        "documentation": {}
    },
    {
        "label": "__main__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__main__",
        "description": "__main__",
        "detail": "__main__",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "code",
        "description": "code",
        "detail": "code",
        "documentation": {}
    },
    {
        "label": "ctypes.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes.util",
        "description": "ctypes.util",
        "detail": "ctypes.util",
        "documentation": {}
    },
    {
        "label": "tokenize",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tokenize",
        "description": "tokenize",
        "detail": "tokenize",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "lookup",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "BOM_UTF8",
        "importPath": "codecs",
        "description": "codecs",
        "isExtraImport": true,
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "LPCWSTR",
        "importPath": "ctypes.wintypes",
        "description": "ctypes.wintypes",
        "isExtraImport": true,
        "detail": "ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "LPWSTR",
        "importPath": "ctypes.wintypes",
        "description": "ctypes.wintypes",
        "isExtraImport": true,
        "detail": "ctypes.wintypes",
        "documentation": {}
    },
    {
        "label": "google.protobuf.message",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "google.protobuf.message",
        "description": "google.protobuf.message",
        "detail": "google.protobuf.message",
        "documentation": {}
    },
    {
        "label": "Message",
        "importPath": "google.protobuf.message",
        "description": "google.protobuf.message",
        "isExtraImport": true,
        "detail": "google.protobuf.message",
        "documentation": {}
    },
    {
        "label": "onnx.defs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnx.defs",
        "description": "onnx.defs",
        "detail": "onnx.defs",
        "documentation": {}
    },
    {
        "label": "checker",
        "importPath": "onnx.onnx_cpp2py_export",
        "description": "onnx.onnx_cpp2py_export",
        "isExtraImport": true,
        "detail": "onnx.onnx_cpp2py_export",
        "documentation": {}
    },
    {
        "label": "parser",
        "importPath": "onnx.onnx_cpp2py_export",
        "description": "onnx.onnx_cpp2py_export",
        "isExtraImport": true,
        "detail": "onnx.onnx_cpp2py_export",
        "documentation": {}
    },
    {
        "label": "printer",
        "importPath": "onnx.onnx_cpp2py_export",
        "description": "onnx.onnx_cpp2py_export",
        "isExtraImport": true,
        "detail": "onnx.onnx_cpp2py_export",
        "documentation": {}
    },
    {
        "label": "shape_inference",
        "importPath": "onnx.onnx_cpp2py_export",
        "description": "onnx.onnx_cpp2py_export",
        "isExtraImport": true,
        "detail": "onnx.onnx_cpp2py_export",
        "documentation": {}
    },
    {
        "label": "version_converter",
        "importPath": "onnx.onnx_cpp2py_export",
        "description": "onnx.onnx_cpp2py_export",
        "isExtraImport": true,
        "detail": "onnx.onnx_cpp2py_export",
        "documentation": {}
    },
    {
        "label": "onnx.shape_inference",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnx.shape_inference",
        "description": "onnx.shape_inference",
        "detail": "onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "onnx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnx",
        "description": "onnx",
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "IR_VERSION",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "AttributeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "FunctionProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "GraphProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "NodeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "SparseTensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ValueInfoProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "helper",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "GraphProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "checker",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "helper",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "IR_VERSION",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "AttributeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "FunctionProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "GraphProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "MapProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "NodeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "OperatorSetIdProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "OptionalProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "SequenceProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "SparseTensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorShapeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TrainingInfoProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TypeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ValueInfoProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "defs",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "mapping",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "OptionalProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "SequenceProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "MapProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "OptionalProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "SequenceProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "helper",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "AttributeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "FunctionProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TypeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "FunctionProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "NodeProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ValueInfoProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx",
        "description": "onnx",
        "isExtraImport": true,
        "detail": "onnx",
        "documentation": {}
    },
    {
        "label": "AttributeProto",
        "importPath": "onnx.onnx_pb",
        "description": "onnx.onnx_pb",
        "isExtraImport": true,
        "detail": "onnx.onnx_pb",
        "documentation": {}
    },
    {
        "label": "GraphProto",
        "importPath": "onnx.onnx_pb",
        "description": "onnx.onnx_pb",
        "isExtraImport": true,
        "detail": "onnx.onnx_pb",
        "documentation": {}
    },
    {
        "label": "ModelProto",
        "importPath": "onnx.onnx_pb",
        "description": "onnx.onnx_pb",
        "isExtraImport": true,
        "detail": "onnx.onnx_pb",
        "documentation": {}
    },
    {
        "label": "TensorProto",
        "importPath": "onnx.onnx_pb",
        "description": "onnx.onnx_pb",
        "isExtraImport": true,
        "detail": "onnx.onnx_pb",
        "documentation": {}
    },
    {
        "label": "collections.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections.abc",
        "description": "collections.abc",
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Rational",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Rational",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "isnan",
        "importPath": "cmath",
        "description": "cmath",
        "isExtraImport": true,
        "detail": "cmath",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib.error",
        "description": "urllib.error",
        "isExtraImport": true,
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "urlopen",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "load_external_data_for_tensor",
        "importPath": "onnx.external_data_helper",
        "description": "onnx.external_data_helper",
        "isExtraImport": true,
        "detail": "onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "uses_external_data",
        "importPath": "onnx.external_data_helper",
        "description": "onnx.external_data_helper",
        "isExtraImport": true,
        "detail": "onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "onnx.checker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnx.checker",
        "description": "onnx.checker",
        "detail": "onnx.checker",
        "documentation": {}
    },
    {
        "label": "onnx.helper",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "onnx.helper",
        "description": "onnx.helper",
        "detail": "onnx.helper",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "iskeyword",
        "importPath": "keyword",
        "description": "keyword",
        "isExtraImport": true,
        "detail": "keyword",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "soft_unicode",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "soft_unicode",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "EscapeFormatter",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "Markup",
        "importPath": "markupsafe",
        "description": "markupsafe",
        "isExtraImport": true,
        "detail": "markupsafe",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "literal_eval",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "decimal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "decimal",
        "description": "decimal",
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "olefile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "olefile",
        "description": "olefile",
        "detail": "olefile",
        "documentation": {}
    },
    {
        "label": "PIL",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PIL",
        "description": "PIL",
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFile",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "PngImagePlugin",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFile",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "i8",
        "importPath": "PIL._binary",
        "description": "PIL._binary",
        "isExtraImport": true,
        "detail": "PIL._binary",
        "documentation": {}
    },
    {
        "label": "isStringType",
        "importPath": "PIL._util",
        "description": "PIL._util",
        "isExtraImport": true,
        "detail": "PIL._util",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "FFI",
        "importPath": "cffi",
        "description": "cffi",
        "isExtraImport": true,
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "distutils.version",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils.version",
        "description": "distutils.version",
        "detail": "distutils.version",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "Fraction",
        "importPath": "fractions",
        "description": "fractions",
        "isExtraImport": true,
        "detail": "fractions",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "MarkedYAMLError",
        "importPath": "error",
        "description": "error",
        "isExtraImport": true,
        "detail": "error",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "error",
        "description": "error",
        "isExtraImport": true,
        "detail": "error",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "events",
        "description": "events",
        "isExtraImport": true,
        "detail": "events",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nodes",
        "description": "nodes",
        "isExtraImport": true,
        "detail": "nodes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nodes",
        "description": "nodes",
        "isExtraImport": true,
        "detail": "nodes",
        "documentation": {}
    },
    {
        "label": "binascii,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "binascii.",
        "description": "binascii.",
        "detail": "binascii.",
        "documentation": {}
    },
    {
        "label": "CParser",
        "importPath": "yaml._yaml",
        "description": "yaml._yaml",
        "isExtraImport": true,
        "detail": "yaml._yaml",
        "documentation": {}
    },
    {
        "label": "CEmitter",
        "importPath": "yaml._yaml",
        "description": "yaml._yaml",
        "isExtraImport": true,
        "detail": "yaml._yaml",
        "documentation": {}
    },
    {
        "label": "escape_special_symbols",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def escape_special_symbols(strval):\n    retval = \"\"\n    for c in strval:\n        if c in (\"\\\\\", \"\\\"\"):\n            retval += \"\\\\\" + c\n        elif ord(c) < 0x20:\n            retval += c.encode('unicode_escape').decode('utf-8')\n        else:\n            retval += c\n    return retval",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "escape_line_feed",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def escape_line_feed(strval):\n    return re.sub(r'\\\\n', r'\\\\n\"\\\\\\n' + indent + '\"', strval)\ndef escaped_define(strkey, strval):\n    return \"#define \" + strkey + \" \\\"\" + escape_line_feed(escape_special_symbols(strval)) + \"\\\"\"\ndef get_build_info(compiler, flags):\n    build_info = \"Build info:\\n\"\n    build_info += indent + \"Compiler: \" + compiler + \"\\n\"\n    build_info += indent + \"Compiler version: \\n\" + get_compiler_info(compiler) + \"\\n\"\n    build_info += indent + \"Compile flags: \" + (flags if flags else \"no flags info\")\n    return build_info",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "escaped_define",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def escaped_define(strkey, strval):\n    return \"#define \" + strkey + \" \\\"\" + escape_line_feed(escape_special_symbols(strval)) + \"\\\"\"\ndef get_build_info(compiler, flags):\n    build_info = \"Build info:\\n\"\n    build_info += indent + \"Compiler: \" + compiler + \"\\n\"\n    build_info += indent + \"Compiler version: \\n\" + get_compiler_info(compiler) + \"\\n\"\n    build_info += indent + \"Compile flags: \" + (flags if flags else \"no flags info\")\n    return build_info\ndef get_compiler_info(compiler):\n    compiler_binary = os.path.basename(compiler).lower()",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "get_build_info",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def get_build_info(compiler, flags):\n    build_info = \"Build info:\\n\"\n    build_info += indent + \"Compiler: \" + compiler + \"\\n\"\n    build_info += indent + \"Compiler version: \\n\" + get_compiler_info(compiler) + \"\\n\"\n    build_info += indent + \"Compile flags: \" + (flags if flags else \"no flags info\")\n    return build_info\ndef get_compiler_info(compiler):\n    compiler_binary = os.path.basename(compiler).lower()\n    if len(compiler.split(' ')) > 1 or compiler_binary == \"ymake\" or compiler_binary == \"ymake.exe\":\n        compiler_ver_out = \"Build by wrapper. No useful info here.\"",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "get_compiler_info",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def get_compiler_info(compiler):\n    compiler_binary = os.path.basename(compiler).lower()\n    if len(compiler.split(' ')) > 1 or compiler_binary == \"ymake\" or compiler_binary == \"ymake.exe\":\n        compiler_ver_out = \"Build by wrapper. No useful info here.\"\n    else:\n        compiler_ver_cmd = [compiler]\n        if compiler_binary not in (\"cl\", \"cl.exe\"):\n            compiler_ver_cmd.append('--version')\n        env = os.environ.copy()\n        env['LOCALE'] = 'C'",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "filterflags",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def filterflags(flags_str):\n    badflgs = {\n        '-fdebug-prefix-map',\n        '-DARCADIA_ROOT',\n        '-DARCADIA_BUILD_ROOT',\n        '/DARCADIA_ROOT',\n        '/DARCADIA_BUILD_ROOT',\n    }\n    def flags_iter():\n        for flag in flags_str.split():",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "def main():\n    if len(sys.argv) != 4:\n        print(\"Usage: build_info_gen.py <output file> <CXX compiler> <CXX flags>\", file=sys.stderr)\n        sys.exit(1)\n    cxx_compiler = sys.argv[2]\n    cxx_flags = filterflags(sys.argv[3])\n    with open(sys.argv[1], 'w') as result:\n        print(\"#pragma once\\n\", file=result)\n        print(escaped_define(\"BUILD_INFO\", get_build_info(cxx_compiler, cxx_flags)), file=result)\n        print(escaped_define(\"BUILD_COMPILER\", cxx_compiler), file=result)",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "indent",
        "kind": 5,
        "importPath": "catboost.build.scripts.build_info_gen",
        "description": "catboost.build.scripts.build_info_gen",
        "peekOfCode": "indent = \"    \"\ndef escape_special_symbols(strval):\n    retval = \"\"\n    for c in strval:\n        if c in (\"\\\\\", \"\\\"\"):\n            retval += \"\\\\\" + c\n        elif ord(c) < 0x20:\n            retval += c.encode('unicode_escape').decode('utf-8')\n        else:\n            retval += c",
        "detail": "catboost.build.scripts.build_info_gen",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "catboost.build.scripts.check_config_h",
        "description": "catboost.build.scripts.check_config_h",
        "peekOfCode": "data = \"\"\"\n#if defined(SIZEOF_LONG)\nstatic_assert(sizeof(long) == SIZEOF_LONG, \"fixme 1\");\n#endif\n#if defined(SIZEOF_PTHREAD_T)\n#include <pthread.h>\nstatic_assert(sizeof(pthread_t) == SIZEOF_PTHREAD_T, \"fixme 2\");\n#endif\n#if defined(SIZEOF_SIZE_T)\n#include <stddef.h>",
        "detail": "catboost.build.scripts.check_config_h",
        "documentation": {}
    },
    {
        "label": "fix_win_bin_name",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_cuda",
        "description": "catboost.build.scripts.compile_cuda",
        "peekOfCode": "def fix_win_bin_name(name):\n    res = os.path.normpath(name)\n    if not os.path.splitext(name)[1]:\n        return res + '.exe'\n    return res\ndef find_compiler_bindir(command):\n    for idx, word in enumerate(command):\n        if '--compiler-bindir' in word:\n            return idx\n    return None",
        "detail": "catboost.build.scripts.compile_cuda",
        "documentation": {}
    },
    {
        "label": "find_compiler_bindir",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_cuda",
        "description": "catboost.build.scripts.compile_cuda",
        "peekOfCode": "def find_compiler_bindir(command):\n    for idx, word in enumerate(command):\n        if '--compiler-bindir' in word:\n            return idx\n    return None\ndef is_clang(command):\n    cmplr_dir_idx = find_compiler_bindir(command)\n    return cmplr_dir_idx is not None and 'clang' in command[cmplr_dir_idx]\ndef fix_win(command, flags):\n    if platform.system().lower() == \"windows\":",
        "detail": "catboost.build.scripts.compile_cuda",
        "documentation": {}
    },
    {
        "label": "is_clang",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_cuda",
        "description": "catboost.build.scripts.compile_cuda",
        "peekOfCode": "def is_clang(command):\n    cmplr_dir_idx = find_compiler_bindir(command)\n    return cmplr_dir_idx is not None and 'clang' in command[cmplr_dir_idx]\ndef fix_win(command, flags):\n    if platform.system().lower() == \"windows\":\n        command[0] = fix_win_bin_name(command[0])\n        cmplr_dir_idx = find_compiler_bindir(command)\n        if cmplr_dir_idx is not None:\n            key, value = command[cmplr_dir_idx].split('=')\n            command[cmplr_dir_idx] = key + '=' + fix_win_bin_name(value)",
        "detail": "catboost.build.scripts.compile_cuda",
        "documentation": {}
    },
    {
        "label": "fix_win",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_cuda",
        "description": "catboost.build.scripts.compile_cuda",
        "peekOfCode": "def fix_win(command, flags):\n    if platform.system().lower() == \"windows\":\n        command[0] = fix_win_bin_name(command[0])\n        cmplr_dir_idx = find_compiler_bindir(command)\n        if cmplr_dir_idx is not None:\n            key, value = command[cmplr_dir_idx].split('=')\n            command[cmplr_dir_idx] = key + '=' + fix_win_bin_name(value)\ndef main():\n    try:\n        sys.argv.remove('--y_skip_nocxxinc')",
        "detail": "catboost.build.scripts.compile_cuda",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_cuda",
        "description": "catboost.build.scripts.compile_cuda",
        "peekOfCode": "def main():\n    try:\n        sys.argv.remove('--y_skip_nocxxinc')\n        skip_nocxxinc = True\n    except ValueError:\n        skip_nocxxinc = False\n    spl = sys.argv.index('--cflags')\n    cmd = 1\n    mtime0 = None\n    if sys.argv[1] == '--mtime':",
        "detail": "catboost.build.scripts.compile_cuda",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_java",
        "description": "catboost.build.scripts.compile_java",
        "peekOfCode": "def parse_args(args):\n    parser = argparse.ArgumentParser(description='Wrapper to invoke Java compilation from ya make build')\n    parser.add_argument('--javac-bin', help='path to javac')\n    parser.add_argument('--jar-bin', help='path to jar tool')\n    parser.add_argument('--java-bin', help='path to java binary')\n    parser.add_argument('--kotlin-compiler', help='path to kotlin compiler jar file')\n    parser.add_argument('--vcs-mf', help='path to VCS info manifest snippet')\n    parser.add_argument('--package-prefix', help='package prefix for resource files')\n    parser.add_argument('--jar-output', help='jar file with compiled classes destination path')\n    parser.add_argument('--srcs-jar-output', help='jar file with sources destination path')",
        "detail": "catboost.build.scripts.compile_java",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_java",
        "description": "catboost.build.scripts.compile_java",
        "peekOfCode": "def mkdir_p(directory):\n    if not os.path.exists(directory):\n        os.makedirs(directory)\ndef split_cmd_by_delim(cmd, delim='DELIM'):\n    result = [[]]\n    for arg in cmd:\n        if arg == delim:\n            result.append([])\n        else:\n            result[-1].append(arg)",
        "detail": "catboost.build.scripts.compile_java",
        "documentation": {}
    },
    {
        "label": "split_cmd_by_delim",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_java",
        "description": "catboost.build.scripts.compile_java",
        "peekOfCode": "def split_cmd_by_delim(cmd, delim='DELIM'):\n    result = [[]]\n    for arg in cmd:\n        if arg == delim:\n            result.append([])\n        else:\n            result[-1].append(arg)\n    return result\ndef main():\n    loaded_args = pcf.get_args(sys.argv[1:])",
        "detail": "catboost.build.scripts.compile_java",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.compile_java",
        "description": "catboost.build.scripts.compile_java",
        "peekOfCode": "def main():\n    loaded_args = pcf.get_args(sys.argv[1:])\n    cmd_parts = split_cmd_by_delim(loaded_args)\n    assert len(cmd_parts) == 4\n    args, javac_opts, peers, ktc_opts = cmd_parts\n    opts, jsrcs = parse_args(args)\n    jsrcs += list(filter(lambda x: x.endswith('.jsrc'), peers))\n    peers = list(filter(lambda x: not x.endswith('.jsrc'), peers))\n    sources_dir = 'src'\n    mkdir_p(sources_dir)",
        "detail": "catboost.build.scripts.compile_java",
        "documentation": {}
    },
    {
        "label": "replaceLine",
        "kind": 2,
        "importPath": "catboost.build.scripts.configure_file",
        "description": "catboost.build.scripts.configure_file",
        "peekOfCode": "def replaceLine(l, varDict, define):\n    words = l.split()\n    if words:\n        if words[0] == cmakeDef:\n            sPos = l.find(cmakeDef)\n            ePos = sPos + len(cmakeDef)\n            l = l[:sPos] + define + l[ePos:] + '\\n'\n        if words[0] == cmakeDef01:\n            var = words[1]\n            cmakeValue = varDict.get(var)",
        "detail": "catboost.build.scripts.configure_file",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.configure_file",
        "description": "catboost.build.scripts.configure_file",
        "peekOfCode": "def main(inputPath, outputPath, varDict):\n    define = '#define' if os.path.splitext(outputPath)[1] != '.asm' else '%define'\n    with open(outputPath, 'w') as output:\n        with open(inputPath, 'r') as input:\n            for l in input:\n                output.write(replaceLine(l, varDict, define))\ndef usage():\n    print(\"usage: configure_file.py inputPath outputPath key1=value1 ...\")\n    exit(1)\nif __name__ == \"__main__\":",
        "detail": "catboost.build.scripts.configure_file",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "catboost.build.scripts.configure_file",
        "description": "catboost.build.scripts.configure_file",
        "peekOfCode": "def usage():\n    print(\"usage: configure_file.py inputPath outputPath key1=value1 ...\")\n    exit(1)\nif __name__ == \"__main__\":\n    if len(sys.argv) < 3:\n        usage()\n    varDict = {}\n    for x in sys.argv[3:]:\n        key, value = str(x).split('=', 1)\n        varDict[key] = value",
        "detail": "catboost.build.scripts.configure_file",
        "documentation": {}
    },
    {
        "label": "cmakeDef01",
        "kind": 5,
        "importPath": "catboost.build.scripts.configure_file",
        "description": "catboost.build.scripts.configure_file",
        "peekOfCode": "cmakeDef01 = \"#cmakedefine01\"\ncmakeDef = \"#cmakedefine\"\ndef replaceLine(l, varDict, define):\n    words = l.split()\n    if words:\n        if words[0] == cmakeDef:\n            sPos = l.find(cmakeDef)\n            ePos = sPos + len(cmakeDef)\n            l = l[:sPos] + define + l[ePos:] + '\\n'\n        if words[0] == cmakeDef01:",
        "detail": "catboost.build.scripts.configure_file",
        "documentation": {}
    },
    {
        "label": "cmakeDef",
        "kind": 5,
        "importPath": "catboost.build.scripts.configure_file",
        "description": "catboost.build.scripts.configure_file",
        "peekOfCode": "cmakeDef = \"#cmakedefine\"\ndef replaceLine(l, varDict, define):\n    words = l.split()\n    if words:\n        if words[0] == cmakeDef:\n            sPos = l.find(cmakeDef)\n            ePos = sPos + len(cmakeDef)\n            l = l[:sPos] + define + l[ePos:] + '\\n'\n        if words[0] == cmakeDef01:\n            var = words[1]",
        "detail": "catboost.build.scripts.configure_file",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.copy_to_dir",
        "description": "catboost.build.scripts.copy_to_dir",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--build-root', required=True)\n    parser.add_argument('--dest-arch', default=None)\n    parser.add_argument('--dest-dir', required=True)\n    parser.add_argument('args', nargs='*')\n    return parser.parse_args()\ndef ensure_dir_exists(path):\n    try:\n        os.makedirs(path)",
        "detail": "catboost.build.scripts.copy_to_dir",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "kind": 2,
        "importPath": "catboost.build.scripts.copy_to_dir",
        "description": "catboost.build.scripts.copy_to_dir",
        "peekOfCode": "def ensure_dir_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as e:\n        if e.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            raise\ndef hardlink_or_copy(src, dst):\n    if os.name == 'nt':",
        "detail": "catboost.build.scripts.copy_to_dir",
        "documentation": {}
    },
    {
        "label": "hardlink_or_copy",
        "kind": 2,
        "importPath": "catboost.build.scripts.copy_to_dir",
        "description": "catboost.build.scripts.copy_to_dir",
        "peekOfCode": "def hardlink_or_copy(src, dst):\n    if os.name == 'nt':\n        shutil.copy(src, dst)\n    else:\n        try:\n            os.link(src, dst)\n        except OSError as e:\n            if e.errno == errno.EEXIST:\n                return\n            elif e.errno == errno.EXDEV:",
        "detail": "catboost.build.scripts.copy_to_dir",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.copy_to_dir",
        "description": "catboost.build.scripts.copy_to_dir",
        "peekOfCode": "def main():\n    opts = parse_args()\n    dest_arch = None\n    if opts.dest_arch:\n        if opts.dest_arch.endswith('.tar'):\n            dest_arch = tarfile.open(opts.dest_arch, 'w', dereference=True)\n        elif opts.dest_arch.endswith('.tar.gz') or opts.dest_arch.endswith('.tgz'):\n            dest_arch = tarfile.open(opts.dest_arch, 'w:gz', dereference=True)\n        else:\n            # TODO: move check to graph generation stage",
        "detail": "catboost.build.scripts.copy_to_dir",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.cpp_flatc_wrapper",
        "description": "catboost.build.scripts.cpp_flatc_wrapper",
        "peekOfCode": "def main():\n    cmd = sys.argv[1:]\n    h_file = None\n    try:\n        index = cmd.index('-o')\n        h_file = cmd[index + 1]\n        cmd[index + 1] = os.path.dirname(h_file)\n    except (ValueError, IndexError):\n        pass\n    p = subprocess.run(cmd, capture_output=True, text=True)",
        "detail": "catboost.build.scripts.cpp_flatc_wrapper",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.cpp_proto_wrapper",
        "description": "catboost.build.scripts.cpp_proto_wrapper",
        "peekOfCode": "def parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--outputs', nargs='+', required=True)\n    parser.add_argument('subcommand', nargs='+')\n    return parser.parse_args()\ndef patch_proto_file(text: str) -> tuple[str, int]:\n    return re.subn(FROM_RE, TO_RE, text)\ndef main(namespace: argparse.Namespace) -> int:\n    try:\n        subprocess.check_output(namespace.subcommand, stdin=None, stderr=subprocess.STDOUT)",
        "detail": "catboost.build.scripts.cpp_proto_wrapper",
        "documentation": {}
    },
    {
        "label": "patch_proto_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.cpp_proto_wrapper",
        "description": "catboost.build.scripts.cpp_proto_wrapper",
        "peekOfCode": "def patch_proto_file(text: str) -> tuple[str, int]:\n    return re.subn(FROM_RE, TO_RE, text)\ndef main(namespace: argparse.Namespace) -> int:\n    try:\n        subprocess.check_output(namespace.subcommand, stdin=None, stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        sys.stderr.write(\n            '{} returned non-zero exit code {}.\\n{}\\n'.format(' '.join(e.cmd), e.returncode, e.output.decode('utf-8'))\n        )\n        return e.returncode",
        "detail": "catboost.build.scripts.cpp_proto_wrapper",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.cpp_proto_wrapper",
        "description": "catboost.build.scripts.cpp_proto_wrapper",
        "peekOfCode": "def main(namespace: argparse.Namespace) -> int:\n    try:\n        subprocess.check_output(namespace.subcommand, stdin=None, stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError as e:\n        sys.stderr.write(\n            '{} returned non-zero exit code {}.\\n{}\\n'.format(' '.join(e.cmd), e.returncode, e.output.decode('utf-8'))\n        )\n        return e.returncode\n    for output in namespace.outputs:\n        with open(output, 'rt', encoding=\"utf-8\") as f:",
        "detail": "catboost.build.scripts.cpp_proto_wrapper",
        "documentation": {}
    },
    {
        "label": "FROM_RE",
        "kind": 5,
        "importPath": "catboost.build.scripts.cpp_proto_wrapper",
        "description": "catboost.build.scripts.cpp_proto_wrapper",
        "peekOfCode": "FROM_RE = re.compile(r\"((?:struct|class)\\s+\\S+\\s+)final\\s*:\")\nTO_RE = r\"\\1:\"\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--outputs', nargs='+', required=True)\n    parser.add_argument('subcommand', nargs='+')\n    return parser.parse_args()\ndef patch_proto_file(text: str) -> tuple[str, int]:\n    return re.subn(FROM_RE, TO_RE, text)\ndef main(namespace: argparse.Namespace) -> int:",
        "detail": "catboost.build.scripts.cpp_proto_wrapper",
        "documentation": {}
    },
    {
        "label": "TO_RE",
        "kind": 5,
        "importPath": "catboost.build.scripts.cpp_proto_wrapper",
        "description": "catboost.build.scripts.cpp_proto_wrapper",
        "peekOfCode": "TO_RE = r\"\\1:\"\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--outputs', nargs='+', required=True)\n    parser.add_argument('subcommand', nargs='+')\n    return parser.parse_args()\ndef patch_proto_file(text: str) -> tuple[str, int]:\n    return re.subn(FROM_RE, TO_RE, text)\ndef main(namespace: argparse.Namespace) -> int:\n    try:",
        "detail": "catboost.build.scripts.cpp_proto_wrapper",
        "documentation": {}
    },
    {
        "label": "Opts",
        "kind": 6,
        "importPath": "catboost.build.scripts.create_recursive_library_for_cmake",
        "description": "catboost.build.scripts.create_recursive_library_for_cmake",
        "peekOfCode": "class Opts(object):\n    def __init__(self, args):\n        argparser = argparse.ArgumentParser(allow_abbrev=False)\n        argparser.add_argument('--project-binary-dir', required=True)\n        argparser.add_argument('--cmake-ar', required=True)\n        argparser.add_argument('--cmake-ranlib', required=True)\n        argparser.add_argument('--cmake-host-system-name', required=True)\n        argparser.add_argument('--cmake-cxx-standard-libraries')\n        argparser.add_argument('--global-part-suffix', required=True)\n        self.parsed_args, other_args = argparser.parse_known_args(args=args)",
        "detail": "catboost.build.scripts.create_recursive_library_for_cmake",
        "documentation": {}
    },
    {
        "label": "FilesCombiner",
        "kind": 6,
        "importPath": "catboost.build.scripts.create_recursive_library_for_cmake",
        "description": "catboost.build.scripts.create_recursive_library_for_cmake",
        "peekOfCode": "class FilesCombiner(object):\n    def __init__(self, opts):\n        self.opts = opts\n        archiver_tool_path = opts.parsed_args.cmake_ar\n        if sys.platform.startswith('darwin'):\n            # force LIBTOOL even if CMAKE_AR is defined because 'ar' under Darwin does not contain the necessary options\n            arch_type = 'LIBTOOL'\n            archiver_tool_path = 'libtool'\n        elif opts.is_msvc_compatible_linker:\n            arch_type = 'LIB'",
        "detail": "catboost.build.scripts.create_recursive_library_for_cmake",
        "documentation": {}
    },
    {
        "label": "parse_export_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def parse_export_file(src):\n    for line in src:\n        line = line.strip()\n        if line and '#' not in line:\n            words = line.split()\n            if len(words) == 2 and words[0] == 'linux_version':\n                yield {'linux_version': words[1]}\n            elif len(words) == 2:\n                yield {'lang': words[0], 'sym': words[1]}\n            elif len(words) == 1:",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "to_c",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def to_c(sym):\n    symbols = collections.deque(sym.split('::'))\n    c_prefixes = [  # demangle prefixes for c++ symbols\n        '_ZN',  # namespace\n        '_ZTIN',  # typeinfo for\n        '_ZTSN',  # typeinfo name for\n        '_ZTTN',  # VTT for\n        '_ZTVN',  # vtable for\n        '_ZNK',  # const methods\n    ]",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "to_gnu",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def to_gnu(src, dest):\n    d = collections.defaultdict(list)\n    version = None\n    for item in parse_export_file(src):\n        if item.get('linux_version'):\n            if not version:\n                version = item.get('linux_version')\n            else:\n                raise Exception('More than one linux_version defined')\n        elif item['lang'] == 'C++':",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "to_msvc",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def to_msvc(src, dest):\n    dest.write('EXPORTS\\n')\n    for item in parse_export_file(src):\n        if item.get('linux_version'):\n            continue\n        if item.get('lang') == 'C':\n            dest.write('    {}\\n'.format(item.get('sym')))\ndef to_darwin(src, dest):\n    pre = ''\n    for item in parse_export_file(src):",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "to_darwin",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def to_darwin(src, dest):\n    pre = ''\n    for item in parse_export_file(src):\n        if item.get('linux_version'):\n            continue\n        if item['lang'] == 'C':\n            dest.write(pre + '-Wl,-exported_symbol,_' + item['sym'])\n        elif item['lang'] == 'C++':\n            for sym in to_c(item['sym']):\n                dest.write(pre + '-Wl,-exported_symbol,_' + sym)",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.export_script_gen",
        "description": "catboost.build.scripts.export_script_gen",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description='Convert self-invented platform independent export file format to the format required by specific linker'\n    )\n    parser.add_argument(\n        'src', type=argparse.FileType('r', encoding='UTF-8'), help='platform independent export file path'\n    )\n    parser.add_argument(\n        'dest', type=argparse.FileType('w', encoding='UTF-8'), help='destination export file for required linker'\n    )",
        "detail": "catboost.build.scripts.export_script_gen",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "catboost.build.scripts.f2c",
        "description": "catboost.build.scripts.f2c",
        "peekOfCode": "def mkdir_p(directory):\n    if not os.path.exists(directory):\n        os.makedirs(directory)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-t', '--tool')\n    parser.add_argument('-c', '--input')\n    parser.add_argument('-o', '--output')\n    args = parser.parse_args()\n    tmpdir = args.output + '.f2c'",
        "detail": "catboost.build.scripts.f2c",
        "documentation": {}
    },
    {
        "label": "header",
        "kind": 5,
        "importPath": "catboost.build.scripts.f2c",
        "description": "catboost.build.scripts.f2c",
        "peekOfCode": "header = '''\\\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wmissing-braces\"\n#pragma GCC diagnostic ignored \"-Wuninitialized\"\n#pragma GCC diagnostic ignored \"-Wreturn-type\"\n#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n#endif\n'''",
        "detail": "catboost.build.scripts.f2c",
        "documentation": {}
    },
    {
        "label": "footer",
        "kind": 5,
        "importPath": "catboost.build.scripts.f2c",
        "description": "catboost.build.scripts.f2c",
        "peekOfCode": "footer = '''\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n'''\ndef mkdir_p(directory):\n    if not os.path.exists(directory):\n        os.makedirs(directory)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()",
        "detail": "catboost.build.scripts.f2c",
        "documentation": {}
    },
    {
        "label": "BadChecksumFetchError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class BadChecksumFetchError(Exception):\n    pass\nclass IncompleteFetchError(Exception):\n    pass\nclass ResourceUnpackingError(Exception):\n    pass\nclass ResourceIsDirectoryError(Exception):\n    pass\nclass OutputIsDirectoryError(Exception):\n    pass",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "IncompleteFetchError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class IncompleteFetchError(Exception):\n    pass\nclass ResourceUnpackingError(Exception):\n    pass\nclass ResourceIsDirectoryError(Exception):\n    pass\nclass OutputIsDirectoryError(Exception):\n    pass\nclass OutputNotExistError(Exception):\n    pass",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "ResourceUnpackingError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class ResourceUnpackingError(Exception):\n    pass\nclass ResourceIsDirectoryError(Exception):\n    pass\nclass OutputIsDirectoryError(Exception):\n    pass\nclass OutputNotExistError(Exception):\n    pass\ndef setup_logging(args, base_name):\n    def makedirs(path):",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "ResourceIsDirectoryError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class ResourceIsDirectoryError(Exception):\n    pass\nclass OutputIsDirectoryError(Exception):\n    pass\nclass OutputNotExistError(Exception):\n    pass\ndef setup_logging(args, base_name):\n    def makedirs(path):\n        try:\n            os.makedirs(path)",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "OutputIsDirectoryError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class OutputIsDirectoryError(Exception):\n    pass\nclass OutputNotExistError(Exception):\n    pass\ndef setup_logging(args, base_name):\n    def makedirs(path):\n        try:\n            os.makedirs(path)\n        except OSError:\n            pass",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "OutputNotExistError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "class OutputNotExistError(Exception):\n    pass\ndef setup_logging(args, base_name):\n    def makedirs(path):\n        try:\n            os.makedirs(path)\n        except OSError:\n            pass\n    if args.log_path:\n        log_file_name = args.log_path",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "make_user_agent",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def make_user_agent():\n    return 'fetch_from: {host}'.format(host=socket.gethostname())\ndef add_common_arguments(parser):\n    parser.add_argument('--copy-to')  # used by jbuild in fetch_resource\n    parser.add_argument('--rename-to')  # used by test_node in inject_mds_resource_to_graph\n    parser.add_argument('--copy-to-dir')\n    parser.add_argument('--untar-to')\n    parser.add_argument(\n        '--rename', action='append', default=[], metavar='FILE', help='rename FILE to the corresponding output'\n    )",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "add_common_arguments",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def add_common_arguments(parser):\n    parser.add_argument('--copy-to')  # used by jbuild in fetch_resource\n    parser.add_argument('--rename-to')  # used by test_node in inject_mds_resource_to_graph\n    parser.add_argument('--copy-to-dir')\n    parser.add_argument('--untar-to')\n    parser.add_argument(\n        '--rename', action='append', default=[], metavar='FILE', help='rename FILE to the corresponding output'\n    )\n    parser.add_argument('--executable', action='store_true', help='make outputs executable')\n    parser.add_argument('--log-path')",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def ensure_dir(path):\n    if not (path == '' or os.path.isdir(path)):\n        os.makedirs(path)\n# Reference code: library/python/fs/__init__.py\ndef hardlink_or_copy(src, dst):\n    ensure_dir(os.path.dirname(dst))\n    if os.name == 'nt':\n        shutil.copy(src, dst)\n    else:\n        try:",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "hardlink_or_copy",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def hardlink_or_copy(src, dst):\n    ensure_dir(os.path.dirname(dst))\n    if os.name == 'nt':\n        shutil.copy(src, dst)\n    else:\n        try:\n            os.link(src, dst)\n        except OSError as e:\n            if e.errno == errno.EEXIST:\n                return",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "rename_or_copy_and_remove",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def rename_or_copy_and_remove(src, dst):\n    ensure_dir(os.path.dirname(dst))\n    try:\n        os.rename(src, dst)\n    except OSError:\n        shutil.copy(src, dst)\n        os.remove(src)\nclass BadChecksumFetchError(Exception):\n    pass\nclass IncompleteFetchError(Exception):",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def setup_logging(args, base_name):\n    def makedirs(path):\n        try:\n            os.makedirs(path)\n        except OSError:\n            pass\n    if args.log_path:\n        log_file_name = args.log_path\n    else:\n        log_file_name = base_name + \".log\"",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "is_temporary",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def is_temporary(e):\n    def is_broken(e):\n        return isinstance(e, urllib2.HTTPError) and e.code in (410, 404)\n    if is_broken(e):\n        return False\n    if isinstance(e, (BadChecksumFetchError, IncompleteFetchError, urllib2.URLError, socket.error)):\n        return True\n    import error\n    return error.is_temporary_error(e)\ndef uniq_string_generator(size=6, chars=string.ascii_lowercase + string.digits):",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "uniq_string_generator",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def uniq_string_generator(size=6, chars=string.ascii_lowercase + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))\ndef report_to_snowden(value):\n    def inner():\n        body = {\n            'namespace': 'ygg',\n            'key': 'fetch-from-sandbox',\n            'value': json.dumps(value),\n        }\n        urllib2.urlopen(",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "report_to_snowden",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def report_to_snowden(value):\n    def inner():\n        body = {\n            'namespace': 'ygg',\n            'key': 'fetch-from-sandbox',\n            'value': json.dumps(value),\n        }\n        urllib2.urlopen(\n            'https://back-snowden.qloud.yandex-team.ru/report/add',\n            json.dumps(",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "copy_stream",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def copy_stream(read, *writers, **kwargs):\n    chunk_size = kwargs.get('size', 1024 * 1024)\n    while True:\n        data = read(chunk_size)\n        if not data:\n            break\n        for write in writers:\n            write(data)\ndef md5file(fname):\n    res = hashlib.md5()",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "md5file",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def md5file(fname):\n    res = hashlib.md5()\n    with open(fname, 'rb') as f:\n        copy_stream(f.read, res.update)\n    return res.hexdigest()\ndef git_like_hash_with_size(filepath):\n    \"\"\"\n    Calculate git like hash for path\n    \"\"\"\n    sha = hashlib.sha1()",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "git_like_hash_with_size",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def git_like_hash_with_size(filepath):\n    \"\"\"\n    Calculate git like hash for path\n    \"\"\"\n    sha = hashlib.sha1()\n    file_size = 0\n    with open(filepath, 'rb') as f:\n        while True:\n            block = f.read(2**16)\n            if not block:",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "size_printer",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def size_printer(display_name, size):\n    sz = [0]\n    last_stamp = [dt.datetime.now()]\n    def printer(chunk):\n        sz[0] += len(chunk)\n        now = dt.datetime.now()\n        if last_stamp[0] + dt.timedelta(seconds=10) < now:\n            if size:\n                print >> sys.stderr, \"##status##{} - [[imp]]{:.1f}%[[rst]]\".format(\n                    display_name, 100.0 * sz[0] / size if size else 0",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "fetch_url",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def fetch_url(url, unpack, resource_file_name, expected_md5=None, expected_sha1=None, tries=10, writers=None):\n    logging.info('Downloading from url %s name %s and expected md5 %s', url, resource_file_name, expected_md5)\n    tmp_file_name = uniq_string_generator()\n    request = urllib2.Request(url, headers={'User-Agent': make_user_agent()})\n    req = retry.retry_func(lambda: urllib2.urlopen(request, timeout=30), tries=tries, delay=5, backoff=1.57079)\n    logging.debug('Headers: %s', req.headers.headers)\n    expected_file_size = int(req.headers.get('Content-Length', 0))\n    real_md5 = hashlib.md5()\n    real_sha1 = hashlib.sha1()\n    with open(tmp_file_name, 'wb') as fp:",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "chmod",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def chmod(filename, mode):\n    if platform.system().lower() == 'windows':\n        # https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions:\n        # hard to reset read-only attribute for removal if there are multiple hardlinks\n        return\n    stat = os.stat(filename)\n    if stat.st_mode & 0o777 != mode:\n        try:\n            os.chmod(filename, mode)\n        except OSError:",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "make_readonly",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def make_readonly(filename):\n    chmod(filename, os.stat(filename).st_mode & 0o111 | 0o444)\ndef process(fetched_file, file_name, args, remove=True):\n    assert len(args.rename) <= len(args.outputs), ('too few outputs to rename', args.rename, 'into', args.outputs)\n    fetched_file_is_dir = os.path.isdir(fetched_file)\n    if fetched_file_is_dir and not args.untar_to:\n        raise ResourceIsDirectoryError('Resource may be directory only with untar_to option: ' + fetched_file)\n    # make all read only\n    if fetched_file_is_dir:\n        for root, _, files in os.walk(fetched_file):",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "process",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from",
        "description": "catboost.build.scripts.fetch_from",
        "peekOfCode": "def process(fetched_file, file_name, args, remove=True):\n    assert len(args.rename) <= len(args.outputs), ('too few outputs to rename', args.rename, 'into', args.outputs)\n    fetched_file_is_dir = os.path.isdir(fetched_file)\n    if fetched_file_is_dir and not args.untar_to:\n        raise ResourceIsDirectoryError('Resource may be directory only with untar_to option: ' + fetched_file)\n    # make all read only\n    if fetched_file_is_dir:\n        for root, _, files in os.walk(fetched_file):\n            for filename in files:\n                make_readonly(os.path.join(root, filename))",
        "detail": "catboost.build.scripts.fetch_from",
        "documentation": {}
    },
    {
        "label": "ResourceInfoError",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "class ResourceInfoError(Exception):\n    pass\nclass UnsupportedProtocolException(Exception):\n    pass\ndef _sky_path():\n    return \"/usr/local/bin/sky\"\ndef _is_skynet_avaliable():\n    if not os.path.exists(_sky_path()):\n        return False\n    try:",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "UnsupportedProtocolException",
        "kind": 6,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "class UnsupportedProtocolException(Exception):\n    pass\ndef _sky_path():\n    return \"/usr/local/bin/sky\"\ndef _is_skynet_avaliable():\n    if not os.path.exists(_sky_path()):\n        return False\n    try:\n        subprocess.check_output([_sky_path(), \"--version\"])\n        return True",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser()\n    fetch_from.add_common_arguments(parser)\n    parser.add_argument('--resource-id', type=int, required=True)\n    parser.add_argument('--custom-fetcher')\n    parser.add_argument('--resource-file')\n    return parser.parse_args()\nclass ResourceInfoError(Exception):\n    pass\nclass UnsupportedProtocolException(Exception):",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "download_by_skynet",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def download_by_skynet(resource_info, file_name):\n    def sky_get(skynet_id, target_dir, timeout=None):\n        cmd_args = [_sky_path(), 'get', \"-N\", \"Backbone\", \"--user\", \"--wait\", \"--dir\", target_dir, skynet_id]\n        if timeout is not None:\n            cmd_args += [\"--timeout\", str(timeout)]\n        logging.info('Call skynet with args: %s', cmd_args)\n        stdout = subprocess.check_output(cmd_args).strip()\n        logging.debug('Skynet call with args %s is finished, result is %s', cmd_args, stdout)\n        return stdout\n    if not _is_skynet_avaliable():",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "get_resource_info",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def get_resource_info(resource_id, touch=False, no_links=False):\n    url = ''.join((_SANDBOX_BASE_URL, '/resource/', str(resource_id)))\n    headers = {}\n    if touch:\n        headers.update({'X-Touch-Resource': '1'})\n    if no_links:\n        headers.update({'X-No-Links': '1'})\n    return _query(url)\ndef get_resource_http_links(resource_id):\n    url = ''.join((_SANDBOX_BASE_URL, '/resource/', str(resource_id), '/data/http'))",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "get_resource_http_links",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def get_resource_http_links(resource_id):\n    url = ''.join((_SANDBOX_BASE_URL, '/resource/', str(resource_id), '/data/http'))\n    return [r['url'] + ORIGIN_SUFFIX for r in _query(url)]\ndef fetch_via_script(script, resource_id):\n    return subprocess.check_output([script, str(resource_id)]).rstrip()\ndef fetch(resource_id, custom_fetcher):\n    try:\n        resource_info = get_resource_info(resource_id, touch=True, no_links=True)\n    except Exception as e:\n        sys.stderr.write(",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "fetch_via_script",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def fetch_via_script(script, resource_id):\n    return subprocess.check_output([script, str(resource_id)]).rstrip()\ndef fetch(resource_id, custom_fetcher):\n    try:\n        resource_info = get_resource_info(resource_id, touch=True, no_links=True)\n    except Exception as e:\n        sys.stderr.write(\n            \"Failed to fetch resource {}: {}\\n\".format(resource_id, str(e))\n        )\n        raise",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "fetch",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def fetch(resource_id, custom_fetcher):\n    try:\n        resource_info = get_resource_info(resource_id, touch=True, no_links=True)\n    except Exception as e:\n        sys.stderr.write(\n            \"Failed to fetch resource {}: {}\\n\".format(resource_id, str(e))\n        )\n        raise\n    if resource_info.get('state', 'DELETED') != 'READY':\n        raise ResourceInfoError(\"Resource {} is not READY\".format(resource_id))",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "def main(args):\n    custom_fetcher = os.environ.get('YA_CUSTOM_FETCHER')\n    resource_info = _get_resource_info_from_file(args.resource_file)\n    if resource_info:\n        fetched_file = args.resource_file\n        file_name = resource_info['file_name']\n    else:\n        # This code should be merged to ya and removed.\n        fetched_file, file_name = fetch(args.resource_id, custom_fetcher)\n    fetch_from.process(fetched_file, file_name, args, remove=not custom_fetcher and not resource_info)",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "ORIGIN_SUFFIX",
        "kind": 5,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "ORIGIN_SUFFIX = '?origin=fetch-from-sandbox'\nMDS_PREFIX = 'http://storage-int.mds.yandex.net/get-sandbox/'\nTEMPORARY_ERROR_CODES = (429, 500, 503, 504)\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    fetch_from.add_common_arguments(parser)\n    parser.add_argument('--resource-id', type=int, required=True)\n    parser.add_argument('--custom-fetcher')\n    parser.add_argument('--resource-file')\n    return parser.parse_args()",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "MDS_PREFIX",
        "kind": 5,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "MDS_PREFIX = 'http://storage-int.mds.yandex.net/get-sandbox/'\nTEMPORARY_ERROR_CODES = (429, 500, 503, 504)\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    fetch_from.add_common_arguments(parser)\n    parser.add_argument('--resource-id', type=int, required=True)\n    parser.add_argument('--custom-fetcher')\n    parser.add_argument('--resource-file')\n    return parser.parse_args()\nclass ResourceInfoError(Exception):",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "TEMPORARY_ERROR_CODES",
        "kind": 5,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "TEMPORARY_ERROR_CODES = (429, 500, 503, 504)\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    fetch_from.add_common_arguments(parser)\n    parser.add_argument('--resource-id', type=int, required=True)\n    parser.add_argument('--custom-fetcher')\n    parser.add_argument('--resource-file')\n    return parser.parse_args()\nclass ResourceInfoError(Exception):\n    pass",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "_SANDBOX_BASE_URL",
        "kind": 5,
        "importPath": "catboost.build.scripts.fetch_from_sandbox",
        "description": "catboost.build.scripts.fetch_from_sandbox",
        "peekOfCode": "_SANDBOX_BASE_URL = 'https://sandbox.yandex-team.ru/api/v1.0'\ndef get_resource_info(resource_id, touch=False, no_links=False):\n    url = ''.join((_SANDBOX_BASE_URL, '/resource/', str(resource_id)))\n    headers = {}\n    if touch:\n        headers.update({'X-Touch-Resource': '1'})\n    if no_links:\n        headers.update({'X-No-Links': '1'})\n    return _query(url)\ndef get_resource_http_links(resource_id):",
        "detail": "catboost.build.scripts.fetch_from_sandbox",
        "documentation": {}
    },
    {
        "label": "out2err",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_msvc_output",
        "description": "catboost.build.scripts.fix_msvc_output",
        "peekOfCode": "def out2err(cmd):\n    return subprocess.Popen(cmd, stdout=sys.stderr).wait()\ndef decoding_needed(strval):\n    if sys.version_info >= (3, 0, 0):\n        return isinstance(strval, bytes)\n    else:\n        return False\ndef out2err_cut_first_line(cmd):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    first_line = True",
        "detail": "catboost.build.scripts.fix_msvc_output",
        "documentation": {}
    },
    {
        "label": "decoding_needed",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_msvc_output",
        "description": "catboost.build.scripts.fix_msvc_output",
        "peekOfCode": "def decoding_needed(strval):\n    if sys.version_info >= (3, 0, 0):\n        return isinstance(strval, bytes)\n    else:\n        return False\ndef out2err_cut_first_line(cmd):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    first_line = True\n    while True:\n        line = p.stdout.readline()",
        "detail": "catboost.build.scripts.fix_msvc_output",
        "documentation": {}
    },
    {
        "label": "out2err_cut_first_line",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_msvc_output",
        "description": "catboost.build.scripts.fix_msvc_output",
        "peekOfCode": "def out2err_cut_first_line(cmd):\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    first_line = True\n    while True:\n        line = p.stdout.readline()\n        line = line.decode('utf-8') if decoding_needed(line) else line\n        if not line:\n            break\n        if first_line:\n            sys.stdout.write(line)",
        "detail": "catboost.build.scripts.fix_msvc_output",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def run(*args):\n    # print >>sys.stderr, args\n    return subprocess.check_output(list(args), shell=False).strip()\ndef gen_renames_1(d):\n    for l in d.split('\\n'):\n        l = l.strip()\n        if ' ' in l:\n            yield l.split(' ')[-1]\ndef gen_renames_2(p, d):\n    for s in gen_renames_1(d):",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "gen_renames_1",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def gen_renames_1(d):\n    for l in d.split('\\n'):\n        l = l.strip()\n        if ' ' in l:\n            yield l.split(' ')[-1]\ndef gen_renames_2(p, d):\n    for s in gen_renames_1(d):\n        yield s + ' ' + p + s\ndef gen_renames(p, d):\n    return '\\n'.join(gen_renames_2(p, d)).strip() + '\\n'",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "gen_renames_2",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def gen_renames_2(p, d):\n    for s in gen_renames_1(d):\n        yield s + ' ' + p + s\ndef gen_renames(p, d):\n    return '\\n'.join(gen_renames_2(p, d)).strip() + '\\n'\ndef rename_syms(where, ret, libs):\n    p = 'py2_'\n    # join libs\n    run(where + 'llvm-ar', 'qcL', ret, *libs)\n    # find symbols to rename",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "gen_renames",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def gen_renames(p, d):\n    return '\\n'.join(gen_renames_2(p, d)).strip() + '\\n'\ndef rename_syms(where, ret, libs):\n    p = 'py2_'\n    # join libs\n    run(where + 'llvm-ar', 'qcL', ret, *libs)\n    # find symbols to rename\n    syms = run(where + 'llvm-nm', '--extern-only', '--defined-only', '-A', ret)\n    # prepare rename plan\n    renames = gen_renames(p, syms)",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "rename_syms",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def rename_syms(where, ret, libs):\n    p = 'py2_'\n    # join libs\n    run(where + 'llvm-ar', 'qcL', ret, *libs)\n    # find symbols to rename\n    syms = run(where + 'llvm-nm', '--extern-only', '--defined-only', '-A', ret)\n    # prepare rename plan\n    renames = gen_renames(p, syms)\n    with open('syms', 'w') as f:\n        f.write(renames)",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "fix_py2",
        "kind": 2,
        "importPath": "catboost.build.scripts.fix_py2_protobuf",
        "description": "catboost.build.scripts.fix_py2_protobuf",
        "peekOfCode": "def fix_py2(cmd, have_comand_files=False, prefix='lib', suffix='a'):\n    args = cmd\n    if have_comand_files:\n        args = pcf.get_args(cmd)\n    if 'protobuf_old' not in str(args):\n        return cmd\n    py2_libs = [prefix + 'contrib-libs-protobuf_old.' + suffix, prefix + 'pypython-protobuf-py2.' + suffix]\n    def need_rename(x):\n        for v in py2_libs:\n            if v in x:",
        "detail": "catboost.build.scripts.fix_py2_protobuf",
        "documentation": {}
    },
    {
        "label": "link_or_copy",
        "kind": 2,
        "importPath": "catboost.build.scripts.fs_tools",
        "description": "catboost.build.scripts.fs_tools",
        "peekOfCode": "def link_or_copy(src, dst, trace={}):\n    if dst not in trace:\n        trace[dst] = src\n    try:\n        if platform.system().lower() == 'windows':\n            shutil.copy(src, dst)\n        else:\n            os.link(src, dst)\n    except OSError as e:\n        if e.errno == errno.EEXIST:",
        "detail": "catboost.build.scripts.fs_tools",
        "documentation": {}
    },
    {
        "label": "mangle",
        "kind": 2,
        "importPath": "catboost.build.scripts.gen_py3_reg",
        "description": "catboost.build.scripts.gen_py3_reg",
        "peekOfCode": "def mangle(name):\n    if '.' not in name:\n        return name\n    return ''.join('{}{}'.format(len(s), s) for s in name.split('.'))\nif __name__ == '__main__':\n    if len(sys.argv) != 3:\n        print >> sys.stderr, 'Usage: <path/to/gen_py_reg.py> <python_module_name> <output_file>'\n        print >> sys.stderr, 'Passed: ' + ' '.join(sys.argv)\n        sys.exit(1)\n    with open(sys.argv[2], 'w') as f:",
        "detail": "catboost.build.scripts.gen_py3_reg",
        "documentation": {}
    },
    {
        "label": "template",
        "kind": 5,
        "importPath": "catboost.build.scripts.gen_py3_reg",
        "description": "catboost.build.scripts.gen_py3_reg",
        "peekOfCode": "template = '''\nstruct PyObject;\nextern \"C\" int PyImport_AppendInittab(const char* name, PyObject* (*initfunc)());\nextern \"C\" PyObject* {1}();\nnamespace {\n    struct TRegistrar {\n        inline TRegistrar() {\n            // TODO Collect all modules and call PyImport_ExtendInittab once\n            PyImport_AppendInittab(\"{0}\", {1});\n        }",
        "detail": "catboost.build.scripts.gen_py3_reg",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.gen_py_protos",
        "description": "catboost.build.scripts.gen_py_protos",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--suffixes\", nargs=\"*\", default=[])\n    parser.add_argument(\"--input\")\n    parser.add_argument(\"--ns\")\n    parser.add_argument(\"--py_ver\")\n    parser.add_argument(\"protoc_args\", nargs=argparse.REMAINDER)\n    script_args = parser.parse_args()\n    args = script_args.protoc_args\n    if args[0] == \"--\":",
        "detail": "catboost.build.scripts.gen_py_protos",
        "documentation": {}
    },
    {
        "label": "OUT_DIR_ARG",
        "kind": 5,
        "importPath": "catboost.build.scripts.gen_py_protos",
        "description": "catboost.build.scripts.gen_py_protos",
        "peekOfCode": "OUT_DIR_ARG = '--python_out='\ndef _noext(fname):\n    return fname[: fname.rfind('.')]\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--suffixes\", nargs=\"*\", default=[])\n    parser.add_argument(\"--input\")\n    parser.add_argument(\"--ns\")\n    parser.add_argument(\"--py_ver\")\n    parser.add_argument(\"protoc_args\", nargs=argparse.REMAINDER)",
        "detail": "catboost.build.scripts.gen_py_protos",
        "documentation": {}
    },
    {
        "label": "mangle",
        "kind": 2,
        "importPath": "catboost.build.scripts.gen_py_reg",
        "description": "catboost.build.scripts.gen_py_reg",
        "peekOfCode": "def mangle(name):\n    if '.' not in name:\n        return name\n    return ''.join('{}{}'.format(len(s), s) for s in name.split('.'))\nif __name__ == '__main__':\n    if len(sys.argv) != 3:\n        print >> sys.stderr, 'Usage: <path/to/gen_py_reg.py> <python_module_name> <output_file>'\n        print >> sys.stderr, 'Passed: ' + ' '.join(sys.argv)\n        sys.exit(1)\n    with open(sys.argv[2], 'w') as f:",
        "detail": "catboost.build.scripts.gen_py_reg",
        "documentation": {}
    },
    {
        "label": "template",
        "kind": 5,
        "importPath": "catboost.build.scripts.gen_py_reg",
        "description": "catboost.build.scripts.gen_py_reg",
        "peekOfCode": "template = '''\nextern \"C\" void PyImport_AppendInittab(const char* name, void (*fn)(void));\nextern \"C\" void {1}();\nnamespace {\n    struct TRegistrar {\n        inline TRegistrar() {\n            PyImport_AppendInittab(\"{0}\", {1});\n        }\n    } REG;\n}",
        "detail": "catboost.build.scripts.gen_py_reg",
        "documentation": {}
    },
    {
        "label": "_GitVersion",
        "kind": 6,
        "importPath": "catboost.build.scripts.generate_vcs_info",
        "description": "catboost.build.scripts.generate_vcs_info",
        "peekOfCode": "class _GitVersion:\n    @classmethod\n    def parse(cls, commit_hash, author_info, summary_info, body_info, tag_info, branch_info, depth=None):\n        r\"\"\"Parses output of\n        git rev-parse HEAD\n        git log -1 --format='format:%an <%ae>'\n        git log -1 --format='format:%s'\n        git log -1 --grep='^git-svn-id: ' --format='format:%b' or\n        git log -1 --grep='^Revision: r?\\d*' --format='format:%b\n        git describe --exact-match --tags HEAD",
        "detail": "catboost.build.scripts.generate_vcs_info",
        "documentation": {}
    },
    {
        "label": "_SystemInfo",
        "kind": 6,
        "importPath": "catboost.build.scripts.generate_vcs_info",
        "description": "catboost.build.scripts.generate_vcs_info",
        "peekOfCode": "class _SystemInfo:\n    LOCALE_LIST = _get_user_locale() + [sys.getfilesystemencoding(), 'utf-8']\n    @classmethod\n    def get_locale(cls):\n        import codecs\n        for i in cls.LOCALE_LIST:\n            if not i:\n                continue\n            try:\n                codecs.lookup(i)",
        "detail": "catboost.build.scripts.generate_vcs_info",
        "documentation": {}
    },
    {
        "label": "get_version_info",
        "kind": 2,
        "importPath": "catboost.build.scripts.generate_vcs_info",
        "description": "catboost.build.scripts.generate_vcs_info",
        "peekOfCode": "def get_version_info(arc_root, custom_version=\"\"):\n    info, vcs_root = _get_json(arc_root)\n    if info is None:\n        return \"\"\n    return _dump_json(\n        vcs_root,\n        info,\n        other_data=_SystemInfo.get_other_data(\n            src_dir=vcs_root,\n        ),",
        "detail": "catboost.build.scripts.generate_vcs_info",
        "documentation": {}
    },
    {
        "label": "INDENT",
        "kind": 5,
        "importPath": "catboost.build.scripts.generate_vcs_info",
        "description": "catboost.build.scripts.generate_vcs_info",
        "peekOfCode": "INDENT = \" \" * 4\ndef _get_vcs_dictionary(vcs_type, *arg):\n    if vcs_type == 'git':\n        return _GitVersion.parse(*arg)\n    else:\n        raise Exception(\"Unknown VCS type {}\".format(str(vcs_type)))\ndef _get_user_locale():\n    try:\n        return [locale.getencoding()]\n    except Exception:",
        "detail": "catboost.build.scripts.generate_vcs_info",
        "documentation": {}
    },
    {
        "label": "make_vfsoverlay",
        "kind": 2,
        "importPath": "catboost.build.scripts.generate_win_vfs",
        "description": "catboost.build.scripts.generate_win_vfs",
        "peekOfCode": "def make_vfsoverlay(bin_dir, args):\n    # args - list of paths in format: '/LIBPATH:\"path_to_dir\"'\n    libpaths = [path[len('/LIBPATH:\"'):-1] for path in args]\n    overlay = {\n        \"version\": 0,\n        \"case-sensitive\": \"false\",\n        \"roots\": []\n    }\n    for dir in libpaths:\n        for file in os.listdir(dir):",
        "detail": "catboost.build.scripts.generate_win_vfs",
        "documentation": {}
    },
    {
        "label": "call_java_with_command_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.java_command_file",
        "description": "catboost.build.scripts.java_command_file",
        "peekOfCode": "def call_java_with_command_file(cmd, wrapped_args, **kwargs):\n    is_win = platform.system() == 'Windows'\n    args = cmd\n    args_to_wrap = wrapped_args\n    if is_win:\n        args = [cmd[0]]\n        args_to_wrap = cmd[1:] + args_to_wrap\n    commands_file = 'wrapped.args'\n    with open(commands_file, 'w') as f:\n        f.write(' '.join(_java_cmd_file_quote(arg) for arg in args_to_wrap))",
        "detail": "catboost.build.scripts.java_command_file",
        "documentation": {}
    },
    {
        "label": "shlex_join",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def shlex_join(cmd):\n    # equivalent to shlex.join() in python 3\n    return ' '.join(pipes.quote(part) for part in cmd)\ndef parse_export_file(p):\n    with open(p, 'r') as f:\n        for l in f:\n            l = l.strip()\n            if l and '#' not in l:\n                words = l.split()\n                if len(words) == 2 and words[0] == 'linux_version':",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "parse_export_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def parse_export_file(p):\n    with open(p, 'r') as f:\n        for l in f:\n            l = l.strip()\n            if l and '#' not in l:\n                words = l.split()\n                if len(words) == 2 and words[0] == 'linux_version':\n                    yield {'linux_version': words[1]}\n                elif len(words) == 2:\n                    yield {'lang': words[0], 'sym': words[1]}",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "to_c",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def to_c(sym):\n    symbols = collections.deque(sym.split('::'))\n    c_prefixes = [  # demangle prefixes for c++ symbols\n        '_ZN',  # namespace\n        '_ZTIN',  # typeinfo for\n        '_ZTSN',  # typeinfo name for\n        '_ZTTN',  # VTT for\n        '_ZTVN',  # vtable for\n        '_ZNK',  # const methods\n    ]",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_darwin_param",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_darwin_param(ex):\n    for item in ex:\n        if item.get('linux_version'):\n            continue\n        if item['lang'] == 'C':\n            yield '-Wl,-exported_symbol,_' + item['sym']\n        elif item['lang'] == 'C++':\n            for sym in to_c(item['sym']):\n                yield '-Wl,-exported_symbol,_' + sym\n        else:",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_gnu_param",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_gnu_param(arch, ex):\n    d = collections.defaultdict(list)\n    version = None\n    for item in ex:\n        if item.get('linux_version'):\n            if not version:\n                version = item.get('linux_version')\n            else:\n                raise Exception('More than one linux_version defined')\n        elif item['lang'] == 'C++':",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_windows_param",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_windows_param(ex):\n    with tempfile.NamedTemporaryFile(delete=False) as def_file:\n        exports = []\n        for item in ex:\n            if item.get('lang') == 'C':\n                exports.append(item.get('sym'))\n        def_file.write('EXPORTS\\n')\n        for export in exports:\n            def_file.write('    {}\\n'.format(export))\n        return ['/DEF:{}'.format(def_file.name)]",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_cmd",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_cmd(arch, c):\n    if arch == 'WINDOWS':\n        prefix = '/DEF:'\n        f = fix_windows_param\n    else:\n        prefix = '-Wl,--version-script='\n        if arch in ('DARWIN', 'IOS', 'IOSSIM'):\n            f = fix_darwin_param\n        else:\n            f = lambda x: fix_gnu_param(arch, x)",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_cmd_for_musl",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_cmd_for_musl(cmd):\n    flags = []\n    for flag in cmd:\n        if flag not in MUSL_LIBS:\n            flags.append(flag)\n    return flags\ndef fix_cmd_for_dynamic_cuda(cmd):\n    flags = []\n    for flag in cmd:\n        if flag in CUDA_LIBRARIES:",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_cmd_for_dynamic_cuda",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_cmd_for_dynamic_cuda(cmd):\n    flags = []\n    for flag in cmd:\n        if flag in CUDA_LIBRARIES:\n            flags.append(CUDA_LIBRARIES[flag])\n        else:\n            flags.append(flag)\n    return flags\ndef fix_blas_resolving(cmd):\n    # Intel mkl comes as a precompiled static library and thus can not be recompiled with sanitizer runtime instrumentation.",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "fix_blas_resolving",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def fix_blas_resolving(cmd):\n    # Intel mkl comes as a precompiled static library and thus can not be recompiled with sanitizer runtime instrumentation.\n    # That's why we prefer to use cblas instead of Intel mkl as a drop-in replacement under sanitizers.\n    # But if the library has dependencies on mkl and cblas simultaneously, it will get a linking error.\n    # Hence we assume that it's probably compiling without sanitizers and we can easily remove cblas to prevent multiple definitions of the same symbol at link time.\n    for arg in cmd:\n        if arg.startswith('contrib/libs') and arg.endswith('mkl-lp64.a'):\n            return [arg for arg in cmd if not arg.endswith('libcontrib-libs-cblas.a')]\n    return cmd\ndef parse_args():",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def parse_args():\n    parser = optparse.OptionParser()\n    parser.disable_interspersed_args()\n    parser.add_option('--arch')\n    parser.add_option('--target')\n    parser.add_option('--soname')\n    parser.add_option('--source-root')\n    parser.add_option('--build-root')\n    parser.add_option('--fix-elf')\n    parser.add_option('--linker-output')",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "write_temp_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def write_temp_file(content):\n    import yatest.common as yc\n    filename = yc.output_path('test.exports')\n    with open(filename, 'w') as f:\n        f.write(content)\n    return filename\ndef test_fix_cmd_darwin():\n    export_file_content = \"\"\"\nC++ geobase5::details::lookup_impl::*\nC++ geobase5::hardcoded_service",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "test_fix_cmd_darwin",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def test_fix_cmd_darwin():\n    export_file_content = \"\"\"\nC++ geobase5::details::lookup_impl::*\nC++ geobase5::hardcoded_service\n\"\"\"\n    filename = write_temp_file(export_file_content)\n    args = ['-Wl,--version-script={}'.format(filename)]\n    assert fix_cmd('DARWIN', args) == [\n        '-Wl,-exported_symbol,__ZN8geobase57details11lookup_impl*',\n        '-Wl,-exported_symbol,__ZTIN8geobase57details11lookup_impl*',",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "run_fix_gnu_param",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def run_fix_gnu_param(export_file_content):\n    filename = write_temp_file(export_file_content)\n    result = fix_gnu_param('LINUX', list(parse_export_file(filename)))[0]\n    version_script_path = result[len('-Wl,--version-script=') :]\n    with open(version_script_path) as f:\n        content = f.read()\n    return content\ndef test_fix_gnu_param():\n    export_file_content = \"\"\"\nC++ geobase5::details::lookup_impl::*",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "test_fix_gnu_param",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def test_fix_gnu_param():\n    export_file_content = \"\"\"\nC++ geobase5::details::lookup_impl::*\nC   getFactoryMap\n\"\"\"\n    assert (\n        run_fix_gnu_param(export_file_content)\n        == \"\"\"{\nglobal:\n    extern \"C\" {",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "test_fix_gnu_param_with_linux_version",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "def test_fix_gnu_param_with_linux_version():\n    export_file_content = \"\"\"\nC++ geobase5::details::lookup_impl::*\nlinux_version ver1.0\nC   getFactoryMap\n\"\"\"\n    assert (\n        run_fix_gnu_param(export_file_content)\n        == \"\"\"ver1.0 {\nglobal:",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "MUSL_LIBS",
        "kind": 5,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "MUSL_LIBS = '-lc', '-lcrypt', '-ldl', '-lm', '-lpthread', '-lrt', '-lutil'\nCUDA_LIBRARIES = {\n    '-lcublas_static': '-lcublas',\n    '-lcublasLt_static': '-lcublasLt',\n    '-lcudart_static': '-lcudart',\n    '-lcudnn_static': '-lcudnn',\n    '-lcufft_static_nocallback': '-lcufft',\n    '-lcurand_static': '-lcurand',\n    '-lcusolver_static': '-lcusolver',\n    '-lcusparse_static': '-lcusparse',",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "CUDA_LIBRARIES",
        "kind": 5,
        "importPath": "catboost.build.scripts.link_dyn_lib",
        "description": "catboost.build.scripts.link_dyn_lib",
        "peekOfCode": "CUDA_LIBRARIES = {\n    '-lcublas_static': '-lcublas',\n    '-lcublasLt_static': '-lcublasLt',\n    '-lcudart_static': '-lcudart',\n    '-lcudnn_static': '-lcudnn',\n    '-lcufft_static_nocallback': '-lcufft',\n    '-lcurand_static': '-lcurand',\n    '-lcusolver_static': '-lcusolver',\n    '-lcusparse_static': '-lcusparse',\n    '-lmyelin_compiler_static': '-lmyelin',",
        "detail": "catboost.build.scripts.link_dyn_lib",
        "documentation": {}
    },
    {
        "label": "CUDAManager",
        "kind": 6,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "class CUDAManager:\n    def __init__(self, known_arches, nvprune_exe):\n        self.fatbin_libs = self._known_fatbin_libs(set(CUDA_LIBRARIES))\n        self.prune_args = []\n        if known_arches:\n            for arch in known_arches.split(':'):\n                self.prune_args.append('-gencode')\n                self.prune_args.append(self._arch_flag(arch))\n        self.nvprune_exe = nvprune_exe\n    def has_cuda_fatbins(self, cmd):",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "get_leaks_suppressions",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def get_leaks_suppressions(cmd):\n    supp, newcmd = [], []\n    for arg in cmd:\n        if arg.endswith(\".supp\"):\n            supp.append(arg)\n        else:\n            newcmd.append(arg)\n    return supp, newcmd\nMUSL_LIBS = '-lc', '-lcrypt', '-ldl', '-lm', '-lpthread', '-lrt', '-lutil'\nCUDA_LIBRARIES = {",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "tmpdir_generator",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def tmpdir_generator(base_path, prefix):\n    for idx in itertools.count():\n        path = os.path.abspath(os.path.join(base_path, prefix + '_' + str(idx)))\n        os.makedirs(path)\n        yield path\ndef process_cuda_library_by_external_tool(cmd, build_root, tool_name, callable_tool_executor, allowed_cuda_libs):\n    tmpdir_gen = tmpdir_generator(build_root, 'cuda_' + tool_name + '_libs')\n    new_flags = []\n    cuda_deps = set()\n    # Because each directory flag only affects flags that follow it,",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "process_cuda_library_by_external_tool",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def process_cuda_library_by_external_tool(cmd, build_root, tool_name, callable_tool_executor, allowed_cuda_libs):\n    tmpdir_gen = tmpdir_generator(build_root, 'cuda_' + tool_name + '_libs')\n    new_flags = []\n    cuda_deps = set()\n    # Because each directory flag only affects flags that follow it,\n    # for correct pruning we need to process that in reversed order\n    for flag in reversed(cmd):\n        if flag in allowed_cuda_libs:\n            cuda_deps.add('lib' + flag[2:] + '.a')\n            flag += '_' + tool_name",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "process_cuda_libraries_by_objcopy",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def process_cuda_libraries_by_objcopy(cmd, build_root, objcopy_exe):\n    if not objcopy_exe:\n        return cmd\n    def run_objcopy(from_path, to_path):\n        rename_section_command = [objcopy_exe, \"--rename-section\", \".ctors=.init_array\", from_path, to_path]\n        subprocess.check_call(rename_section_command)\n    possible_libraries = set(CUDA_LIBRARIES.keys())\n    possible_libraries.update([\n        '-lcudadevrt',\n        '-lcufilt',",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "process_cuda_libraries_by_nvprune",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def process_cuda_libraries_by_nvprune(cmd, cuda_manager, build_root):\n    if not cuda_manager.has_cuda_fatbins(cmd):\n        return cmd\n    # add custom linker script\n    to_dirpath = next(tmpdir_generator(build_root, 'cuda_linker_script'))\n    script_path = os.path.join(to_dirpath, 'script')\n    with open(script_path, 'w') as f:\n        cuda_manager.write_linker_script(f)\n    flags_with_linker = list(cmd) + ['-Wl,--script={}'.format(script_path)]\n    if not cuda_manager.can_prune_libs:",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "remove_excessive_flags",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def remove_excessive_flags(cmd):\n    flags = []\n    for flag in cmd:\n        if not flag.endswith('.ios.interface') and not flag.endswith('.pkg.fake'):\n            flags.append(flag)\n    return flags\ndef fix_sanitize_flag(cmd, opts):\n    \"\"\"\n    Remove -fsanitize=address flag if sanitazers are linked explicitly for linux target.\n    \"\"\"",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "fix_sanitize_flag",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def fix_sanitize_flag(cmd, opts):\n    \"\"\"\n    Remove -fsanitize=address flag if sanitazers are linked explicitly for linux target.\n    \"\"\"\n    for flag in cmd:\n        if flag.startswith('--target') and 'linux' not in flag.lower():\n            # use toolchained sanitize libraries\n            return cmd\n    assert opts.clang_ver\n    CLANG_RT = 'contrib/libs/clang' + opts.clang_ver + '-rt/lib/'",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "fix_cmd_for_musl",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def fix_cmd_for_musl(cmd):\n    flags = []\n    for flag in cmd:\n        if flag not in MUSL_LIBS:\n            flags.append(flag)\n    return flags\ndef fix_cmd_for_dynamic_cuda(cmd):\n    flags = []\n    for flag in cmd:\n        if flag in CUDA_LIBRARIES:",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "fix_cmd_for_dynamic_cuda",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def fix_cmd_for_dynamic_cuda(cmd):\n    flags = []\n    for flag in cmd:\n        if flag in CUDA_LIBRARIES:\n            flags.append(CUDA_LIBRARIES[flag])\n        else:\n            flags.append(flag)\n    return flags\ndef gen_default_suppressions(inputs, output, source_root):\n    import collections",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "gen_default_suppressions",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def gen_default_suppressions(inputs, output, source_root):\n    import collections\n    import os\n    supp_map = collections.defaultdict(set)\n    for filename in inputs:\n        sanitizer = os.path.basename(filename).split('.', 1)[0]\n        with open(os.path.join(source_root, filename)) as src:\n            for line in src:\n                line = line.strip()\n                if not line or line.startswith('#'):",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "fix_blas_resolving",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def fix_blas_resolving(cmd):\n    # Intel mkl comes as a precompiled static library and thus can not be recompiled with sanitizer runtime instrumentation.\n    # That's why we prefer to use cblas instead of Intel mkl as a drop-in replacement under sanitizers.\n    # But if the library has dependencies on mkl and cblas simultaneously, it will get a linking error.\n    # Hence we assume that it's probably compiling without sanitizers and we can easily remove cblas to prevent multiple definitions of the same symbol at link time.\n    for arg in cmd:\n        if arg.startswith('contrib/libs') and arg.endswith('mkl-lp64.a'):\n            return [arg for arg in cmd if not arg.endswith('libcontrib-libs-cblas.a')]\n    return cmd\ndef parse_args():",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "def parse_args():\n    parser = optparse.OptionParser()\n    parser.disable_interspersed_args()\n    parser.add_option('--musl', action='store_true')\n    parser.add_option('--custom-step')\n    parser.add_option('--python')\n    parser.add_option('--source-root')\n    parser.add_option('--build-root')\n    parser.add_option('--clang-ver')\n    parser.add_option('--dynamic-cuda', action='store_true')",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "MUSL_LIBS",
        "kind": 5,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "MUSL_LIBS = '-lc', '-lcrypt', '-ldl', '-lm', '-lpthread', '-lrt', '-lutil'\nCUDA_LIBRARIES = {\n    '-lcublas_static': '-lcublas',\n    '-lcublasLt_static': '-lcublasLt',\n    '-lcudart_static': '-lcudart',\n    '-lcudnn_static': '-lcudnn',\n    '-lcufft_static_nocallback': '-lcufft',\n    '-lcupti_static': '-lcupti',\n    '-lcurand_static': '-lcurand',\n    '-lcusolver_static': '-lcusolver',",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "CUDA_LIBRARIES",
        "kind": 5,
        "importPath": "catboost.build.scripts.link_exe",
        "description": "catboost.build.scripts.link_exe",
        "peekOfCode": "CUDA_LIBRARIES = {\n    '-lcublas_static': '-lcublas',\n    '-lcublasLt_static': '-lcublasLt',\n    '-lcudart_static': '-lcudart',\n    '-lcudnn_static': '-lcudnn',\n    '-lcufft_static_nocallback': '-lcufft',\n    '-lcupti_static': '-lcupti',\n    '-lcurand_static': '-lcurand',\n    '-lcusolver_static': '-lcusolver',\n    '-lcusparse_static': '-lcusparse',",
        "detail": "catboost.build.scripts.link_exe",
        "documentation": {}
    },
    {
        "label": "flt_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "def flt_args():\n    for a in sys.argv[1:]:\n        if a.startswith('-l'):\n            # skip -lxxx args\n            pass\n        else:\n            yield a\ndef get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--obj')",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "def get_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--obj')\n    parser.add_argument('--globals-lib')\n    parser.add_argument('--lib', required=True)\n    parser.add_argument('--arch', required=True)\n    parser.add_argument('--build-root', default=None)\n    parser.add_argument('--with-own-obj', action='store_true', default=False)\n    parser.add_argument('--with-global-srcs', action='store_true', default=False)\n    groups = {}",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "strip_suppression_files",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "def strip_suppression_files(srcs):\n    return [s for s in srcs if not s.endswith('.supp')]\ndef strip_forceload_prefix(srcs):\n    force_load_prefix = '-Wl,-force_load,'\n    return list(map(lambda lib: lib[lib.startswith(force_load_prefix) and len(force_load_prefix) :], srcs))\ndef main():\n    args, groups = get_args()\n    # Inputs\n    auto_input = groups['input']\n    # Outputs",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "strip_forceload_prefix",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "def strip_forceload_prefix(srcs):\n    force_load_prefix = '-Wl,-force_load,'\n    return list(map(lambda lib: lib[lib.startswith(force_load_prefix) and len(force_load_prefix) :], srcs))\ndef main():\n    args, groups = get_args()\n    # Inputs\n    auto_input = groups['input']\n    # Outputs\n    lib_output = args.lib\n    obj_output = args.obj",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "def main():\n    args, groups = get_args()\n    # Inputs\n    auto_input = groups['input']\n    # Outputs\n    lib_output = args.lib\n    obj_output = args.obj\n    # Dependencies\n    global_srcs = groups['global_srcs']\n    global_srcs = strip_suppression_files(global_srcs)",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "YA_ARG_PREFIX",
        "kind": 5,
        "importPath": "catboost.build.scripts.link_fat_obj",
        "description": "catboost.build.scripts.link_fat_obj",
        "peekOfCode": "YA_ARG_PREFIX = '-Ya,'\ndef flt_args():\n    for a in sys.argv[1:]:\n        if a.startswith('-l'):\n            # skip -lxxx args\n            pass\n        else:\n            yield a\ndef get_args():\n    parser = argparse.ArgumentParser()",
        "detail": "catboost.build.scripts.link_fat_obj",
        "documentation": {}
    },
    {
        "label": "Opts",
        "kind": 6,
        "importPath": "catboost.build.scripts.link_lib",
        "description": "catboost.build.scripts.link_lib",
        "peekOfCode": "class Opts(object):\n    def __init__(self, args):\n        self.archiver = args[0]\n        self.arch_type = args[1]\n        self.llvm_ar_format = args[2]\n        self.build_root = args[3]\n        self.plugin = args[4]\n        self.output = args[5]\n        auto_input = args[6:]\n        self.need_modify = False",
        "detail": "catboost.build.scripts.link_lib",
        "documentation": {}
    },
    {
        "label": "get_opts",
        "kind": 2,
        "importPath": "catboost.build.scripts.link_lib",
        "description": "catboost.build.scripts.link_lib",
        "peekOfCode": "def get_opts(args):\n    return Opts(args)\nif __name__ == \"__main__\":\n    opts = get_opts(sys.argv[1:])\n    # There is a bug in llvm-ar. Some files with size slightly greater 2^32\n    # still have GNU format instead of GNU64 and cause link problems.\n    # Workaround just lowers llvm-ar's GNU64 threshold to 2^31.\n    if opts.arch_type == 'LLVM_AR':\n        os.environ['SYM64_THRESHOLD'] = '31'\n    def call():",
        "detail": "catboost.build.scripts.link_lib",
        "documentation": {}
    },
    {
        "label": "load_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.preprocess",
        "description": "catboost.build.scripts.preprocess",
        "peekOfCode": "def load_file(p):\n    with open(p, 'r') as f:\n        return f.read()\ndef step(base, data, hh):\n    def flt():\n        for line in data.split('\\n'):\n            if line in hh:\n                pp = os.path.join(base, hh[line])\n                yield '\\n\\n' + load_file(pp) + '\\n\\n'\n                os.unlink(pp)",
        "detail": "catboost.build.scripts.preprocess",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "catboost.build.scripts.preprocess",
        "description": "catboost.build.scripts.preprocess",
        "peekOfCode": "def step(base, data, hh):\n    def flt():\n        for line in data.split('\\n'):\n            if line in hh:\n                pp = os.path.join(base, hh[line])\n                yield '\\n\\n' + load_file(pp) + '\\n\\n'\n                os.unlink(pp)\n            else:\n                yield line\n    return '\\n'.join(flt())",
        "detail": "catboost.build.scripts.preprocess",
        "documentation": {}
    },
    {
        "label": "subst_headers",
        "kind": 2,
        "importPath": "catboost.build.scripts.preprocess",
        "description": "catboost.build.scripts.preprocess",
        "peekOfCode": "def subst_headers(path, headers):\n    hh = dict()\n    for h in headers:\n        hh['# include \"' + h + '\"'] = h\n    data = load_file(path)\n    prev = data\n    while True:\n        ret = step(os.path.dirname(path), prev, hh)\n        if ret == prev:\n            break",
        "detail": "catboost.build.scripts.preprocess",
        "documentation": {}
    },
    {
        "label": "is_cmdfile_arg",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def is_cmdfile_arg(arg):\n    # type: (str) -> bool\n    return arg.startswith('@')\ndef cmdfile_path(arg):\n    # type: (str) -> str\n    return arg[1:]\ndef read_from_command_file(arg):\n    # type: (str) -> list[str]\n    with open(arg) as afile:\n        return afile.read().splitlines()",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "cmdfile_path",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def cmdfile_path(arg):\n    # type: (str) -> str\n    return arg[1:]\ndef read_from_command_file(arg):\n    # type: (str) -> list[str]\n    with open(arg) as afile:\n        return afile.read().splitlines()\ndef skip_markers(args):\n    # type: (list[str]) -> list[str]\n    res = []",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "read_from_command_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def read_from_command_file(arg):\n    # type: (str) -> list[str]\n    with open(arg) as afile:\n        return afile.read().splitlines()\ndef skip_markers(args):\n    # type: (list[str]) -> list[str]\n    res = []\n    for arg in args:\n        if arg == '--ya-start-command-file' or arg == '--ya-end-command-file':\n            continue",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "skip_markers",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def skip_markers(args):\n    # type: (list[str]) -> list[str]\n    res = []\n    for arg in args:\n        if arg == '--ya-start-command-file' or arg == '--ya-end-command-file':\n            continue\n        res.append(arg)\n    return res\ndef iter_args(\n        args,  # type: list[str]",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "iter_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def iter_args(\n        args,  # type: list[str]\n        ):\n    for arg in args:\n        if not is_cmdfile_arg(arg):\n            if arg == '--ya-start-command-file' or arg == '--ya-end-command-file':\n                continue\n            yield arg\n        else:\n            for cmdfile_arg in read_from_command_file(cmdfile_path(arg)):",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_command_files",
        "description": "catboost.build.scripts.process_command_files",
        "peekOfCode": "def get_args(args):\n    # type: (list[str]) -> list[str]\n    return list(iter_args(args))",
        "detail": "catboost.build.scripts.process_command_files",
        "documentation": {}
    },
    {
        "label": "ProcessWholeArchiveOption",
        "kind": 6,
        "importPath": "catboost.build.scripts.process_whole_archive_option",
        "description": "catboost.build.scripts.process_whole_archive_option",
        "peekOfCode": "class ProcessWholeArchiveOption:\n    def __init__(self, arch, peers=None, libs=None):\n        self.arch = arch.upper()\n        self.peers = {x: 0 for x in peers} if peers else None\n        self.libs = {x: 0 for x in libs} if libs else None\n        self.start_wa_marker = '--start-wa'\n        self.end_wa_marker = '--end-wa'\n    def _match_peer_lib(self, arg, ext):\n        key = None\n        if arg.endswith(ext):",
        "detail": "catboost.build.scripts.process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "get_whole_archive_peers_and_libs",
        "kind": 2,
        "importPath": "catboost.build.scripts.process_whole_archive_option",
        "description": "catboost.build.scripts.process_whole_archive_option",
        "peekOfCode": "def get_whole_archive_peers_and_libs(args):\n    remaining_args = []\n    peers = []\n    libs = []\n    peers_flag = '--whole-archive-peers'\n    libs_flag = '--whole-archive-libs'\n    next_is_peer = False\n    next_is_lib = False\n    for arg in args:\n        if arg == peers_flag:",
        "detail": "catboost.build.scripts.process_whole_archive_option",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.py_compile",
        "description": "catboost.build.scripts.py_compile",
        "peekOfCode": "def main():\n    srcpathx, in_fname, out_fname = sys.argv[1:]\n    srcpath = srcpathx[:-1]\n    with open(in_fname, 'r') as in_file:\n        source = in_file.read()\n    code = compile(source, srcpath, 'exec', dont_inherit=True)\n    with open(out_fname, 'wb') as out_file:\n        marshal.dump(code, out_file)\nif __name__ == \"__main__\":\n    main()",
        "detail": "catboost.build.scripts.py_compile",
        "documentation": {}
    },
    {
        "label": "patch_line",
        "kind": 2,
        "importPath": "catboost.build.scripts.re_replace",
        "description": "catboost.build.scripts.re_replace",
        "peekOfCode": "def patch_line(line: str, from_re: re.Pattern, to_re: str) -> str:\n    return re.sub(from_re, to_re, line)\ndef main(args: List[str]):\n    argparser = argparse.ArgumentParser(allow_abbrev=False)\n    argparser.add_argument('--from-re', required=True)\n    argparser.add_argument('--to-re', required=True)\n    parsed_args, files = argparser.parse_known_args(args=args)\n    from_re = re.compile(parsed_args.from_re)\n    if not files:\n        raise Exception('No input files')",
        "detail": "catboost.build.scripts.re_replace",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.re_replace",
        "description": "catboost.build.scripts.re_replace",
        "peekOfCode": "def main(args: List[str]):\n    argparser = argparse.ArgumentParser(allow_abbrev=False)\n    argparser.add_argument('--from-re', required=True)\n    argparser.add_argument('--to-re', required=True)\n    parsed_args, files = argparser.parse_known_args(args=args)\n    from_re = re.compile(parsed_args.from_re)\n    if not files:\n        raise Exception('No input files')\n    patched_files = []\n    skipped_files = []",
        "detail": "catboost.build.scripts.re_replace",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.rodata2asm",
        "description": "catboost.build.scripts.rodata2asm",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description='Convert rodata into asm source with embedded file content')\n    parser.add_argument('symbol', help='symvol name exported from generated filr')\n    parser.add_argument('rodata', help='input .rodata file path')\n    parser.add_argument('asm', type=argparse.FileType('w', encoding='UTF-8'), help='destination .asm file path')\n    parser.add_argument('--elf', action='store_true')\n    args = parser.parse_args()\n    file_size = os.path.getsize(args.rodata)\n    args.asm.write('global ' + args.symbol + '\\n')\n    args.asm.write('global ' + args.symbol + 'Size' + '\\n')",
        "detail": "catboost.build.scripts.rodata2asm",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.rodata2cpp",
        "description": "catboost.build.scripts.rodata2cpp",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description='Convert rodata into C++ source with embedded file content')\n    parser.add_argument('symbol', help='symbol name exported from generated file')\n    parser.add_argument('rodata', type=argparse.FileType('rb'), help='input .rodata file path')\n    parser.add_argument('cpp', type=argparse.FileType('w', encoding='UTF-8'), help='destination .cpp file path')\n    args = parser.parse_args()\n    args.cpp.write('static_assert(sizeof(unsigned int) == 4, \"ups, something gone wrong\");\\n\\n')\n    args.cpp.write('extern \"C\" {\\n')\n    args.cpp.write('    extern const unsigned char ' + args.symbol + '[] = {\\n')\n    cnt = 0",
        "detail": "catboost.build.scripts.rodata2cpp",
        "documentation": {}
    },
    {
        "label": "stringize",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def stringize(s):\n    return s.encode('utf-8') if isinstance(s, unicode) else s\ndef run_subprocess(*args, **kwargs):\n    if 'env' in kwargs:\n        kwargs['env'] = {stringize(k): stringize(v) for k, v in kwargs['env'].iteritems()}\n    p = subprocess.Popen(*args, **kwargs)\n    procs.append(p)\n    return p\ndef run_subprocess_with_timeout(timeout, args):\n    attempts_remaining = 5",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "run_subprocess",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def run_subprocess(*args, **kwargs):\n    if 'env' in kwargs:\n        kwargs['env'] = {stringize(k): stringize(v) for k, v in kwargs['env'].iteritems()}\n    p = subprocess.Popen(*args, **kwargs)\n    procs.append(p)\n    return p\ndef run_subprocess_with_timeout(timeout, args):\n    attempts_remaining = 5\n    delay = 1\n    p = None",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "run_subprocess_with_timeout",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def run_subprocess_with_timeout(timeout, args):\n    attempts_remaining = 5\n    delay = 1\n    p = None\n    while True:\n        try:\n            p = run_subprocess(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            stdout, stderr = p.communicate(timeout=timeout)\n            return p, stdout, stderr\n        except subprocess.TimeoutExpired as e:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "terminate_slaves",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def terminate_slaves():\n    for p in procs:\n        try:\n            p.terminate()\n        except Exception:\n            pass\ndef sig_term(sig, fr):\n    terminate_slaves()\n    sys.exit(sig)\ndef subst_path(l):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "sig_term",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def sig_term(sig, fr):\n    terminate_slaves()\n    sys.exit(sig)\ndef subst_path(l):\n    if len(l) > 3:\n        if l[:3].lower() in ('z:\\\\', 'z:/'):\n            return l[2:].replace('\\\\', '/')\n    return l\ndef call_wine_cmd_once(wine, cmd, env, mode):\n    p = run_subprocess(",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "subst_path",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def subst_path(l):\n    if len(l) > 3:\n        if l[:3].lower() in ('z:\\\\', 'z:/'):\n            return l[2:].replace('\\\\', '/')\n    return l\ndef call_wine_cmd_once(wine, cmd, env, mode):\n    p = run_subprocess(\n        wine + cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, env=env, close_fds=True, shell=False\n    )\n    output = find_cmd_out(cmd)",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "call_wine_cmd_once",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def call_wine_cmd_once(wine, cmd, env, mode):\n    p = run_subprocess(\n        wine + cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, env=env, close_fds=True, shell=False\n    )\n    output = find_cmd_out(cmd)\n    error = None\n    if output is not None and os.path.exists(output):\n        try:\n            os.remove(output)\n        except OSError as e:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "prepare_vc",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def prepare_vc(fr, to):\n    for p in os.listdir(fr):\n        fr_p = os.path.join(fr, p)\n        to_p = os.path.join(to, p)\n        if not os.path.exists(to_p):\n            print >> sys.stderr, 'install %s -> %s' % (fr_p, to_p)\n            os.link(fr_p, to_p)\ndef run_slave():\n    args = json.loads(sys.argv[3])\n    wine = sys.argv[1]",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "run_slave",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def run_slave():\n    args = json.loads(sys.argv[3])\n    wine = sys.argv[1]\n    signal.signal(signal.SIGTERM, sig_term)\n    if args.get('tout', None):\n        signal.signal(signal.SIGALRM, sig_term)\n        signal.alarm(args['tout'])\n    tout = 0.1\n    while True:\n        try:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "find_cmd_out",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def find_cmd_out(args):\n    for arg in args:\n        if arg.startswith('/Fo'):\n            return arg[3:]\n        if arg.startswith('/OUT:'):\n            return arg[5:]\ndef calc_zero_cnt(data):\n    zero_cnt = 0\n    for ch in data:\n        if ch == chr(0):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "calc_zero_cnt",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def calc_zero_cnt(data):\n    zero_cnt = 0\n    for ch in data:\n        if ch == chr(0):\n            zero_cnt += 1\n    return zero_cnt\ndef is_good_file(p):\n    if not os.path.isfile(p):\n        return False\n    if os.path.getsize(p) < 300:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "is_good_file",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def is_good_file(p):\n    if not os.path.isfile(p):\n        return False\n    if os.path.getsize(p) < 300:\n        return False\n    asm_pattern = re.compile(r'asm(\\.\\w+)?\\.obj$')\n    if asm_pattern.search(p):\n        pass\n    elif p.endswith('.obj'):\n        with open(p, 'rb') as f:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "colorize_strings",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]\n        p = l.find(\"'\")\n        if p >= 0:\n            yield CYA + \"'\" + subst_path(l[:p]) + \"'\" + RST\n            for x in colorize_strings(l[p + 1 :]):\n                yield x",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "colorize_line",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def colorize_line(l):\n    lll = l\n    try:\n        parts = []\n        if l.startswith('(compiler file'):\n            return ''.join(colorize_strings(l))\n        if l.startswith('/'):\n            p = l.find('(')\n            parts.append(GRAY + l[:p] + RST)\n            l = l[p:]",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def colorize(out):\n    return '\\n'.join(colorize_line(l) for l in out.split('\\n'))\ndef trim_path(path, winepath):\n    p1, p1_stdout, p1_stderr = run_subprocess_with_timeout(60, [winepath, '-w', path])\n    win_path = p1_stdout.strip()\n    if p1.returncode != 0 or not win_path:\n        # Fall back to only winepath -s\n        win_path = path\n    p2, p2_stdout, p2_stderr = run_subprocess_with_timeout(60, [winepath, '-s', win_path])\n    short_path = p2_stdout.strip()",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "trim_path",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def trim_path(path, winepath):\n    p1, p1_stdout, p1_stderr = run_subprocess_with_timeout(60, [winepath, '-w', path])\n    win_path = p1_stdout.strip()\n    if p1.returncode != 0 or not win_path:\n        # Fall back to only winepath -s\n        win_path = path\n    p2, p2_stdout, p2_stderr = run_subprocess_with_timeout(60, [winepath, '-s', win_path])\n    short_path = p2_stdout.strip()\n    check_path = short_path\n    if check_path.startswith(('Z:', 'z:')):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "downsize_path",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def downsize_path(path, short_names):\n    flag = ''\n    if path.startswith('/Fo'):\n        flag = '/Fo'\n        path = path[3:]\n    for full_name, short_name in short_names.items():\n        if path.startswith(full_name):\n            path = path.replace(full_name, short_name)\n    return flag + path\ndef make_full_path_arg(arg, bld_root, short_root):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "make_full_path_arg",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def make_full_path_arg(arg, bld_root, short_root):\n    if arg[0] != '/' and len(os.path.join(bld_root, arg)) > 250:\n        return os.path.join(short_root, arg)\n    return arg\ndef fix_path(p):\n    topdirs = ['/%s/' % d for d in os.listdir('/')]\n    def abs_path_start(path, pos):\n        if pos < 0:\n            return False\n        return pos == 0 or path[pos - 1] == ':'",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "fix_path",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def fix_path(p):\n    topdirs = ['/%s/' % d for d in os.listdir('/')]\n    def abs_path_start(path, pos):\n        if pos < 0:\n            return False\n        return pos == 0 or path[pos - 1] == ':'\n    pp = None\n    for pr in topdirs:\n        pp2 = p.find(pr)\n        if abs_path_start(p, pp2) and (pp is None or pp > pp2):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "process_free_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def process_free_args(args, wine, bld_root, mode):\n    whole_archive_prefix = '/WHOLEARCHIVE:'\n    short_names = {}\n    winepath = os.path.join(os.path.dirname(wine), 'winepath')\n    short_names[bld_root] = trim_path(bld_root, winepath)\n    # Slow for no benefit.\n    # arc_root = args.arcadia_root\n    # short_names[arc_root] = trim_path(arc_root, winepath)\n    free_args, wa_peers, wa_libs = pwa.get_whole_archive_peers_and_libs(pcf.skip_markers(args))\n    process_link = lambda x: make_full_path_arg(x, bld_root, short_names[bld_root]) if mode in ('link', 'lib') else x",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "run_main",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def run_main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('wine', action='store')\n    parser.add_argument('-v', action='store', dest='version', default='120')\n    parser.add_argument('-I', action='append', dest='incl_paths')\n    parser.add_argument('mode', action='store')\n    parser.add_argument('arcadia_root', action='store')\n    parser.add_argument('arcadia_build_root', action='store')\n    parser.add_argument('binary', action='store')\n    parser.add_argument('free_args', nargs=argparse.REMAINDER)",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "def main():\n    prefix_suffix = os.environ.pop('WINEPREFIX_SUFFIX', None)\n    if prefix_suffix is not None:\n        prefix = os.environ.pop('WINEPREFIX', None)\n        if prefix is not None:\n            os.environ['WINEPREFIX'] = os.path.join(prefix, prefix_suffix)\n    # just in case\n    signal.alarm(2000)\n    if sys.argv[2] == 'slave':\n        func = run_slave",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "procs",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "procs = []\nbuild_kekeke = 45\ndef stringize(s):\n    return s.encode('utf-8') if isinstance(s, unicode) else s\ndef run_subprocess(*args, **kwargs):\n    if 'env' in kwargs:\n        kwargs['env'] = {stringize(k): stringize(v) for k, v in kwargs['env'].iteritems()}\n    p = subprocess.Popen(*args, **kwargs)\n    procs.append(p)\n    return p",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "build_kekeke",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "build_kekeke = 45\ndef stringize(s):\n    return s.encode('utf-8') if isinstance(s, unicode) else s\ndef run_subprocess(*args, **kwargs):\n    if 'env' in kwargs:\n        kwargs['env'] = {stringize(k): stringize(v) for k, v in kwargs['env'].iteritems()}\n    p = subprocess.Popen(*args, **kwargs)\n    procs.append(p)\n    return p\ndef run_subprocess_with_timeout(timeout, args):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "RED = '\\x1b[31;1m'\nGRAY = '\\x1b[30;1m'\nRST = '\\x1b[0m'\nMGT = '\\x1b[35m'\nYEL = '\\x1b[33m'\nGRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "GRAY",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "GRAY = '\\x1b[30;1m'\nRST = '\\x1b[0m'\nMGT = '\\x1b[35m'\nYEL = '\\x1b[33m'\nGRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "RST",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "RST = '\\x1b[0m'\nMGT = '\\x1b[35m'\nYEL = '\\x1b[33m'\nGRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "MGT",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "MGT = '\\x1b[35m'\nYEL = '\\x1b[33m'\nGRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]\n        p = l.find(\"'\")",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "YEL",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "YEL = '\\x1b[33m'\nGRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]\n        p = l.find(\"'\")\n        if p >= 0:",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "GRN",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "GRN = '\\x1b[32m'\nCYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]\n        p = l.find(\"'\")\n        if p >= 0:\n            yield CYA + \"'\" + subst_path(l[:p]) + \"'\" + RST",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "CYA",
        "kind": 5,
        "importPath": "catboost.build.scripts.run_msvc_wine",
        "description": "catboost.build.scripts.run_msvc_wine",
        "peekOfCode": "CYA = '\\x1b[36m'\ndef colorize_strings(l):\n    p = l.find(\"'\")\n    if p >= 0:\n        yield l[:p]\n        l = l[p + 1 :]\n        p = l.find(\"'\")\n        if p >= 0:\n            yield CYA + \"'\" + subst_path(l[:p]) + \"'\" + RST\n            for x in colorize_strings(l[p + 1 :]):",
        "detail": "catboost.build.scripts.run_msvc_wine",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--split-factor\", type=int, default=0)\n    parser.add_argument(\"--shard\", type=int, default=0)\n    parser.add_argument(\"--fork-mode\", type=str, default=\"SEQUENTIAL\")\n    parser.add_argument(\"command\", nargs=argparse.REMAINDER)\n    return parser.parse_args()\ndef get_sequential_chunk(tests, modulo, modulo_index):\n    chunk_size = len(tests) // modulo\n    not_used = len(tests) % modulo",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "get_sequential_chunk",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def get_sequential_chunk(tests, modulo, modulo_index):\n    chunk_size = len(tests) // modulo\n    not_used = len(tests) % modulo\n    shift = chunk_size + (modulo_index < not_used)\n    start = chunk_size * modulo_index + min(modulo_index, not_used)\n    end = start + shift\n    return [] if end > len(tests) else tests[start:end]\ndef get_shuffled_chunk(tests, modulo, modulo_index):\n    result_tests = []\n    for i, test in enumerate(tests):",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "get_shuffled_chunk",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def get_shuffled_chunk(tests, modulo, modulo_index):\n    result_tests = []\n    for i, test in enumerate(tests):\n        if i % modulo == modulo_index:\n            result_tests.append(test)\n    return result_tests\ndef list_tests(binary):\n    # can't use NamedTemporaryFile or mkstemp because of child process access issues on Windows\n    # https://stackoverflow.com/questions/66744497/python-tempfile-namedtemporaryfile-cant-use-generated-tempfile\n    with tempfile.TemporaryDirectory() as tmp_dir:",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "list_tests",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def list_tests(binary):\n    # can't use NamedTemporaryFile or mkstemp because of child process access issues on Windows\n    # https://stackoverflow.com/questions/66744497/python-tempfile-namedtemporaryfile-cant-use-generated-tempfile\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        list_file = os.path.join(tmp_dir, 'list')\n        cmd = [binary, \"--list-verbose\", \"--list-path\", list_file]\n        subprocess.check_call(cmd)\n        with open(list_file) as afile:\n            lines = afile.read().strip().split(\"\\n\")\n            lines = [x.strip() for x in lines]",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "get_shard_tests",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def get_shard_tests(args):\n    test_names = list_tests(args.command[0])\n    test_names = sorted(test_names)\n    if args.fork_mode == \"MODULO\":\n        return get_shuffled_chunk(test_names, args.split_factor, args.shard)\n    elif args.fork_mode == \"SEQUENTIAL\":\n        return get_sequential_chunk(test_names, args.split_factor, args.shard)\n    else:\n        raise ValueError(\"detected unknown partition mode: {}\".format(args.fork_mode))\ndef get_shard_cmd_args(args):",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "get_shard_cmd_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def get_shard_cmd_args(args):\n    return [\"+{}\".format(x) for x in get_shard_tests(args)]\ndef main():\n    args = parse_args()\n    if args.split_factor:\n        shard_cmd = get_shard_cmd_args(args)\n        if shard_cmd:\n            cmd = args.command + shard_cmd\n        else:\n            print(\"No tests for {} shard\".format(args.shard))",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.split_unittest",
        "description": "catboost.build.scripts.split_unittest",
        "peekOfCode": "def main():\n    args = parse_args()\n    if args.split_factor:\n        shard_cmd = get_shard_cmd_args(args)\n        if shard_cmd:\n            cmd = args.command + shard_cmd\n        else:\n            print(\"No tests for {} shard\".format(args.shard))\n            return 0\n    else:",
        "detail": "catboost.build.scripts.split_unittest",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.build.scripts.tared_protoc",
        "description": "catboost.build.scripts.tared_protoc",
        "peekOfCode": "def parse_args():\n    parser = optparse.OptionParser()\n    parser.disable_interspersed_args()\n    parser.add_option('--tar-output')\n    parser.add_option('--protoc-out-dir')\n    return parser.parse_args()\ndef main():\n    opts, args = parse_args()\n    assert opts.tar_output\n    assert opts.protoc_out_dir",
        "detail": "catboost.build.scripts.tared_protoc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.tared_protoc",
        "description": "catboost.build.scripts.tared_protoc",
        "peekOfCode": "def main():\n    opts, args = parse_args()\n    assert opts.tar_output\n    assert opts.protoc_out_dir\n    if not os.path.exists(opts.protoc_out_dir):\n        os.makedirs(opts.protoc_out_dir)\n    sp.check_call(args)\n    with tarfile.open(opts.tar_output, 'w', format=tarfile.USTAR_FORMAT) as tf:\n        for root, dirs, files in os.walk(opts.protoc_out_dir, topdown=True):\n            dirs.sort()",
        "detail": "catboost.build.scripts.tared_protoc",
        "documentation": {}
    },
    {
        "label": "add_options",
        "kind": 2,
        "importPath": "catboost.build.scripts.thinlto_cache",
        "description": "catboost.build.scripts.thinlto_cache",
        "peekOfCode": "def add_options(parser):\n    parser.add_option('--thinlto-cache')\n    parser.add_option('--thinlto-cache-write', action='store_true')\ndef preprocess(opts, cmd):\n    if opts.thinlto_cache:\n        cache_dir = os.path.join(opts.build_root, CACHE_DIR_NAME)\n        cmd +=['-Wl,--thinlto-cache-dir={}'.format(cache_dir)]\n        if opts.thinlto_cache_write:\n            os.mkdir(cache_dir)\n        else:",
        "detail": "catboost.build.scripts.thinlto_cache",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "catboost.build.scripts.thinlto_cache",
        "description": "catboost.build.scripts.thinlto_cache",
        "peekOfCode": "def preprocess(opts, cmd):\n    if opts.thinlto_cache:\n        cache_dir = os.path.join(opts.build_root, CACHE_DIR_NAME)\n        cmd +=['-Wl,--thinlto-cache-dir={}'.format(cache_dir)]\n        if opts.thinlto_cache_write:\n            os.mkdir(cache_dir)\n        else:\n            with tarfile.open(opts.thinlto_cache, 'r') as tar:\n                tar.extractall(opts.build_root)\ndef postprocess(opts):",
        "detail": "catboost.build.scripts.thinlto_cache",
        "documentation": {}
    },
    {
        "label": "postprocess",
        "kind": 2,
        "importPath": "catboost.build.scripts.thinlto_cache",
        "description": "catboost.build.scripts.thinlto_cache",
        "peekOfCode": "def postprocess(opts):\n    if opts.thinlto_cache:\n        cache_dir = os.path.join(opts.build_root, CACHE_DIR_NAME)\n        if opts.thinlto_cache_write:\n            with tarfile.open(opts.thinlto_cache, 'w:gz') as tar:\n                tar.add(cache_dir, arcname=os.path.basename(cache_dir))",
        "detail": "catboost.build.scripts.thinlto_cache",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.build.scripts.touch",
        "description": "catboost.build.scripts.touch",
        "peekOfCode": "def main(argv):\n    parser = optparse.OptionParser(add_help_option=False)\n    parser.disable_interspersed_args()\n    parser.add_option('-?', '--help', dest='help', action='store_true', default=None, help='print help')\n    parser.add_option('-t', dest='t', action='store', default=None)\n    opts, argv_rest = parser.parse_args(argv)\n    if getattr(opts, 'help', False):\n        parser.print_help()\n        return 0\n    tspec = opts.t",
        "detail": "catboost.build.scripts.touch",
        "documentation": {}
    },
    {
        "label": "_Formatting",
        "kind": 6,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "class _Formatting(object):\n    @staticmethod\n    def is_str(strval):\n        return isinstance(strval, (bytes, str))\n    @staticmethod\n    def encoding_needed(strval):\n        return isinstance(strval, str)\n    @staticmethod\n    def escape_special_symbols(strval):\n        encoding_needed = _Formatting.encoding_needed(strval)",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "get_default_json",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def get_default_json():\n    return json.loads(\n        '''{\n    \"ARCADIA_SOURCE_HG_HASH\": \"0000000000000000000000000000000000000000\",\n    \"ARCADIA_SOURCE_LAST_AUTHOR\": \"<UNKNOWN>\",\n    \"ARCADIA_SOURCE_LAST_CHANGE\": -1,\n    \"ARCADIA_SOURCE_PATH\": \"/\",\n    \"ARCADIA_SOURCE_REVISION\": -1,\n    \"ARCADIA_SOURCE_URL\": \"\",\n    \"BRANCH\": \"unknown-vcs-branch\",",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "get_json",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def get_json(file_name):\n    try:\n        with open(file_name, 'rt', encoding=\"utf-8\") as f:\n            out = json.load(f)\n        # TODO: check 'tar+svn' parsing\n        for num_var in ['ARCADIA_SOURCE_REVISION', 'ARCADIA_SOURCE_LAST_CHANGE', 'SVN_REVISION']:\n            if num_var in out and _Formatting.is_str(out[num_var]):\n                try:\n                    out[num_var] = int(out[num_var])\n                except:",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "print_c",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def print_c(json_file, output_file, argv):\n    \"\"\"params:\n    json file\n    output file\n    $(SOURCE_ROOT)/build/scripts/c_templates/svn_interface.c\"\"\"\n    interface = argv[0]\n    with open(interface, 'rt', encoding=\"utf-8\") as c:\n        c_file = c.read()\n    with open(output_file, 'wt', encoding=\"utf-8\") as f:\n        header = '\\n'.join(_Formatting.escaped_define(k, v) for k, v in json_file.items())",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "merge_java_content",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def merge_java_content(old_content, json_file):\n    new_content, names = print_java_mf(json_file)\n    def split_to_sections(content):\n        sections = []\n        cur_section = []\n        for l in content:\n            if l.rstrip():\n                cur_section.append(l)\n            else:\n                sections.append(cur_section)",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "merge_java_mf_jar",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def merge_java_mf_jar(json_file, out_manifest, jar_file):\n    try:\n        temp_dir = tempfile.mkdtemp()\n        try:\n            with zipfile.ZipFile(jar_file, 'r') as jar:\n                jar.extract(os.path.join('META-INF', 'MANIFEST.MF'), path=temp_dir)\n        except KeyError:\n            pass\n        merge_java_mf_dir(json_file, out_manifest, temp_dir)\n    finally:",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "merge_java_mf_dir",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def merge_java_mf_dir(json_file, out_manifest, input_dir):\n    manifest = os.path.join(input_dir, 'META-INF', 'MANIFEST.MF')\n    old_lines = []\n    if os.path.isfile(manifest):\n        with open(manifest, 'rt', encoding=\"utf-8\") as f:\n            old_lines = f.readlines()\n    with open(out_manifest, 'wt', encoding=\"utf-8\") as f:\n        f.write(merge_java_content(old_lines, json_file))\ndef merge_java_mf(json_file, out_manifest, input):\n    if zipfile.is_zipfile(input):",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "merge_java_mf",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def merge_java_mf(json_file, out_manifest, input):\n    if zipfile.is_zipfile(input):\n        merge_java_mf_jar(json_file, out_manifest, input)\n    elif os.path.isdir(input):\n        merge_java_mf_dir(json_file, out_manifest, input)\ndef print_java_mf(info):\n    wrapper = textwrap.TextWrapper(\n        subsequent_indent=' ', break_long_words=True, replace_whitespace=False, drop_whitespace=False\n    )\n    names = set()",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "print_java_mf",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def print_java_mf(info):\n    wrapper = textwrap.TextWrapper(\n        subsequent_indent=' ', break_long_words=True, replace_whitespace=False, drop_whitespace=False\n    )\n    names = set()\n    def wrap(key, val):\n        names.add(key[:-2])\n        if not val:\n            return []\n        return wrapper.wrap(key + val)",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "print_java",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def print_java(json_file, output_file, argv):\n    \"\"\"params:\n    json file\n    output file\n    file\"\"\"\n    input = argv[0] if argv else os.curdir\n    merge_java_mf(json_file, output_file, input)\ndef print_go(json_file, output_file, arc_project_prefix):\n    def gen_map(info):\n        lines = []",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "print_go",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def print_go(json_file, output_file, arc_project_prefix):\n    def gen_map(info):\n        lines = []\n        for k, v in info.items():\n            lines.append(_Formatting.escaped_go_map_key(k, v))\n        return lines\n    with open(output_file, 'wt', encoding=\"utf-8\") as f:\n        f.write(\n            '\\n'.join(\n                [",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "print_json",
        "kind": 2,
        "importPath": "catboost.build.scripts.vcs_info",
        "description": "catboost.build.scripts.vcs_info",
        "peekOfCode": "def print_json(json_file, output_file):\n    MANDATOTRY_FIELDS_MAP = {\n        'ARCADIA_TAG': 'Arcadia-Tag',\n        'ARCADIA_PATCH_NUMBER': 'Arcadia-Patch-Number',\n        'ARCADIA_SOURCE_URL': 'Arcadia-Source-URL',\n        'ARCADIA_SOURCE_REVISION': 'Arcadia-Source-Revision',\n        'ARCADIA_SOURCE_HG_HASH': 'Arcadia-Source-Hash',\n        'ARCADIA_SOURCE_LAST_CHANGE': 'Arcadia-Source-Last-Change',\n        'ARCADIA_SOURCE_LAST_AUTHOR': 'Arcadia-Source-Last-Author',\n        'BRANCH': 'Branch',",
        "detail": "catboost.build.scripts.vcs_info",
        "documentation": {}
    },
    {
        "label": "Target",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class Target(object):\n    def __init__(self, catboost_component, need_pic, macos_binaries_paths):\n        self.catboost_component = catboost_component\n        self.need_pic = need_pic\n        self.macos_binaries_paths = macos_binaries_paths # needed for lipo\nclass Targets(object):\n    catboost = {\n        'catboost': Target('app', need_pic=False, macos_binaries_paths=['catboost/app/catboost']),\n        'catboostmodel_static':\n            Target(",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "Targets",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class Targets(object):\n    catboost = {\n        'catboost': Target('app', need_pic=False, macos_binaries_paths=['catboost/app/catboost']),\n        'catboostmodel_static':\n            Target(\n                'libs',\n                need_pic=False,\n                macos_binaries_paths=[\n                    f'catboost/libs/model_interface/static/libcatboostmodel_static{suff}.a' for suff in ['', '.global']\n                ]",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "Option",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class Option(object):\n    def __init__(self, description, required=False, default=None, opt_type=str):\n        self.description = description\n        self.required = required\n        if required and (default is not None):\n            raise RuntimeError(\"Required option shouldn't have default specified\")\n        self.default = default\n        self.opt_type = opt_type\nclass Opts(object):\n    known_opts = {",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "Opts",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class Opts(object):\n    known_opts = {\n        'dry_run': Option('Only print, not execute commands', default=False, opt_type=bool),\n        'verbose': Option('Verbose output for CMake and Ninja', default=False, opt_type=bool),\n        'build_root_dir': Option('CMake build dir (-B)', required=True),\n        'build_type': Option('build type (Debug,Release,RelWithDebInfo,MinSizeRel)', default='Release'),\n        'rebuild': Option('Rebuild targets from scratch', default=False, opt_type=bool),\n        'targets':\n            Option(\n                f'List of CMake targets to build (,-separated). Note: you cannot mix targets that require PIC and non-PIC targets here',",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "PythonDevPaths",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class PythonDevPaths:\n    def __init__(self, include_path:str, library_path:str):\n        self.include_path = include_path\n        self.library_path = library_path\ndef get_host_platform():\n    arch = platform.machine()\n    if arch == 'AMD64':\n        arch = 'x86_64'\n    return f'{platform.system().lower()}-{arch}'\nclass CmdRunner(object):",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "CmdRunner",
        "kind": 6,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "class CmdRunner(object):\n    def __init__(self, dry_run=False):\n        self.dry_run = dry_run\n    @staticmethod\n    def shlex_join(cmd):\n        if sys.version_info >= (3, 8):\n            return shlex.join(cmd)\n        else:\n            return ' '.join(\n                pipes.quote(part)",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_host_platform",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_host_platform():\n    arch = platform.machine()\n    if arch == 'AMD64':\n        arch = 'x86_64'\n    return f'{platform.system().lower()}-{arch}'\nclass CmdRunner(object):\n    def __init__(self, dry_run=False):\n        self.dry_run = dry_run\n    @staticmethod\n    def shlex_join(cmd):",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_source_root_dir",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_source_root_dir():\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\ndef mkdir_if_not_exists(dir, verbose, dry_run):\n    if verbose:\n        logging.info(f'create directory {dir}')\n    if not dry_run:\n        os.makedirs(dir, exist_ok=True)\ndef lipo(opts : Opts, cmd_runner: CmdRunner):\n    all_targets_specs = {**Targets.catboost, **Targets.test_tools}\n    for target in opts.targets:",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "mkdir_if_not_exists",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def mkdir_if_not_exists(dir, verbose, dry_run):\n    if verbose:\n        logging.info(f'create directory {dir}')\n    if not dry_run:\n        os.makedirs(dir, exist_ok=True)\ndef lipo(opts : Opts, cmd_runner: CmdRunner):\n    all_targets_specs = {**Targets.catboost, **Targets.test_tools}\n    for target in opts.targets:\n        for target_binary_sub_path in all_targets_specs[target].macos_binaries_paths:\n            dst_path = os.path.join(opts.build_root_dir, target_binary_sub_path)",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "lipo",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def lipo(opts : Opts, cmd_runner: CmdRunner):\n    all_targets_specs = {**Targets.catboost, **Targets.test_tools}\n    for target in opts.targets:\n        for target_binary_sub_path in all_targets_specs[target].macos_binaries_paths:\n            dst_path = os.path.join(opts.build_root_dir, target_binary_sub_path)\n            mkdir_if_not_exists(os.path.dirname(dst_path), opts.verbose, opts.dry_run)\n            cmd = ['lipo', '-create', '-output', dst_path]\n            for platform_subdir in ['darwin-x86_64', 'darwin-arm64']:\n                cmd += [os.path.join(opts.build_root_dir, platform_subdir, target_binary_sub_path)]\n            cmd_runner.run(cmd)",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "build_macos_universal_binaries",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def build_macos_universal_binaries(\n    opts: Opts,\n    cmake_platform_to_root_path:Dict[str,str],\n    cmake_platform_to_python_dev_paths:Dict[str,PythonDevPaths],\n    cmd_runner: CmdRunner):\n    host_platform = get_host_platform()\n    if host_platform == 'darwin-x86_64':\n        cross_build_platform = 'darwin-arm64'\n    elif host_platform == 'darwin-arm64':\n        cross_build_platform = 'darwin-x86_64'",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_default_cross_build_toolchain",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_default_cross_build_toolchain(source_root_dir, opts):\n    build_system_name = platform.system().lower()\n    target_system_name, target_system_arch = opts.target_platform.split('-')\n    default_toolchains_dir = os.path.join(source_root_dir, 'build','toolchains')\n    if build_system_name == 'darwin':\n        if target_system_name != 'darwin':\n            raise RuntimeError('Cross-compilation from macOS to non-macOS is not supported')\n        return os.path.join(\n            default_toolchains_dir,\n            f'cross-build.host.darwin.target.{target_system_arch}-darwin-default.clang.toolchain'",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_default_conan_host_profile",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_default_conan_host_profile(source_root_dir, target_platform):\n    target_system_name, target_system_arch = target_platform.split('-')\n    # a bit of name mismatch\n    conan_profile_target_system_name = 'macos' if target_system_name == 'darwin' else target_system_name\n    return os.path.join(\n        source_root_dir,\n        'cmake',\n        'conan-profiles',\n        f'{conan_profile_target_system_name}.{target_system_arch}.profile'\n    )",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "cross_build",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def cross_build(opts: Opts, cmd_runner=None):\n    if cmd_runner is None:\n        cmd_runner = CmdRunner(opts.dry_run)\n    host_platform = get_host_platform()\n    logging.info(f\"Cross-building from host platform {host_platform} to target platform {opts.target_platform}\")\n    tmp_native_built_tools_root_dir = None\n    if opts.native_built_tools_root_dir:\n        native_built_tools_root_dir = opts.native_built_tools_root_dir\n    else:\n        tmp_native_built_tools_root_dir = tempfile.TemporaryDirectory(prefix='native_built_tools_root_dir')",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_require_pic",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_require_pic(targets):\n    for target in targets:\n        if target in Targets.catboost:\n            if Targets.catboost[target].need_pic:\n                return True\n    return False\ndef get_msvs_dir(msvs_installation_path, msvs_version):\n    if msvs_installation_path is None:\n        program_files = 'Program Files' if msvs_version == '2022' else 'Program Files (x86)'\n        msvs_base_dir = f'c:\\\\{program_files}\\\\Microsoft Visual Studio\\\\{msvs_version}'",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_msvs_dir",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_msvs_dir(msvs_installation_path, msvs_version):\n    if msvs_installation_path is None:\n        program_files = 'Program Files' if msvs_version == '2022' else 'Program Files (x86)'\n        msvs_base_dir = f'c:\\\\{program_files}\\\\Microsoft Visual Studio\\\\{msvs_version}'\n    else:\n        msvs_base_dir = os.path.join(msvs_installation_path, msvs_version)\n    if os.path.exists(f'{msvs_base_dir}\\\\Community'):\n        msvs_dir = f'{msvs_base_dir}\\\\Community'\n    elif os.path.exists(f'{msvs_base_dir}\\\\Enterprise'):\n        msvs_dir = f'{msvs_base_dir}\\\\Enterprise'",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_msvc_environ",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_msvc_environ(msvs_installation_path, msvs_version, msvc_toolset, cmd_runner, dry_run):\n    msvs_dir = get_msvs_dir(msvs_installation_path, msvs_version)\n    if msvc_toolset is None:\n        if msvs_version not in MSVS_TO_DEFAULT_MSVC_TOOLSET:\n            raise RuntimeError(f'No default C++ toolset for Microsoft Visual Studio {msvs_version}')\n        msvc_toolset = MSVS_TO_DEFAULT_MSVC_TOOLSET[msvs_version]\n    env_vars = {}\n    # can't use NamedTemporaryFile or mkstemp because of child proces access issues\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        env_vars_file_path = os.path.join(tmp_dir, 'env_vars')",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_cuda_root_dir",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_cuda_root_dir(cuda_root_dir_option):\n    cuda_root_dir = cuda_root_dir_option or os.environ.get('CUDA_PATH') or os.environ.get('CUDA_ROOT')\n    if not cuda_root_dir:\n        raise RuntimeError('No cuda_root_dir specified and CUDA_PATH and CUDA_ROOT environment variables also not defined')\n    return cuda_root_dir\ndef add_cuda_bin_path_to_system_path(build_environ, cuda_root_dir):\n    cuda_bin_dir = os.path.join(cuda_root_dir, 'bin')\n    if platform.system().lower() == 'windows':\n        if 'Path' in build_environ:\n            path_env_name = 'Path'",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "add_cuda_bin_path_to_system_path",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def add_cuda_bin_path_to_system_path(build_environ, cuda_root_dir):\n    cuda_bin_dir = os.path.join(cuda_root_dir, 'bin')\n    if platform.system().lower() == 'windows':\n        if 'Path' in build_environ:\n            path_env_name = 'Path'\n        elif 'PATH' in build_environ:\n            path_env_name = 'PATH'\n        else:\n            raise RuntimeError('no PATH environment variable')\n        build_environ[path_env_name] = cuda_bin_dir + ';' + build_environ[path_env_name]",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_catboost_components",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_catboost_components(targets):\n    catboost_components = set()\n    for target in targets:\n        if target in Targets.catboost:\n            catboost_components.add(Targets.catboost[target].catboost_component)\n    return catboost_components\ndef get_default_build_platform_toolchain(source_root_dir):\n    if platform.system().lower() == 'windows':\n        return os.path.abspath(os.path.join(source_root_dir, 'build', 'toolchains', 'default.toolchain'))\n    else:",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_default_build_platform_toolchain",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_default_build_platform_toolchain(source_root_dir):\n    if platform.system().lower() == 'windows':\n        return os.path.abspath(os.path.join(source_root_dir, 'build', 'toolchains', 'default.toolchain'))\n    else:\n        return os.path.abspath(os.path.join(source_root_dir, 'build', 'toolchains', 'clang.toolchain'))\ndef get_build_environ(opts, target_platform, cmd_runner):\n    if platform.system().lower() == 'windows':\n        # Need vcvars set up for Ninja generator\n        build_environ = get_msvc_environ(\n            opts.msvs_installation_path,",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "get_build_environ",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def get_build_environ(opts, target_platform, cmd_runner):\n    if platform.system().lower() == 'windows':\n        # Need vcvars set up for Ninja generator\n        build_environ = get_msvc_environ(\n            opts.msvs_installation_path,\n            opts.msvs_version,\n            opts.msvc_toolset,\n            cmd_runner,\n            opts.dry_run\n        )",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 2,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "def build(\n    opts=None,\n    cross_build_final_stage=False,\n    cmake_platform_to_root_path:Dict[str,str]=None,\n    cmake_platform_to_python_dev_paths:Dict[str,PythonDevPaths]=None,\n    **kwargs):\n    \"\"\"\n        cmake_platform_to_root_path is dict: platform_name -> cmake_find_root_path\n        cmake_platform_to_python_dev_paths is dict: platform_name -> PythonDevPaths\n        used only for macOS universal builds because in other cases it is sufficient",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "MSVS_TO_DEFAULT_MSVC_TOOLSET",
        "kind": 5,
        "importPath": "catboost.build.build_native",
        "description": "catboost.build.build_native",
        "peekOfCode": "MSVS_TO_DEFAULT_MSVC_TOOLSET = {\n    '2019': '14.28.29333',\n    '2022': '14.29.30133'\n}\nclass Target(object):\n    def __init__(self, catboost_component, need_pic, macos_binaries_paths):\n        self.catboost_component = catboost_component\n        self.need_pic = need_pic\n        self.macos_binaries_paths = macos_binaries_paths # needed for lipo\nclass Targets(object):",
        "detail": "catboost.build.build_native",
        "documentation": {}
    },
    {
        "label": "Cwd",
        "kind": 6,
        "importPath": "catboost.catboost.R-package.mk_package",
        "description": "catboost.catboost.R-package.mk_package",
        "peekOfCode": "class Cwd(object):\n    def __init__(self, dir):\n        self.target_dir = dir\n    def __enter__(self):\n        self.save_dir = os.getcwd()\n        os.chdir(self.target_dir)\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        os.chdir(self.save_dir)\n        if exc_val:\n            raise",
        "detail": "catboost.catboost.R-package.mk_package",
        "documentation": {}
    },
    {
        "label": "RPackager",
        "kind": 6,
        "importPath": "catboost.catboost.R-package.mk_package",
        "description": "catboost.catboost.R-package.mk_package",
        "peekOfCode": "class RPackager(object):\n    def __init__(self, r_dir, target_os, keep_temp):\n        self.target_os = target_os\n        self.r_dir = os.path.abspath(r_dir)\n        self.version = [l for l in open(self.r_dir + '/DESCRIPTION').readlines() if 'Version:' in l][0].split()[1]\n        self.build_dir = tempfile.mkdtemp()\n        self.stem = 'catboost-R-{}-{}'.format(self.target_os, self.version)\n        self.keep_temp = keep_temp\n    def __del__(self):\n        if self.keep_temp:",
        "detail": "catboost.catboost.R-package.mk_package",
        "documentation": {}
    },
    {
        "label": "test_R_version",
        "kind": 2,
        "importPath": "catboost.catboost.R-package.test",
        "description": "catboost.catboost.R-package.test",
        "peekOfCode": "def test_R_version(links):\n    links.set('R --version', _run_cmd(['R', '--version'], yatest.common.output_path('r_version.out')))\ndef test_cmd_build(links):\n    links.set('R CMD build', _run_cmd(['R', 'CMD', 'build', '.'], yatest.common.output_path('r_cmd_build.out')))\ndef test_cmd_install(links):\n    links.set('R CMD INSTALL', _run_cmd(['R', 'CMD', 'INSTALL', '.'], yatest.common.output_path('r_cmd_install.out')))\ndef test_cmd_check(links):\n    links.set('R CMD check', _run_cmd(['R', 'CMD', 'check', '.', '--no-manual', '--no-examples'], yatest.common.output_path('r_cmd_check.out')))",
        "detail": "catboost.catboost.R-package.test",
        "documentation": {}
    },
    {
        "label": "test_cmd_build",
        "kind": 2,
        "importPath": "catboost.catboost.R-package.test",
        "description": "catboost.catboost.R-package.test",
        "peekOfCode": "def test_cmd_build(links):\n    links.set('R CMD build', _run_cmd(['R', 'CMD', 'build', '.'], yatest.common.output_path('r_cmd_build.out')))\ndef test_cmd_install(links):\n    links.set('R CMD INSTALL', _run_cmd(['R', 'CMD', 'INSTALL', '.'], yatest.common.output_path('r_cmd_install.out')))\ndef test_cmd_check(links):\n    links.set('R CMD check', _run_cmd(['R', 'CMD', 'check', '.', '--no-manual', '--no-examples'], yatest.common.output_path('r_cmd_check.out')))",
        "detail": "catboost.catboost.R-package.test",
        "documentation": {}
    },
    {
        "label": "test_cmd_install",
        "kind": 2,
        "importPath": "catboost.catboost.R-package.test",
        "description": "catboost.catboost.R-package.test",
        "peekOfCode": "def test_cmd_install(links):\n    links.set('R CMD INSTALL', _run_cmd(['R', 'CMD', 'INSTALL', '.'], yatest.common.output_path('r_cmd_install.out')))\ndef test_cmd_check(links):\n    links.set('R CMD check', _run_cmd(['R', 'CMD', 'check', '.', '--no-manual', '--no-examples'], yatest.common.output_path('r_cmd_check.out')))",
        "detail": "catboost.catboost.R-package.test",
        "documentation": {}
    },
    {
        "label": "test_cmd_check",
        "kind": 2,
        "importPath": "catboost.catboost.R-package.test",
        "description": "catboost.catboost.R-package.test",
        "peekOfCode": "def test_cmd_check(links):\n    links.set('R CMD check', _run_cmd(['R', 'CMD', 'check', '.', '--no-manual', '--no-examples'], yatest.common.output_path('r_cmd_check.out')))",
        "detail": "catboost.catboost.R-package.test",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_catboost",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_lightgbm",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.extract_scores_xgboost",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "documentation": {}
    },
    {
        "label": "cb_cuda_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "peekOfCode": "cb_cuda_path = \"./cb_cuda\"\ncatboost_path = \"./catboost\"\nfit_template = \" fit --auto-stop-pval 1.0 --overfitting-detector-iterations-wait 500 --use-best-model\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "documentation": {}
    },
    {
        "label": "catboost_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "peekOfCode": "catboost_path = \"./catboost\"\nfit_template = \" fit --auto-stop-pval 1.0 --overfitting-detector-iterations-wait 500 --use-best-model\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "documentation": {}
    },
    {
        "label": "fit_template",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "peekOfCode": "fit_template = \" fit --auto-stop-pval 1.0 --overfitting-detector-iterations-wait 500 --use-best-model\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)\n    parser.add_argument('--mult',",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_catboost",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "documentation": {}
    },
    {
        "label": "lightgbm_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "peekOfCode": "lightgbm_path = \"./lightgbm\"\nfit_template = \" sparse_threshold=1.0 num_threads=16 device=gpu early_stopping_rounds=300\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "documentation": {}
    },
    {
        "label": "fit_template",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "peekOfCode": "fit_template = \" sparse_threshold=1.0 num_threads=16 device=gpu early_stopping_rounds=300\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)\n    parser.add_argument('--mult',",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_lightgbm",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "peekOfCode": "__author__ = \"noxoomo\"\n__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "documentation": {}
    },
    {
        "label": "__email__",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "peekOfCode": "__email__ = \"noxoomo@yandex-team.ru\"\nimport json\nimport subprocess\nimport os\nimport sys\nfrom subprocess import Popen\nimport subprocess\nimport argparse\nimport os\nimport os.path",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "documentation": {}
    },
    {
        "label": "xgboost_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "peekOfCode": "xgboost_path = \"./xgboost\"\nfit_template = \" xgboost.conf nthread=16 tree_method=gpu_hist early_stopping_rounds=100 \"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "documentation": {}
    },
    {
        "label": "fit_template",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "description": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "peekOfCode": "fit_template = \" xgboost.conf nthread=16 tree_method=gpu_hist early_stopping_rounds=100 \"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--base-step',\n                        type=float,\n                        required=True)\n    parser.add_argument('--base-iter',\n                        type=float,\n                        required=True)\n    parser.add_argument('--mult',",
        "detail": "catboost.catboost.benchmarks.gpu_vs_cpu_training_speed.run_experiment_xgboost",
        "documentation": {}
    },
    {
        "label": "CatBoostExperimentEarlyStopping",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_early_stopping",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_early_stopping",
        "peekOfCode": "class CatBoostExperimentEarlyStopping(experiment_lib.ExperimentEarlyStopping):\n    def __init__(self, **kwargs):\n        super(CatBoostExperimentEarlyStopping, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return cb.CatBoostRegressor(\n            verbose=True,\n            loss_function='RMSE',\n            thread_count=16,\n            cat_features=cat_cols,\n            n_estimators=9999,",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_early_stopping",
        "documentation": {}
    },
    {
        "label": "CatBoostExperimentGridSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_grid_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_grid_cv",
        "peekOfCode": "class CatBoostExperimentGridSearchCV(experiment_lib.ExperimentGridSearchCV):\n    def __init__(self, **kwargs):\n        super(CatBoostExperimentGridSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return cb.CatBoostRegressor(\n            verbose=True,\n            loss_function='RMSE',\n            thread_count=16,\n            cat_features=cat_cols\n        )",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_grid_cv",
        "documentation": {}
    },
    {
        "label": "CatBoostExperimentRandomSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_random_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_random_cv",
        "peekOfCode": "class CatBoostExperimentRandomSearchCV(experiment_lib.ExperimentRandomSearchCV):\n    def __init__(self, **kwargs):\n        super(CatBoostExperimentRandomSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return cb.CatBoostRegressor(\n            verbose=True,\n            loss_function='RMSE',\n            thread_count=16,\n            cat_features=cat_cols\n        )",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.catboost_experiment_sklearn_random_cv",
        "documentation": {}
    },
    {
        "label": "orig_dataset_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "peekOfCode": "orig_dataset_path = os.path.expanduser('~/datasets/rossmann-store-sales/')\npreprocessed_dataset_path = os.path.expanduser('~/datasets/rossmann-store-sales-preprocessed/')\ntraining_output_path = os.path.expanduser('~/training_output/rossmann-store-sales/')",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "documentation": {}
    },
    {
        "label": "preprocessed_dataset_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "peekOfCode": "preprocessed_dataset_path = os.path.expanduser('~/datasets/rossmann-store-sales-preprocessed/')\ntraining_output_path = os.path.expanduser('~/training_output/rossmann-store-sales/')",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "documentation": {}
    },
    {
        "label": "training_output_path",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "peekOfCode": "training_output_path = os.path.expanduser('~/training_output/rossmann-store-sales/')",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.config",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "peekOfCode": "class Experiment(object):\n    def __init__(self, learning_task='classification', bst_name=None, gpu_id=0, max_n_estimators=1500,\n                 hyperopt_evals=50, dataset_path='./', output_folder_path='./'):\n        self.learning_task, self.bst_name = learning_task, bst_name\n        self.gpu_id = gpu_id\n        self.max_n_estimators = max_n_estimators\n        self.best_loss = np.inf\n        self.hyperopt_evals, self.hyperopt_eval_num = hyperopt_evals, 0\n        self.dataset_path, self.output_folder_path = dataset_path, output_folder_path\n        self.default_params, self.best_params = None, None",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "documentation": {}
    },
    {
        "label": "XGBExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "peekOfCode": "class XGBExperiment(Experiment):\n    def __init__(self, learning_task, gpu_id=0, max_n_estimators=1500,\n                 max_hyperopt_evals=50, dataset_path='./', output_folder_path='./'):\n        Experiment.__init__(self, learning_task, 'xgb', gpu_id, max_n_estimators, max_hyperopt_evals,\n                            dataset_path, output_folder_path)\n        self.space = {\n            'learning_rate': hp.loguniform('learning_rate', -3, 0),\n            'min_split_loss': hp.choice('min_split_loss', [0, hp.loguniform('min_split_loss_positive', -16, 0)]),\n            'max_depth' : hp.quniform('max_depth', 5, 16, 1),\n            # min_child_weight ?",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "documentation": {}
    },
    {
        "label": "CABExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "peekOfCode": "class CABExperiment(Experiment):\n    def __init__(self, learning_task, gpu_id=0,\n                 max_n_estimators=1500, max_hyperopt_evals=50,\n                 dataset_path='./', output_folder_path='./'):\n        Experiment.__init__(self, learning_task, 'cab', gpu_id, max_n_estimators, max_hyperopt_evals,\n                            dataset_path, output_folder_path)\n        self.space = {\n            'learning_rate': hp.loguniform('learning_rate', -3, 0),\n            'depth': hp.quniform('depth', 5, 14, 1),\n            'random_strength': hp.choice('random_strength', [1, 20]),",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "documentation": {}
    },
    {
        "label": "LGBExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "peekOfCode": "class LGBExperiment(Experiment):\n    def __init__(self, learning_task, gpu_id=0, max_n_estimators=1500,\n                 max_hyperopt_evals=50, dataset_path='./', output_folder_path='./'):\n        Experiment.__init__(self, learning_task, 'lgb', gpu_id, max_n_estimators, max_hyperopt_evals,\n                            dataset_path, output_folder_path)\n        self.space = {\n            #'boosting': hp.choice('boosting', ['gbdt', 'rf', 'dart', 'goss']),\n            'learning_rate': hp.loguniform('learning_rate', -7, 0),\n            'num_leaves': hp.qloguniform('num_leaves', 0, 7, 1),\n            'max_depth': hp.choice('max_depth', [-1, hp.qloguniform('max_depth_positive', 0, 4, 1)]),",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "documentation": {}
    },
    {
        "label": "createParser",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "peekOfCode": "def createParser():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('bst', choices=['xgb', 'lgb', 'cab'])\n    parser.add_argument('-t', '--max_n_estimators', type=int, default=1500)\n    parser.add_argument('-n', '--hyperopt_evals', type=int, default=50)\n    parser.add_argument('--gpu_id', type=int, default=None,\n                        help='Set gpu_id to run on GPU (CPU is the default)')\n    return parser\nif __name__ == \"__main__\":\n    parser = createParser()",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_hyperopt",
        "documentation": {}
    },
    {
        "label": "ExperimentBase",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "peekOfCode": "class ExperimentBase(object):\n    def __init__(self, train_path, test_path, cd_path, output_folder_path='./',\n                 learning_task='regression', scoring='neg_mean_squared_error',\n                 header_in_data=True):\n        self.train_path, self.test_path, self.cd_path = train_path, test_path, cd_path\n        self.output_folder_path = os.path.join(output_folder_path, '')\n        self.learning_task = learning_task\n        self.scoring = scoring\n        self.header_in_data = header_in_data\n    def read_file(self, file_name, target_col, header_in_data):",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "documentation": {}
    },
    {
        "label": "ExperimentEarlyStopping",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "peekOfCode": "class ExperimentEarlyStopping(ExperimentBase):\n    def __init__(self, **kwargs):\n        super(ExperimentEarlyStopping, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        raise NotImplementedError('Method get_estimator is not implemented.')\n    # override if necessary\n    def fit_estimator(self, estimator, X_train, y_train, X_test, y_test, cat_cols, early_stopping_rounds):\n        estimator.fit(\n            X_train,\n            y_train,",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "documentation": {}
    },
    {
        "label": "ExperimentGridSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "peekOfCode": "class ExperimentGridSearchCV(ExperimentBase):\n    def __init__(self, **kwargs):\n        super(ExperimentGridSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        raise NotImplementedError('Method get_estimator is not implemented.')\n    def get_param_grid(self):\n        raise NotImplementedError('Method get_param_grid is not implemented.')\n    # override if necessary\n    def call_fit(self, grid_search_instance, X, y, cat_cols):\n        grid_search_instance.fit(X, y)",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "documentation": {}
    },
    {
        "label": "ExperimentRandomSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "peekOfCode": "class ExperimentRandomSearchCV(ExperimentBase):\n    def __init__(self, **kwargs):\n        super(ExperimentRandomSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        raise NotImplementedError('Method get_estimator is not implemented.')\n    def get_param_distributions(self):\n        raise NotImplementedError('Method get_param_distributions is not implemented.')\n    # override if necessary\n    def call_fit(self, randomized_search_instance, X, y, cat_cols):\n        randomized_search_instance.fit(X, y)",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "documentation": {}
    },
    {
        "label": "LogUniform",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "peekOfCode": "class LogUniform(object):\n    def __init__(self, l_bound, r_bound, is_integral=False):\n        self.l_bound = np.log(l_bound)\n        self.width = np.log(r_bound) - self.l_bound\n        self.uniform = scipy.stats.uniform()\n        self.is_integral = is_integral\n    def rvs(self, random_state=None):\n        cont_sample = np.exp(self.l_bound + self.width * self.uniform.rvs(random_state=random_state))\n        return int(cont_sample) if self.is_integral else cont_sample",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.experiment_lib",
        "documentation": {}
    },
    {
        "label": "LightGBMExperimentEarlyStopping",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_early_stopping",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_early_stopping",
        "peekOfCode": "class LightGBMExperimentEarlyStopping(experiment_lib.ExperimentEarlyStopping):\n    def __init__(self, **kwargs):\n        super(LightGBMExperimentEarlyStopping, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return lgb.LGBMRegressor(\n            n_jobs=16,\n            n_estimators=9999\n        )\n    def fit_estimator(self, estimator, X_train, y_train, X_test, y_test, cat_cols, early_stopping_rounds):\n        estimator.fit(",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_early_stopping",
        "documentation": {}
    },
    {
        "label": "LightGBMExperimentGridSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_grid_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_grid_cv",
        "peekOfCode": "class LightGBMExperimentGridSearchCV(experiment_lib.ExperimentGridSearchCV):\n    def __init__(self, **kwargs):\n        super(LightGBMExperimentGridSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return lgb.LGBMRegressor(\n            n_jobs=16\n        )\n    def get_param_grid(self):\n        return {\n            'n_estimators' : [int(v) for v in np.geomspace(100, 15000, 10)],",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_grid_cv",
        "documentation": {}
    },
    {
        "label": "LightGBMExperimentRandomSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_random_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_random_cv",
        "peekOfCode": "class LightGBMExperimentRandomSearchCV(experiment_lib.ExperimentRandomSearchCV):\n    def __init__(self, **kwargs):\n        super(LightGBMExperimentRandomSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return lgb.LGBMRegressor(\n            n_jobs=16\n        )\n    def get_param_distributions(self):\n        return {\n            'n_estimators' : experiment_lib.LogUniform(100, 1000, True),",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.lightgbm_experiment_sklearn_random_cv",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "def preprocess(df, stores):\n    date = np.array([map(int, s.split('-')) for s in df['Date']])\n    df = df.drop(['Date'], axis=1)\n    df['Year'] = date[:, 0]\n    df['Month'] = date[:, 1]\n    df['Day'] = date[:, 2]\n    df = df.join(stores, on='Store', rsuffix='_right')\n    df = df.drop(['Store_right'], axis=1)\n    print df.head()\n    promo2_start_months = [(s.split(',') if not pd.isnull(s) else []) for s in df['PromoInterval']]",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "get_str_column_names",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "def get_str_column_names(df):\n    str_names = []\n    for col in df.columns:\n        for x in df[col]:\n            if isinstance(x, str):\n                str_names.append(col)\n                break\n    return str_names\ntrain_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2014].index\ntest_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2015].index",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "fix_strs",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "def fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)\n    if test_df is not None:\n        test_df[cat_names] = test_df[cat_names].fillna(0)\n    for col in cat_names:\n        enc = LabelEncoder()\n        df[col] = enc.fit_transform(df[col])\n        if test_df is not None:\n            test_df[col] = enc.transform(test_df[col])\n    return df, test_df",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "train = pd.read_csv(os.path.join(config.orig_dataset_path, 'train.csv.zip'))\nstore = pd.read_csv(os.path.join(config.orig_dataset_path, 'store.csv.zip'))\nprint (train.shape, store.shape)\nmonth_abbrs = calendar.month_abbr[1:]\nmonth_abbrs[8] = 'Sept'\n# 1) make integer Year,Month,Day columns instead of Date\n# 2) join data from store table\ndef preprocess(df, stores):\n    date = np.array([map(int, s.split('-')) for s in df['Date']])\n    df = df.drop(['Date'], axis=1)",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "store",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "store = pd.read_csv(os.path.join(config.orig_dataset_path, 'store.csv.zip'))\nprint (train.shape, store.shape)\nmonth_abbrs = calendar.month_abbr[1:]\nmonth_abbrs[8] = 'Sept'\n# 1) make integer Year,Month,Day columns instead of Date\n# 2) join data from store table\ndef preprocess(df, stores):\n    date = np.array([map(int, s.split('-')) for s in df['Date']])\n    df = df.drop(['Date'], axis=1)\n    df['Year'] = date[:, 0]",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "month_abbrs",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "month_abbrs = calendar.month_abbr[1:]\nmonth_abbrs[8] = 'Sept'\n# 1) make integer Year,Month,Day columns instead of Date\n# 2) join data from store table\ndef preprocess(df, stores):\n    date = np.array([map(int, s.split('-')) for s in df['Date']])\n    df = df.drop(['Date'], axis=1)\n    df['Year'] = date[:, 0]\n    df['Month'] = date[:, 1]\n    df['Day'] = date[:, 2]",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "month_abbrs[8]",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "month_abbrs[8] = 'Sept'\n# 1) make integer Year,Month,Day columns instead of Date\n# 2) join data from store table\ndef preprocess(df, stores):\n    date = np.array([map(int, s.split('-')) for s in df['Date']])\n    df = df.drop(['Date'], axis=1)\n    df['Year'] = date[:, 0]\n    df['Month'] = date[:, 1]\n    df['Day'] = date[:, 2]\n    df = df.join(stores, on='Store', rsuffix='_right')",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "train_prepared_fixed_date",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "train_prepared_fixed_date = preprocess(train, store)\ndef get_str_column_names(df):\n    str_names = []\n    for col in df.columns:\n        for x in df[col]:\n            if isinstance(x, str):\n                str_names.append(col)\n                break\n    return str_names\ntrain_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2014].index",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "train_inds",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "train_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2014].index\ntest_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2015].index\nprint ('before iloc' , train_prepared_fixed_date.head())\ntrain2 = train_prepared_fixed_date.iloc[train_inds]\ntest2 = train_prepared_fixed_date.iloc[test_inds]\nstr_cat_columns = get_str_column_names(train_prepared_fixed_date)\nprint str_cat_columns\n# transform categorical columns with strings using LabelEncoder\ndef fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "test_inds",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "test_inds = train_prepared_fixed_date[train_prepared_fixed_date['Year'] == 2015].index\nprint ('before iloc' , train_prepared_fixed_date.head())\ntrain2 = train_prepared_fixed_date.iloc[train_inds]\ntest2 = train_prepared_fixed_date.iloc[test_inds]\nstr_cat_columns = get_str_column_names(train_prepared_fixed_date)\nprint str_cat_columns\n# transform categorical columns with strings using LabelEncoder\ndef fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)\n    if test_df is not None:",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "train2",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "train2 = train_prepared_fixed_date.iloc[train_inds]\ntest2 = train_prepared_fixed_date.iloc[test_inds]\nstr_cat_columns = get_str_column_names(train_prepared_fixed_date)\nprint str_cat_columns\n# transform categorical columns with strings using LabelEncoder\ndef fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)\n    if test_df is not None:\n        test_df[cat_names] = test_df[cat_names].fillna(0)\n    for col in cat_names:",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "test2",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "test2 = train_prepared_fixed_date.iloc[test_inds]\nstr_cat_columns = get_str_column_names(train_prepared_fixed_date)\nprint str_cat_columns\n# transform categorical columns with strings using LabelEncoder\ndef fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)\n    if test_df is not None:\n        test_df[cat_names] = test_df[cat_names].fillna(0)\n    for col in cat_names:\n        enc = LabelEncoder()",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "str_cat_columns",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "str_cat_columns = get_str_column_names(train_prepared_fixed_date)\nprint str_cat_columns\n# transform categorical columns with strings using LabelEncoder\ndef fix_strs(df, cat_names, test_df=None):\n    df[cat_names] = df[cat_names].fillna(0)\n    if test_df is not None:\n        test_df[cat_names] = test_df[cat_names].fillna(0)\n    for col in cat_names:\n        enc = LabelEncoder()\n        df[col] = enc.fit_transform(df[col])",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "all_cat_names",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "peekOfCode": "all_cat_names = (['Store', 'DayOfWeek', 'Open', 'Promo', 'StateHoliday', 'SchoolHoliday',\n                'StoreType', 'Assortment', 'Promo2']\n                 + ['Promo2Start_' + month_abbr for month_abbr in month_abbrs])\nif not os.path.exists(config.preprocessed_dataset_path):\n    os.mkdir(config.preprocessed_dataset_path)\ntrain2.to_csv(os.path.join(config.preprocessed_dataset_path, 'train'), sep='\\t', header=False, index=False)\ntest2.to_csv(os.path.join(config.preprocessed_dataset_path, 'test'), sep='\\t', header=False, index=False)\nwith open(os.path.join(config.preprocessed_dataset_path, 'cd'), 'w') as cd:\n    for idx, name in enumerate(train2.columns):\n        cd.write('{}\\t{}\\n'.format(",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.preprocess_data",
        "documentation": {}
    },
    {
        "label": "XGBoostExperimentEarlyStopping",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_early_stopping",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_early_stopping",
        "peekOfCode": "class XGBoostExperimentEarlyStopping(experiment_lib.ExperimentEarlyStopping):\n    def __init__(self, **kwargs):\n        super(XGBoostExperimentEarlyStopping, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return xgb.XGBRegressor(\n            silent=False,\n            n_jobs=16,\n            n_estimators=9999\n        )\n    def fit_estimator(self, estimator, X_train, y_train, X_test, y_test, cat_cols, early_stopping_rounds):",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_early_stopping",
        "documentation": {}
    },
    {
        "label": "XGBoostExperimentGridSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_grid_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_grid_cv",
        "peekOfCode": "class XGBoostExperimentGridSearchCV(experiment_lib.ExperimentGridSearchCV):\n    def __init__(self, **kwargs):\n        super(XGBoostExperimentGridSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return xgb.XGBRegressor(\n            n_jobs=16\n        )\n    def get_param_grid(self):\n        return {\n            'n_estimators' : [int(v) for v in np.geomspace(100, 15000, 10)],",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_grid_cv",
        "documentation": {}
    },
    {
        "label": "XGBoostExperimentRandomSearchCV",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_random_cv",
        "description": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_random_cv",
        "peekOfCode": "class XGBoostExperimentRandomSearchCV(experiment_lib.ExperimentRandomSearchCV):\n    def __init__(self, **kwargs):\n        super(XGBoostExperimentRandomSearchCV, self).__init__(**kwargs)\n    def get_estimator(self, cat_cols):\n        return xgb.XGBRegressor(\n            n_jobs=16\n        )\n    def get_param_distributions(self):\n        return {\n            'n_estimators' : experiment_lib.LogUniform(100, 1000, True),",
        "detail": "catboost.catboost.benchmarks.kaggle.rossmann-store-sales.xgboost_experiment_sklearn_random_cv",
        "documentation": {}
    },
    {
        "label": "get_raw_data",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def get_raw_data(rows_count: int, columns_count: int) -> tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    float64_data: np.ndarray = np.float64(np.random.rand(columns_count//4, rows_count))\n    float32_data: np.ndarray = np.float32(np.random.rand(columns_count//4, rows_count))\n    int8_data: np.ndarray = np.random.randint(np.iinfo(np.int8).min, np.iinfo(np.int8).max,\n                                              size=(columns_count//4, rows_count), dtype=np.int8)\n    int32_data: np.ndarray = np.random.randint(np.iinfo(np.int32).min, np.iinfo(np.int32).max,\n                                               size=(columns_count//4, rows_count), dtype=np.int32)\n    return float64_data, float32_data, int8_data, int32_data\ndef measure_numpy_ndarray_with_fortran_order_dataset(rows_count: int, columns_count: int = 200) -> tp.Tuple:\n    raw_data: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_numpy_ndarray_with_fortran_order_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_numpy_ndarray_with_fortran_order_dataset(rows_count: int, columns_count: int = 200) -> tp.Tuple:\n    raw_data: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)\n    concatenated: np.ndarray = np.transpose(np.concatenate(raw_data, axis=0))\n    data: np.ndarray = np.array(concatenated, order='F')\n    return measure_pool_building_with_numerical_data(data)\ndef measure_numpy_ndarray_with_column_order_dataset(rows_count: int, columns_count: int = 200) -> tp.Tuple:\n    raw_data: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)\n    concatenated: np.ndarray = np.transpose(np.concatenate(raw_data, axis=0))\n    data: np.ndarray = np.array(concatenated, order='C')\n    return measure_pool_building_with_numerical_data(data)",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_numpy_ndarray_with_column_order_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_numpy_ndarray_with_column_order_dataset(rows_count: int, columns_count: int = 200) -> tp.Tuple:\n    raw_data: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)\n    concatenated: np.ndarray = np.transpose(np.concatenate(raw_data, axis=0))\n    data: np.ndarray = np.array(concatenated, order='C')\n    return measure_pool_building_with_numerical_data(data)\ndef measure_numerical_dataframe(rows_count: int, columns_count: int = 200) -> tp.Tuple[float, float]:\n    batches: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)\n    column_to_data: tp.Dict[str, tp.Any] = {}\n    column_prefixes: tp.List[str] = [\"float64_\", \"float32_\", \"int8_\", \"int32_\"]\n    for batch_id in range(len(batches)):",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_numerical_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_numerical_dataframe(rows_count: int, columns_count: int = 200) -> tp.Tuple[float, float]:\n    batches: tp.Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] = get_raw_data(rows_count, columns_count)\n    column_to_data: tp.Dict[str, tp.Any] = {}\n    column_prefixes: tp.List[str] = [\"float64_\", \"float32_\", \"int8_\", \"int32_\"]\n    for batch_id in range(len(batches)):\n        column_to_data.update({column_prefixes[batch_id] + str(num): batches[batch_id][num]\n                               for num in range(batches[batch_id].shape[0])})\n    frame = pd.DataFrame(column_to_data)\n    return measure_pool_building_with_numerical_data(frame)\ndef measure_pool_building_with_numerical_data(data: tp.Union[np.ndarray, pd.DataFrame], iteration: int = 10)\\",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_pool_building_with_numerical_data",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_pool_building_with_numerical_data(data: tp.Union[np.ndarray, pd.DataFrame], iteration: int = 10)\\\n        -> tp.Tuple[float, float]:\n    times: tp.List[float] = []\n    for _ in range(iteration):\n        start: float = default_timer()\n        _ = Pool(data)\n        finish: float = default_timer()\n        times.append(finish - start)\n    return np.mean(times), np.std(times)\ndef get_unique_random_strings(count: int) -> tp.List[str]:",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "get_unique_random_strings",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def get_unique_random_strings(count: int) -> tp.List[str]:\n    return [\"str_\" + str(num) for num in range(count)]\ndef measure_categorical_dataframe(rows_count: int, columns_count: int = 200, unique_features_count: int = 1000)\\\n        -> tp.Tuple[float, float]:\n    unique_str_values: tp.List[str] = get_unique_random_strings(unique_features_count)\n    assert len(set(unique_str_values)) == unique_features_count\n    column_data: tp.Dict[str, tp.List[str]] = {}\n    column_names: tp.List[str] = [\"str_\" + str(column_id) for column_id in range(columns_count)]\n    for column_id in range(columns_count):\n        column_data[column_names[column_id]] = [unique_str_values[value_id]",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_categorical_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_categorical_dataframe(rows_count: int, columns_count: int = 200, unique_features_count: int = 1000)\\\n        -> tp.Tuple[float, float]:\n    unique_str_values: tp.List[str] = get_unique_random_strings(unique_features_count)\n    assert len(set(unique_str_values)) == unique_features_count\n    column_data: tp.Dict[str, tp.List[str]] = {}\n    column_names: tp.List[str] = [\"str_\" + str(column_id) for column_id in range(columns_count)]\n    for column_id in range(columns_count):\n        column_data[column_names[column_id]] = [unique_str_values[value_id]\n                                                for value_id in np.random.randint(unique_features_count,\n                                                                                  size=rows_count)]",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_categorical_and_numerical_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_categorical_and_numerical_dataframe(rows_count: int, columns_count: int = 200,\n                                                unique_features_count: int = 1000) -> tp.Tuple[float, float]:\n    unique_str_values: tp.List[str] = get_unique_random_strings(unique_features_count)\n    assert len(set(unique_str_values)) == unique_features_count\n    column_data: tp.Dict[str, tp.List[tp.Any]] = {}\n    str_columns_names: tp.List[str] = [\"str_\" + str(num) for num in range(columns_count//2)]\n    for column_id in range(columns_count//2):\n        values: np.ndarray = np.array([unique_str_values[value_id]\n                                       for value_id in np.random.randint(unique_features_count, size=rows_count)])\n        column_data[str_columns_names[column_id]] = values",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measure_pool_building_with_categorical_data",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "def measure_pool_building_with_categorical_data(data: tp.Union[np.ndarray, pd.DataFrame],\n                                                categorical_feature_names: tp.List[str], iteration: int = 10)\\\n        -> tp.Tuple[float, float]:\n    times: tp.List[float] = []\n    for _ in range(iteration):\n        start: float = default_timer()\n        _ = Pool(data, cat_features=categorical_feature_names)\n        finish: float = default_timer()\n        times.append(finish - start)\n    return np.mean(times), np.std(times)",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measurement",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "measurement = measure_numpy_ndarray_with_column_order_dataset(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with numerical data, rows={rows}, columns={columns}\")\nmeasurement = measure_numerical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with categorical data, rows={rows}, columns={columns}\")\nmeasurement = measure_categorical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with categorical and numerical data, rows={rows},\"\n      f\" columns={columns}\")",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measurement",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "measurement = measure_numerical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with categorical data, rows={rows}, columns={columns}\")\nmeasurement = measure_categorical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with categorical and numerical data, rows={rows},\"\n      f\" columns={columns}\")\nmeasurement = measure_categorical_and_numerical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measurement",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "measurement = measure_categorical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")\nprint(f\"creating catboost.Pool with pandas.DataFrame with categorical and numerical data, rows={rows},\"\n      f\" columns={columns}\")\nmeasurement = measure_categorical_and_numerical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "measurement",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "description": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "peekOfCode": "measurement = measure_categorical_and_numerical_dataframe(rows, columns)\nprint(f\"avg time = {measurement[0]}s, std = {measurement[1]}s\\n\")",
        "detail": "catboost.catboost.benchmarks.pool_creation_benchmark.benchmarks",
        "documentation": {}
    },
    {
        "label": "CatCounter",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.cat_counter",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.cat_counter",
        "peekOfCode": "class CatCounter(object):\n    def __init__(self, learning_task, sort_values=None, seed=0):\n        self.learning_task = learning_task\n        self.sort_values = sort_values\n        self.seed = seed\n        self.sum_dicts = defaultdict(lambda : defaultdict(float))\n        self.count_dicts = defaultdict(lambda : defaultdict(float))\n    def update(self, value, col, key):\n        self.sum_dicts[col][key] += value\n        self.count_dicts[col][key] += 1",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.cat_counter",
        "documentation": {}
    },
    {
        "label": "CABExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.catboost_experiment",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.catboost_experiment",
        "peekOfCode": "class CABExperiment(Experiment):\n    def __init__(self, learning_task, n_estimators=5000, max_hyperopt_evals=50, \n                 counters_sort_col=None, holdout_size=0, \n                 train_path=None, test_path=None, cd_path=None, output_folder_path='./'):\n        assert holdout_size == 0, 'For Catboost holdout_size must be equal to 0'\n        Experiment.__init__(self, learning_task, 'cab', n_estimators, max_hyperopt_evals, \n                            False, None, holdout_size, \n                            train_path, test_path, cd_path, output_folder_path)\n        self.space = {\n            'depth': hp.choice('depth', [6]),",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.catboost_experiment",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.experiment",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.experiment",
        "peekOfCode": "class Experiment(object):\n    def __init__(self, learning_task='classification', bst_name=None, n_estimators=5000, hyperopt_evals=50,\n                 compute_counters=True, counters_sort_col=None, holdout_size=0,\n                 train_path=None, test_path=None, cd_path=None, output_folder_path='./'):\n        self.learning_task, self.bst_name = learning_task, bst_name\n        self.compute_counters = compute_counters\n        self.holdout_size = holdout_size\n        self.counters_sort_col = counters_sort_col\n        self.n_estimators, self.best_loss = n_estimators, np.inf\n        self.best_n_estimators = None",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.experiment",
        "documentation": {}
    },
    {
        "label": "DataPreprocessor",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "peekOfCode": "class DataPreprocessor(Experiment):\n    def convert_to_dataset(self, data, label, cat_cols=None):\n        return (data, label)\ndef preprpocess(learning_task, train_path, test_path, cd_path, output_folder):\n    experiment = DataPreprocessor(learning_task, train_path=train_path,\n                                  test_path=test_path, cd_path=cd_path)\n    X_train, y_train, X_test, y_test, cat_cols = experiment.read_data()\n    cv_pairs, (dtrain, dtest) = experiment.split_and_preprocess(X_train.copy(), y_train,\n                                                                X_test.copy(), y_test,\n                                                                cat_cols, n_splits=2)",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "documentation": {}
    },
    {
        "label": "preprpocess",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "peekOfCode": "def preprpocess(learning_task, train_path, test_path, cd_path, output_folder):\n    experiment = DataPreprocessor(learning_task, train_path=train_path,\n                                  test_path=test_path, cd_path=cd_path)\n    X_train, y_train, X_test, y_test, cat_cols = experiment.read_data()\n    cv_pairs, (dtrain, dtest) = experiment.split_and_preprocess(X_train.copy(), y_train,\n                                                                X_test.copy(), y_test,\n                                                                cat_cols, n_splits=2)\n    for pool, filename in zip((dtrain, dtest), ('parsed_train', 'parsed_test')):\n        with open(os.path.join(output_folder, filename), mode='wb') as f:\n            for i in range(len(pool[0])):",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "documentation": {}
    },
    {
        "label": "createParser",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "peekOfCode": "def createParser():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('learning_task', choices=['classification', 'regression'])\n    parser.add_argument('--train')\n    parser.add_argument('--test')\n    parser.add_argument('--cd')\n    parser.add_argument('-o')\n    return parser\nif __name__ == \"__main__\":\n    parser = createParser()",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.h2o_preprocessing",
        "documentation": {}
    },
    {
        "label": "LGBExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.lightgbm_experiment",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.lightgbm_experiment",
        "peekOfCode": "class LGBExperiment(Experiment):\n    def __init__(self, learning_task, n_estimators=5000, max_hyperopt_evals=50, \n                 counters_sort_col=None, holdout_size=0, \n                 train_path=None, test_path=None, cd_path=None, output_folder_path='./'):\n        Experiment.__init__(self, learning_task, 'lgb', n_estimators, max_hyperopt_evals, \n                            True, counters_sort_col, holdout_size, \n                            train_path, test_path, cd_path, output_folder_path)\n        self.space = {\n            'learning_rate': hp.loguniform('learning_rate', -7, 0),\n            'num_leaves' : hp.qloguniform('num_leaves', 0, 7, 1),",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.lightgbm_experiment",
        "documentation": {}
    },
    {
        "label": "createParser",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.run",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.run",
        "peekOfCode": "def createParser():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('bst', choices=['xgb', 'lgb', 'cab'])\n    parser.add_argument('learning_task', choices=['classification', 'regression'])\n    parser.add_argument('-t', '--n_estimators', type=int, default=5000)\n    parser.add_argument('-n', '--hyperopt_evals', type=int, default=50)\n    parser.add_argument('-s', '--time_sort', type=int, default=None)\n    parser.add_argument('--train', required=True)\n    parser.add_argument('--test', required=True)\n    parser.add_argument('--cd', required=True)",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.run",
        "documentation": {}
    },
    {
        "label": "createParser",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.run_default",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.run_default",
        "peekOfCode": "def createParser():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('bst', choices=['xgb', 'lgb', 'cab'])\n    parser.add_argument('learning_task', choices=['classification', 'regression'])\n    parser.add_argument('-t', '--n_estimators', type=int, default=5000)\n    parser.add_argument('-n', '--hyperopt_evals', type=int, default=50)\n    parser.add_argument('-s', '--time_sort', type=int, default=None)\n    parser.add_argument('--train', required=True)\n    parser.add_argument('--test', required=True)\n    parser.add_argument('--cd', required=True)",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.run_default",
        "documentation": {}
    },
    {
        "label": "XGBExperiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.quality_benchmarks.xgboost_experiment",
        "description": "catboost.catboost.benchmarks.quality_benchmarks.xgboost_experiment",
        "peekOfCode": "class XGBExperiment(Experiment):\n    def __init__(self, learning_task, n_estimators=5000, max_hyperopt_evals=50, \n                 counters_sort_col=None, holdout_size=0, \n                 train_path=None, test_path=None, cd_path=None, output_folder_path='./'):\n        Experiment.__init__(self, learning_task, 'xgb', n_estimators, max_hyperopt_evals, \n                            True, counters_sort_col, holdout_size, \n                            train_path, test_path, cd_path, output_folder_path)\n        self.space = {\n            'eta': hp.loguniform('eta', -7, 0),\n            'max_depth' : hp.quniform('max_depth', 2, 10, 1),",
        "detail": "catboost.catboost.benchmarks.quality_benchmarks.xgboost_experiment",
        "documentation": {}
    },
    {
        "label": "argmin",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.eval_params",
        "description": "catboost.catboost.benchmarks.ranking.eval_params",
        "peekOfCode": "def argmin(fn, space):\n    best_score = np.NINF\n    best_params = {}\n    for params in ParameterGrid(space):\n        try:\n            score = fn(params)\n        except Exception as e:\n            print('Exception during training: ' + repr(e))\n            continue\n        if score > best_score:",
        "detail": "catboost.catboost.benchmarks.ranking.eval_params",
        "documentation": {}
    },
    {
        "label": "eval_params",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.eval_params",
        "description": "catboost.catboost.benchmarks.ranking.eval_params",
        "peekOfCode": "def eval_params(ranker_name, RankerType, data, static_params, param_space, log_file, out_file):\n    if not os.path.exists(log_file):\n        with open(log_file, 'w') as f:\n            json.dump({}, f)\n    def objective(params):\n        ranker_params = deepcopy(static_params)\n        ranker_params.update(params)\n        print('Fit with params: ' + _params_to_str(ranker_params))\n        with open(log_file, 'r') as f:\n            log = json.load(f)",
        "detail": "catboost.catboost.benchmarks.ranking.eval_params",
        "documentation": {}
    },
    {
        "label": "print_versions",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.eval_params",
        "description": "catboost.catboost.benchmarks.ranking.eval_params",
        "peekOfCode": "def print_versions():\n    import catboost\n    import xgboost\n    import lightgbm\n    print('CatBoost: ' + catboost.__version__)\n    print('XGBoost : ' + xgboost.__version__)\n    print('LightGBM: ' + lightgbm.__version__)\nif __name__ == \"__main__\":\n    rankers = {\n        'xgb-rmse': [XGBoostRanker, 'reg:linear'],",
        "detail": "catboost.catboost.benchmarks.ranking.eval_params",
        "documentation": {}
    },
    {
        "label": "RANDOM_SEED",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.ranking.eval_params",
        "description": "catboost.catboost.benchmarks.ranking.eval_params",
        "peekOfCode": "RANDOM_SEED = 0\ndef argmin(fn, space):\n    best_score = np.NINF\n    best_params = {}\n    for params in ParameterGrid(space):\n        try:\n            score = fn(params)\n        except Exception as e:\n            print('Exception during training: ' + repr(e))\n            continue",
        "detail": "catboost.catboost.benchmarks.ranking.eval_params",
        "documentation": {}
    },
    {
        "label": "Data",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.ranking.models",
        "description": "catboost.catboost.benchmarks.ranking.models",
        "peekOfCode": "class Data:\n    def __init__(self, train, test, RankerType):\n        self.X_train = train[0]\n        self.y_train = train[1]\n        self.queries_train = train[2]\n        self.X_test = test[0]\n        self.y_test = test[1]\n        self.queries_test = test[2]\n        if RankerType is CatBoostRanker:\n            self.train_pool = Pool(data=self.X_train, label=self.y_train, group_id=self.queries_train)",
        "detail": "catboost.catboost.benchmarks.ranking.models",
        "documentation": {}
    },
    {
        "label": "Ranker",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.ranking.models",
        "description": "catboost.catboost.benchmarks.ranking.models",
        "peekOfCode": "class Ranker:\n    def eval_ndcg(self, data, eval_period=10):\n        staged_predictions = self.staged_predict(data, eval_period)\n        eval_log = []\n        for y_pred in staged_predictions:\n            value = mean_ndcg(y_pred, data.y_test, data.queries_test)\n            eval_log.append(value)\n        return eval_log\n    def fit(self, train):\n        raise Exception('call of interface function')",
        "detail": "catboost.catboost.benchmarks.ranking.models",
        "documentation": {}
    },
    {
        "label": "CatBoostRanker",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.ranking.models",
        "description": "catboost.catboost.benchmarks.ranking.models",
        "peekOfCode": "class CatBoostRanker(Ranker):\n    def __init__(self, params):\n        self.params = params\n        if params['loss_function'] == 'PairLogitPairwise' and params['max_depth'] >= 8:\n            raise Exception('max_depth for pair-logit-pairwise should be < 8')\n        self.model = CatBoost(params)\n    def fit(self, data):\n        self.model.fit(X=data.train_pool)\n    def staged_predict(self, data, eval_period):\n        return list(self.model.staged_predict(data.test_pool, eval_period=eval_period))",
        "detail": "catboost.catboost.benchmarks.ranking.models",
        "documentation": {}
    },
    {
        "label": "XGBoostRanker",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.ranking.models",
        "description": "catboost.catboost.benchmarks.ranking.models",
        "peekOfCode": "class XGBoostRanker(Ranker):\n    def __init__(self, params):\n        self.params = params\n        self.iterations = self.params['iterations']\n        del self.params['iterations']\n    def fit(self, data):\n        self.model = xgb.train(\n            params=self.params,\n            num_boost_round=self.iterations,\n            dtrain=data.train_pool",
        "detail": "catboost.catboost.benchmarks.ranking.models",
        "documentation": {}
    },
    {
        "label": "LightGBMRanker",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.ranking.models",
        "description": "catboost.catboost.benchmarks.ranking.models",
        "peekOfCode": "class LightGBMRanker(Ranker):\n    def __init__(self, params):\n        self.params = params\n        self.params['num_leaves'] = 2 ** self.params['max_depth']\n        del self.params['max_depth']\n        self.iterations = self.params['iterations']\n        del self.params['iterations']\n    def fit(self, data):\n        self.model = lgb.train(\n            self.params,",
        "detail": "catboost.catboost.benchmarks.ranking.models",
        "documentation": {}
    },
    {
        "label": "dcg_score",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "description": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "peekOfCode": "def dcg_score(y_true, y_score, k=5):\n    \"\"\"Discounted cumulative gain (DCG) at rank K.\n    Parameters\n    ----------\n    y_true : array, shape = [n_samples]\n        Ground truth (true relevance labels).\n    y_score : array, shape = [n_samples, n_classes]\n        Predicted scores.\n    k : int\n        Rank.",
        "detail": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "documentation": {}
    },
    {
        "label": "ndcg_score",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "description": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "peekOfCode": "def ndcg_score(ground_truth, predictions, k=5):\n    \"\"\"Normalized discounted cumulative gain (NDCG) at rank K.\n    Normalized Discounted Cumulative Gain (NDCG) measures the performance of a\n    recommendation system based on the graded relevance of the recommended\n    entities. It varies from 0.0 to 1.0, with 1.0 representing the ideal\n    ranking of the entities.\n    Parameters\n    ----------\n    ground_truth : array, shape = [n_samples]\n        Ground truth (true labels represended as integers).",
        "detail": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "documentation": {}
    },
    {
        "label": "ndcg_scorer",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "description": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "peekOfCode": "ndcg_scorer = make_scorer(ndcg_score, needs_proba=True, k=5)",
        "detail": "catboost.catboost.benchmarks.ranking.ndcg_kaggle",
        "documentation": {}
    },
    {
        "label": "generate_relevances",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "description": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "peekOfCode": "def generate_relevances(size=10):\n    rel_true = np.random.randint(0, 5, size=size)\n    rel_pred = np.random.uniform(0, 5, size=size)\n    return rel_true, rel_pred\ndef test():\n    for i in range(10000):\n        size = np.random.randint(3, 30)\n        top = np.random.randint(2, size)\n        rel_true, rel_pred = generate_relevances(size)\n        expect = ndcg_score([rel_true], [rel_pred], top)",
        "detail": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "description": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "peekOfCode": "def test():\n    for i in range(10000):\n        size = np.random.randint(3, 30)\n        top = np.random.randint(2, size)\n        rel_true, rel_pred = generate_relevances(size)\n        expect = ndcg_score([rel_true], [rel_pred], top)\n        real = ndcg(rel_pred, rel_true, top)\n        if np.abs(real - expect) > 1e-6:\n            print('real ' + str(real) + ' but expect ' + str(expect))\n            print('top ' + str(top))",
        "detail": "catboost.catboost.benchmarks.ranking.ndcg_test",
        "documentation": {}
    },
    {
        "label": "sparsity",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def sparsity(X):\n    number_of_nan = np.count_nonzero(np.isnan(X))\n    number_of_zeros = np.count_nonzero(np.abs(X) < 1e-6)\n    return (number_of_nan + number_of_zeros) / float(X.shape[0] * X.shape[1]) * 100.\ndef print_dataset_statistics(X, y, queries, name):\n    print('----------------------------------')\n    print(\"Characteristics of dataset \" + name)\n    print(\"rows x columns \" + str(X.shape))\n    print(\"sparsity: \" + str(sparsity(X)))\n    print(\"y distribution\")",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "print_dataset_statistics",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def print_dataset_statistics(X, y, queries, name):\n    print('----------------------------------')\n    print(\"Characteristics of dataset \" + name)\n    print(\"rows x columns \" + str(X.shape))\n    print(\"sparsity: \" + str(sparsity(X)))\n    print(\"y distribution\")\n    print(Counter(y))\n    print(\"num samples in queries: minimum, median, maximum\")\n    num_queries = Counter(queries).values()\n    print(np.min(num_queries), np.median(num_queries), np.max(num_queries))",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "process_libsvm_file",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def process_libsvm_file(file_name):\n    X, y, queries = load_svmlight_file(file_name, query_id=True)\n    return X.todense(), y, queries\ndef dump_to_file(out_file_name, X, y, queries):\n    all = np.hstack((y.reshape(-1, 1), queries.reshape(-1, 1), X))\n    pd.DataFrame(all).sort_values(by=[1]).to_csv(out_file_name, sep='\\t', header=False, index=False)\ndef mq2008(src_path, dst_path):\n    \"\"\"\n    0 - label, 1 - qid, ...features...\n    ----------------------------------",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "dump_to_file",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def dump_to_file(out_file_name, X, y, queries):\n    all = np.hstack((y.reshape(-1, 1), queries.reshape(-1, 1), X))\n    pd.DataFrame(all).sort_values(by=[1]).to_csv(out_file_name, sep='\\t', header=False, index=False)\ndef mq2008(src_path, dst_path):\n    \"\"\"\n    0 - label, 1 - qid, ...features...\n    ----------------------------------\n    Characteristics of dataset mq2008 train\n    rows x columns (9630, 46)\n    sparsity: 47.2267370987",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "mq2008",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def mq2008(src_path, dst_path):\n    \"\"\"\n    0 - label, 1 - qid, ...features...\n    ----------------------------------\n    Characteristics of dataset mq2008 train\n    rows x columns (9630, 46)\n    sparsity: 47.2267370987\n    y distribution\n    Counter({0.0: 7820, 1.0: 1223, 2.0: 587})\n    num samples in queries: minimum, median, maximum",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "msrank",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def msrank(src_path, dst_path):\n    \"\"\"\n    0 - label, 1 - qid, ...features...\n    ----------------------------------\n    Characteristics of dataset msrank train\n    rows x columns (723412, 136)\n    sparsity: 37.2279141802\n    y distribution\n    Counter({0.0: 377957, 1.0: 232569, 2.0: 95082, 3.0: 12658, 4.0: 5146})\n    num samples in queries: minimum, median, maximum",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "yahoo",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def yahoo(src_path, dst_path):\n    \"\"\"\n    0 - label, 1 - qid, ...features...\n    ----------------------------------\n    Characteristics of dataset yahoo train\n    rows x columns (473134, 699)\n    sparsity: 68.1320434932\n    y distribution\n    Counter({1.0: 169897, 2.0: 134832, 0.0: 123294, 3.0: 36170, 4.0: 8941})\n    num samples in queries: minimum, median, maximum",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "yandex",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.preprocess",
        "description": "catboost.catboost.benchmarks.ranking.preprocess",
        "peekOfCode": "def yandex(src_path, dst_path):\n    \"\"\"\n    0 - qid, 1 - label, 2 - URL, 3 - GroupId, ...features...\n    ----------------------------------\n    Characteristics of dataset yandex train\n    rows x columns (12463, 53)\n    sparsity: 54.3395620849\n    y distribution\n    Counter({0: 6599, 2: 3311, 1: 2303, 3: 196, 4: 56})\n    num samples in queries: minimum, median, maximum",
        "detail": "catboost.catboost.benchmarks.ranking.preprocess",
        "documentation": {}
    },
    {
        "label": "read_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def read_dataset(file_name):\n    df = pd.read_csv(file_name, sep='\\t', header=None)\n    y = df[0].values\n    queries = df[1].values\n    X = df.iloc[:, 2:].values\n    # assert np.all(queries == np.sort(queries))\n    return X, y, queries\ndef doc_comparator(doc1, doc2):\n    if doc1[1] < doc2[1]:\n        return 1",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "doc_comparator",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def doc_comparator(doc1, doc2):\n    if doc1[1] < doc2[1]:\n        return 1\n    elif doc1[1] == doc2[1]:\n        return int(doc1[0] > doc2[0])\n    else:\n        return -1\ndef cumulative_gain(relevances):\n    return np.sum((2 ** relevances - 1) / np.log2(np.arange(relevances.shape[0]) + 2))\ndef ndcg(y_pred, y_true, top):",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "cumulative_gain",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def cumulative_gain(relevances):\n    return np.sum((2 ** relevances - 1) / np.log2(np.arange(relevances.shape[0]) + 2))\ndef ndcg(y_pred, y_true, top):\n    assert y_pred.shape[0] == y_true.shape[0]\n    top = min(top, y_pred.shape[0])\n    first_k_docs = sorted(zip(y_true, y_pred), key=cmp_to_key(doc_comparator))\n    first_k_docs = np.array(first_k_docs)[:top,0]\n    top_k_idxs = np.argsort(y_true)[::-1][:top]\n    top_k_docs = y_true[top_k_idxs]\n    dcg = cumulative_gain(first_k_docs)",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "ndcg",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def ndcg(y_pred, y_true, top):\n    assert y_pred.shape[0] == y_true.shape[0]\n    top = min(top, y_pred.shape[0])\n    first_k_docs = sorted(zip(y_true, y_pred), key=cmp_to_key(doc_comparator))\n    first_k_docs = np.array(first_k_docs)[:top,0]\n    top_k_idxs = np.argsort(y_true)[::-1][:top]\n    top_k_docs = y_true[top_k_idxs]\n    dcg = cumulative_gain(first_k_docs)\n    idcg = cumulative_gain(top_k_docs)\n    return dcg / idcg if idcg > 0 else 1.",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "mean_ndcg",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def mean_ndcg(y_pred, y_true, query_idxs, top=10):\n    sum_ndcg = 0\n    queries = np.unique(query_idxs)\n    for query in queries:\n        idxs = query_idxs == query\n        value = ndcg(y_pred[idxs], y_true[idxs], top)\n        sum_ndcg += value\n    return sum_ndcg / float(queries.shape[0])\ndef plot_validate_curves(num_iterations, cb_log, xgb_log, lgb_log):\n    plt.figure(figsize=(13, 8))",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "plot_validate_curves",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.ranking.utils",
        "description": "catboost.catboost.benchmarks.ranking.utils",
        "peekOfCode": "def plot_validate_curves(num_iterations, cb_log, xgb_log, lgb_log):\n    plt.figure(figsize=(13, 8))\n    plt.title('NDCG(iteration)', fontdict={'fontsize': 20})\n    x_values = np.array(range(0, num_iterations, 10))\n    cb_line, = plt.plot(x_values, np.mean(cb_log, axis=0))\n    xgb_line, = plt.plot(x_values, np.mean(xgb_log, axis=0))\n    lgb_line, = plt.plot(x_values, np.mean(lgb_log, axis=0))\n    plt.grid(True)\n    plt.legend([cb_line, xgb_line, lgb_line], ['CatBoost', 'XGBoost', 'LightGBM'], fontsize='x-large')\n    plt.savefig('eval_results.png')",
        "detail": "catboost.catboost.benchmarks.ranking.utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.benchmark",
        "description": "catboost.catboost.benchmarks.training_speed.benchmark",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--use-gpu', action='store_true')\n    parser.add_argument('--datasets', default='datasets')\n    parser.add_argument('--iterations', default=1000, type=int)\n    parser.add_argument('--result', default='result.json')\n    parser.add_argument('--table', default='common-table.txt')\n    args = parser.parse_args()\n    experiments_names = [\n        'abalone',",
        "detail": "catboost.catboost.benchmarks.training_speed.benchmark",
        "documentation": {}
    },
    {
        "label": "get_from_cache",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def get_from_cache(experiment_name, train_file, test_file):\n    print('loading train')\n    train = np.fromfile(train_file, sep='\\t')\n    n_features = DATASET_CHARACTERISTIC[experiment_name][1] + 1\n    train = train.reshape((train.shape[0] // n_features, n_features))\n    X_train = train[:, 1:]\n    y_train = train[:, 0]\n    print('loading test')\n    test = np.fromfile(test_file, sep='\\t')\n    test = test.reshape((test.shape[0] // n_features, n_features))",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "save_to_cache",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def save_to_cache(data, train_file, test_file):\n    train = np.hstack([data.y_train.reshape(-1, 1), data.X_train])\n    train_df = pd.DataFrame(data=train)\n    train_df.to_csv(train_file, index=False, header=False, sep='\\t')\n    test = np.hstack([data.y_test.reshape(-1, 1), data.X_test])\n    test_df = pd.DataFrame(data=test)\n    test_df.to_csv(test_file, index=False, header=False, sep='\\t')\ndef get_dataset(experiment_name, dataset_dir):\n    data_loader = DATA_LOADERS[experiment_name]\n    cache_dir = os.path.join(dataset_dir, experiment_name)",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "get_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def get_dataset(experiment_name, dataset_dir):\n    data_loader = DATA_LOADERS[experiment_name]\n    cache_dir = os.path.join(dataset_dir, experiment_name)\n    train_file = os.path.join(cache_dir, \"train.tsv\")\n    test_file = os.path.join(cache_dir, \"test.tsv\")\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n    if all([os.path.exists(file_name) for file_name in [train_file, test_file]]):\n        print('Loading from cache')\n        return get_from_cache(experiment_name, train_file, test_file)",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "read_libsvm",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def read_libsvm(file_obj, n_samples, n_features):\n    X = np.zeros((n_samples, n_features))\n    y = np.zeros((n_samples,))\n    counter = 0\n    regexp = re.compile(r'[A-Za-z0-9]+:(-?\\d*\\.?\\d+)')\n    for line in file_obj:\n        line = line if type(line) == str else line.decode('ascii')\n        line = regexp.sub(r'\\g<1>', line)\n        line = line.rstrip(\" \\n\\r\").split(' ')\n        y[counter] = int(line[0])",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "abalone",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def abalone(dataset_dir):\n    \"\"\"\n    https://archive.ics.uci.edu/ml/machine-learning-databases/abalone\n    TaskType:regression\n    NumberOfFeatures:8\n    NumberOfInstances:4177\n    \"\"\"\n    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data'\n    filename = os.path.join(dataset_dir, 'abalone.data')\n    if not os.path.exists(filename):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "airline",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def airline(dataset_dir):\n    \"\"\"\n    Airline dataset (http://kt.ijs.si/elena_ikonomovska/data.html)\n    TaskType:binclass\n    NumberOfFeatures:13\n    NumberOfInstances:115M\n    \"\"\"\n    url = 'http://kt.ijs.si/elena_ikonomovska/datasets/airline/airline_14col.data.bz2'\n    filename = os.path.join(dataset_dir, 'airline_14col.data.bz2')\n    if not os.path.exists(filename):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "airline_one_hot",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def airline_one_hot(dataset_dir):\n    \"\"\"\n    Dataset from szilard benchmarks: https://github.com/szilard/GBM-perf\n    TaskType:binclass\n    NumberOfFeatures:700\n    NumberOfInstances:10100000\n    \"\"\"\n    url = 'https://s3.amazonaws.com/benchm-ml--main/'\n    name_train = 'train-10m.csv'\n    name_test = 'test.csv'",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "bosch",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def bosch(dataset_dir):\n    \"\"\"\n    Bosch Production Line Performance data set (\n    https://www.kaggle.com/c/bosch-production-line-performance)\n    Requires Kaggle API and API token (https://github.com/Kaggle/kaggle-api)\n    Contains missing values as NaN.\n    TaskType:binclass\n    NumberOfFeatures:968\n    NumberOfInstances:1.184M\n    \"\"\"",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "cover_type",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def cover_type(dataset_dir):\n    \"\"\"\n    Cover type dataset from UCI machine learning repository (\n    https://archive.ics.uci.edu/ml/datasets/covertype).\n    Train/test split was taken from:\n    https://www.kaggle.com/c/forest-cover-type-prediction\n    y contains 7 unique class labels from 1 to 7 inclusive.\n    TaskType:multiclass\n    NumberOfFeatures:54\n    NumberOfInstances:581012",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def epsilon(dataset_dir):\n    \"\"\"\n    TaskType:binclass\n    NumberOfFeatures:2000\n    NumberOfInstances:500K\n    \"\"\"\n    url = 'https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary/'\n    name_train = 'epsilon_normalized.bz2'\n    name_test = 'epsilon_normalized.t.bz2'\n    xs = []",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "epsilon_sampled",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def epsilon_sampled(dataset_dir):\n    \"\"\"\n    TaskType:binclass\n    NumberOfFeatures:28\n    NumberOfInstances:500K\n    \"\"\"\n    xs, ys = epsilon(dataset_dir)\n    feat_ids = np.random.choice(xs[0].shape[1], 28, replace=False)\n    xs[0] = xs[0][:, feat_ids]\n    xs[1] = xs[1][:, feat_ids]",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "higgs",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def higgs(dataset_dir):\n    \"\"\"\n    Higgs dataset from UCI machine learning repository (\n    https://archive.ics.uci.edu/ml/datasets/HIGGS).\n    TaskType:binclass\n    NumberOfFeatures:28\n    NumberOfInstances:11M\n    \"\"\"\n    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/00280/HIGGS.csv.gz'\n    filename = os.path.join(dataset_dir, 'HIGGS.csv.gz')",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "higgs_sampled",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def higgs_sampled(dataset_dir):\n    \"\"\"\n    TaskType:binclass\n    NumberOfFeatures:28\n    NumberOfInstances:500K\n    \"\"\"\n    X, y = higgs(dataset_dir)\n    ids = np.random.choice(X.shape[0], size=500000, replace=False)\n    return X[ids], y[ids]\ndef letters(dataset_dir):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def letters(dataset_dir):\n    \"\"\"\n    http://archive.ics.uci.edu/ml/datasets/Letter+Recognition\n    TaskType:multiclass\n    NumberOfFeatures:16\n    NumberOfInstances:20.000\n    \"\"\"\n    url = 'http://archive.ics.uci.edu/ml/machine-learning-databases/letter-recognition/letter-recognition.data'\n    filename = os.path.join(dataset_dir, 'letter-recognition.data')\n    if not os.path.exists(filename):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "msrank",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def msrank(dataset_dir):\n    \"\"\"\n    Microsoft learning to rank dataset\n    TaskType:ranking\n    NumberOfFeatures:137 (including query id)\n    NumberOfInstances:1200192\n    \"\"\"\n    url = \"https://storage.mds.yandex.net/get-devtools-opensource/471749/msrank.tar.gz\"\n    filename = os.path.join(dataset_dir, 'msrank.tar.gz')\n    if not os.path.exists(filename):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "synthetic_classification",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def synthetic_classification(dataset_dir):\n    \"\"\"\n    Synthetic classification generator from sklearn\n    TaskType:binclass\n    NumberOfFeatures:28\n    NumberOfInstances:500K\n    \"\"\"\n    return datasets.make_classification(n_samples=500000, n_features=28, n_classes=2, random_state=0)\ndef synthetic_regression(dataset_dir):\n    \"\"\"",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "synthetic_regression",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def synthetic_regression(dataset_dir):\n    \"\"\"\n    Synthetic regression generator from sklearn\n    http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_regression.html\n    TaskType:regression\n    NumberOfFeatures:100\n    NumberOfInstances:10M\n    \"\"\"\n    return datasets.make_regression(n_samples=10000000, bias=100, noise=1.0, random_state=0)\ndef synthetic_regression_5k_features(dataset_dir):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "synthetic_regression_5k_features",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def synthetic_regression_5k_features(dataset_dir):\n    \"\"\"\n    Synthetic regression generator from sklearn\n    http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_regression.html\n    TaskType:regression\n    NumberOfFeatures:5000\n    NumberOfInstances:100K\n    \"\"\"\n    return datasets.make_regression(n_samples=100000, n_features=5000, bias=100, noise=1.0, random_state=0)\ndef yahoo(dataset_dir):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "yahoo",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def yahoo(dataset_dir):\n    train_file = os.path.join(dataset_dir, 'train.tsv')\n    test_file = os.path.join(dataset_dir, 'test.tsv')\n    if not (os.path.exists(train_file) or os.path.exists(test_file)):\n        raise Exception('Please download dataset from '\n                        'https://webscope.sandbox.yahoo.com/catalog.php?datatype=c'\n                        ' and convert it to tsv file, 0 - Label, 1 - QueryId, 2 - ...features...')\n    train = pd.read_csv(train_file, sep='\\t', header=None)\n    test = pd.read_csv(test_file, sep='\\t', header=None)\ndef year(dataset_dir):",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "year",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "def year(dataset_dir):\n    \"\"\"\n    YearPredictionMSD dataset from UCI repository (\n    https://archive.ics.uci.edu/ml/datasets/yearpredictionmsd)\n    TaskType:regression\n    NumberOfFeatures:90\n    NumberOfInstances:515345\n    \"\"\"\n    url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/00203/YearPredictionMSD.txt.zip'\n    filename = os.path.join(dataset_dir, 'YearPredictionMSD.txt.zip')",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TEST_SIZE",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "DEFAULT_TEST_SIZE = 0.2\nDATASET_CHARACTERISTIC = {\n    \"abalone\": (4177, 8),\n    \"airline\": (115000000, 13),\n    \"airline-one-hot\": (10100000, 700),\n    \"bosch\": (1184000, 968),\n    \"cover-type\": (581012, 54),\n    \"epsilon\": (500000, 2000),\n    \"epsilon-sampled\": (500000, 28),\n    \"higgs\": (11000000, 28),",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "DATASET_CHARACTERISTIC",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "DATASET_CHARACTERISTIC = {\n    \"abalone\": (4177, 8),\n    \"airline\": (115000000, 13),\n    \"airline-one-hot\": (10100000, 700),\n    \"bosch\": (1184000, 968),\n    \"cover-type\": (581012, 54),\n    \"epsilon\": (500000, 2000),\n    \"epsilon-sampled\": (500000, 28),\n    \"higgs\": (11000000, 28),\n    \"higgs-sampled\": (500000, 28),",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "Data",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "Data = namedtuple(\"Data\", [\"name\", \"X_train\", \"X_test\", \"y_train\", \"y_test\"])\ndef get_from_cache(experiment_name, train_file, test_file):\n    print('loading train')\n    train = np.fromfile(train_file, sep='\\t')\n    n_features = DATASET_CHARACTERISTIC[experiment_name][1] + 1\n    train = train.reshape((train.shape[0] // n_features, n_features))\n    X_train = train[:, 1:]\n    y_train = train[:, 0]\n    print('loading test')\n    test = np.fromfile(test_file, sep='\\t')",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "ALREADY_SPLIT",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "ALREADY_SPLIT = {\n    \"airline-one-hot\",\n    \"cover-type\",\n    \"epsilon-sampled\",\n    \"msrank\",\n    \"msrank-classification\",\n    \"epsilon\"\n}\ndef read_libsvm(file_obj, n_samples, n_features):\n    X = np.zeros((n_samples, n_features))",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "DATA_LOADERS",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.data_loader",
        "description": "catboost.catboost.benchmarks.training_speed.data_loader",
        "peekOfCode": "DATA_LOADERS = {\n    \"abalone\": abalone,\n    \"airline\": airline,\n    \"airline-one-hot\": airline_one_hot,\n    \"bosch\": bosch,\n    \"cover-type\": cover_type,\n    \"epsilon\": epsilon,\n    \"epsilon-sampled\": epsilon_sampled,\n    \"higgs\": higgs,\n    \"higgs-sampled\": higgs_sampled,",
        "detail": "catboost.catboost.benchmarks.training_speed.data_loader",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "class Experiment:\n    def __init__(self, name, task, metric):\n        self.name = name\n        self.task = task\n        self.metric = metric\n    def run(self, use_gpu, learners, params_grid, dataset_dir, result_file, out_dir):\n        dataset = get_dataset(self.name, dataset_dir)\n        device_type = 'GPU' if use_gpu else 'CPU'\n        for LearnerType in learners:\n            learner = LearnerType(dataset, self.task, self.metric, use_gpu)",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "check_exists",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "def check_exists(hash_id, result_file):\n    if not os.path.exists(result_file):\n        with open(result_file, 'w') as f:\n            json.dump({}, f)\n        return False\n    with open(result_file, 'r') as f:\n        content = json.load(f)\n        return str(hash_id) in content\ndef update_result_file(track, result_file):\n    chunk = track.dump_to_json()",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "update_result_file",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "def update_result_file(track, result_file):\n    chunk = track.dump_to_json()\n    with open(result_file, 'r') as f:\n        results = json.load(f)\n    results.update(chunk)\n    backup_result_file = result_file + '.bkp'\n    with open(backup_result_file, 'w') as f:\n        json.dump(results, f, indent=4)\n    os.rename(backup_result_file, result_file)\nclass Experiment:",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "params_to_str",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "def params_to_str(params):\n    return ''.join(map(lambda item: '{}[{}]'.format(item[0], str(item[1])), params.items()))",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "EXPERIMENT_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "EXPERIMENT_TYPE = {\n    \"abalone\":\n        [\"regression\", \"RMSE\"],\n    \"airline\":\n        [\"binclass\", \"Accuracy\"],\n    \"airline-one-hot\":\n        [\"binclass\", \"Accuracy\"],\n    \"bosch\":\n        [\"binclass\", \"Accuracy\"],\n    \"cover-type\":",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "EXPERIMENTS",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.experiments",
        "description": "catboost.catboost.benchmarks.training_speed.experiments",
        "peekOfCode": "EXPERIMENTS = {\n    name: Experiment(name, experiment_type[0], experiment_type[1])\n    for name, experiment_type in EXPERIMENT_TYPE.items()\n}\ndef params_to_str(params):\n    return ''.join(map(lambda item: '{}[{}]'.format(item[0], str(item[1])), params.items()))",
        "detail": "catboost.catboost.benchmarks.training_speed.experiments",
        "documentation": {}
    },
    {
        "label": "calculate_statistics",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def calculate_statistics(tracks, niter):\n    niter -= 1\n    best_track = None\n    best_quality = np.inf\n    best_iter = -1\n    median = []\n    low = []\n    high = []\n    total = []\n    for track in tracks:",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "get_experiment_stats",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def get_experiment_stats(results_file, gpu, niter):\n    stats = {}\n    tracks = read_results(results_file)\n    for experiment_name in tracks:\n        stats[experiment_name] = {}\n        experiment_tracks = tracks[experiment_name]\n        experiment_tracks = dict(filter(lambda track: gpu == ('GPU' in track[0]), experiment_tracks.items()))\n        for algorithm_name in experiment_tracks:\n            stats[experiment_name][algorithm_name] = {}\n            table_tracks = split_tracks(experiment_tracks[algorithm_name])",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "get_table_header",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def get_table_header(experiment_stats):\n    parameter_set = None\n    for algorithm_name in experiment_stats:\n        alg_parameter_set = set(experiment_stats[algorithm_name].keys())\n        if parameter_set is None:\n            parameter_set = alg_parameter_set\n        else:\n            parameter_set &= alg_parameter_set\n    return sorted(list(parameter_set))\ndef get_median_str(stat):",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "get_median_str",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def get_median_str(stat):\n    median = np.round(stat[\"MedianTime\"], 3)\n    dev = np.round(stat[\"Deviation\"], 3)\n    median_str = str(median)\n    if abs(dev) > 0:\n        median_str += u' +/- ' + str(dev)\n    return median_str\ndef print_all_in_one_table(stats, gpu, params, output):\n    median_table = []\n    total_table = []",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "print_all_in_one_table",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def print_all_in_one_table(stats, gpu, params, output):\n    median_table = []\n    total_table = []\n    index = [\"catboost\", \"xgboost\", \"lightgbm\"]\n    for algorithm_name in index:\n        median_row = []\n        total_row = []\n        if gpu:\n            algorithm_name += \"-GPU\"\n        else:",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "print_experiment_table",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def print_experiment_table(stats, output):\n    for experiment_name in stats:\n        experiment_stats = stats[experiment_name]\n        header = get_table_header(experiment_stats)\n        median_table = []\n        total_table = []\n        for algorithm_name in experiment_stats:\n            algorithm_stats = experiment_stats[algorithm_name]\n            median_row = []\n            total_row = []",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "split_tracks",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def split_tracks(tracks):\n    depths = []\n    samples = []\n    for track in tracks:\n        depths.append(track.params.max_depth)\n        if \"subsample\" not in track.params_dict.keys():\n            samples.append(1.0)\n            continue\n        samples.append(track.params.subsample)\n    depths = set(depths)",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.generate_report",
        "description": "catboost.catboost.benchmarks.training_speed.generate_report",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-i', '--result', default='./results.json')\n    parser.add_argument('-o', '--output')\n    parser.add_argument('-t', '--type', choices=['common-table', 'by-depth-table', 'json'], default='common-table')\n    parser.add_argument('-f', '--filter', choices=['only-gpu', 'only-cpu'], default='only-gpu')\n    parser.add_argument('-p', '--params', default=(6.0, 1.0))\n    parser.add_argument('-niter', type=int, default=999)\n    args = parser.parse_args()\n    on_gpu = args.filter == 'only-gpu'",
        "detail": "catboost.catboost.benchmarks.training_speed.generate_report",
        "documentation": {}
    },
    {
        "label": "TimeAnnotatedFile",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class TimeAnnotatedFile:\n    def __init__(self, file_descriptor):\n        self.file_descriptor = file_descriptor\n    def write(self, message):\n        if message == '\\n':\n            self.file_descriptor.write('\\n')\n            return\n        cur_time = datetime.now()\n        new_message = \"Time: [%d.%06d]\\t%s\" % (cur_time.second, cur_time.microsecond, message)\n        self.file_descriptor.write(new_message)",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class Logger:\n    def __init__(self, filename):\n        self.filename = filename\n        self.stdout = sys.stdout\n    def __enter__(self):\n        self.file = TimeAnnotatedFile(open(self.filename, 'w'))\n        sys.stdout = self.file\n    def __exit__(self, exception_type, exception_value, traceback):\n        if exception_type is not None:\n            print(str(exception_value) + '\\n' + str(traceback))",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "Learner",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class Learner:\n    def __init__(self):\n        self.default_params = {}\n    def _fit(self, tunable_params):\n        params = deepcopy(self.default_params)\n        params.update(tunable_params)\n        print('Parameters:\\n{}' + str(params))\n        return params\n    def eval(self, data, num_iterations, step=10):\n        scores = []",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "XGBoostLearner",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class XGBoostLearner(Learner):\n    def __init__(self, data, task, metric, use_gpu):\n        Learner.__init__(self)\n        params = {\n            'n_gpus': 1,\n            'silent': 0,\n            'seed': RANDOM_SEED\n        }\n        if use_gpu:\n            params['tree_method'] = 'gpu_hist'",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "LightGBMLearner",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class LightGBMLearner(Learner):\n    def __init__(self, data, task, metric, use_gpu):\n        Learner.__init__(self)\n        params = {\n            'task': 'train',\n            'boosting_type': 'gbdt',\n            'verbose': 0,\n            'random_state': RANDOM_SEED,\n            'bagging_freq': 1\n        }",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "CatBoostLearner",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "class CatBoostLearner(Learner):\n    def __init__(self, data, task, metric, use_gpu):\n        Learner.__init__(self)\n        params = {\n            'devices': [0],\n            'logging_level': 'Verbose',\n            'use_best_model': False,\n            'bootstrap_type': 'Bernoulli',\n            'random_seed': RANDOM_SEED\n        }",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "def eval_metric(data, prediction):\n    if data.metric == \"RMSE\":\n        return np.sqrt(mean_squared_error(data.y_test, prediction))\n    elif data.metric == \"Accuracy\":\n        if data.task == \"binclass\":\n            prediction = prediction > 0.5\n        elif data.task == \"multiclass\":\n            if prediction.ndim > 1:\n                prediction = np.argmax(prediction, axis=1)\n        return accuracy_score(data.y_test, prediction)",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "RANDOM_SEED",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.learners",
        "description": "catboost.catboost.benchmarks.training_speed.learners",
        "peekOfCode": "RANDOM_SEED = 0\nclass TimeAnnotatedFile:\n    def __init__(self, file_descriptor):\n        self.file_descriptor = file_descriptor\n    def write(self, message):\n        if message == '\\n':\n            self.file_descriptor.write('\\n')\n            return\n        cur_time = datetime.now()\n        new_message = \"Time: [%d.%06d]\\t%s\" % (cur_time.second, cur_time.microsecond, message)",
        "detail": "catboost.catboost.benchmarks.training_speed.learners",
        "documentation": {}
    },
    {
        "label": "Track",
        "kind": 6,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "class Track:\n    param_regex = re.compile(r'(\\w+)\\[(\\d+\\.?\\d*)\\]')\n    def __init__(self, algorithm_name, experiment_name, task_type, parameters_str, time_series, scores, duration):\n        self.log_name = parameters_str\n        self.algorithm_name = algorithm_name\n        self.scores = scores\n        self.experiment_name = experiment_name\n        self.task_type = task_type\n        self.duration = duration\n        self.parameters_str = parameters_str",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "parse_catboost_log",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "def parse_catboost_log(test_error_file, task_type, iterations):\n    values = []\n    with open(test_error_file) as metric_log:\n        file_content = metric_log.read()\n        first_line_idx = file_content.find('\\n')\n        first_line = file_content[:first_line_idx]\n        header = first_line.split('\\t')\n        column_idx = header.index(METRIC_NAME['catboost'][task_type])\n        regex = LOG_LINE_REGEX['catboost-tsv']\n        matches = regex.findall(file_content)",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "parse_log",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "def parse_log(algorithm_name, experiment_name, task_type, params_str, file_name, iterations):\n    time_series = []\n    values = []\n    algorithm = algorithm_name.rstrip('-CPU|GPU')\n    if algorithm == 'catboost':\n        catboost_train_dir = file_name + 'dir'\n        test_error_file = os.path.join(catboost_train_dir, 'test_error.tsv')\n        values = parse_catboost_log(test_error_file, task_type, iterations)\n    with open(file_name, 'r') as log:\n        file_content = log.read()",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "read_results",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "def read_results(results_file):\n    with open(results_file, 'r') as f:\n        results_json = json.load(f)\n    results = results_json.values()\n    tracks = {}\n    for result in results:\n        experiment_name = result[\"dataset\"]\n        algorithm_name = result[\"algorithm_name\"]\n        if experiment_name not in tracks:\n            tracks[experiment_name] = {}",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "ALGORITHMS",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "ALGORITHMS = [method + '-' + device_type\n              for device_type in ['CPU', 'GPU']\n              for method in ['catboost', 'xgboost', 'lightgbm']]\nTIME_REGEX = r'Time: \\[\\s*(\\d+\\.?\\d*)\\s*\\]\\t'\nELAPSED_REGEX = re.compile(r'Elapsed: (\\d+\\.?\\d*)')\nLOG_LINE_REGEX = {\n    'lightgbm': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\tvalid_0\\'s (\\w+): (\\d+\\.?\\d*)'),\n    'xgboost': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\t([a-zA-Z\\-]+):(\\d+\\.?\\d*)'),\n    'catboost': re.compile(TIME_REGEX + r'(\\d+)'),\n    'catboost-tsv': re.compile(r'(\\d+)(\\t(\\d+\\.?\\d*))+\\n')",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "TIME_REGEX",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "TIME_REGEX = r'Time: \\[\\s*(\\d+\\.?\\d*)\\s*\\]\\t'\nELAPSED_REGEX = re.compile(r'Elapsed: (\\d+\\.?\\d*)')\nLOG_LINE_REGEX = {\n    'lightgbm': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\tvalid_0\\'s (\\w+): (\\d+\\.?\\d*)'),\n    'xgboost': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\t([a-zA-Z\\-]+):(\\d+\\.?\\d*)'),\n    'catboost': re.compile(TIME_REGEX + r'(\\d+)'),\n    'catboost-tsv': re.compile(r'(\\d+)(\\t(\\d+\\.?\\d*))+\\n')\n}\nclass Track:\n    param_regex = re.compile(r'(\\w+)\\[(\\d+\\.?\\d*)\\]')",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "ELAPSED_REGEX",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "ELAPSED_REGEX = re.compile(r'Elapsed: (\\d+\\.?\\d*)')\nLOG_LINE_REGEX = {\n    'lightgbm': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\tvalid_0\\'s (\\w+): (\\d+\\.?\\d*)'),\n    'xgboost': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\t([a-zA-Z\\-]+):(\\d+\\.?\\d*)'),\n    'catboost': re.compile(TIME_REGEX + r'(\\d+)'),\n    'catboost-tsv': re.compile(r'(\\d+)(\\t(\\d+\\.?\\d*))+\\n')\n}\nclass Track:\n    param_regex = re.compile(r'(\\w+)\\[(\\d+\\.?\\d*)\\]')\n    def __init__(self, algorithm_name, experiment_name, task_type, parameters_str, time_series, scores, duration):",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "LOG_LINE_REGEX",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "LOG_LINE_REGEX = {\n    'lightgbm': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\tvalid_0\\'s (\\w+): (\\d+\\.?\\d*)'),\n    'xgboost': re.compile(TIME_REGEX + r'\\[(\\d+)\\]\\t([a-zA-Z\\-]+):(\\d+\\.?\\d*)'),\n    'catboost': re.compile(TIME_REGEX + r'(\\d+)'),\n    'catboost-tsv': re.compile(r'(\\d+)(\\t(\\d+\\.?\\d*))+\\n')\n}\nclass Track:\n    param_regex = re.compile(r'(\\w+)\\[(\\d+\\.?\\d*)\\]')\n    def __init__(self, algorithm_name, experiment_name, task_type, parameters_str, time_series, scores, duration):\n        self.log_name = parameters_str",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "TASK_TYPES_ACCURACY",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "TASK_TYPES_ACCURACY = ['binclass', 'multiclass']\nMETRIC_NAME = {\n    'lightgbm': {'regression': 'rmse', 'binclass': 'binary_error', 'multiclass': 'multi_error'},\n    'xgboost': {'regression': 'eval-rmse', 'binclass': 'eval-error', 'multiclass': 'eval-merror'},\n    'catboost': {'regression': 'RMSE', 'binclass': 'Accuracy', 'multiclass': 'Accuracy'}\n}\ndef parse_catboost_log(test_error_file, task_type, iterations):\n    values = []\n    with open(test_error_file) as metric_log:\n        file_content = metric_log.read()",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "METRIC_NAME",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.log_parser",
        "description": "catboost.catboost.benchmarks.training_speed.log_parser",
        "peekOfCode": "METRIC_NAME = {\n    'lightgbm': {'regression': 'rmse', 'binclass': 'binary_error', 'multiclass': 'multi_error'},\n    'xgboost': {'regression': 'eval-rmse', 'binclass': 'eval-error', 'multiclass': 'eval-merror'},\n    'catboost': {'regression': 'RMSE', 'binclass': 'Accuracy', 'multiclass': 'Accuracy'}\n}\ndef parse_catboost_log(test_error_file, task_type, iterations):\n    values = []\n    with open(test_error_file) as metric_log:\n        file_content = metric_log.read()\n        first_line_idx = file_content.find('\\n')",
        "detail": "catboost.catboost.benchmarks.training_speed.log_parser",
        "documentation": {}
    },
    {
        "label": "plot_time_per_iter",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def plot_time_per_iter(tracks, figsize=FIGURE_SIZE, title=None, save_path='time_per_iter.png'):\n    fig = plt.figure(figsize=figsize)\n    time_per_iters = []\n    algs = tracks.keys()\n    for alg_name in algs:\n        time_per_iter_alg = []\n        for track in tracks[alg_name]:\n            # aggregating statistic over different tracks\n            time_per_iter = track.get_time_per_iter()\n            time_per_iter_alg.extend(time_per_iter)",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "plot_quality",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def plot_quality(tracks, from_iter, to_iter, figsize=FIGURE_SIZE, title=None, save_path='quality.png'):\n    fig = plt.figure(figsize=figsize)\n    if title is not None:\n        plt.title(title, FONT_DICT)\n    flat_tracks = []\n    for alg in tracks.keys():\n        flat_tracks += tracks[alg]\n    first_track = flat_tracks[0]\n    task_type = first_track.task_type\n    metric = 'Error' if task_type == 'Classification' or task_type == 'Multiclass' else 'RMSE'",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "plot_quality_vs_time",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def plot_quality_vs_time(tracks, best_quality, low_percent=0.8, num_bins=100, only_min=False,\n                         figsize=FIGURE_SIZE, title=None, save_path='time_distr.png'):\n    fig = plt.figure(figsize=figsize)\n    if title is not None:\n        plt.title(title, FONT_DICT)\n    plt.xlabel('Quality (%)', FONT_DICT)\n    plt.ylabel('Time to obtain (sec)', FONT_DICT)\n    algs = tracks.keys()\n    up_percent = 1. - low_percent\n    for i, alg_name in enumerate(algs):",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "params_to_str",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def params_to_str(params):\n    return ''.join(map(lambda (key, value): '{}{}'.format(key, str(value)), params.items()))\ndef get_best(tracks, top=1):\n    algorithms = tracks.keys()\n    best_tracks = {}\n    for algorithm_name in algorithms:\n        best_scores = map(lambda track: track.get_best_score(), tracks[algorithm_name])\n        idx_best = np.argsort(best_scores)[:top]\n        best_tracks[algorithm_name] = map(lambda idx: tracks[algorithm_name][idx], idx_best)\n    return best_tracks",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "get_best",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def get_best(tracks, top=1):\n    algorithms = tracks.keys()\n    best_tracks = {}\n    for algorithm_name in algorithms:\n        best_scores = map(lambda track: track.get_best_score(), tracks[algorithm_name])\n        idx_best = np.argsort(best_scores)[:top]\n        best_tracks[algorithm_name] = map(lambda idx: tracks[algorithm_name][idx], idx_best)\n    return best_tracks\ndef filter_tracks(tracks, params_cases):\n    filtered_tracks = {}",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "filter_tracks",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def filter_tracks(tracks, params_cases):\n    filtered_tracks = {}\n    for alg in tracks.keys():\n        filtered_tracks[alg] = []\n        for track in tracks[alg]:\n            if all([track.params_dict[param_name] in params_cases[param_name] for param_name in params_cases.keys()]):\n                filtered_tracks[alg].append(track)\n    return filtered_tracks\nONLY_TYPES = {\n    'cat-cpu': ['catboost-CPU'],",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "get_default_file_name",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def get_default_file_name(plot_type, params):\n    default_file_names = {\n        'best': 'best_quality.png',\n        'quality-vs-time': 'quality_vs_time.png',\n        'time-per-iter': 'time_per_iter.png'\n    }\n    if plot_type in default_file_names.keys():\n        return default_file_names[plot_type]\n    if plot_type == 'custom':\n        return params_to_str(params) + '.png'",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "plot_experiment",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def plot_experiment(tracks, experiment_name, args):\n    file_name = args.file_name if args.file_name else get_default_file_name(args.type, args.params_cases)\n    save_dir = os.path.join(args.out_dir, experiment_name)\n    if not os.path.exists(save_dir):\n        os.makedirs(save_dir)\n    save_path = os.path.join(save_dir, file_name)\n    if args.only:\n        filtered_tracks = {}\n        for only_type in args.only:\n            for alg_name in ONLY_TYPES[only_type]:",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "def main():\n    plot_functions = {\n        'time-per-iter': plot_time_per_iter,\n        'best': plot_quality,\n        'quality-vs-time': plot_quality_vs_time,\n        'custom': plot_quality\n    }\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--type', choices=plot_functions.keys(), required=True)\n    parser.add_argument('--only', nargs='+', choices=ONLY_TYPES.keys(), required=False)",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "FONT_DICT",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "FONT_DICT = {'fontsize': 20}\nFIGURE_SIZE = (10, 5)\ndef plot_time_per_iter(tracks, figsize=FIGURE_SIZE, title=None, save_path='time_per_iter.png'):\n    fig = plt.figure(figsize=figsize)\n    time_per_iters = []\n    algs = tracks.keys()\n    for alg_name in algs:\n        time_per_iter_alg = []\n        for track in tracks[alg_name]:\n            # aggregating statistic over different tracks",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "FIGURE_SIZE",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "FIGURE_SIZE = (10, 5)\ndef plot_time_per_iter(tracks, figsize=FIGURE_SIZE, title=None, save_path='time_per_iter.png'):\n    fig = plt.figure(figsize=figsize)\n    time_per_iters = []\n    algs = tracks.keys()\n    for alg_name in algs:\n        time_per_iter_alg = []\n        for track in tracks[alg_name]:\n            # aggregating statistic over different tracks\n            time_per_iter = track.get_time_per_iter()",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "ONLY_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.plot",
        "description": "catboost.catboost.benchmarks.training_speed.plot",
        "peekOfCode": "ONLY_TYPES = {\n    'cat-cpu': ['catboost-CPU'],\n    'xgb-cpu': ['xgboost-CPU'],\n    'lgb-cpu': ['lightgbm-CPU'],\n    'cat-gpu': ['catboost-GPU'],\n    'xgb-gpu': ['xgboost-GPU'],\n    'lgb-gpu': ['lightgbm-GPU'],\n    'cat': ['catboost-CPU', 'catboost-GPU'],\n    'xgb': ['xgboost-CPU', 'xgboost-GPU'],\n    'lgb': ['lightgbm-CPU', 'lightgbm-GPU'],",
        "detail": "catboost.catboost.benchmarks.training_speed.plot",
        "documentation": {}
    },
    {
        "label": "default_num_iterations",
        "kind": 2,
        "importPath": "catboost.catboost.benchmarks.training_speed.run",
        "description": "catboost.catboost.benchmarks.training_speed.run",
        "peekOfCode": "def default_num_iterations(experiment_name):\n    num_samples = DATASET_CHARACTERISTIC[experiment_name][0]\n    if num_samples > 10e6:\n        return 8000\n    elif num_samples > 50e3:\n        return 5000\n    else:\n        return 2000\ndef _get_all_values_from_subset(items, subset):\n    filtered_keys = filter(lambda x: x in subset, items.keys())",
        "detail": "catboost.catboost.benchmarks.training_speed.run",
        "documentation": {}
    },
    {
        "label": "LEARNERS",
        "kind": 5,
        "importPath": "catboost.catboost.benchmarks.training_speed.run",
        "description": "catboost.catboost.benchmarks.training_speed.run",
        "peekOfCode": "LEARNERS = {\n    \"xgb\": XGBoostLearner,\n    \"lgb\": LightGBMLearner,\n    \"cat\": CatBoostLearner\n}\ndef default_num_iterations(experiment_name):\n    num_samples = DATASET_CHARACTERISTIC[experiment_name][0]\n    if num_samples > 10e6:\n        return 8000\n    elif num_samples > 50e3:",
        "detail": "catboost.catboost.benchmarks.training_speed.run",
        "documentation": {}
    },
    {
        "label": "build_shared_lib_with_ya",
        "kind": 2,
        "importPath": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "description": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "peekOfCode": "def build_shared_lib_with_ya(parsed_args, top_src_root_dir, package_src_sub_path, extra_ya_make_args):\n    print('building dynamic library with `ya`', file=sys.stderr)\n    sys.stderr.flush()\n    native_lib_dir = _get_native_lib_dir(top_src_root_dir, package_src_sub_path)\n    env = os.environ.copy()\n    ya_path = _get_ya_path()\n    ya_make_commands = []\n    common_ya_make_args = ([sys.executable, ya_path, 'make', native_lib_dir]\n        + ['--output', parsed_args.build_output_root_dir]\n        + ['--build=' + parsed_args.build_type.lower()]",
        "detail": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "documentation": {}
    },
    {
        "label": "postprocess_after_ya",
        "kind": 2,
        "importPath": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "description": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "peekOfCode": "def postprocess_after_ya(native_lib_build_dir, lib_name, resources_dir, base_dir):\n    jar_name = lib_name + '.jar'\n    jar_src_path = os.path.join(native_lib_build_dir, jar_name)\n    if os.path.exists(jar_src_path):\n        \"\"\"\n        Ya Make's DLL_JAVA packs classes generated by SWIG into it's own jar,\n        put these classes into resource dir to be added in main package's jar.\n        \"\"\"\n        print('extract classes from jar to resources', file=sys.stderr)\n        _extract_classes_from_jar(jar_src_path, resources_dir)",
        "detail": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "documentation": {}
    },
    {
        "label": "postprocess_after_cmake",
        "kind": 2,
        "importPath": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "description": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "peekOfCode": "def postprocess_after_cmake(parsed_args, top_src_root_dir, resources_dir):\n    package_src_sub_path = os.path.relpath(parsed_args.base_dir, top_src_root_dir)\n    if parsed_args.macos_universal_binaries:\n        # build_native.build does not produce anything except final binaries in standard native_lib_build_dir place\n        # so get java sources from one of the architecture subdirs\n        native_lib_build_dir = _get_native_lib_dir(\n            os.path.join(parsed_args.build_output_root_dir, 'darwin-x86_64'),\n            package_src_sub_path\n        )\n    else:",
        "detail": "catboost.catboost.jvm-packages.tools.build_native_for_maven",
        "documentation": {}
    },
    {
        "label": "makedirs_if_not_exist",
        "kind": 2,
        "importPath": "catboost.catboost.jvm-packages.tools.copy_prebuilt_native_files",
        "description": "catboost.catboost.jvm-packages.tools.copy_prebuilt_native_files",
        "peekOfCode": "def makedirs_if_not_exist(dir_path):\n    \"\"\"\n        ensure that target directory exists, can't use exist_ok flag because it is unavailable in\n        python 2.7\n    \"\"\"\n    try:\n        os.makedirs(dir_path)\n    except OSError as e:\n        if e.errno != errno.EEXIST:\n            raise",
        "detail": "catboost.catboost.jvm-packages.tools.copy_prebuilt_native_files",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "catboost.catboost.libs.data.benchmarks_ut.test_perf",
        "description": "catboost.catboost.libs.data.benchmarks_ut.test_perf",
        "peekOfCode": "def test(metrics):\n    metrics.set_benchmark(yatest.common.execute_benchmark(\"catboost/libs/data/benchmarks/benchmarks\"))",
        "detail": "catboost.catboost.libs.data.benchmarks_ut.test_perf",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "description": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "description": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "description": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.libs.model.model_export.resources.apply_catboost_model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_calcer",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "description": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data",
        "detail": "catboost.catboost.libs.model.model_export.resources.ctr_structs",
        "documentation": {}
    },
    {
        "label": "test_cpp_export",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "def test_cpp_export(dataset, parameters):\n    model_cpp, _, model_cbm = _get_cpp_py_cbm_model(dataset, parameters)\n    _, test_path, cd_path = _get_train_test_cd_path(dataset)\n    # form the commands we are going to run\n    applicator_cpp = yatest.common.source_path('catboost/libs/model/model_export/ut/applicator.cpp')\n    applicator_exe = yatest.common.test_output_path('applicator.exe')\n    predictions_by_catboost_path = yatest.common.test_output_path('predictions_by_catboost.txt')\n    predictions_path = yatest.common.test_output_path('predictions.txt')\n    is_multiclass_model = __get_train_loss_function(dataset) == 'MultiClass'\n    if os.name == 'posix':",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "test_read_model_after_train",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "def test_read_model_after_train():\n    train_path, test_path, cd_path = _get_train_test_cd_path('adult')\n    eval_file = yatest.common.test_output_path('eval-file')\n    cmd = [\n        CATBOOST_APP_PATH, 'fit',\n        '-f', train_path,\n        '--cd', cd_path,\n        '-t', test_path,\n        '-i', '100',\n        '--eval-file', eval_file",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "test_python_export_from_app",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "def test_python_export_from_app(dataset):\n    _, test_pool = _get_train_test_pool(dataset)\n    _, model_py, model_cbm = _get_cpp_py_cbm_model(dataset)\n    model = CatBoost()\n    model.load_model(model_cbm)\n    pred_model = model.predict(test_pool, prediction_type='RawFormulaVal')\n    is_multiclass_model = __get_train_loss_function(dataset) == 'MultiClass'\n    scope = {}\n    exec(open(model_py).read(), scope)  # noqa\n    pred_python = _predict_python_on_test(",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "test_python_export_from_python",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "def test_python_export_from_python(dataset, iterations):\n    train_pool, test_pool = _get_train_test_pool(dataset)\n    model = CatBoost(\n        {'iterations': iterations, 'random_seed': 0, 'loss_function': __get_train_loss_function(dataset)}\n    )\n    model.fit(train_pool)\n    pred_model = model.predict(test_pool, prediction_type='RawFormulaVal')\n    model_py = yatest.common.test_output_path('model.py')\n    model.save_model(model_py, format=\"python\", pool=train_pool)\n    is_multiclass_model = __get_train_loss_function(dataset) == 'MultiClass'",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "test_python_after_load",
        "kind": 2,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "def test_python_after_load(dataset):\n    train_pool, test_pool = _get_train_test_pool(dataset)\n    model = CatBoostClassifier(iterations=40, random_seed=0)\n    model.fit(train_pool)\n    pred_model = model.predict(test_pool, prediction_type='RawFormulaVal')\n    model_cbm = yatest.common.test_output_path('model.cbm')\n    model.save_model(model_cbm)\n    model_loaded = CatBoostClassifier()\n    model_loaded.load_model(model_cbm)\n    model_py = yatest.common.test_output_path('model.py')",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "CATBOOST_APP_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "CATBOOST_APP_PATH = yatest.common.binary_path('catboost/app/catboost')\nAPPROXIMATE_DIFF_PATH = yatest.common.binary_path('catboost/tools/limited_precision_dsv_diff/limited_precision_dsv_diff')\ndef _get_train_test_cd_path(dataset):\n    train_path = data_file(dataset, 'train_small')\n    test_path = data_file(dataset, 'test_small')\n    cd_path = data_file(dataset, 'train.cd')\n    return (train_path, test_path, cd_path)\ndef _get_train_test_pool(dataset):\n    train_path, test_path, cd_path = _get_train_test_cd_path(dataset)\n    train_pool = Pool(train_path, column_description=cd_path)",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "APPROXIMATE_DIFF_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.libs.model.model_export.ut.test",
        "description": "catboost.catboost.libs.model.model_export.ut.test",
        "peekOfCode": "APPROXIMATE_DIFF_PATH = yatest.common.binary_path('catboost/tools/limited_precision_dsv_diff/limited_precision_dsv_diff')\ndef _get_train_test_cd_path(dataset):\n    train_path = data_file(dataset, 'train_small')\n    test_path = data_file(dataset, 'test_small')\n    cd_path = data_file(dataset, 'train.cd')\n    return (train_path, test_path, cd_path)\ndef _get_train_test_pool(dataset):\n    train_path, test_path, cd_path = _get_train_test_cd_path(dataset)\n    train_pool = Pool(train_path, column_description=cd_path)\n    test_pool = Pool(test_path, column_description=cd_path)",
        "detail": "catboost.catboost.libs.model.model_export.ut.test",
        "documentation": {}
    },
    {
        "label": "generate_concatenated_random_labeled_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def generate_concatenated_random_labeled_dataset(nrows, nvals, labels, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=seed)\n    label = prng.choice(labels, [nrows, 1])\n    feature = prng.random_sample([nrows, nvals])\n    return np.concatenate([label, feature], axis=1)\ndef diff_tool(threshold=2e-7):\n    return get_limited_precision_dsv_diff_tool(threshold, True)\ndef skipif_no_cuda():\n    if 'HAVE_CUDA' in os.environ:",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def diff_tool(threshold=2e-7):\n    return get_limited_precision_dsv_diff_tool(threshold, True)\ndef skipif_no_cuda():\n    if 'HAVE_CUDA' in os.environ:\n        flags = [f\"HAVE_CUDA={os.environ['HAVE_CUDA']}\"]\n    else:\n        try:\n            flags = yatest.common.runtime._get_ya_config().option.flags\n        except Exception:\n            flags = ['HAVE_CUDA=no']",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "skipif_no_cuda",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def skipif_no_cuda():\n    if 'HAVE_CUDA' in os.environ:\n        flags = [f\"HAVE_CUDA={os.environ['HAVE_CUDA']}\"]\n    else:\n        try:\n            flags = yatest.common.runtime._get_ya_config().option.flags\n        except Exception:\n            flags = ['HAVE_CUDA=no']\n    for flag in flags:\n        if re.match('HAVE_CUDA=(0|no|false)', flag, flags=re.IGNORECASE):",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "fit_catboost_gpu",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def fit_catboost_gpu(params, devices='0'):\n    execute_catboost_fit(\n        task_type='GPU',\n        params=params,\n        devices=devices,\n    )\n# currently only works on CPU\ndef fstr_catboost_cpu(params):\n    cmd = list()\n    cmd.append(CATBOOST_PATH)",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "fstr_catboost_cpu",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def fstr_catboost_cpu(params):\n    cmd = list()\n    cmd.append(CATBOOST_PATH)\n    cmd.append('fstr')\n    append_params_to_cmdline(cmd, params)\n    yatest.common.execute(cmd)\ndef test_eval_metric_equals_loss_metric():\n    output_model_path = 'model.bin'\n    train_dir_path = 'trainDir'\n    params = (",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_eval_metric_equals_loss_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_eval_metric_equals_loss_metric():\n    output_model_path = 'model.bin'\n    train_dir_path = 'trainDir'\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '--eval-metric', 'RMSE',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_queryrmse",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_queryrmse(boosting_type, qwise_loss):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    predictions_path_learn = yatest.common.test_output_path('predictions_learn.tsv')\n    predictions_path_test = yatest.common.test_output_path('predictions_test.tsv')\n    learn_file = data_file('querywise', 'train')\n    cd_file = data_file('querywise', 'train.cd')\n    test_file = data_file('querywise', 'test')\n    params = {\"--loss-function\": qwise_loss,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_boosting_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_boosting_type(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_file = data_file('adult', 'train_small')\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': train_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_rsm_with_default_value",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_rsm_with_default_value(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': data_file('adult', 'test_small'),\n        '--column-description': data_file('adult', 'train.cd'),\n        '--boosting-type': boosting_type,\n        '-i': '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_tweedie_with_fixed_variance_power",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_tweedie_with_fixed_variance_power(boosting_type, leaf_estimation_method):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Tweedie:variance_power=1.9',\n        '-f': data_file('adult', 'train_small'),\n        '-t': data_file('adult', 'test_small'),\n        '--column-description': data_file('adult', 'train.cd'),\n        '--boosting-type': boosting_type,\n        '--leaf-estimation-method': leaf_estimation_method,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_huber_with_fixed_delta",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_huber_with_fixed_delta(boosting_type, leaf_estimation_method):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Huber:delta=1.0',\n        '-f': data_file('adult', 'train_small'),\n        '-t': data_file('adult', 'test_small'),\n        '--column-description': data_file('adult', 'train.cd'),\n        '--boosting-type': boosting_type,\n        '--leaf-estimation-method': leaf_estimation_method,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_rsm_with_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_rsm_with_pairwise(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'PairLogitPairwise',\n        '-f': data_file('querywise', 'train'),\n        '--learn-pairs': data_file('querywise', 'train.pairs'),\n        '--column-description': data_file('querywise', 'train.cd'),\n        '--boosting-type': boosting_type,\n        '-i': '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "combine_dicts",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def combine_dicts(first, *vargs):\n    combined = first.copy()\n    for rest in vargs:\n        combined.update(rest)\n    return combined\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_bootstrap(boosting_type):\n    bootstrap_option = {\n        'bayes': {'--bootstrap-type': 'Bayesian', '--bagging-temperature': '0.0'},\n        'bernoulli': {'--bootstrap-type': 'Bernoulli', '--subsample': '1.0'},",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_bootstrap(boosting_type):\n    bootstrap_option = {\n        'bayes': {'--bootstrap-type': 'Bayesian', '--bagging-temperature': '0.0'},\n        'bernoulli': {'--bootstrap-type': 'Bernoulli', '--subsample': '1.0'},\n        'mvs': {'--bootstrap-type': 'MVS', '--subsample': '1.0'},\n    }\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_bootstrap_no",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_bootstrap_no(boosting_type):\n    bootstrap_option = {\n        'no': {'--bootstrap-type': 'No'},\n        'bayes': {'--bootstrap-type': 'Bayesian', '--bagging-temperature': '0.0'},\n    }\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_nan_mode_forbidden",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_nan_mode_forbidden(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult', 'test_small')\n    learn_file = data_file('adult', 'train_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '-f': learn_file,\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_iter",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_overfit_detector_iter(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_inc_to_dec",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_overfit_detector_inc_to_dec(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_nan_mode",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_nan_mode(nan_mode, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult_nan', 'test_small')\n    cd_file = data_file('adult_nan', 'train.cd')\n    params = {\n        '--use-best-model': 'false',\n        '-f': data_file('adult_nan', 'train_small'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_use_best_model",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_use_best_model(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_crossentropy",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_crossentropy(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = {\n        '--loss-function': 'CrossEntropy',\n        '-f': data_file('adult_crossentropy', 'train_proba'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_permutation_block",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_permutation_block(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = {\n        '--loss-function': 'CrossEntropy',\n        '-f': data_file('adult_crossentropy', 'train_proba'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ignored_features(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ignored_features_not_read",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ignored_features_not_read():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    input_cd_path = data_file('adult', 'train.cd')\n    cd_file = yatest.common.test_output_path('train.cd')\n    with open(input_cd_path, \"rt\") as f:\n        cd_lines = f.readlines()\n    with open(cd_file, \"wt\") as f:\n        for cd_line in cd_lines:\n            # Corrupt some features by making them 'Num'\n            if cd_line.split() == ('5', 'Categ'):  # column 5 --> feature 4",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_baseline(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('train_adult_baseline.cd')\n    test_file = data_file('adult_weight', 'test_weight')\n    params = {\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_weight', 'train_weight'),\n        '-t': test_file,\n        '--column-description': cd_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_boost_from_average",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_boost_from_average(boosting_type, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_calc_eval_path = yatest.common.test_output_path('test_calc.eval')\n    output_eval_path_with_avg = yatest.common.test_output_path('test_avg.eval')\n    output_eval_path_with_baseline = yatest.common.test_output_path('test_baseline.eval')\n    baselined_train = yatest.common.test_output_path('baselined_train')\n    baselined_test = yatest.common.test_output_path('baselined_test')\n    baselined_cd = yatest.common.test_output_path('baselined.cd')\n    train_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_weights(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_weight', 'train.cd')\n    test_file = data_file('adult_weight', 'test_weight')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_weight', 'train_weight'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_weights_without_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_weights_without_bootstrap(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_weight', 'train.cd')\n    test_file = data_file('adult_weight', 'test_weight')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_weight', 'train_weight'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_weighted_pool_leaf_estimation_method",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_weighted_pool_leaf_estimation_method(boosting_type, leaf_estimation):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_weight', 'train.cd')\n    test_file = data_file('adult_weight', 'test_weight')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_weight', 'train_weight'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_leaf_estimation_method",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_leaf_estimation_method(boosting_type, leaf_estimation):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_one_hot_max_size",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_one_hot_max_size(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_l2_reg_size",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_l2_reg_size(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_has_time",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_has_time(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult', 'train.cd')\n    test_file = data_file('adult', 'test_small')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_logloss_with_not_binarized_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_logloss_with_not_binarized_target(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_not_binarized', 'train.cd')\n    test_file = data_file('adult_not_binarized', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_not_binarized', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fold_len_mult",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fold_len_mult():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_not_binarized', 'train.cd')\n    test_file = data_file('adult_not_binarized', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_not_binarized', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_random_strength",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_random_strength():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_not_binarized', 'train.cd')\n    test_file = data_file('adult_not_binarized', 'test_small')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',\n        '-f': data_file('adult_not_binarized', 'train_small'),\n        '-t': test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_all_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_all_targets(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult', 'train_small'),\n        '-t', test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_cv",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_cv(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_cv_for_query",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_cv_for_query(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_cv_for_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_cv_for_pairs(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'PairLogit',\n        '-f', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_custom_priors",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_custom_priors(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ctr_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ctr_type(ctr_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_train_dir",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_train_dir():\n    output_model_path = 'model.bin'\n    train_dir_path = 'trainDir'\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_train_on_binarized_equal_train_on_float",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_train_on_binarized_equal_train_on_float(boosting_type, qwise_loss):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_model_path_binarized = yatest.common.test_output_path('model_binarized.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    borders_file = yatest.common.test_output_path('borders.tsv')\n    borders_file_output = borders_file + '.out'\n    predictions_path_learn = yatest.common.test_output_path('predictions_learn.tsv')\n    predictions_path_learn_binarized = yatest.common.test_output_path('predictions_learn_binarized.tsv')\n    predictions_path_test = yatest.common.test_output_path('predictions_test.tsv')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fstr(fstr_type, boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    fit_params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_quantized_pool(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    quantized_train_file = 'quantized://' + data_file('quantized_adult', 'train.qbin')\n    quantized_test_file = 'quantized://' + data_file('quantized_adult', 'test.qbin')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', quantized_train_file,\n        '-t', quantized_test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "execute_fit_for_test_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def execute_fit_for_test_quantized_pool(loss_function, pool_path, test_path, cd_path, eval_path,\n                                        border_count=128, other_options=()):\n    model_path = yatest.common.test_output_path('model.bin')\n    params = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', pool_path,\n        '-t', test_path,\n        '--cd', cd_path,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_with_large_grid",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_quantized_pool_with_large_grid():\n    test_path = data_file('querywise', 'test')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='PairLogitPairwise',\n        pool_path=data_file('querywise', 'train'),\n        test_path=test_path,\n        cd_path=data_file('querywise', 'train.cd.query_id'),\n        eval_path=tsv_eval_path,\n        border_count=1024",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_allow_writing_files_and_used_ram_limit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_allow_writing_files_and_used_ram_limit(boosting_type, used_ram_limit):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('airlines_5K', 'cd')\n    params = (\n        '--use-best-model', 'false',\n        '--allow-writing-files', 'false',\n        '--used-ram-limit', used_ram_limit,\n        '--loss-function', 'Logloss',\n        '--max-ctr-complexity', '8',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_pairs_generation():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    predictions_path_learn = yatest.common.test_output_path('predictions_learn.tsv')\n    predictions_path_test = yatest.common.test_output_path('predictions_test.tsv')\n    cd_file = data_file('querywise', 'train.cd')\n    learn_file = data_file('querywise', 'train')\n    test_file = data_file('querywise', 'test')\n    params = [",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_pairlogit_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_pairlogit_no_target(compressed_data, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_test_error_path = yatest.common.test_output_path('test_error.tsv')\n    params = [\n        '--loss-function', 'PairLogit',\n        '-f', os.path.join(compressed_data.name, 'mslr_web1k', 'train'),\n        '-t', os.path.join(compressed_data.name, 'mslr_web1k', 'test'),\n        '--column-description', os.path.join(compressed_data.name, 'mslr_web1k', 'cd.no_target'),\n        '--learn-pairs', os.path.join(compressed_data.name, 'mslr_web1k', 'train.pairs'),\n        '--test-pairs', os.path.join(compressed_data.name, 'mslr_web1k', 'test.pairs'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_learn_without_header_eval_with_header",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_learn_without_header_eval_with_header():\n    train_path = yatest.common.test_output_path('airlines_without_header')\n    with open(data_file('airlines_5K', 'train'), 'r') as with_header_file:\n        with open(train_path, 'w') as without_header_file:\n            without_header_file.writelines(with_header_file.readlines()[1:])\n    model_path = yatest.common.test_output_path('model.bin')\n    fit_params = [\n        '--loss-function', 'Logloss',\n        '-f', train_path,\n        '--cd', data_file('airlines_5K', 'cd'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_group_weights_file",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_group_weights_file():\n    first_eval_path = yatest.common.test_output_path('first.eval')\n    second_eval_path = yatest.common.test_output_path('second.eval')\n    first_model_path = yatest.common.test_output_path('first_model.bin')\n    second_model_path = yatest.common.test_output_path('second_model.bin')\n    def run_catboost(eval_path, model_path, cd_file, is_additional_query_weights):\n        cd_file_path = data_file('querywise', cd_file)\n        fit_params = [\n            '--use-best-model', 'false',\n            '--loss-function', 'QueryRMSE',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_group_weights_file_quantized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_group_weights_file_quantized():\n    first_eval_path = yatest.common.test_output_path('first.eval')\n    second_eval_path = yatest.common.test_output_path('second.eval')\n    first_model_path = yatest.common.test_output_path('first_model.bin')\n    second_model_path = yatest.common.test_output_path('second_model.bin')\n    def run_catboost(eval_path, model_path, train, is_additional_query_weights):\n        fit_params = [\n            '--use-best-model', 'false',\n            '--loss-function', 'QueryRMSE',\n            '-f', 'quantized://' + data_file('querywise', train),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def eval_metric(model_path, metrics, data_path, cd_path, output_log, eval_period='1'):\n    cmd = [\n        CATBOOST_PATH,\n        'eval-metrics',\n        '--metrics', metrics,\n        '-m', model_path,\n        '--input-path', data_path,\n        '--cd', cd_path,\n        '--output-path', output_log,\n        '--eval-period', eval_period",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_class_weight_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_class_weight_multiclass(loss_function):\n    model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')\n    cd_path = data_file('adult', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multi_leaf_estimation_method",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multi_leaf_estimation_method(leaf_estimation_method):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_test_error_path = yatest.common.test_output_path('eval_test_error.tsv')\n    train_path = data_file('cloudness_small', 'train_small')\n    test_path = data_file('cloudness_small', 'test_small')\n    cd_path = data_file('cloudness_small', 'train.cd')\n    fit_params = {\n        '--loss-function': 'MultiClass',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_rmse_with_uncertainty",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_rmse_with_uncertainty():\n    train_path = data_file('higgs', 'train_small')\n    test_path = data_file('higgs', 'test_small')\n    cd_path = data_file('higgs', 'train.cd')\n    fit_params = (\n        '--loss-function', 'RMSEWithUncertainty',\n        '--learning-rate', '0.03',\n        '-f', train_path,\n        '-t', test_path,\n        '--column-description', cd_path,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multilogloss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multilogloss(loss_function):\n    fit_params = (\n        '--loss-function', loss_function,\n        '--learning-rate', '0.03',\n        '-f', data_file('scene', 'train'),\n        '-t', data_file('scene', 'test'),\n        '--column-description', data_file('scene', 'train.cd'),\n        '--boosting-type', 'Plain',\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multilogloss_with_bow",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multilogloss_with_bow(loss_function):\n    datatset = 'rotten_tomatoes_small_with_embeddings'\n    text_processing = {\"feature_processing\": {\"default\": [{\"feature_calcers\": [\"BoW\"]}]}}\n    fit_params = (\n        '--loss-function', loss_function,\n        '--learning-rate', '0.03',\n        '-f', data_file(datatset, 'train_two_labels'),\n        '-t', data_file(datatset, 'train_two_labels'),\n        '--column-description', data_file(datatset, 'cd_binclass_only_text_two_labels'),\n        '--text-processing', json.dumps(text_processing),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multirmse",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multirmse():\n    fit_params = (\n        '--loss-function', 'MultiRMSE',\n        '--learning-rate', '0.03',\n        '-f', data_file('multiregression', 'train'),\n        '-t', data_file('multiregression', 'test'),\n        '--column-description', data_file('multiregression', 'train.cd'),\n        '--boosting-type', 'Plain',\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multirmse_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multirmse_with_cat_features():\n    fit_params = (\n        '--loss-function', 'MultiRMSE',\n        '--learning-rate', '0.03',\n        '-f', data_file('multiregression', 'train'),\n        '-t', data_file('multiregression', 'test'),\n        '--column-description', data_file('multiregression', 'train_two_targets_with_cat_features.cd'),\n        '--boosting-type', 'Plain',\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multiclass_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multiclass_baseline(loss_function):\n    labels = [0, 1, 2, 3]\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Baseline'], [2, 'Baseline'], [3, 'Baseline'], [4, 'Baseline']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 1000, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 1000, labels, prng=prng), fmt='%s', delimiter='\\t')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multiclass_baseline_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multiclass_baseline_lost_class(loss_function):\n    num_objects = 1000\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Baseline'], [2, 'Baseline']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(num_objects, 10, labels=[1, 2], prng=prng), fmt='%.5f', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(num_objects, 10, labels=[0, 1, 2, 3], prng=prng), fmt='%.5f', delimiter='\\t')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ctr_buckets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ctr_buckets():\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')\n    cd_path = data_file('adult', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_multi_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_multi_targets(loss_function):\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('cloudness_small', 'train_small')\n    test_path = data_file('cloudness_small', 'test_small')\n    cd_path = data_file('cloudness_small', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_custom_loss_for_multiclassification",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_custom_loss_for_multiclassification():\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('cloudness_small', 'train_small')\n    test_path = data_file('cloudness_small', 'test_small')\n    cd_path = data_file('cloudness_small', 'train.cd')\n    custom_metric = [\n        'Accuracy',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_custom_loss_for_classification",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_custom_loss_for_classification(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')\n    cd_path = data_file('adult', 'train.cd')\n    custom_metric = [\n        'AUC',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_class_names_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_class_names_multiclass(loss_function):\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('precipitation_small', 'train_small')\n    test_path = data_file('precipitation_small', 'test_small')\n    cd_path = data_file('precipitation_small', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_lost_class(loss_function):\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('cloudness_lost_class', 'train_small')\n    test_path = data_file('cloudness_lost_class', 'test_small')\n    cd_path = data_file('cloudness_lost_class', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_class_weight_with_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_class_weight_with_lost_class():\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')\n    learn_path = data_file('cloudness_lost_class', 'train_small')\n    test_path = data_file('cloudness_lost_class', 'test_small')\n    cd_path = data_file('cloudness_lost_class', 'train.cd')\n    fit_params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_eval_metrics_multiclass(metric, loss_function, dataset, metric_period):\n    if loss_function == 'MultiClass' and metric == 'MultiClassOneVsAll' or loss_function == 'MultiClassOneVsAll' and metric == 'MultiClass':\n        return\n    learn_path = data_file(dataset, 'train_small')\n    test_path = data_file(dataset, 'test_small')\n    cd_path = data_file(dataset, 'train.cd')\n    model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_error_path = yatest.common.test_output_path('eval_error.tsv')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_eval_metrics_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fit_multiclass_with_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fit_multiclass_with_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    learn_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(learn_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_extract_multiclass_labels_from_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_extract_multiclass_labels_from_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_save_and_apply_multiclass_labels_from_classes_count",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_save_and_apply_multiclass_labels_from_classes_count(loss_function, prediction_type):\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, [1, 2], prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, [0, 1, 2, 3], prng=prng), fmt='%s', delimiter='\\t')\n    eval_path = yatest.common.test_output_path('eval.txt')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_reg_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_reg_targets(loss_function, boosting_type, custom_metric):\n    test_error_path = yatest.common.test_output_path(\"test_error.tsv\")\n    params = [\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_eval_result_on_different_pool_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_eval_result_on_different_pool_type():\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_quantized_eval_path = yatest.common.test_output_path('test.eval.quantized')\n    def get_params(train, test, eval_path):\n        return (\n            '--use-best-model', 'false',\n            '--loss-function', 'Logloss',\n            '-f', train,\n            '-t', test,\n            '--cd', data_file('querywise', 'train.cd'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_convert_model_to_json_without_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_convert_model_to_json_without_cat_features():\n    output_model_path = yatest.common.test_output_path('model.json')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    fit_params = [\n        '--use-best-model', 'false',\n        '-f', data_file('higgs', 'train_small'),\n        '-t', data_file('higgs', 'test_small'),\n        '--column-description', data_file('higgs', 'train.cd'),\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_pairwise(loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_file = data_file('querywise', 'train')\n    test_file = data_file('querywise', 'test')\n    train_pairs = data_file('querywise', 'train.pairs')\n    test_pairs = data_file('querywise', 'test.pairs')\n    cd_file = data_file('querywise', 'train.cd')\n    params = [\n        '--loss-function', loss_function,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_groupwise_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_groupwise_with_cat_features(compressed_data, loss_function, eval_metric_name, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_test_error_path = yatest.common.test_output_path('test_error.tsv')\n    output_eval_error_path = yatest.common.test_output_path('eval_file.tsv')\n    train_file = os.path.join(compressed_data.name, 'mslr_web1k', 'train')\n    test_file = os.path.join(compressed_data.name, 'mslr_web1k', 'test')\n    cd_file = os.path.join(compressed_data.name, 'mslr_web1k', 'cd.with_cat_features')\n    params = [\n        '--loss-function', loss_function,\n        '-f', train_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ctr_target_quantization",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ctr_target_quantization(border_count, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_file = data_file('adult_crossentropy', 'train_proba')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'RMSE',\n        '-f': train_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_apply_with_grow_policy",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_apply_with_grow_policy(grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    train_file = data_file('adult', 'train_small')\n    test_file = data_file('adult', 'test_small')\n    cd_file = data_file('adult', 'train.cd')\n    params = {\n        '--use-best-model': 'false',\n        '--loss-function': 'Logloss',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_yetirank_default_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_yetirank_default_metric(loss_function):\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    train_file = data_file('black_friday', 'train')\n    test_file = data_file('black_friday', 'test')\n    cd_file = data_file('black_friday', 'cd')\n    params = [\n        '--loss-function', loss_function,\n        '--has-header',\n        '-f', train_file,\n        '-t', test_file,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "is_valid_gpu_params",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def is_valid_gpu_params(boosting_type, grow_policy, score_function, loss_func):\n    correlation_scores = ['Cosine', 'NewtonCosine']\n    second_order_scores = ['NewtonL2', 'NewtonCosine']\n    is_correct = True\n    # compatibility with ordered boosting\n    if (grow_policy in NONSYMMETRIC) or (score_function not in correlation_scores) or (loss_func in MULTICLASS_LOSSES):\n        is_correct = boosting_type in ['Plain', 'Default']\n    if loss_func in MULTICLASS_LOSSES and score_function in second_order_scores:\n        is_correct = False\n    return is_correct",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_grow_policies",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_grow_policies(boosting_type, grow_policy, score_function, loss_func):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    if loss_func in ['RMSE', 'Logloss']:\n        learn = data_file('adult', 'train_small')\n        test = data_file('adult', 'test_small')\n        cd = data_file('adult', 'train.cd')\n    elif loss_func == 'MultiClass':",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_output_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_output_options():\n    output_options_path = 'training_options.json'\n    train_dir = 'catboost_info'\n    params = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "model_based_eval_catboost_gpu",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def model_based_eval_catboost_gpu(params):\n    cmd = [CATBOOST_PATH, 'model-based-eval', '--task-type', 'GPU']\n    append_params_to_cmdline(cmd, params)\n    yatest.common.execute(cmd)\n@pytest.mark.parametrize(\n    'dataset',\n    [\n        {'base': 'querywise', 'cd': 'train.cd'},\n        {'base': 'adult', 'train': 'train_small', 'test': 'test_small', 'cd': 'train.cd'},\n        {'base': 'adult', 'train': 'train_small', 'test': 'test_small', 'cd': 'train_with_id.cd'}",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_model_based_eval",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_model_based_eval(dataset):\n    test_err_log = 'test_error.log'\n    def get_table_path(table):\n        return data_file(dataset['base'], dataset.get(table, table))\n    def get_params():\n        return (\n            '--data-partition', 'DocParallel',\n            '--permutations', '1',\n            '--loss-function', 'RMSE',\n            '-f', get_table_path('train'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fit_binclass_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fit_binclass_with_text_features(boosting_type, separator_type, feature_estimators):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]\n    text_processing = {'feature_processing': {'default': feature_processing}, 'dictionaries': dictionaries, 'tokenizers': tokenizers}",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fit_multiclass_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fit_multiclass_with_text_features(separator_type, feature_estimators, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]\n    text_processing = {'feature_processing': {'default': feature_processing}, 'dictionaries': dictionaries, 'tokenizers': tokenizers}",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fit_regression_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fit_regression_with_text_features(separator_type, feature_estimators):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_shrink_model_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_shrink_model_with_text_features(grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    loss_function = 'MultiClass'\n    feature_estimators = 'BoW,NaiveBayes,BM25'\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_text_processing_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_text_processing_options(dictionaries, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    dictionaries = ','.join([key + ':' + value for key, value in dictionaries.items()])\n    feature_estimators = 'BM25,BoW,NaiveBayes'\n    pool_name = 'rotten_tomatoes'\n    test_file = data_file(pool_name, 'test')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_fit_with_per_feature_text_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_fit_with_per_feature_text_options(problem_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    text_processing = {\n        'tokenizers': [\n            {'tokenizer_id': 'Space', 'delimiter': ' '},\n            {'tokenizer_id': 'Comma', 'delimiter': ','},",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_eval_feature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_eval_feature(task_type):\n    output_eval_path = yatest.common.test_output_path('feature.eval')\n    test_err_log = 'test_error.log'\n    cmd = (\n        CATBOOST_PATH,\n        'eval-feature',\n        '--task-type', task_type,\n        '--loss-function', 'Logloss',\n        '-f', data_file('higgs', 'train_small'),\n        '--cd', data_file('higgs', 'train.cd'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_metric_description",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_metric_description(dataset_has_weights):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    if dataset_has_weights:\n        train_pool_filename = data_file('adult_weight', 'train_weight')\n        test_pool_filename = data_file('adult_weight', 'test_weight')\n        pool_cd_filename = data_file('adult_weight', 'train.cd')\n    else:\n        train_pool_filename = data_file('adult', 'train_small')\n        test_pool_filename = data_file('adult', 'test_small')",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_ranking_auc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_ranking_auc():\n    learn_error = yatest.common.test_output_path('learn_error.tsv')\n    test_error = yatest.common.test_output_path('test_error.tsv')\n    train = data_file('black_friday', 'train')  # labels are outside [0, 1]\n    test = data_file('black_friday', 'test')\n    cd = data_file('black_friday', 'cd')\n    ranking_auc = 'AUC:hints=skip_train~false;type=Ranking'\n    classic_auc = 'AUC:hints=skip_train~false;type=Classic'\n    params = (\n        '--loss-function', 'PairLogit',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_combination",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_combination(boosting_type, loss_function):\n    learn_file = data_file('querywise', 'train')\n    test_file = data_file('querywise', 'test')\n    cd_file = data_file('querywise', 'train.cd')\n    params = {\n        '-f': learn_file,\n        '-t': test_file,\n        '--cd': cd_file,\n        '--boosting-type': boosting_type,\n        '--bootstrap-type': 'Bernoulli',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "test_mvs_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "def test_mvs_bootstrap(boosting_type, loss_function):\n    pool = 'airlines_5K'\n    learn_file = data_file(pool, 'train')\n    test_file = data_file(pool, 'test')\n    cd_file = data_file(pool, 'cd')\n    def run_catboost(eval_path, mvs_sample_rate):\n        cmd = [\n            CATBOOST_PATH,\n            'fit',\n            '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "append_params_to_cmdline",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "append_params_to_cmdline = lib.append_params_to_cmdline\napply_catboost = lib.apply_catboost\ncompare_evals_with_precision = lib.compare_evals_with_precision\ncompare_fit_evals_with_precision = lib.compare_fit_evals_with_precision\ncompare_metrics_with_diff = lib.compare_metrics_with_diff\ndata_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "apply_catboost",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "apply_catboost = lib.apply_catboost\ncompare_evals_with_precision = lib.compare_evals_with_precision\ncompare_fit_evals_with_precision = lib.compare_fit_evals_with_precision\ncompare_metrics_with_diff = lib.compare_metrics_with_diff\ndata_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "compare_evals_with_precision",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "compare_evals_with_precision = lib.compare_evals_with_precision\ncompare_fit_evals_with_precision = lib.compare_fit_evals_with_precision\ncompare_metrics_with_diff = lib.compare_metrics_with_diff\ndata_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "compare_fit_evals_with_precision",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "compare_fit_evals_with_precision = lib.compare_fit_evals_with_precision\ncompare_metrics_with_diff = lib.compare_metrics_with_diff\ndata_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "compare_metrics_with_diff",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "compare_metrics_with_diff = lib.compare_metrics_with_diff\ndata_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "data_file = lib.data_file\nexecute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "execute_catboost_fit",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "execute_catboost_fit = lib.execute_catboost_fit\nformat_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "format_crossvalidation",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "format_crossvalidation = lib.format_crossvalidation\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_dsv_diff_tool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "get_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nlocal_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "local_canonical_file = lib.local_canonical_file\nCATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CATBOOST_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "CATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "BOOSTING_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "BOOSTING_TYPE = ['Ordered', 'Plain']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "MULTICLASS_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "MULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]\nSEPARATOR_TYPES = [",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "NONSYMMETRIC",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "NONSYMMETRIC = ['Lossguide', 'Depthwise']\nGROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]\nSEPARATOR_TYPES = [\n    'ByDelimiter',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "GROW_POLICIES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "GROW_POLICIES = ['SymmetricTree'] + NONSYMMETRIC\nLEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "LEAF_ESTIMATION_METHODS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "LEAF_ESTIMATION_METHODS = ['Newton', 'Gradient']\nSCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "SCORE_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "SCORE_FUNCTIONS = [\n    'L2', 'Cosine',\n    'NewtonL2', 'NewtonCosine',\n    'SolarL2', 'LOOL2'\n]\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "SEPARATOR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "SEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',\n    'BoW,NaiveBayes',\n    'BoW,NaiveBayes,BM25'",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CLASSIFICATION_TEXT_FEATURE_ESTIMATORS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "CLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',\n    'BoW,NaiveBayes',\n    'BoW,NaiveBayes,BM25'\n]\nREGRESSION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW'\n]",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "REGRESSION_TEXT_FEATURE_ESTIMATORS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "REGRESSION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW'\n]\ndef generate_concatenated_random_labeled_dataset(nrows, nvals, labels, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=seed)\n    label = prng.choice(labels, [nrows, 1])\n    feature = prng.random_sample([nrows, nvals])\n    return np.concatenate([label, feature], axis=1)\ndef diff_tool(threshold=2e-7):",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "pytestmark = skipif_no_cuda()\ndef fit_catboost_gpu(params, devices='0'):\n    execute_catboost_fit(\n        task_type='GPU',\n        params=params,\n        devices=devices,\n    )\n# currently only works on CPU\ndef fstr_catboost_cpu(params):\n    cmd = list()",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "NAN_MODE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "NAN_MODE = ['Min', 'Max']\n@pytest.mark.parametrize('nan_mode', NAN_MODE)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_nan_mode(nan_mode, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_file = data_file('adult_nan', 'test_small')\n    cd_file = data_file('adult_nan', 'train.cd')\n    params = {\n        '--use-best-model': 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "LOSS_FUNCTIONS = ['RMSE', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile', 'Poisson', 'MAPE']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_crossentropy(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = {\n        '--loss-function': 'CrossEntropy',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "LEAF_ESTIMATION_METHOD",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "LEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_crossentropy(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = {\n        '--loss-function': 'CrossEntropy',\n        '-f': data_file('adult_crossentropy', 'train_proba'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CTR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "CTR_TYPES = ['Borders', 'Buckets', 'FloatTargetMeanValue',\n             'Borders,FloatTargetMeanValue', 'Buckets,Borders']\n@pytest.mark.parametrize('ctr_type', CTR_TYPES)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_ctr_type(ctr_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cd_file = data_file('adult_crossentropy', 'train.cd')\n    test_file = data_file('adult_crossentropy', 'test_proba')\n    params = (",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "FSTR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "FSTR_TYPES = ['PredictionValuesChange', 'InternalFeatureImportance', 'InternalInteraction', 'Interaction', 'ShapValues']\n@pytest.mark.parametrize('fstr_type', FSTR_TYPES)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_fstr(fstr_type, boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    fit_params = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS_NO_MAPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "LOSS_FUNCTIONS_NO_MAPE = ['RMSE', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile', 'Poisson']\n@pytest.mark.parametrize('loss_function', LOSS_FUNCTIONS_NO_MAPE)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_quantized_pool(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    quantized_train_file = 'quantized://' + data_file('quantized_adult', 'train.qbin')\n    quantized_test_file = 'quantized://' + data_file('quantized_adult', 'test.qbin')\n    params = (\n        '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "NO_RANDOM_PARAMS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "NO_RANDOM_PARAMS = (\n    '--random-strength', '0',\n    '--bootstrap-type', 'No',\n    '--has-time'\n)\nMETRIC_CHECKING_MULTICLASS_NO_WEIGHTS = 'Accuracy'\nMETRIC_CHECKING_MULTICLASS_WITH_WEIGHTS = 'Accuracy:use_weights=false'\nCAT_COMPARE_PARAMS = {\n    '--counter-calc-method': 'SkipTest',\n    '--simple-ctr': 'Buckets',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "METRIC_CHECKING_MULTICLASS_NO_WEIGHTS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "METRIC_CHECKING_MULTICLASS_NO_WEIGHTS = 'Accuracy'\nMETRIC_CHECKING_MULTICLASS_WITH_WEIGHTS = 'Accuracy:use_weights=false'\nCAT_COMPARE_PARAMS = {\n    '--counter-calc-method': 'SkipTest',\n    '--simple-ctr': 'Buckets',\n    '--max-ctr-complexity': 1\n}\ndef eval_metric(model_path, metrics, data_path, cd_path, output_log, eval_period='1'):\n    cmd = [\n        CATBOOST_PATH,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "METRIC_CHECKING_MULTICLASS_WITH_WEIGHTS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "METRIC_CHECKING_MULTICLASS_WITH_WEIGHTS = 'Accuracy:use_weights=false'\nCAT_COMPARE_PARAMS = {\n    '--counter-calc-method': 'SkipTest',\n    '--simple-ctr': 'Buckets',\n    '--max-ctr-complexity': 1\n}\ndef eval_metric(model_path, metrics, data_path, cd_path, output_log, eval_period='1'):\n    cmd = [\n        CATBOOST_PATH,\n        'eval-metrics',",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CAT_COMPARE_PARAMS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "CAT_COMPARE_PARAMS = {\n    '--counter-calc-method': 'SkipTest',\n    '--simple-ctr': 'Buckets',\n    '--max-ctr-complexity': 1\n}\ndef eval_metric(model_path, metrics, data_path, cd_path, output_log, eval_period='1'):\n    cmd = [\n        CATBOOST_PATH,\n        'eval-metrics',\n        '--metrics', metrics,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "REG_LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "REG_LOSS_FUNCTIONS = ['RMSE', 'MAE', 'Lq:q=1', 'Lq:q=1.5', 'Lq:q=3']\nCUSTOM_METRIC = [\"MAE,Lq:q=2.5,NumErrors:greater_than=0.1,NumErrors:greater_than=0.01,NumErrors:greater_than=0.5\"]\n@pytest.mark.parametrize('loss_function', REG_LOSS_FUNCTIONS)\n@pytest.mark.parametrize('custom_metric', CUSTOM_METRIC)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_reg_targets(loss_function, boosting_type, custom_metric):\n    test_error_path = yatest.common.test_output_path(\"test_error.tsv\")\n    params = [\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CUSTOM_METRIC",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "CUSTOM_METRIC = [\"MAE,Lq:q=2.5,NumErrors:greater_than=0.1,NumErrors:greater_than=0.01,NumErrors:greater_than=0.5\"]\n@pytest.mark.parametrize('loss_function', REG_LOSS_FUNCTIONS)\n@pytest.mark.parametrize('custom_metric', CUSTOM_METRIC)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_reg_targets(loss_function, boosting_type, custom_metric):\n    test_error_path = yatest.common.test_output_path(\"test_error.tsv\")\n    params = [\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult_crossentropy', 'train_proba'),",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "DICTIONARIES_OPTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "description": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "peekOfCode": "DICTIONARIES_OPTIONS = [\n    {\n        \"Simple\": \"token_level_type=Word:occurrence_lower_bound=50\"\n    },\n    {\n        \"UniGramOccur5\": \"occurrence_lower_bound=5:token_level_type=Letter\",\n        \"BiGramOccur2\": \"occurrence_lower_bound=2:gram_order=2:token_level_type=Letter\",\n        \"WordDictOccur1\": \"occurrence_lower_bound=1:token_level_type=Word\",\n        \"WordDictOccur2\": \"occurrence_lower_bound=2:token_level_type=Word\",\n        \"WordDictOccur3\": \"occurrence_lower_bound=3:token_level_type=Word\"",
        "detail": "catboost.catboost.pytest.cuda_tests.test_gpu",
        "documentation": {}
    },
    {
        "label": "CanonicalProcessor",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "description": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "peekOfCode": "class CanonicalProcessor(object):\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):  # noqa\n        def get_wrapper(obj):\n            def wrapper(*args, **kwargs):\n                obj(*args, **kwargs)\n            return wrapper\n        item.obj = get_wrapper(item.obj)\n        yield\nclass WorkdirProcessor(object):",
        "detail": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "WorkdirProcessor",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "description": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "peekOfCode": "class WorkdirProcessor(object):\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):  # noqa\n        def get_wrapper(obj):\n            def wrapper(*args, **kwargs):\n                test_output_path = yatest.common.test_output_path()\n                # TODO: have to create in standard tmp dir because of max path length issues on Windows\n                work_dir = tempfile.mkdtemp(prefix='work_dir_')\n                prev_cwd = None\n                try:",
        "detail": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "description": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "peekOfCode": "def pytest_configure(config):\n    global pytest_config\n    pytest_config = config\n    config.ya = yatest_lib.ya.Ya(\n        source_root=os.environ['CMAKE_SOURCE_DIR'],\n        build_root=os.environ['CMAKE_BINARY_DIR'],\n        output_dir=os.environ['TEST_OUTPUT_DIR']\n    )\n    config.sanitizer_extra_checks = False\n    yatest.common.runtime._set_ya_config(config=config)",
        "detail": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "pytest_runtest_setup",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "description": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "peekOfCode": "def pytest_runtest_setup(item):\n    pytest_config.current_item_nodeid = item.nodeid\n    class_name, test_name = tools.split_node_id(item.nodeid)\n    test_log_path = tools.get_test_log_file_path(pytest_config.ya.output_dir, class_name, test_name)\n    pytest_config.current_test_log_path = test_log_path",
        "detail": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "pytest_config",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "description": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "peekOfCode": "pytest_config = None\nclass CanonicalProcessor(object):\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):  # noqa\n        def get_wrapper(obj):\n            def wrapper(*args, **kwargs):\n                obj(*args, **kwargs)\n            return wrapper\n        item.obj = get_wrapper(item.obj)\n        yield",
        "detail": "catboost.catboost.pytest.lib.common.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "SubtestInfo",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "class SubtestInfo(object):\n    skipped_prefix = '[SKIPPED] '\n    @classmethod\n    def from_str(cls, s):\n        if s.startswith(SubtestInfo.skipped_prefix):\n            s = s[len(SubtestInfo.skipped_prefix) :]\n            skipped = True\n        else:\n            skipped = False\n        return SubtestInfo(*s.rsplit(TEST_SUBTEST_SEPARATOR, 1), skipped=skipped)",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "Status",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "class Status(object):\n    GOOD, XFAIL, FAIL, XPASS, MISSING, CRASHED, TIMEOUT = range(7)\n    SKIPPED = -100\n    NOT_LAUNCHED = -200\n    CANON_DIFF = -300\n    FLAKY = -1\n    BY_NAME = {\n        'good': GOOD,\n        'fail': FAIL,\n        'xfail': XFAIL,",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "class Test(object):\n    def __init__(self, name, path, status=None, comment=None, subtests=None):\n        self.name = name\n        self.path = path\n        self.status = status\n        self.comment = comment\n        self.subtests = subtests or []\n    def __eq__(self, other):\n        if not isinstance(other, Test):\n            return False",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "YaCtx",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "class YaCtx(object):\n    pass\nya_ctx = YaCtx()\nTRACE_FILE_NAME = \"ytest.report.trace\"\ndef lazy(func):\n    memory = {}\n    @functools.wraps(func)\n    def wrapper(*args):\n        # Disabling caching in test mode\n        if True:",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "MissingTestModule",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "class MissingTestModule(Exception):\n    pass\n# If CONFTEST_LOAD_POLICY==LOCAL the path parameters is a true test file path. Something like\n#   /-B/taxi/uservices/services/alt/gen/tests/build/services/alt/validation/test_generated_files.py\n# If CONFTEST_LOAD_POLICY is not LOCAL the path parameter is a module name with '.py' extension added. Example:\n#  validation.test_generated_files.py\n# To make test names independent of the CONFTEST_LOAD_POLICY value replace path by module name if possible.\n@lazy\ndef _unify_path(path):\n    py_ext = \".py\"",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "lazy",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def lazy(func):\n    memory = {}\n    @functools.wraps(func)\n    def wrapper(*args):\n        # Disabling caching in test mode\n        if True:\n            return func(*args)\n        try:\n            return memory[args]\n        except KeyError:",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "get_max_filename_length",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def get_max_filename_length(dirname):\n    \"\"\"\n    Return maximum filename length for the filesystem\n    :return:\n    \"\"\"\n    if sys.platform.startswith(\"linux\"):\n        # Linux user's may work on mounted ecryptfs filesystem\n        # which has filename length limitations\n        for entry in _get_mtab():\n            mounted_dir, filesystem = entry[1], entry[2]",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "get_unique_file_path",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def get_unique_file_path(dir_path, filename, cache=collections.defaultdict(set)):\n    \"\"\"\n    Get unique filename in dir with proper filename length, using given filename/dir.\n    File/dir won't be created (thread nonsafe)\n    :param dir_path: path to dir\n    :param filename: original filename\n    :return: unique filename\n    \"\"\"\n    max_suffix = 10000\n    # + 1 symbol for dot before suffix",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "escape_for_fnmatch",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def escape_for_fnmatch(s):\n    return s.replace(\"[\", \"&#91;\").replace(\"]\", \"&#93;\")\ndef get_python_cmd(opts=None, use_huge=True, suite=None):\n    if opts and getattr(opts, 'flags', {}).get(\"USE_ARCADIA_PYTHON\") == \"no\":\n        return [\"python\"]\n    if suite and not suite._use_arcadia_python:\n        return [\"python\"]\n    if use_huge:\n        return [\"$(PYTHON)/python\"]\n    ymake_path = opts.ymake_bin if opts and getattr(opts, 'ymake_bin', None) else \"$(YMAKE)/ymake\"",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "get_python_cmd",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def get_python_cmd(opts=None, use_huge=True, suite=None):\n    if opts and getattr(opts, 'flags', {}).get(\"USE_ARCADIA_PYTHON\") == \"no\":\n        return [\"python\"]\n    if suite and not suite._use_arcadia_python:\n        return [\"python\"]\n    if use_huge:\n        return [\"$(PYTHON)/python\"]\n    ymake_path = opts.ymake_bin if opts and getattr(opts, 'ymake_bin', None) else \"$(YMAKE)/ymake\"\n    return [ymake_path, \"--python\"]\ndef normalize_name(name):",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "normalize_name",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def normalize_name(name):\n    replacements = [\n        (\"\\\\\", \"\\\\\\\\\"),\n        (\"\\n\", \"\\\\n\"),\n        (\"\\t\", \"\\\\t\"),\n        (\"\\r\", \"\\\\r\"),\n    ]\n    for from_, to in replacements:\n        name = name.replace(from_, to)\n    return name",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "normalize_filename",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def normalize_filename(filename):\n    \"\"\"\n    Replace invalid for file names characters with string equivalents\n    :param some_string: string to be converted to a valid file name\n    :return: valid file name\n    \"\"\"\n    not_allowed_pattern = r\"[\\[\\]\\/:*?\\\"\\'<>|+\\0\\\\\\s\\x0b\\x0c]\"\n    filename = re.sub(not_allowed_pattern, \".\", filename)\n    return re.sub(r\"\\.{2,}\", \".\", filename)\ndef get_test_log_file_path(output_dir, class_name, test_name, extension=\"log\"):",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "get_test_log_file_path",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def get_test_log_file_path(output_dir, class_name, test_name, extension=\"log\"):\n    \"\"\"\n    get test log file path, platform dependant\n    :param output_dir: dir where log file should be placed\n    :param class_name: test class name\n    :param test_name: test name\n    :return: test log file name\n    \"\"\"\n    if os.name == \"nt\":\n        # don't add class name to the log's filename",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "split_node_id",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def split_node_id(nodeid, test_suffix=None):\n    path, possible_open_bracket, params = nodeid.partition('[')\n    separator = \"::\"\n    test_name = None\n    if separator in path:\n        path, test_name = path.split(separator, 1)\n    path = _unify_path(path)\n    class_name = os.path.basename(path)\n    if test_name is None:\n        test_name = class_name",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "colorize_pytest_error",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "def colorize_pytest_error(text):\n    error_prefix = \"E   \"\n    blocks = [text]\n    while True:\n        text = blocks.pop()\n        err_start = text.find(error_prefix, 1)\n        if err_start == -1:\n            return ''.join(blocks + [text])\n        for pos in range(err_start + 1, len(text) - 1):\n            if text[pos] == '\\n':",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "SEP",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "SEP = '/'\nTEST_MOD_PREFIX = '__tests__.'\nclass SubtestInfo(object):\n    skipped_prefix = '[SKIPPED] '\n    @classmethod\n    def from_str(cls, s):\n        if s.startswith(SubtestInfo.skipped_prefix):\n            s = s[len(SubtestInfo.skipped_prefix) :]\n            skipped = True\n        else:",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "TEST_MOD_PREFIX",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "TEST_MOD_PREFIX = '__tests__.'\nclass SubtestInfo(object):\n    skipped_prefix = '[SKIPPED] '\n    @classmethod\n    def from_str(cls, s):\n        if s.startswith(SubtestInfo.skipped_prefix):\n            s = s[len(SubtestInfo.skipped_prefix) :]\n            skipped = True\n        else:\n            skipped = False",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "TEST_SUBTEST_SEPARATOR",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "TEST_SUBTEST_SEPARATOR = '::'\n# TODO: extract color theme logic from ya\nCOLOR_THEME = {\n    'test_name': 'light-blue',\n    'test_project_path': 'dark-blue',\n    'test_dir_desc': 'dark-magenta',\n    'test_binary_path': 'light-gray',\n}\n# XXX: remove me\nclass YaCtx(object):",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "COLOR_THEME",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "COLOR_THEME = {\n    'test_name': 'light-blue',\n    'test_project_path': 'dark-blue',\n    'test_dir_desc': 'dark-magenta',\n    'test_binary_path': 'light-gray',\n}\n# XXX: remove me\nclass YaCtx(object):\n    pass\nya_ctx = YaCtx()",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "ya_ctx",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "ya_ctx = YaCtx()\nTRACE_FILE_NAME = \"ytest.report.trace\"\ndef lazy(func):\n    memory = {}\n    @functools.wraps(func)\n    def wrapper(*args):\n        # Disabling caching in test mode\n        if True:\n            return func(*args)\n        try:",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "TRACE_FILE_NAME",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common.tools",
        "description": "catboost.catboost.pytest.lib.common.tools",
        "peekOfCode": "TRACE_FILE_NAME = \"ytest.report.trace\"\ndef lazy(func):\n    memory = {}\n    @functools.wraps(func)\n    def wrapper(*args):\n        # Disabling caching in test mode\n        if True:\n            return func(*args)\n        try:\n            return memory[args]",
        "detail": "catboost.catboost.pytest.lib.common.tools",
        "documentation": {}
    },
    {
        "label": "DelayedTee",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "class DelayedTee(object):\n    def __init__(self, src_stream, dst_stream):\n        self.src_stream = src_stream\n        self.dst_stream = dst_stream\n    def __enter__(self):\n        self.src_stream.flush()\n        self._old_src_stream = os.dup(self.src_stream.fileno())\n        self._old_dst_stream_pos = self.dst_stream.tell()\n        os.dup2(self.dst_stream.fileno(), self.src_stream.fileno())\n    def __exit__(self, exc_type, exc_value, traceback):",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "remove_time_from_json",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def remove_time_from_json(filename):\n    with open(filename) as f:\n        log = json.load(f)\n    iterations = log['iterations']\n    for i, iter_info in enumerate(iterations):\n        for key in ['remaining_time', 'passed_time']:\n            if key in iter_info.keys():\n                del iter_info[key]\n    with open(filename, 'w') as f:\n        json.dump(log, f, sort_keys=True)",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "permute_dataset_columns",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def permute_dataset_columns(test_pool_path, cd_path, seed=123):\n    permuted_test_path = test_output_path('permuted_test')\n    permuted_cd_path = test_output_path('permuted_cd')\n    generator = random.Random(seed)\n    column_count = len(open(test_pool_path).readline().split('\\t'))\n    permutation = list(range(column_count))\n    generator.shuffle(permutation)\n    with open(cd_path) as original_cd, open(permuted_cd_path, 'w') as permuted_cd:\n        for line in original_cd:\n            line = line.strip()",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "generate_concatenated_random_labeled_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def generate_concatenated_random_labeled_dataset(nrows, nvals, labels, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=seed)\n    label = prng.choice(labels, [nrows, 1])\n    feature = prng.random_sample([nrows, nvals])\n    return np.concatenate([label, feature], axis=1)\ndef generate_patients_datasets(train_path, test_path):\n    samples = 237\n    for samples, path in zip([237, 154], [train_path, test_path]):\n        data = DataFrame()",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "generate_patients_datasets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def generate_patients_datasets(train_path, test_path):\n    samples = 237\n    for samples, path in zip([237, 154], [train_path, test_path]):\n        data = DataFrame()\n        data['age'] = np.random.randint(20, 71, size=samples)\n        data['gender'] = np.where(np.random.binomial(1, 0.7, samples) == 1, 'male', 'female')\n        data['diet'] = np.where(np.random.binomial(1, 0.1, samples) == 1, 'yes', 'no')\n        data['glucose'] = np.random.uniform(4, 12, size=samples)\n        data['platelets'] = np.random.randint(100, 500, size=samples)\n        data['cholesterol'] = np.random.uniform(4.5, 6.5, size=samples)",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "generate_random_labeled_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def generate_random_labeled_dataset(\n    n_samples,\n    n_features,\n    labels,\n    features_density=1.0,\n    features_dtype=np.float32,\n    features_range=(-1., 1.),\n    features_order='C',\n    seed=20191008\n):",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "generate_dataset_with_num_and_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def generate_dataset_with_num_and_cat_features(\n    n_samples,\n    n_num_features,\n    n_cat_features,\n    labels,\n    num_features_density=1.0,\n    num_features_dtype=np.float32,\n    num_features_range=(-1., 1.),\n    cat_features_uniq_value_count=5,\n    cat_features_dtype=np.int32,",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "generate_survival_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def generate_survival_dataset(seed=20201015):\n    np.random.seed(seed)\n    X = np.random.rand(200, 20)*10\n    mean_y = np.sin(X[:, 0])\n    y = np.random.randn(200, 10) * 0.3 + mean_y[:, None]\n    y_lower = np.min(y, axis=1)\n    y_upper = np.max(y, axis=1)\n    y_upper = np.where(y_upper >= 1.4, -1, y_upper+abs(np.min(y_lower)))\n    y_lower += abs(np.min(y_lower))\n    right_censored_ids = np.where(y_upper == -1)[0]",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "compare_metrics_with_diff",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def compare_metrics_with_diff(custom_metric, fit_eval, calc_eval, eps=1e-7):\n    with open(fit_eval, \"r\") as fit_eval_file, open(calc_eval, \"r\") as calc_eval_file:\n        csv_fit = csv.reader(fit_eval_file, dialect='excel-tab')\n        csv_calc = csv.reader(calc_eval_file, dialect='excel-tab')\n        head_fit = next(csv_fit)\n        head_calc = next(csv_calc)\n        if isinstance(custom_metric, str):\n            custom_metric = [custom_metric]\n        for metric_name in deepcopy(custom_metric):\n            if metric_name in BY_CLASS_METRICS:",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "compare_evals",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def compare_evals(fit_eval, calc_eval, skip_header=False):\n    with open(fit_eval, \"r\") as fit_eval_file, open(calc_eval, \"r\") as calc_eval_file:\n        csv_fit = csv.reader(fit_eval_file, dialect='excel-tab')\n        csv_calc = csv.reader(calc_eval_file, dialect='excel-tab')\n        if skip_header:\n            next(csv_fit)\n            next(csv_calc)\n        while True:\n            try:\n                line_fit = next(csv_fit)",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "compare_evals_with_precision",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def compare_evals_with_precision(fit_eval, calc_eval, rtol=1e-6, atol=1e-8, skip_last_column_in_fit=True):\n    df_fit = read_csv(fit_eval, sep='\\t')\n    if skip_last_column_in_fit:\n        df_fit = df_fit.iloc[:, :-1]\n    df_calc = read_csv(calc_eval, sep='\\t')\n    if np.any(df_fit.columns != df_calc.columns):\n        sys.stderr.write('column sets differ: {}, {}'.format(df_fit.columns, df_calc.columns))\n        return False\n    def print_diff(column, row_idx):\n        sys.stderr.write(",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "compare_fit_evals_with_precision",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def compare_fit_evals_with_precision(fit_eval_1, fit_eval_2, rtol=1e-6, atol=1e-8):\n    return compare_evals_with_precision(\n        fit_eval_1,\n        fit_eval_2,\n        rtol=rtol,\n        atol=atol,\n        skip_last_column_in_fit=False\n    )\ndef load_dataset_as_dataframe(data_file, columns_metadata, has_header=False):\n    \"\"\"",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "load_dataset_as_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def load_dataset_as_dataframe(data_file, columns_metadata, has_header=False):\n    \"\"\"\n        returns dict with 'features', 'target' keys\n    \"\"\"\n    if 'Label' not in columns_metadata['column_type_to_indices']:\n        raise Exception('no target in dataset')\n    df = read_csv(\n        data_file,\n        sep='\\t',\n        header=1 if has_header else None",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "load_pool_features_as_df",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def load_pool_features_as_df(pool_file, cd_file):\n    columns_metadata = read_cd(cd_file, data_file=pool_file, canonize_column_types=True)\n    data = load_dataset_as_dataframe(pool_file, columns_metadata)\n    return (data['features'], columns_metadata['cat_feature_indices'])\ndef append_params_to_cmdline(cmd, params):\n    if isinstance(params, dict):\n        for param in params.items():\n            key = \"{}\".format(param[0])\n            value = \"{}\".format(param[1])\n            cmd.append(key)",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "append_params_to_cmdline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def append_params_to_cmdline(cmd, params):\n    if isinstance(params, dict):\n        for param in params.items():\n            key = \"{}\".format(param[0])\n            value = \"{}\".format(param[1])\n            cmd.append(key)\n            cmd.append(value)\n    else:\n        for param in params:\n            cmd.append(param)",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "format_crossvalidation",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def format_crossvalidation(is_inverted, n, k):\n    cv_type = 'Inverted' if is_inverted else 'Classical'\n    return '{}:{};{}'.format(cv_type, n, k)\ndef is_canonical_test_run():\n    return os.environ.get('IS_CANONICAL_TEST_RUN', '1').lower() in ('yes', 'true', '1')\ndef get_limited_precision_dsv_diff_tool(diff_limit, have_header=False):\n    diff_tool = [\n        binary_path(\"catboost/tools/limited_precision_dsv_diff/limited_precision_dsv_diff\"),\n    ]\n    if diff_limit is not None:",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "is_canonical_test_run",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def is_canonical_test_run():\n    return os.environ.get('IS_CANONICAL_TEST_RUN', '1').lower() in ('yes', 'true', '1')\ndef get_limited_precision_dsv_diff_tool(diff_limit, have_header=False):\n    diff_tool = [\n        binary_path(\"catboost/tools/limited_precision_dsv_diff/limited_precision_dsv_diff\"),\n    ]\n    if diff_limit is not None:\n        diff_tool += ['--diff-limit', str(diff_limit)]\n    if have_header:\n        diff_tool += ['--have-header']",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_dsv_diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def get_limited_precision_dsv_diff_tool(diff_limit, have_header=False):\n    diff_tool = [\n        binary_path(\"catboost/tools/limited_precision_dsv_diff/limited_precision_dsv_diff\"),\n    ]\n    if diff_limit is not None:\n        diff_tool += ['--diff-limit', str(diff_limit)]\n    if have_header:\n        diff_tool += ['--have-header']\n    return diff_tool\ndef get_limited_precision_json_diff_tool(diff_limit):",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_json_diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def get_limited_precision_json_diff_tool(diff_limit):\n    diff_tool = [\n        binary_path(\"catboost/tools/limited_precision_json_diff/limited_precision_json_diff\"),\n    ]\n    if diff_limit is not None:\n        diff_tool += ['--diff-limit', str(diff_limit)]\n    return diff_tool\ndef get_limited_precision_numpy_diff_tool(rtol=None, atol=None):\n    diff_tool = [binary_path(\"catboost/tools/limited_precision_numpy_diff/limited_precision_numpy_diff\")]\n    if diff_tool[0] is None:",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_numpy_diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def get_limited_precision_numpy_diff_tool(rtol=None, atol=None):\n    diff_tool = [binary_path(\"catboost/tools/limited_precision_numpy_diff/limited_precision_numpy_diff\")]\n    if diff_tool[0] is None:\n        diff_tool = [\n            'python',\n            os.path.join(os.environ['CMAKE_SOURCE_DIR'], 'catboost', 'tools', 'limited_precision_numpy_diff', 'main.py')\n        ]\n    if rtol is not None:\n        diff_tool += ['--rtol', str(rtol)]\n    if atol is not None:",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "compare_with_limited_precision",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "def compare_with_limited_precision(lhs, rhs, rtol=1e-6, atol=1e-8):\n    if isinstance(lhs, dict):\n        if not isinstance(rhs, dict):\n            return False\n        if len(lhs) != len(rhs):\n            return False\n        for k in lhs.keys():\n            if k not in rhs:\n                return False\n            if not compare_with_limited_precision(lhs[k], rhs[k], rtol, atol):",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "__all__ = [\n    'DelayedTee',\n    'append_params_to_cmdline',\n    'binary_path',\n    'compare_evals',\n    'compare_evals_with_precision',\n    'compare_fit_evals_with_precision',\n    'compare_metrics_with_diff',\n    'format_crossvalidation',\n    'get_limited_precision_dsv_diff_tool',",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "BY_CLASS_METRICS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.lib.common_helpers",
        "description": "catboost.catboost.pytest.lib.common_helpers",
        "peekOfCode": "BY_CLASS_METRICS = ['AUC', 'Precision', 'Recall', 'F1']\ndef compare_metrics_with_diff(custom_metric, fit_eval, calc_eval, eps=1e-7):\n    with open(fit_eval, \"r\") as fit_eval_file, open(calc_eval, \"r\") as calc_eval_file:\n        csv_fit = csv.reader(fit_eval_file, dialect='excel-tab')\n        csv_calc = csv.reader(calc_eval_file, dialect='excel-tab')\n        head_fit = next(csv_fit)\n        head_calc = next(csv_calc)\n        if isinstance(custom_metric, str):\n            custom_metric = [custom_metric]\n        for metric_name in deepcopy(custom_metric):",
        "detail": "catboost.catboost.pytest.lib.common_helpers",
        "documentation": {}
    },
    {
        "label": "score_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "def score_catboost_model(catboost_parameters, update_defaults=False):\n    r2_values = []\n    rmse_values = []\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    for train_index, test_index in kf.split(df):\n        train_pool = Pool(df.iloc[train_index].drop(['price_usd'], 1),\n                          label=df.iloc[train_index].price_usd,\n                          cat_features=categorical_features_names)\n        test_pool = Pool(df.iloc[test_index].drop(['price_usd'], 1),\n                        label=df.iloc[test_index].price_usd,",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "weight_model",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "def weight_model(catboost_parameters):\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    model = CatBoost(catboost_parameters)\n    model.fit(train_pool, verbose=False)\n    model.save_model('model_tmp')\n    model_size = Path('model_tmp').stat().st_size\n    return model_size\nmodel_size_reg_0 = weight_model({'model_size_reg': 0})\nmodel_size_reg_1 = weight_model({'model_size_reg': 1})\nmodel_size_reg_0/model_size_reg_1",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "df = pd.read_csv('cars.csv')\ndf\ncategorical_features_names = ['manufacturer_name', 'model_name', 'transmission', 'color', 'engine_fuel',\n                              'engine_type',  'body_type',  'state', 'drivetrain','location_region']\n#Lets see how many unique values each categorical variable has:\ndf[categorical_features_names].nunique()\n#Here is the target value distribution:\nsns.distplot(df.price_usd.values)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "categorical_features_names",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "categorical_features_names = ['manufacturer_name', 'model_name', 'transmission', 'color', 'engine_fuel',\n                              'engine_type',  'body_type',  'state', 'drivetrain','location_region']\n#Lets see how many unique values each categorical variable has:\ndf[categorical_features_names].nunique()\n#Here is the target value distribution:\nsns.distplot(df.price_usd.values)\nnp.median(df.price_usd.values)\n#First, we are going to roughly estimate the number of trees and the learning rate required that are sufficient for this task.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "df_",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "df_ = df.sample(frac=1., random_state=0)\ndf_train = df_.iloc[: 2 * len(df) // 3]\ndf_test = df_.iloc[2 * len(df) // 3 :]\ntrain_pool = Pool(df_train.drop(['price_usd'], 1),\n                  label=df_train.price_usd,\n                  cat_features=categorical_features_names)\ntest_pool = Pool(df_test.drop(['price_usd'], 1),\n                 label=df_test.price_usd,\n                 cat_features=categorical_features_names)\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "df_train",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "df_train = df_.iloc[: 2 * len(df) // 3]\ndf_test = df_.iloc[2 * len(df) // 3 :]\ntrain_pool = Pool(df_train.drop(['price_usd'], 1),\n                  label=df_train.price_usd,\n                  cat_features=categorical_features_names)\ntest_pool = Pool(df_test.drop(['price_usd'], 1),\n                 label=df_test.price_usd,\n                 cat_features=categorical_features_names)\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)\nmodel.fit(train_pool, eval_set=test_pool, verbose=500, plot=True)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "df_test",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "df_test = df_.iloc[2 * len(df) // 3 :]\ntrain_pool = Pool(df_train.drop(['price_usd'], 1),\n                  label=df_train.price_usd,\n                  cat_features=categorical_features_names)\ntest_pool = Pool(df_test.drop(['price_usd'], 1),\n                 label=df_test.price_usd,\n                 cat_features=categorical_features_names)\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)\nmodel.fit(train_pool, eval_set=test_pool, verbose=500, plot=True)\n#Now we are going to write a simple function that tests CatBoost performance on 3-fold cross-validation given the parameters and returns the full list of parameters for the last model. Optionally this function compares the model's metrics with the results of the model trained with the default categorical features parameters.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "train_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "train_pool = Pool(df_train.drop(['price_usd'], 1),\n                  label=df_train.price_usd,\n                  cat_features=categorical_features_names)\ntest_pool = Pool(df_test.drop(['price_usd'], 1),\n                 label=df_test.price_usd,\n                 cat_features=categorical_features_names)\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)\nmodel.fit(train_pool, eval_set=test_pool, verbose=500, plot=True)\n#Now we are going to write a simple function that tests CatBoost performance on 3-fold cross-validation given the parameters and returns the full list of parameters for the last model. Optionally this function compares the model's metrics with the results of the model trained with the default categorical features parameters.\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "test_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "test_pool = Pool(df_test.drop(['price_usd'], 1),\n                 label=df_test.price_usd,\n                 cat_features=categorical_features_names)\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)\nmodel.fit(train_pool, eval_set=test_pool, verbose=500, plot=True)\n#Now we are going to write a simple function that tests CatBoost performance on 3-fold cross-validation given the parameters and returns the full list of parameters for the last model. Optionally this function compares the model's metrics with the results of the model trained with the default categorical features parameters.\n#\n#We will fix the number of estimators at 4500 and the learning rate at 0.1.\nkf = KFold(n_splits=3, shuffle=True)\nDEFAULT_PARAMETERS = {'n_estimators' : 100, 'learning_rate' : 0.95}",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100)\nmodel.fit(train_pool, eval_set=test_pool, verbose=500, plot=True)\n#Now we are going to write a simple function that tests CatBoost performance on 3-fold cross-validation given the parameters and returns the full list of parameters for the last model. Optionally this function compares the model's metrics with the results of the model trained with the default categorical features parameters.\n#\n#We will fix the number of estimators at 4500 and the learning rate at 0.1.\nkf = KFold(n_splits=3, shuffle=True)\nDEFAULT_PARAMETERS = {'n_estimators' : 100, 'learning_rate' : 0.95}\nDEFAULT_MODEL_METRICS = {}\ndef score_catboost_model(catboost_parameters, update_defaults=False):\n    r2_values = []",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "kf",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "kf = KFold(n_splits=3, shuffle=True)\nDEFAULT_PARAMETERS = {'n_estimators' : 100, 'learning_rate' : 0.95}\nDEFAULT_MODEL_METRICS = {}\ndef score_catboost_model(catboost_parameters, update_defaults=False):\n    r2_values = []\n    rmse_values = []\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    for train_index, test_index in kf.split(df):\n        train_pool = Pool(df.iloc[train_index].drop(['price_usd'], 1),\n                          label=df.iloc[train_index].price_usd,",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PARAMETERS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "DEFAULT_PARAMETERS = {'n_estimators' : 100, 'learning_rate' : 0.95}\nDEFAULT_MODEL_METRICS = {}\ndef score_catboost_model(catboost_parameters, update_defaults=False):\n    r2_values = []\n    rmse_values = []\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    for train_index, test_index in kf.split(df):\n        train_pool = Pool(df.iloc[train_index].drop(['price_usd'], 1),\n                          label=df.iloc[train_index].price_usd,\n                          cat_features=categorical_features_names)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MODEL_METRICS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "DEFAULT_MODEL_METRICS = {}\ndef score_catboost_model(catboost_parameters, update_defaults=False):\n    r2_values = []\n    rmse_values = []\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    for train_index, test_index in kf.split(df):\n        train_pool = Pool(df.iloc[train_index].drop(['price_usd'], 1),\n                          label=df.iloc[train_index].price_usd,\n                          cat_features=categorical_features_names)\n        test_pool = Pool(df.iloc[test_index].drop(['price_usd'], 1),",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "last_model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "last_model_params = score_catboost_model({}, True)\n#We will save the metrics of the model with the default categorical features parameters for the further comparison.\n### One-Hot Encoding Max Size\n#The first thing we try is to make CatBoost use one-hot encoding for all our categorical features (the max categorical feature cardinality in our dataset is 1118 < 2000). The documentation says, that for the features for which one-hot encoding is used no other encodings are computed.\n#\n#*Default value is:*\n#* N/A if training is performed on CPU in Pairwise scoring mode\n#* 255 if training is performed on GPU and the selected Ctr types require target data that is not available during the training\n#* 10 if training is performed in Ranking mode\n#* 2 if none of the conditions above is met",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'one_hot_max_size' : 2000})\n#As can be seen on our dataset it works quite well. The main problem of one-hot encoding, however, is that it is simply impossible to use it on categorical features with really huge cardinality.\n### Model Size Regularization\n#*This parameter influences the model size if training data has categorical features.*\n#\n#*The information regarding categorical features makes a great contribution to the final size of the model. The mapping from the categorical feature value hash to some statistic values is stored for each categorical feature that is used in the model. The size of this mapping for a particular feature depends on the number of unique values that this feature takes.*\n#\n#*Therefore, the potential weight of a categorical feature can be taken into account in the final model when choosing a split in a tree to reduce the final size of the model. When choosing the best split, all split scores are calculated and then the split with the best score is chosen. But before choosing the split with the best score, all scores change according to the following formula:*\n#\n#![image](https://yastatic.net/doccenter/images/tech2.yandex.com/en/catboost/doc/freeze/PrIQQgX_sav4Z2B0aaOpJ7Dd4oM.svg)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'model_size_reg': 0})\nmodel_params = score_catboost_model({'model_size_reg': 1})\n#To check how the size of the model is affected by this setting we will write a function that given parameters dict will train a model, save it in a file and return the model's weight:\nfrom pathlib import Path\ndef weight_model(catboost_parameters):\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    model = CatBoost(catboost_parameters)\n    model.fit(train_pool, verbose=False)\n    model.save_model('model_tmp')\n    model_size = Path('model_tmp').stat().st_size",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'model_size_reg': 1})\n#To check how the size of the model is affected by this setting we will write a function that given parameters dict will train a model, save it in a file and return the model's weight:\nfrom pathlib import Path\ndef weight_model(catboost_parameters):\n    catboost_parameters.update(DEFAULT_PARAMETERS)\n    model = CatBoost(catboost_parameters)\n    model.fit(train_pool, verbose=False)\n    model.save_model('model_tmp')\n    model_size = Path('model_tmp').stat().st_size\n    return model_size",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_size_reg_0",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_size_reg_0 = weight_model({'model_size_reg': 0})\nmodel_size_reg_1 = weight_model({'model_size_reg': 1})\nmodel_size_reg_0/model_size_reg_1\n#As we can see the model with the strong regularization is almost 13 times smaller than the model without regularization.\n### Number of Features Combined\n#\n#**Feature combinations**: Note that any combination of several categorical features could be considered\n#as a new one. For example, assume that the task is music recommendation and we have two categorical\n#features: user ID and musical genre. Some user prefers, say, rock music. When we convert user ID\n#and musical genre to numerical features we loose this information. A combination of two features solves this problem and gives a new powerful feature.  However, the number of combinations grows exponentially with the number of categorical features in dataset and it is not possible to consider all of them in the algorithm. When constructing a new split for the current tree, CatBoost considers combinations in a greedy way. No combinations are considered for the first split in the tree. For the next splits CatBoost combines all combinations and categorical features present in current tree with all categorical features in dataset. Combination values are converted to numbers on the fly. CatBoost also generates combinations of numerical and categorical features in the following way:  all the splits selected in the tree are considered as categorical with two values and used in",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_size_reg_1",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_size_reg_1 = weight_model({'model_size_reg': 1})\nmodel_size_reg_0/model_size_reg_1\n#As we can see the model with the strong regularization is almost 13 times smaller than the model without regularization.\n### Number of Features Combined\n#\n#**Feature combinations**: Note that any combination of several categorical features could be considered\n#as a new one. For example, assume that the task is music recommendation and we have two categorical\n#features: user ID and musical genre. Some user prefers, say, rock music. When we convert user ID\n#and musical genre to numerical features we loose this information. A combination of two features solves this problem and gives a new powerful feature.  However, the number of combinations grows exponentially with the number of categorical features in dataset and it is not possible to consider all of them in the algorithm. When constructing a new split for the current tree, CatBoost considers combinations in a greedy way. No combinations are considered for the first split in the tree. For the next splits CatBoost combines all combinations and categorical features present in current tree with all categorical features in dataset. Combination values are converted to numbers on the fly. CatBoost also generates combinations of numerical and categorical features in the following way:  all the splits selected in the tree are considered as categorical with two values and used in\n#combinations in the same way as categorical ones.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'max_ctr_complexity': 6})\nmodel_params = score_catboost_model({'max_ctr_complexity': 0})\n#As we can see on our dataset the difference in the model's accuracy is not significant. To check how the size of the model is affected we will use our function that weights a model.\nmodel_size_max_ctr_6 = weight_model({'max_ctr_complexity': 6})\nmodel_size_max_ctr_0 = weight_model({'max_ctr_complexity': 0})\nmodel_size_max_ctr_6/model_size_max_ctr_0\n#As can be seen, the model that can combine up to 6 features weights 6 times more than the model that does not combine features at all.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'max_ctr_complexity': 0})\n#As we can see on our dataset the difference in the model's accuracy is not significant. To check how the size of the model is affected we will use our function that weights a model.\nmodel_size_max_ctr_6 = weight_model({'max_ctr_complexity': 6})\nmodel_size_max_ctr_0 = weight_model({'max_ctr_complexity': 0})\nmodel_size_max_ctr_6/model_size_max_ctr_0\n#As can be seen, the model that can combine up to 6 features weights 6 times more than the model that does not combine features at all.\n### Has Time\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_size_max_ctr_6",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_size_max_ctr_6 = weight_model({'max_ctr_complexity': 6})\nmodel_size_max_ctr_0 = weight_model({'max_ctr_complexity': 0})\nmodel_size_max_ctr_6/model_size_max_ctr_0\n#As can be seen, the model that can combine up to 6 features weights 6 times more than the model that does not combine features at all.\n### Has Time\n#\n#With this setting on we do not perform random permutations during the Transforming categorical features to numerical. This might be useful when the objects of our dataset are already ordered by time. If a Timestamp type column is present in the input data it is used to determine the order of objects.\nmodel_params = score_catboost_model({'has_time': True})",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_size_max_ctr_0",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_size_max_ctr_0 = weight_model({'max_ctr_complexity': 0})\nmodel_size_max_ctr_6/model_size_max_ctr_0\n#As can be seen, the model that can combine up to 6 features weights 6 times more than the model that does not combine features at all.\n### Has Time\n#\n#With this setting on we do not perform random permutations during the Transforming categorical features to numerical. This might be useful when the objects of our dataset are already ordered by time. If a Timestamp type column is present in the input data it is used to determine the order of objects.\nmodel_params = score_catboost_model({'has_time': True})\n### `simple_ctr` and `combinations_ctr`\n#\n#Both `simple_ctr` and `combinations_ctr` are complex parameters that provide regulation of the categorical features encodings types.  While `simple_ctr` is responsible for processing the categorical features initially present in the dataset, `combinations_ctr` affects the encoding of the new features, that CatBoost creates by combining the existing features. The available methods of encodings and possible values of `simple_ctr` and `combinations_ctr` are the same, so we are not going to look at them separately. But of course, you can always tune them separately on your task!",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'has_time': True})\n### `simple_ctr` and `combinations_ctr`\n#\n#Both `simple_ctr` and `combinations_ctr` are complex parameters that provide regulation of the categorical features encodings types.  While `simple_ctr` is responsible for processing the categorical features initially present in the dataset, `combinations_ctr` affects the encoding of the new features, that CatBoost creates by combining the existing features. The available methods of encodings and possible values of `simple_ctr` and `combinations_ctr` are the same, so we are not going to look at them separately. But of course, you can always tune them separately on your task!\n#\n#### Encodings without target quantization\n#\n#**Target quantization** is transforming *float* target values to *int* target values using some borders. We will first consider the target encoding methods that do not require such a transformation.\n#\n##### FloatTargetMeanValue  (GPU only)",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'simple_ctr' : 'FloatTargetMeanValue',\n                                     'combinations_ctr' : 'FloatTargetMeanValue',\n                                     'task_type' : 'GPU'})\n##### FeatureFreq  (GPU only)\n#The second option is *FeatureFreq*. The categorical feature values are replaced with the frequencies of the category in the dataset. Again only the objects placed before the current objects are used.\nmodel_params = score_catboost_model({'simple_ctr' : 'FeatureFreq',\n                                     'combinations_ctr' : 'FeatureFreq',\n                                     'task_type' : 'GPU'})\n##### Counter\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'simple_ctr' : 'FeatureFreq',\n                                     'combinations_ctr' : 'FeatureFreq',\n                                     'task_type' : 'GPU'})\n##### Counter\n#\n#`Counter` method is very similar to the traditional Frequency Encoding described in the introduction and is defined by the following formula:\n#![image](https://yastatic.net/doccenter/images/tech2.yandex.com/en/catboost/doc/freeze/Z4SLgeG9ZGNieCbVnZ_L9ow2N2g.svg)\n#$curCount$ is the number of objects of the current category, $maxCount$ is the number of objects of the most frequent category and $prior$ is a number defined by the parameter `prior`.\nmodel_params = score_catboost_model({'simple_ctr' : 'Counter', 'combinations_ctr' : 'Counter'})\n##### `CtrBorderCount` parameter",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'simple_ctr' : 'Counter', 'combinations_ctr' : 'Counter'})\n##### `CtrBorderCount` parameter\n#\n#Let us say we have calculated encodings for our categorical variable. These encodings are floats and they are comparable: in case of `Counter` the larger encoding value corresponds to the more frequent category. However, if we have a large number of categories the difference between close categories encodings may be caused by noise and we do not want our model to differentiate between close categories. For this reason we transform our float encoding into int encoding $i \\in [0, l]$. By default `CtrBorderCount=15` setting means that $l=14(15-1)$. We can try to use bigger value:\nmodel_params = score_catboost_model({'combinations_ctr':\n                                     ['Counter:CtrBorderCount=40:Prior=0.5/1'],\n                                     'simple_ctr':\n                                     ['Counter:CtrBorderCount=40:Prior=0.5/1']})\n##### Binarized Target Mean Value\n#The second method `BinarizedTargetMeanValue` is very similar to target encoding, except that instead of the sum over the exact target values we use the sum of the values of the beans. Which corresponds to the following formula:",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'combinations_ctr':\n                                     ['Counter:CtrBorderCount=40:Prior=0.5/1'],\n                                     'simple_ctr':\n                                     ['Counter:CtrBorderCount=40:Prior=0.5/1']})\n##### Binarized Target Mean Value\n#The second method `BinarizedTargetMeanValue` is very similar to target encoding, except that instead of the sum over the exact target values we use the sum of the values of the beans. Which corresponds to the following formula:\n#\n#![image.png](https://yastatic.net/doccenter/images/tech2.yandex.com/en/catboost/doc/freeze/nGtSamWtCor-RZl2M0mpoIytQis.svg)\n#\n#where:",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'combinations_ctr': 'BinarizedTargetMeanValue',\n                                     'simple_ctr': 'BinarizedTargetMeanValue'})\n#While using the `BinarizedTargetMeanValue` method we can also finetune `Prior` and `CtrBorderCount`(the number of borders for quantization the category feature encoding). By default `CtrBorderCount`=15 and 0, 0.5 and 1 `Prior` values are used to build three different encodings.\n### Encodings with Target Quantization\n#### Buckets and Borders\n#![buckets](https://www.rowles.com/wp-content/uploads/2018/08/Buck-Market-Volatility-with-a-Retirement-Bucket-Plan.jpg)\n#\n#Now we proceed to the settings of the encodings methods that require target quantization. The first choice is `Borders` vs. `Buckets`. The difference between the two is pretty simple. Both are described by the following formula:\n#\n#for $i \\in [0, k-1]$ in case of `Borders` and for $i \\in [0, k-1]$ in case of `Buckets`:",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "#$encoding^{0}_{sun}",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "#$encoding^{0}_{sun} = \\frac{2 + 0.5}{3} = 0.83 $ and $encoding^{0}_{moon} = \\frac{4 + 0.5}{5} = 0.9 $\n#\n#* Border k=1:\n#\n#$ encoding^{1}_{sun} = \\frac{0 + 0.5}{3} = 0.17 $ and $ encoding^{1}_{moon} = \\frac{3 + 0.5}{5} = 0.7 $\n#\n#Buckets:\n#$i \\in [0, k]$ creates $k+1$ buckets. So the same value of `TargetBorderCount=2` creates more features from each categorical feature if we choose `Buckets`.\n#* Bucket k=0: there is 1 object of category sun and 1 object of category moon with target values within Bucket k=0. In total there are 3 suns and 5 moons. So our encodings are:\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "#$encoding^{0}_{sun}",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "#$encoding^{0}_{sun} = \\frac{1 + 0.5}{3} = 0.5 $ and $encoding^{0}_{moon} = \\frac{1 + 0.5}{5} = 0.3 $\n#\n#* Bucket k=1:\n#\n#$ encoding^{1}_{sun} = \\frac{2 + 0.5}{3} = 0.83 $ and $ encoding^{1}_{moon} = \\frac{1 + 0.5}{5} = 0.3 $\n#\n#* Bucket k=2:\n#\n#$ encoding^{1}_{sun} = \\frac{0 + 0.5}{3} = 0.17 $ and $ encoding^{1}_{moon} = \\frac{3 + 0.5}{5} = 0.7 $\n#| Categorical feature value   | Borders features  |   | Buckets features |   | |",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'combinations_ctr': 'Borders',\n                                     'simple_ctr': 'Borders'})\nmodel_params = score_catboost_model({'combinations_ctr': 'Buckets',\n                                     'simple_ctr': 'Buckets'})\n#An attentive reader may remember that by default CatBoost creates some features using `Borders` splits and also some features using `Counter` method. When we explicitly pass the `Borders` option, `Counter` method is not used.\n#\n#Generally, it is recommended to use `Borders` for the regression task and `Buckets` for the multiclassification task.\n#### Treatment of missing values and new categories\n#\n#1. What happens if there is a **new category in the test set** that never appeared in the training set? The answer is, that since $𝑐𝑜𝑢𝑛𝑡𝐼𝑛𝐶𝑙𝑎𝑠𝑠$ is equal to zero, the prior is used to compute the encoding:",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'combinations_ctr': 'Buckets',\n                                     'simple_ctr': 'Buckets'})\n#An attentive reader may remember that by default CatBoost creates some features using `Borders` splits and also some features using `Counter` method. When we explicitly pass the `Borders` option, `Counter` method is not used.\n#\n#Generally, it is recommended to use `Borders` for the regression task and `Buckets` for the multiclassification task.\n#### Treatment of missing values and new categories\n#\n#1. What happens if there is a **new category in the test set** that never appeared in the training set? The answer is, that since $𝑐𝑜𝑢𝑛𝑡𝐼𝑛𝐶𝑙𝑎𝑠𝑠$ is equal to zero, the prior is used to compute the encoding:\n#\n#$$ctr_i=\\frac{prior}{totalCount + 1}$$",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'combinations_ctr': 'Borders:TargetBorderCount=4',\n                                     'simple_ctr': 'Borders:TargetBorderCount=4'})\n#### Default value of `simple_ctr` and `combinations_ctr`\n#\n#By default, CatBoost uses several encoding techniques to encode each categorical feature.\n#\n#\n#* First it uses `Borders` method with one target border `TargetBorderCount`=1 (in our example for each categorical feature we just want to see if it makes the car more expensive). The obtained float encodings are further discretized into `CtrBorderCount`=15 different values. Three values of `Prior` parameter are used to create 3 three different encodings: `Prior=0/1:Prior=0.5/1:Prior=1/1`\n#\n#* Also for each categorical feature, we create an encoding with `Counter` method. The number of categorical encoding value borders `CtrBorderCount` is also equal to 15, and only one value of `Prior=0/1` is used.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "last_model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "last_model_params = score_catboost_model({}, True)\nlast_model_params['simple_ctr']\nlast_model_params['combinations_ctr']\n### Individual features control via `per_feature_ctr` parameter\n#\n#The next thing I would like to talk about in this tutorial is using different encoding methods for different features with the parameter `per_feature_ctr`. It might be useful in cases when you know that one of your features is more important than the others. We can, for example, increase the number of target borders for model_name feature:\nmodel_params = score_catboost_model({'per_feature_ctr': ['1:Borders:TargetBorderCount=10:Prior=0/1'] })\n### Other parameters\n#### Counter Calculation Method\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'per_feature_ctr': ['1:Borders:TargetBorderCount=10:Prior=0/1'] })\n### Other parameters\n#### Counter Calculation Method\n#\n#The parameter determines whether to use validation dataset(provided through parameter `eval_set` of `fit` method) to estimate categories frequencies with `Counter`. By default, it is `Full` and the objects from validation dataset are used; Pass `SkipTest` value to ignore the objects from the validation set In our `score_catboost_model` function we don't give to CatBoost the validation dataset at all during training so to check this method effect we will use train/test split.\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='Full')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='Full')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method Full: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='SkipTest')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "r2_res",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "r2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method Full: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='SkipTest')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method SkipTest: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\n#### Number of Borders for Target Quantization",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "rmse_res",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "rmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method Full: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\nmodel = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='SkipTest')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method SkipTest: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\n#### Number of Borders for Target Quantization\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.95, n_estimators=100,\n                          counter_calc_method='SkipTest')\nmodel.fit(train_pool, eval_set=test_pool, verbose=False)\nr2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method SkipTest: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\n#### Number of Borders for Target Quantization\n#\n#*The maximum number of borders to use in target quantization for categorical features that need it. Default for regression task is 1.*\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "r2_res",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "r2_res = r2_score(df_test.price_usd.values, model.predict(test_pool))\nrmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method SkipTest: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\n#### Number of Borders for Target Quantization\n#\n#*The maximum number of borders to use in target quantization for categorical features that need it. Default for regression task is 1.*\n#\n#Let us try a rather big number of borders:\nmodel_params = score_catboost_model({'ctr_target_border_count': 10})\n#It is worth noticing that this setting seems to have a huge impact on training time -- on my machine, it increased almost 5 times.",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "rmse_res",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "rmse_res = mean_squared_error(df_test.price_usd.values, model.predict(test_pool))\nprint('Counter Calculation Method SkipTest: R2={:.4f} RMSE={:.0f}'.format(r2_res, rmse_res))\n#### Number of Borders for Target Quantization\n#\n#*The maximum number of borders to use in target quantization for categorical features that need it. Default for regression task is 1.*\n#\n#Let us try a rather big number of borders:\nmodel_params = score_catboost_model({'ctr_target_border_count': 10})\n#It is worth noticing that this setting seems to have a huge impact on training time -- on my machine, it increased almost 5 times.\n#### Categorical Values Limit",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'ctr_target_border_count': 10})\n#It is worth noticing that this setting seems to have a huge impact on training time -- on my machine, it increased almost 5 times.\n#### Categorical Values Limit\n#\n#This parameter regulates the number of the most common categorical feature values that are used by the model. If we have $n$ unique categories and `ctr_leaf_count_limit`=$m$ we preserve the categorical feature value only for objects from $m$ most frequent categories. For the objects from the remaining $n-m$ categories, we replace categorical feature value with `None`.\n#\n#The default value of this parameter is `None` -- all the categorical features values are preserved.\nmodel_params = score_catboost_model({'ctr_leaf_count_limit' : 5})\n#Oops! On our dataset, it ruins the model performance.\n#### Store Simple Categorical Features",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'ctr_leaf_count_limit' : 5})\n#Oops! On our dataset, it ruins the model performance.\n#### Store Simple Categorical Features\n#With this setting on the previous parameter `ctr_leaf_count_limit` affects only the categorical features, that CatBoost creates by combining the initial features and the initial categorical features present in the dataset are not affected. When parameter `ctr_leaf_count_limit` is `None` parameter `store_all_simple_ctr` has no effect.\nmodel_params = score_catboost_model({'store_all_simple_ctr' : True, 'ctr_leaf_count_limit' : 5})\n###  Internal feature importance\n#\n#It is quite common to use several encodings for a categorical feature. For instance, CatBoost creates 4 different encodings for each categorical feature by default (see \"Default value of simple_ctr and combinations_ctr\" section). When we call `get_feature_importances` method we get aggregated across all the encodings importance for the categorical feature. That is because in practice we usually just want to compare the overall usefulness of the different features present in our dataset.\n#\n#However, what if we want to know which encodings worked best for us? For that we would need to get **Internal Feature Importance.** Currently, it is available only in the command-line version of CatBoost library. You can find details about the installation [here](https://catboost.ai/docs/concepts/cli-installation.html) and an example of how to train a model with the command-line version in [this tutorial](https://github.com/catboost/catboost/blob/master/catboost/tutorials/cmdline_tutorial/cmdline_tutorial.md).",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model_params = score_catboost_model({'store_all_simple_ctr' : True, 'ctr_leaf_count_limit' : 5})\n###  Internal feature importance\n#\n#It is quite common to use several encodings for a categorical feature. For instance, CatBoost creates 4 different encodings for each categorical feature by default (see \"Default value of simple_ctr and combinations_ctr\" section). When we call `get_feature_importances` method we get aggregated across all the encodings importance for the categorical feature. That is because in practice we usually just want to compare the overall usefulness of the different features present in our dataset.\n#\n#However, what if we want to know which encodings worked best for us? For that we would need to get **Internal Feature Importance.** Currently, it is available only in the command-line version of CatBoost library. You can find details about the installation [here](https://catboost.ai/docs/concepts/cli-installation.html) and an example of how to train a model with the command-line version in [this tutorial](https://github.com/catboost/catboost/blob/master/catboost/tutorials/cmdline_tutorial/cmdline_tutorial.md).\n#\n#To train a model with the command-line version we first need to create a column description file:\ndescr = ['Categ' if i in categorical_features_names else 'Auxiliary' for i in df.columns]\ndescr[14] = 'Target'",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "descr",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "descr = ['Categ' if i in categorical_features_names else 'Auxiliary' for i in df.columns]\ndescr[14] = 'Target'\npd.Series(descr).to_csv('train.cd', sep='\\t', header=None)\n#Then train a model:\n#\n#`catboost fit --learn-set cars.csv  --loss-function RMSE --learning-rate 0.1 --iterations 4500 --delimiter=',' --has-header --column-description train.cd`\n#\n#And then create an Internal Feature Importance file:\n#`catboost fstr -m model.bin  --cd train.cd --fstr-type InternalFeatureImportance -o feature_strength.tsv`\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "descr[14]",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "descr[14] = 'Target'\npd.Series(descr).to_csv('train.cd', sep='\\t', header=None)\n#Then train a model:\n#\n#`catboost fit --learn-set cars.csv  --loss-function RMSE --learning-rate 0.1 --iterations 4500 --delimiter=',' --has-header --column-description train.cd`\n#\n#And then create an Internal Feature Importance file:\n#`catboost fstr -m model.bin  --cd train.cd --fstr-type InternalFeatureImportance -o feature_strength.tsv`\n#\n#The contents of this file in our case are the following:",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "description": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "peekOfCode": "model = CatBoostRegressor(custom_metric= ['R2', 'RMSE'], learning_rate=0.3, n_estimators=5)\nmodel.fit(train_pool, eval_set=test_pool, logging_level='Info')\n#For numeric features the format is the following:\n#\n#feature name, index of the chosen split, split score\n#\n#Example: `year_produced, bin=47 score 669154.1979`\n#\n#Format for categorical features is:\n#",
        "detail": "catboost.catboost.pytest.smoke_tests.categorical_features_parameters_gpu",
        "documentation": {}
    },
    {
        "label": "build_multiclass_ranking_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "def build_multiclass_ranking_dataset(X, y, cat_features, label_values=[0,1], start_group_id=0):\n    ranking_matrix = []\n    ranking_labels = []\n    group_ids = []\n    X_train_matrix = X.values\n    y_train_vector = y.values\n    for obj_idx in range(X.shape[0]):\n        obj = list(X_train_matrix[obj_idx])\n        for label in label_values:\n            obj_of_given_class = deepcopy(obj)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "soft_max",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "def soft_max(values):\n    return [math.exp(val) / sum([math.exp(val) for val in values]) for val in values]\nprint('Probabilities', np.array(soft_max(ratings)))\n### Metric evaluation on a new dataset\nmodel = CatBoostClassifier(\n    random_seed=63,\n    iterations=200,\n    learning_rate=0.03,\n)\nmodel.fit(",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "y = train_df.ACTION\nX = train_df.drop('ACTION', axis=1)\n#Categorical features declaration\ncat_features = list(range(0, X.shape[1]))\nprint(cat_features)\n#Looking on label balance in dataset\nprint('Labels: {}'.format(set(y)))\nprint('Zero count = {}, One count = {}'.format(len(y) - sum(y), sum(y)))\n#Ways to create Pool class",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "X = train_df.drop('ACTION', axis=1)\n#Categorical features declaration\ncat_features = list(range(0, X.shape[1]))\nprint(cat_features)\n#Looking on label balance in dataset\nprint('Labels: {}'.format(set(y)))\nprint('Zero count = {}, One count = {}'.format(len(y) - sum(y), sum(y)))\n#Ways to create Pool class",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "cat_features",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "cat_features = list(range(0, X.shape[1]))\nprint(cat_features)\n#Looking on label balance in dataset\nprint('Labels: {}'.format(set(y)))\nprint('Zero count = {}, One count = {}'.format(len(y) - sum(y), sum(y)))\n#Ways to create Pool class\ndataset_dir = './amazon'\nif not os.path.exists(dataset_dir):\n    os.makedirs(dataset_dir)\n# We will be able to work with files with/without header and",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "dataset_dir",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "dataset_dir = './amazon'\nif not os.path.exists(dataset_dir):\n    os.makedirs(dataset_dir)\n# We will be able to work with files with/without header and\n# with different separators.\ntrain_df.to_csv(\n    os.path.join(dataset_dir, 'train.tsv'),\n    index=False, sep='\\t', header=False\n)\ntest_df.to_csv(",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "feature_names",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "feature_names = dict()\nfor column, name in enumerate(train_df):\n    if column == 0:\n        continue\n    feature_names[column] = name\ncreate_cd(\n    label=0,\n    cat_features=list(range(1, train_df.columns.shape[0])),\n    feature_names=feature_names,\n    output_path=os.path.join(dataset_dir, 'train.cd')",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "pool1",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "pool1 = Pool(data=X, label=y, cat_features=cat_features)\npool2 = Pool(\n    data=os.path.join(dataset_dir, 'train.csv'),\n    delimiter=',',\n    column_description=os.path.join(dataset_dir, 'train.cd'),\n    has_header=True\n)\npool3 = Pool(data=X, cat_features=cat_features)\n# Fastest way to create a Pool is to create it from numpy matrix.\n# This way should be used if you want fast predictions",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "pool2",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "pool2 = Pool(\n    data=os.path.join(dataset_dir, 'train.csv'),\n    delimiter=',',\n    column_description=os.path.join(dataset_dir, 'train.cd'),\n    has_header=True\n)\npool3 = Pool(data=X, cat_features=cat_features)\n# Fastest way to create a Pool is to create it from numpy matrix.\n# This way should be used if you want fast predictions\n# or fastest way to load the data in python.",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "pool3",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "pool3 = Pool(data=X, cat_features=cat_features)\n# Fastest way to create a Pool is to create it from numpy matrix.\n# This way should be used if you want fast predictions\n# or fastest way to load the data in python.\nX_prepared = X.values.astype(str).astype(object)\n# For FeaturesData class categorial features must have type str\npool4 = Pool(\n    data=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "X_prepared",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "X_prepared = X.values.astype(str).astype(object)\n# For FeaturesData class categorial features must have type str\npool4 = Pool(\n    data=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X)\n    ),\n    label=y.values\n)\nprint('Dataset shape')",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "pool4",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "pool4 = Pool(\n    data=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X)\n    ),\n    label=y.values\n)\nprint('Dataset shape')\nprint('dataset 1:' + str(pool1.shape) +\n      '\\ndataset 2:' + str(pool2.shape) +",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=5,\n    learning_rate=0.1,\n    # loss_function='CrossEntropy'\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),\n    verbose=False",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=15,\n#     verbose=5,\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),\n)\n### Metrics calculation and graph plotting",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=50,\n    random_seed=63,\n    learning_rate=0.5,\n    custom_loss=['AUC', 'Accuracy']\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model1",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model1 = CatBoostClassifier(\n    learning_rate=0.7,\n    iterations=100,\n    random_seed=0,\n    train_dir='learing_rate_0.7'\n)\nmodel2 = CatBoostClassifier(\n    learning_rate=0.01,\n    iterations=100,\n    random_seed=0,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model2",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model2 = CatBoostClassifier(\n    learning_rate=0.01,\n    iterations=100,\n    random_seed=0,\n    train_dir='learing_rate_0.01'\n)\nmodel1.fit(\n    X_train, y_train,\n    eval_set=(X_validation, y_validation),\n    cat_features=cat_features,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=100,\n    random_seed=63,\n    learning_rate=0.5,\n#     use_best_model=False\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params = {}\nparams['loss_function'] = 'Logloss'\nparams['iterations'] = 80\nparams['custom_loss'] = 'AUC'\nparams['random_seed'] = 63\nparams['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params['loss_function']",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params['loss_function'] = 'Logloss'\nparams['iterations'] = 80\nparams['custom_loss'] = 'AUC'\nparams['random_seed'] = 63\nparams['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params['iterations']",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params['iterations'] = 80\nparams['custom_loss'] = 'AUC'\nparams['random_seed'] = 63\nparams['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,\n    partition_random_seed=0,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params['custom_loss']",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params['custom_loss'] = 'AUC'\nparams['random_seed'] = 63\nparams['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,\n    partition_random_seed=0,\n    plot=True,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params['random_seed']",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params['random_seed'] = 63\nparams['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,\n    partition_random_seed=0,\n    plot=True,\n    stratified=False,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params['learning_rate']",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params['learning_rate'] = 0.5\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,\n    partition_random_seed=0,\n    plot=True,\n    stratified=False,\n    verbose=False",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "cv_data",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "cv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    shuffle=True,\n    partition_random_seed=0,\n    plot=True,\n    stratified=False,\n    verbose=False\n)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "best_value",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "best_value = np.min(cv_data['test-Logloss-mean'])\nbest_iter = np.argmin(cv_data['test-Logloss-mean'])\nprint('Best validation Logloss score, not stratified: {:.4f}+-{:.4f} on step {}'.format(\n    best_value,\n    cv_data['test-Logloss-std'][best_iter],\n    best_iter)\n)\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "best_iter",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "best_iter = np.argmin(cv_data['test-Logloss-mean'])\nprint('Best validation Logloss score, not stratified: {:.4f}+-{:.4f} on step {}'.format(\n    best_value,\n    cv_data['test-Logloss-std'][best_iter],\n    best_iter)\n)\ncv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "cv_data",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "cv_data = cv(\n    params = params,\n    pool = Pool(X, label=y, cat_features=cat_features),\n    fold_count=5,\n    type = 'Classical',\n    shuffle=True,\n    partition_random_seed=0,\n    plot=True,\n    stratified=True,\n    verbose=False",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "best_value",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "best_value = np.min(cv_data['test-Logloss-mean'])\nbest_iter = np.argmin(cv_data['test-Logloss-mean'])\nprint('Best validation Logloss score, stratified: {:.4f}+-{:.4f} on step {}'.format(\n    best_value,\n    cv_data['test-Logloss-std'][best_iter],\n    best_iter)\n)\n### Overfitting detector\nmodel_with_early_stop = CatBoostClassifier(\n    iterations=200,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "best_iter",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "best_iter = np.argmin(cv_data['test-Logloss-mean'])\nprint('Best validation Logloss score, stratified: {:.4f}+-{:.4f} on step {}'.format(\n    best_value,\n    cv_data['test-Logloss-std'][best_iter],\n    best_iter)\n)\n### Overfitting detector\nmodel_with_early_stop = CatBoostClassifier(\n    iterations=200,\n    random_seed=63,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model_with_early_stop",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model_with_early_stop = CatBoostClassifier(\n    iterations=200,\n    random_seed=63,\n    learning_rate=0.5,\n    early_stopping_rounds=20\n)\nmodel_with_early_stop.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model_with_early_stop",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model_with_early_stop = CatBoostClassifier(\n    eval_metric='AUC',\n    iterations=200,\n    random_seed=63,\n    learning_rate=0.5,\n    early_stopping_rounds=20\n)\nmodel_with_early_stop.fit(\n    X_train, y_train,\n    cat_features=cat_features,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    random_seed=63,\n    iterations=200,\n    learning_rate=0.03,\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    verbose=False,\n    plot=True",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "eval_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "eval_pool = Pool(X_validation, y_validation, cat_features=cat_features)\ncurve = get_roc_curve(model, eval_pool)\n(fpr, tpr, thresholds) = curve\nroc_auc = sklearn.metrics.auc(fpr, tpr)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(16, 8))\nlw = 2\nplt.plot(fpr, tpr, color='darkorange',\n         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc, alpha=0.5)\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--', alpha=0.5)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "curve",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "curve = get_roc_curve(model, eval_pool)\n(fpr, tpr, thresholds) = curve\nroc_auc = sklearn.metrics.auc(fpr, tpr)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(16, 8))\nlw = 2\nplt.plot(fpr, tpr, color='darkorange',\n         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc, alpha=0.5)\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--', alpha=0.5)\nplt.xlim([0.0, 1.0])",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "roc_auc",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "roc_auc = sklearn.metrics.auc(fpr, tpr)\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(16, 8))\nlw = 2\nplt.plot(fpr, tpr, color='darkorange',\n         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc, alpha=0.5)\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--', alpha=0.5)\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xticks(fontsize=16)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "lw",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "lw = 2\nplt.plot(fpr, tpr, color='darkorange',\n         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc, alpha=0.5)\nplt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--', alpha=0.5)\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xticks(fontsize=16)\nplt.yticks(fontsize=16)\nplt.grid(True)\nplt.xlabel('False Positive Rate', fontsize=16)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "lw",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "lw = 2\nplt.plot(thresholds, fpr, color='blue', lw=lw, label='FPR', alpha=0.5)\nplt.plot(thresholds, fnr, color='green', lw=lw, label='FNR', alpha=0.5)\nplt.xlim([0.0, 1.0])\nplt.ylim([0.0, 1.05])\nplt.xticks(fontsize=16)\nplt.yticks(fontsize=16)\nplt.grid(True)\nplt.xlabel('Threshold', fontsize=16)\nplt.ylabel('Error Rate', fontsize=16)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=100,\n    save_snapshot=True,\n    snapshot_file='snapshot.bkp',\n    snapshot_interval=1,\n    random_seed=43\n)\nmodel.fit(\n    X_train, y_train,\n    eval_set=(X_validation, y_validation),",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "raw_pred",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "raw_pred = model.predict(\n    data=X_validation,\n    prediction_type='RawFormulaVal'\n)\nprint(raw_pred)\nfrom numpy import exp\nsigmoid = lambda x: 1 / (1 + exp(-x))\nprobabilities = sigmoid(raw_pred)\nprint(probabilities)\nX_prepared = X_validation.values.astype(str).astype(object)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "sigmoid",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "sigmoid = lambda x: 1 / (1 + exp(-x))\nprobabilities = sigmoid(raw_pred)\nprint(probabilities)\nX_prepared = X_validation.values.astype(str).astype(object)\n# For FeaturesData class categorial features must have type str\nfast_predictions = model.predict_proba(\n    X=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X_validation)\n    )",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "probabilities",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "probabilities = sigmoid(raw_pred)\nprint(probabilities)\nX_prepared = X_validation.values.astype(str).astype(object)\n# For FeaturesData class categorial features must have type str\nfast_predictions = model.predict_proba(\n    X=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X_validation)\n    )\n)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "X_prepared",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "X_prepared = X_validation.values.astype(str).astype(object)\n# For FeaturesData class categorial features must have type str\nfast_predictions = model.predict_proba(\n    X=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X_validation)\n    )\n)\nprint(fast_predictions)\n### Staged prediction",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "fast_predictions",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "fast_predictions = model.predict_proba(\n    X=FeaturesData(\n        cat_feature_data=X_prepared,\n        cat_feature_names=list(X_validation)\n    )\n)\nprint(fast_predictions)\n### Staged prediction\npredictions_gen = model.staged_predict_proba(\n    data=X_validation,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "predictions_gen",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "predictions_gen = model.staged_predict_proba(\n    data=X_validation,\n    ntree_start=0,\n    ntree_end=5,\n    eval_period=1\n)\ntry:\n    for iteration, predictions in enumerate(predictions_gen):\n        print('Iteration ' + str(iteration) + ', predictions:')\n        print(predictions)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    iterations=50,\n    random_seed=43,\n    loss_function='MultiClass'\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    eval_set=(X_validation, y_validation),\n    verbose=False,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "params = {'iterations':150, 'learning_rate':0.01, 'l2_leaf_reg':30, 'random_seed':0, 'loss_function':'QuerySoftMax'}\ngroupwise_train_pool = build_multiclass_ranking_dataset(X_train, y_train, cat_features, [0,1])\ngroupwise_eval_pool = build_multiclass_ranking_dataset(X_validation, y_validation, cat_features, [0,1], X_train.shape[0])\nmodel = CatBoost(params)\nmodel.fit(\n    X=groupwise_train_pool,\n    verbose=False,\n    eval_set=groupwise_eval_pool,\n    plot=True\n)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "groupwise_train_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "groupwise_train_pool = build_multiclass_ranking_dataset(X_train, y_train, cat_features, [0,1])\ngroupwise_eval_pool = build_multiclass_ranking_dataset(X_validation, y_validation, cat_features, [0,1], X_train.shape[0])\nmodel = CatBoost(params)\nmodel.fit(\n    X=groupwise_train_pool,\n    verbose=False,\n    eval_set=groupwise_eval_pool,\n    plot=True\n)\n#Doing predictions with ranking mode",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "groupwise_eval_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "groupwise_eval_pool = build_multiclass_ranking_dataset(X_validation, y_validation, cat_features, [0,1], X_train.shape[0])\nmodel = CatBoost(params)\nmodel.fit(\n    X=groupwise_train_pool,\n    verbose=False,\n    eval_set=groupwise_eval_pool,\n    plot=True\n)\n#Doing predictions with ranking mode\nimport math",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoost(params)\nmodel.fit(\n    X=groupwise_train_pool,\n    verbose=False,\n    eval_set=groupwise_eval_pool,\n    plot=True\n)\n#Doing predictions with ranking mode\nimport math\nobj = list(X_validation.values[0])",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "obj = list(X_validation.values[0])\nratings = []\nfor label in [0,1]:\n    obj_with_label = deepcopy(obj)\n    obj_with_label.append(label)\n    rating = model.predict([obj_with_label])[0]\n    ratings.append(rating)\nprint('Raw values:', np.array(ratings))\ndef soft_max(values):\n    return [math.exp(val) / sum([math.exp(val) for val in values]) for val in values]",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "ratings",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "ratings = []\nfor label in [0,1]:\n    obj_with_label = deepcopy(obj)\n    obj_with_label.append(label)\n    rating = model.predict([obj_with_label])[0]\n    ratings.append(rating)\nprint('Raw values:', np.array(ratings))\ndef soft_max(values):\n    return [math.exp(val) / sum([math.exp(val) for val in values]) for val in values]\nprint('Probabilities', np.array(soft_max(ratings)))",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "model = CatBoostClassifier(\n    random_seed=63,\n    iterations=200,\n    learning_rate=0.03,\n)\nmodel.fit(\n    X_train, y_train,\n    cat_features=cat_features,\n    verbose=50\n)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "metrics",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "metrics = model.eval_metrics(\n    data=pool1,\n    metrics=['Logloss','AUC'],\n    ntree_start=0,\n    ntree_end=0,\n    eval_period=1,\n    plot=True\n)\nprint('AUC values:')\nprint(np.array(metrics['AUC']))",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "shap_values",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "shap_values = model.get_feature_importance(pool1, type='ShapValues')\nexpected_value = shap_values[0,-1]\nshap_values = shap_values[:,:-1]\nprint(shap_values.shape)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[3,:], X.iloc[3,:], show=False)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[91,:], X.iloc[91,:], show=False)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "expected_value",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "expected_value = shap_values[0,-1]\nshap_values = shap_values[:,:-1]\nprint(shap_values.shape)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[3,:], X.iloc[3,:], show=False)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[91,:], X.iloc[91,:], show=False)\nshap.summary_plot(shap_values, X, show=False)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "shap_values",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "shap_values = shap_values[:,:-1]\nprint(shap_values.shape)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[3,:], X.iloc[3,:], show=False)\nimport shap\nshap.initjs()\nshap.force_plot(expected_value, shap_values[91,:], X.iloc[91,:], show=False)\nshap.summary_plot(shap_values, X, show=False)\nX_small = X.iloc[0:200]",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "X_small",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "X_small = X.iloc[0:200]\nshap_small = shap_values[:200]\nshap.force_plot(expected_value, shap_small, X_small, show=False)\n### Feature evaluation\nlearn_params = {'iterations': 20, # 2000\n                'learning_rate': 0.5, # we set big learning_rate,\n                                      # because we have small\n                                      # #iterations\n                'random_seed': 0,\n                'verbose': False,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "shap_small",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "shap_small = shap_values[:200]\nshap.force_plot(expected_value, shap_small, X_small, show=False)\n### Feature evaluation\nlearn_params = {'iterations': 20, # 2000\n                'learning_rate': 0.5, # we set big learning_rate,\n                                      # because we have small\n                                      # #iterations\n                'random_seed': 0,\n                'verbose': False,\n                'loss_function' : 'Logloss',",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "learn_params",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "learn_params = {'iterations': 20, # 2000\n                'learning_rate': 0.5, # we set big learning_rate,\n                                      # because we have small\n                                      # #iterations\n                'random_seed': 0,\n                'verbose': False,\n                'loss_function' : 'Logloss',\n                'boosting_type': 'Plain'}\nevaluator = CatboostEvaluation('amazon/train.tsv',\n                               fold_size=10000, # <= 50% of dataset",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "evaluator",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "evaluator = CatboostEvaluation('amazon/train.tsv',\n                               fold_size=10000, # <= 50% of dataset\n                               fold_count=20,\n                               column_description='amazon/train.cd',\n                               partition_random_seed=0,\n                               #working_dir=...\n)\nresult = evaluator.eval_features(learn_config=learn_params,\n                                 eval_metrics=['Logloss', 'Accuracy'],\n                                 features_to_eval=[6, 7, 8])",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "result = evaluator.eval_features(learn_config=learn_params,\n                                 eval_metrics=['Logloss', 'Accuracy'],\n                                 features_to_eval=[6, 7, 8])\nlogloss_result = result.get_metric_results('Logloss')\nlogloss_result.get_baseline_comparison(\n    ScoreConfig(ScoreType.Rel, overfit_iterations_info=False)\n)\n### Saving the model\nmy_best_model = CatBoostClassifier(iterations=10)\nmy_best_model.fit(",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "logloss_result",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "logloss_result = result.get_metric_results('Logloss')\nlogloss_result.get_baseline_comparison(\n    ScoreConfig(ScoreType.Rel, overfit_iterations_info=False)\n)\n### Saving the model\nmy_best_model = CatBoostClassifier(iterations=10)\nmy_best_model.fit(\n    X_train, y_train,\n    eval_set=(X_validation, y_validation),\n    cat_features=cat_features,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "my_best_model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "my_best_model = CatBoostClassifier(iterations=10)\nmy_best_model.fit(\n    X_train, y_train,\n    eval_set=(X_validation, y_validation),\n    cat_features=cat_features,\n    verbose=False\n)\nmy_best_model.save_model('catboost_model.bin')\nmy_best_model.save_model('catboost_model.json', format='json')\nmy_best_model.load_model('catboost_model.bin')",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "fast_model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "fast_model = CatBoostClassifier(\n    random_seed=63,\n    iterations=150,\n    learning_rate=0.01,\n    boosting_type='Plain',\n    bootstrap_type='Bernoulli',\n    subsample=0.5,\n    one_hot_max_size=20,\n    rsm=0.5,\n    leaf_estimation_iterations=5,",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "tunned_model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "tunned_model = CatBoostClassifier(\n    random_seed=63,\n    iterations=1000,\n    learning_rate=0.03,\n    l2_leaf_reg=3,\n    bagging_temperature=1,\n    random_strength=1,\n    one_hot_max_size=2,\n    leaf_estimation_method='Newton'\n)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "best_model",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "best_model = CatBoostClassifier(\n    random_seed=63,\n    iterations=int(tunned_model.tree_count_ * 1.2),\n)\nbest_model.fit(\n    X, y,\n    cat_features=cat_features,\n    verbose=100\n)\n### Calculate predictions for the contest",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "X_test = test_df.drop('id', axis=1)\ntest_pool = Pool(data=X_test, cat_features=cat_features)\ncontest_predictions = best_model.predict_proba(test_pool)\nprint('Predictoins:')\nprint(contest_predictions)\n### Prepare the submission\nf = open('submit.csv', 'w')\nf.write('Id,Action\\n')\nfor idx in range(len(contest_predictions)):\n    line = str(test_df['id'][idx]) + ',' + str(contest_predictions[idx][1]) + '\\n'",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "test_pool",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "test_pool = Pool(data=X_test, cat_features=cat_features)\ncontest_predictions = best_model.predict_proba(test_pool)\nprint('Predictoins:')\nprint(contest_predictions)\n### Prepare the submission\nf = open('submit.csv', 'w')\nf.write('Id,Action\\n')\nfor idx in range(len(contest_predictions)):\n    line = str(test_df['id'][idx]) + ',' + str(contest_predictions[idx][1]) + '\\n'\n    f.write(line)",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "contest_predictions",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "contest_predictions = best_model.predict_proba(test_pool)\nprint('Predictoins:')\nprint(contest_predictions)\n### Prepare the submission\nf = open('submit.csv', 'w')\nf.write('Id,Action\\n')\nfor idx in range(len(contest_predictions)):\n    line = str(test_df['id'][idx]) + ',' + str(contest_predictions[idx][1]) + '\\n'\n    f.write(line)\nf.close()",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "description": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "peekOfCode": "f = open('submit.csv', 'w')\nf.write('Id,Action\\n')\nfor idx in range(len(contest_predictions)):\n    line = str(test_df['id'][idx]) + ',' + str(contest_predictions[idx][1]) + '\\n'\n    f.write(line)\nf.close()\n#Submit your solution [here](https://www.kaggle.com/c/amazon-employee-access-challenge/submit).\n#Good luck!!!",
        "detail": "catboost.catboost.pytest.smoke_tests.classification_tutorial_cpu",
        "documentation": {}
    },
    {
        "label": "test_dist_train_many_trees",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.large_dist_test",
        "description": "catboost.catboost.pytest.large_dist_test",
        "peekOfCode": "def test_dist_train_many_trees(dev_score_calc_obj_block_size):\n    pool_path = data_file('higgs', 'train_small')\n    test_path = data_file('higgs', 'test_small')\n    cd_path = data_file('higgs', 'train.cd')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', pool_path,\n        '-t', test_path,\n        '--column-description', cd_path,\n        '-i', '1000',",
        "detail": "catboost.catboost.pytest.large_dist_test",
        "documentation": {}
    },
    {
        "label": "CATBOOST_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.large_dist_test",
        "description": "catboost.catboost.pytest.large_dist_test",
        "peekOfCode": "CATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\n@pytest.mark.xfail(sys.platform == \"darwin\", reason=\"known issue with connections\")\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)",
        "detail": "catboost.catboost.pytest.large_dist_test",
        "documentation": {}
    },
    {
        "label": "SCORE_CALC_OBJ_BLOCK_SIZES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.large_dist_test",
        "description": "catboost.catboost.pytest.large_dist_test",
        "peekOfCode": "SCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\n@pytest.mark.xfail(sys.platform == \"darwin\", reason=\"known issue with connections\")\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)\ndef test_dist_train_many_trees(dev_score_calc_obj_block_size):",
        "detail": "catboost.catboost.pytest.large_dist_test",
        "documentation": {}
    },
    {
        "label": "SCORE_CALC_OBJ_BLOCK_SIZES_IDS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.large_dist_test",
        "description": "catboost.catboost.pytest.large_dist_test",
        "peekOfCode": "SCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\n@pytest.mark.xfail(sys.platform == \"darwin\", reason=\"known issue with connections\")\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)\ndef test_dist_train_many_trees(dev_score_calc_obj_block_size):\n    pool_path = data_file('higgs', 'train_small')",
        "detail": "catboost.catboost.pytest.large_dist_test",
        "documentation": {}
    },
    {
        "label": "TestModelWithoutParams",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "class TestModelWithoutParams(object):\n    @pytest.fixture(\n        params=[\n            ('cut-info', 'RMSE'),\n            ('cut-params', 'RMSE'),\n            ('cut-info', 'QueryRMSE'),\n            ('cut-params', 'QueryRMSE'),\n        ],\n        ids=lambda param: '-'.join(param),\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def diff_tool(threshold=None):\n    return get_limited_precision_dsv_diff_tool(threshold, True)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\n@pytest.mark.parametrize('n_trees', [100, 500])\ndef test_multiregression_with_missing_values(boosting_type, n_trees):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression_with_missing_values",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiregression_with_missing_values(boosting_type, n_trees):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (\n        '--loss-function', 'MultiRMSEWithMissingValues',\n        '--boosting-type', boosting_type,\n        '-f', data_file('multiregression_with_missing', 'train'),\n        '-t', data_file('multiregression_with_missing', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cv_multiregression",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cv_multiregression(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiRMSE',\n        '-f', data_file('multiregression', 'train'),\n        '--column-description', data_file('multiregression', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_multiregression",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_multiregression(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='MultiRMSE',\n        pool='multiregression',\n        train='train',\n        test='test',\n        cd='train.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('--boost-from-average', '0'))))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_multiregression_single",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_multiregression_single(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='MultiRMSE',\n        pool='multiregression',\n        train='train',\n        test='test',\n        cd='train_single.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('--boost-from-average', '0'))))]\n@pytest.mark.parametrize('boosting_type, grow_policy', BOOSTING_TYPE_WITH_GROW_POLICIES)",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiregression(boosting_type, grow_policy, n_trees):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (\n        '--loss-function', 'MultiRMSE',\n        '--boosting-type', boosting_type,\n        '-f', data_file('multiregression', 'train'),\n        '-t', data_file('multiregression', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_survival_aft",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_survival_aft(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (\n        '--loss-function', 'SurvivalAft',\n        '--boosting-type', boosting_type,\n        '-f', data_file('survival_aft', 'train'),\n        '-t', data_file('survival_aft', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_survival_aft_with_nondefault_distributions",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_survival_aft_with_nondefault_distributions(boosting_type, distribution_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (\n        '--loss-function', 'SurvivalAft:dist={}'.format(distribution_type),\n        '--boosting-type', boosting_type,\n        '-f', data_file('survival_aft', 'train'),\n        '-t', data_file('survival_aft', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_survival_aft_on_incompatible_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_survival_aft_on_incompatible_target():\n    cmd_fit = (\n        '--loss-function', 'SurvivalAft',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '100',\n        '-T', '4',\n    )\n    with pytest.raises(yatest.common.ExecutionError):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression_target_permutation_invariance",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiregression_target_permutation_invariance(boosting_type, n_trees, target_count):\n    np.random.seed(42)\n    X_COUNT = 200\n    X_DIM = 5\n    x = np.random.randn(X_COUNT, X_DIM)\n    y = np.stack([\n        np.sin(np.sum([np.pi * x[:, j] * (1 if np.random.randn() > 0 else -1) for j in range(X_DIM)], axis=0))\n        for i in range(target_count)\n    ], axis=1)\n    test_size = X_COUNT // 2",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_compare_multiregression_with_regression",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_compare_multiregression_with_regression(boosting_type, n_trees, target_count):\n    np.random.seed(42)\n    ERR_PERC = 0.1\n    X_COUNT = 200\n    X_DIM = 5\n    x = np.random.randn(X_COUNT, X_DIM)\n    y = np.stack([\n        np.sin(np.sum([np.pi * x[:, j] * (1 if np.random.randn() > 0 else -1) for j in range(X_DIM)], axis=0))\n        for i in range(target_count)\n    ], axis=1)",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression_single",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiregression_single(boosting_type, n_trees):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd_fit = (\n        '--loss-function', 'MultiRMSE',\n        '--boosting-type', boosting_type,\n        '-f', data_file('multiregression', 'train'),\n        '-t', data_file('multiregression', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiregression_with_cat_features(boosting_type, n_trees):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd_fit = (\n        '--loss-function', 'MultiRMSE',\n        '--boosting-type', boosting_type,\n        '-f', data_file('multiregression', 'train'),\n        '-t', data_file('multiregression', 'test'),\n        '--column-description', data_file('multiregression', 'train_with_cat_features.cd'),\n        '-i', '{}'.format(n_trees),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_queryrmse",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_queryrmse(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_queryrmse_newton_gradient",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_queryrmse_newton_gradient(boosting_type, dev_score_calc_obj_block_size):\n    newton_eval_path = yatest.common.test_output_path('newton.eval')\n    gradient_eval_path = yatest.common.test_output_path('gradient.eval')\n    def run_catboost(eval_path, leaf_estimation_method):\n        cmd = [\n            '--loss-function', 'QueryRMSE',\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--column-description', data_file('querywise', 'train.cd'),\n            '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pool_with_QueryId",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pool_with_QueryId(boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd.query_id'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_rmse_on_qwise_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_rmse_on_qwise_pool(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'RMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_averagegain",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_averagegain(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_queryauc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_queryauc(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_queryaverage",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_queryaverage(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_filter",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_filter(sigma, num_estimations):\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('pool.cd')\n    train_path = yatest.common.test_output_path('train.txt')\n    test_path = yatest.common.test_output_path('test.txt')\n    prng = np.random.RandomState(seed=0)\n    n_samples_by_query = 20\n    n_features = 10\n    n_queries = 50\n    n_samples = n_samples_by_query * n_queries",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_lambda_mart",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_lambda_mart():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'LambdaMart',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_lambda_mart_dcgs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_lambda_mart_dcgs(metric, top, dcg_type, denominator, sigma, norm):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'LambdaMart:metric={};top={};type={};denominator={};sigma={};norm={};hints=skip_train~false'.format(\n        metric, top, dcg_type, denominator, sigma, norm)\n    cmd = (\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--cd', data_file('querywise', 'train.cd.query_id'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_lambda_mart_non_dcgs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_lambda_mart_non_dcgs(metric, sigma, norm):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'LambdaMart:metric={};sigma={};norm={};hints=skip_train~false'.format(metric, sigma, norm)\n    cmd = (\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--cd', data_file('querywise', 'train.cd.query_id'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_rank_dcgs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_rank_dcgs(metric, top, dcg_type, denominator):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'StochasticRank:metric={};top={};type={};denominator={};hints=skip_train~false'.format(\n        metric, top, dcg_type, denominator)\n    cmd = (\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--cd', data_file('querywise', 'train.cd.query_id'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_rank_pfound",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_rank_pfound(top, decay):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'StochasticRank:metric=PFound;top={};decay={};hints=skip_train~false'.format(top, decay)\n    cmd = (\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_rank_pfound_with_many_ones",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_rank_pfound_with_many_ones(top, decay):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    loss = 'StochasticRank:metric=PFound;top={};decay={};hints=skip_train~false'.format(top, decay)\n    np.random.seed(0)\n    train_with_ones = yatest.common.test_output_path('train_with_ones')\n    TARGET_COLUMN = 2\n    with open(data_file('querywise', 'train')) as fin:\n        with open(train_with_ones, 'w') as fout:\n            for line in fin.readlines():\n                if np.random.random() < 0.25:",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_rank_err",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_rank_err(top):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'StochasticRank:metric=ERR;top={};hints=skip_train~false'.format(top)\n    cmd = (\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--cd', data_file('querywise', 'train.cd.query_id'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_stochastic_rank_mrr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_stochastic_rank_mrr():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    loss = 'StochasticRank:metric=MRR;hints=skip_train~false'\n    cmd = (\n        '--loss-function', loss,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--cd', data_file('querywise', 'train.cd.query_id'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_averagegain_with_query_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_averagegain_with_query_weights(boosting_type, top):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd.group_weight'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pfound",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pfound(top_size, boosting_type, cd_file):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', cd_file),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_params_ordering",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_params_ordering():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    learn_error_reversed_path = yatest.common.test_output_path('learn_error_reversed.tsv')\n    test_error_path = yatest.common.test_output_path('ignored.tsv')\n    def get_cmd(custom_metric, learn_error_path):\n        return (\n            '--loss-function', 'QueryRMSE',\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--column-description', data_file('querywise', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_recall_at_k",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_recall_at_k():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', 'Ordered',\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_precision_at_k",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_precision_at_k():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', 'Ordered',\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_mapk",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_mapk(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ndcg",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ndcg(boosting_type, ndcg_power_mode, metric_type, ndcg_denominator):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    denominator = '' if ndcg_denominator == 'None' else ';denominator={}'.format(ndcg_denominator)\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_filtered_dcg",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_filtered_dcg(ndcg_power_mode, ndcg_denominator, ndcg_sort_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'YetiRank',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_queryrmse_approx_on_full_history",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_queryrmse_approx_on_full_history():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--approx-on-full-history',\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairlogit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairlogit(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    def run_catboost(eval_path, learn_pairs):\n        cmd = [\n            '--loss-function', 'PairLogit',\n            '--eval-metric', 'PairAccuracy',\n            '-f', data_file('querywise', 'train'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairs_generation():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    def run_catboost(eval_path):\n        cmd = [\n            '--loss-function', 'PairLogit',\n            '--eval-metric', 'PairAccuracy',\n            '-f', data_file('querywise', 'train'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation_with_max_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairs_generation_with_max_pairs():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    def run_catboost(eval_path):\n        cmd = [\n            '--loss-function', 'PairLogit:max_pairs=30',\n            '--eval-metric', 'PairLogit:max_pairs=30',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairlogit_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairlogit_no_target(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'PairLogit',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd.no_target'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--test-pairs', data_file('querywise', 'test.pairs'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairlogit_force_unit_pair_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairlogit_force_unit_pair_weights():\n    def train(params, output_eval_path):\n        cmd = (\n            '--loss-function', 'PairLogit',\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--column-description', data_file('querywise', 'train.cd.group_weight'),\n            '-i', '20',\n            '-T', '4',\n            '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairlogit_approx_on_full_history",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairlogit_approx_on_full_history():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'PairLogit',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--test-pairs', data_file('querywise', 'test.pairs'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairlogit_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairlogit_pairwise(pairs_file, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'PairLogitPairwise',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--test-pairs', data_file('querywise', 'test.pairs'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetirank",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetirank(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'YetiRank',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairwise_reproducibility",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairwise_reproducibility(loss_function):\n    def run_catboost(threads, model_path, eval_path):\n        cmd = [\n            '--use-best-model', 'false',\n            '--loss-function', loss_function,\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--learn-pairs', data_file('querywise', 'train.pairs'),\n            '--test-pairs', data_file('querywise', 'test.pairs'),\n            '--cd', data_file('querywise', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_vs_grouped_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairs_vs_grouped_pairs():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    def run_catboost(learn_pairs_path_with_scheme, test_pairs_path_with_scheme, eval_path):\n        cmd = [\n            '--loss-function', 'PairLogit',\n            '--eval-metric', 'PairAccuracy',\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--column-description', data_file('querywise', 'train.cd'),\n            '--learn-pairs', learn_pairs_path_with_scheme,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetirank_with_params",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetirank_with_params(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'YetiRank:permutations=5;decay=0.9',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetirank_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetirank_pairwise(dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'YetiRankPairwise',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetirank_default_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetirank_default_metric(loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', loss_function,\n        '--has-header',\n        '-f', data_file('black_friday', 'train'),\n        '-t', data_file('black_friday', 'test'),\n        '--column-description', data_file('black_friday', 'cd'),\n        '--model-file', output_model_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_reciprocal_rank_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_reciprocal_rank_metrics(eval_metric):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', 'YetiRank',\n        '--eval-metric', eval_metric,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd.query_id'),\n        '--boosting-type', 'Plain',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetiloss_dcgs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetiloss_dcgs(main_loss_function, mode, top, dcg_type, dcg_denominator, noise, noise_power, num_neighbors):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    loss = '{}:mode={};top={};dcg_type={};dcg_denominator={};noise={};noise_power={};num_neighbors={};hints=skip_train~false'.format(\n        main_loss_function,\n        mode,\n        top,\n        dcg_type,\n        dcg_denominator,\n        noise,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_yetiloss_non_dcgs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_yetiloss_non_dcgs(mode, top, noise, noise_power, num_neighbors):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    loss = 'YetiRank:mode={};top={};noise={};noise_power={};num_neighbors={};hints=skip_train~false'.format(\n        mode,\n        top,\n        noise,\n        noise_power,\n        num_neighbors\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_nan_mode",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_nan_mode(nan_mode, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', data_file('adult_nan', 'train_small'),\n        '-t', data_file('adult_nan', 'test_small'),\n        '--column-description', data_file('adult_nan', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_different_border_count",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_different_border_count(border_count):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_path = data_file('querywise', 'train')\n    test_path = data_file('querywise', 'test')\n    cd_path = data_file('querywise', 'train.cd')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', train_path,\n        '-t', test_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_nan_mode_forbidden",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_nan_mode_forbidden(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_big_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_big_dataset(task, loss, big_test_file):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_file = data_file('big_labor', 'train')\n    test_file = data_file('big_labor', 'test')\n    if big_test_file:\n        train_file, test_file = test_file, train_file\n    cmd = (\n        '--loss-function', loss,\n        '-f', train_file,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_iter",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_overfit_detector_iter(boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_inc_to_dec",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_overfit_detector_inc_to_dec(boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_with_resume_from_snapshot",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_overfit_detector_with_resume_from_snapshot(boosting_type, grow_policy, overfitting_detector_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    snapshot_path = yatest.common.test_output_path('snapshot')\n    cmd_prefix = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_per_object_approx_on_full_history",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_per_object_approx_on_full_history(leaf_estimation_method):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', 'Ordered',\n        '--approx-on-full-history',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_shrink_model",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_shrink_model(boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multi_leaf_estimation_method",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multi_leaf_estimation_method(leaf_estimation_method, boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'MultiClass',\n        '-f', data_file('cloudness_small', 'train_small'),\n        '-t', data_file('cloudness_small', 'test_small'),\n        '--column-description', data_file('cloudness_small', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_sample_id",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_sample_id(loss_function, column_name):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    column_description = data_file('adult_' + column_name, 'train.cd')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', data_file('adult_doc_id', 'train'),\n        '-t', data_file('adult_doc_id', 'test'),\n        '--column-description', column_description,\n        '--boosting-type', 'Plain',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_missing_vals",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_missing_vals(boosting_type, grow_policy):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_crossentropy",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_crossentropy(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'CrossEntropy',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_permutation_block",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_permutation_block(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ignored_features(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ignored_features_names():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'RMSE',\n        '--has-header',\n        '--learn-set', data_file('black_friday', 'train'),\n        '--test-set', data_file('black_friday', 'test'),\n        '--column-description', data_file('black_friday', 'cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features_not_read",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ignored_features_not_read():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    input_cd_path = data_file('adult', 'train.cd')\n    cd_path = yatest.common.test_output_path('train.cd')\n    with open(input_cd_path, \"rt\") as f:\n        cd_lines = f.readlines()\n    with open(cd_path, \"wt\") as f:\n        for cd_line in cd_lines:\n            # Corrupt some features by making them 'Num'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features_not_read_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ignored_features_not_read_names():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    input_cd_path = data_file('black_friday', 'cd')\n    cd_path = yatest.common.test_output_path('cd')\n    with open(input_cd_path, \"rt\") as f:\n        cd_lines = f.readlines()\n    with open(cd_path, \"wt\") as f:\n        for cd_line in cd_lines:\n            if cd_line.split() == ('2', 'Categ', 'Gender'):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_text_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_text_ignored_features(boosting_type, ignored_features):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('rotten_tomatoes', 'train'),\n        '-t', data_file('rotten_tomatoes', 'test'),\n        '--column-description', data_file('rotten_tomatoes', 'cd_binclass'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ignore_text_feature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ignore_text_feature():\n    cd_path = data_file('rotten_tomatoes_small_with_embeddings', 'cd_binclass')\n    train_path = data_file('rotten_tomatoes_small_with_embeddings', 'train')\n    output_path = yatest.common.test_output_path('output.txt')\n    cmd_fit = ('--loss-function', 'Logloss',\n               '--cd', cd_path,\n               '-f', train_path,\n               '-i', '5',\n               '-T', '1',\n               '--learn-err-log', output_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_embedding_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_embedding_ignored_features(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('rotten_tomatoes_small_with_embeddings', 'train'),\n        '-t', data_file('rotten_tomatoes_small_with_embeddings', 'train'),  # there's no test file for now\n        '--column-description', data_file('rotten_tomatoes_small_with_embeddings', 'cd_binclass'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_baseline(boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('train_adult_baseline.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiclass_baseline(boosting_type, loss_function):\n    labels = ['0', '1', '2', '3']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Baseline'], [2, 'Baseline'], [3, 'Baseline'], [4, 'Baseline']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_baseline_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiclass_baseline_lost_class(boosting_type, loss_function):\n    labels = [0, 1, 2, 3]\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Baseline'], [2, 'Baseline']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, [1, 2], prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_weights(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_weights_no_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_weights_no_bootstrap(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_weights_gradient",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_weights_gradient(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_logloss_with_not_binarized_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_logloss_with_not_binarized_target(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_not_binarized', 'train_small'),\n        '-t', data_file('adult_not_binarized', 'test_small'),\n        '--column-description', data_file('adult_not_binarized', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_all_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_all_targets(loss_function, boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_model_path_without_test = yatest.common.test_output_path('model_without_test.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    base_cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cv",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cv(is_inverted, boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cv_for_query",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cv_for_query(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cv_for_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cv_for_pairs(is_inverted, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'PairLogit',\n        '-f', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_cv_spec",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_cv_spec(bad_cv_params):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',\n        '-m', output_model_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_bad_fold_cv_spec",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_bad_fold_cv_spec(is_inverted, error_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',\n        '-m', output_model_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cv_on_quantized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cv_on_quantized(is_inverted, boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    borders_path = yatest.common.test_output_path('borders')\n    def run_cmd(learn_set_path, eval_path, additional_params):\n        cmd = (\n            '--dev-efb-max-buckets', '0',\n            '--use-best-model', 'false',\n            '--loss-function', 'Logloss',\n            '--learn-set', learn_set_path,\n            '--column-description', data_file('higgs', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_empty_eval",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_empty_eval(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_time",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_time(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_gradient",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_gradient(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_gradient_with_leafwise_approxes",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_gradient_with_leafwise_approxes(loss_function, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_eval_path_dev_approxes = yatest.common.test_output_path('test_dev_approxes.eval')\n    cmd = [\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_newton",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_newton(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_newton_with_leafwise_approxes",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_newton_with_leafwise_approxes(dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_eval_path_dev_approxes = yatest.common.test_output_path('test_dev_approxes.eval')\n    cmd = [\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_newton_on_pool_with_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_newton_on_pool_with_weights(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_priors",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_priors(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ctr_buckets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ctr_buckets(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiClass',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fold_len_multiplier",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fold_len_multiplier(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiClass',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr(fstr_type, boosting_type, grow_policy):\n    pool = 'adult' if fstr_type != 'PredictionDiff' else 'higgs'\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=data_file(pool, 'train_small'),\n        cd_path=data_file(pool, 'train.cd'),\n        boosting_type=boosting_type,\n        grow_policy=grow_policy,\n        normalize=False,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_text_features(fstr_type, boosting_type, grow_policy):\n    pool = 'rotten_tomatoes'\n    separator_type = 'ByDelimiter'\n    feature_estimators = 'BoW,NaiveBayes,BM25'\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]\n    text_processing = {'feature_processing': {'default': feature_processing}, 'dictionaries': dictionaries, 'tokenizers': tokenizers}\n    return do_test_fstr(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_text_features_shap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_text_features_shap(fstr_type, boosting_type, grow_policy):\n    pool = 'rotten_tomatoes'\n    separator_type = 'ByDelimiter'\n    feature_estimators = 'NaiveBayes'\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]\n    text_processing = {'feature_processing': {'default': feature_processing}, 'dictionaries': dictionaries, 'tokenizers': tokenizers}\n    return do_test_fstr(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_embedding_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_embedding_features(fstr_type, boosting_type, grow_policy, columns):\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,\n        cd_path=ROTTEN_TOMATOES_CD[columns],\n        boosting_type=boosting_type,\n        grow_policy=grow_policy,\n        normalize=False,\n        additional_train_params=((('--max-ctr-complexity', '1') if fstr_type == 'ShapValues' else ()))",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_normalized_model",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_normalized_model(fstr_type, grow_policy):\n    pool = 'adult' if fstr_type != 'PredictionDiff' else 'higgs'\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=data_file(pool, 'train_small'),\n        cd_path=data_file(pool, 'train.cd'),\n        boosting_type='Plain',\n        grow_policy=grow_policy,\n        normalize=True,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_target_border(fstr_type, grow_policy):\n    if fstr_type == 'PredictionDiff':\n        # because PredictionDiff needs pool without categorical features\n        train_path = data_file('querywise', 'train')\n        cd_path = data_file('querywise', 'train.cd')\n    else:\n        train_path = data_file('adult_not_binarized', 'train_small')\n        cd_path = data_file('adult_not_binarized', 'train.cd')\n    return do_test_fstr(\n        fstr_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_weights(fstr_type, grow_policy):\n    return do_test_fstr(\n        fstr_type,\n        loss_function='RMSE',\n        input_path=data_file('querywise', 'train'),\n        cd_path=data_file('querywise', 'train.cd.weight'),\n        boosting_type='Plain',\n        grow_policy=grow_policy,\n        normalize=False\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_class_weights(fstr_type, grow_policy):\n    pool = 'adult' if fstr_type != 'PredictionDiff' else 'higgs'\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=data_file(pool, 'train_small'),\n        cd_path=data_file(pool, 'train.cd'),\n        boosting_type='Plain',\n        grow_policy=grow_policy,\n        normalize=False,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_with_target_border_and_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_with_target_border_and_class_weights(fstr_type):\n    if fstr_type == 'PredictionDiff':\n        # because PredictionDiff needs pool without categorical features\n        train_path = data_file('querywise', 'train')\n        cd_path = data_file('querywise', 'train.cd')\n    else:\n        train_path = data_file('adult_not_binarized', 'train_small')\n        cd_path = data_file('adult_not_binarized', 'train.cd')\n    return do_test_fstr(\n        fstr_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "do_test_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def do_test_fstr(\n    fstr_type,\n    loss_function,\n    input_path,\n    cd_path,\n    boosting_type,\n    grow_policy,\n    normalize,\n    additional_train_params=()\n):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "make_model_normalized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def make_model_normalized(model_path):\n    yatest.common.execute([\n        CATBOOST_PATH,\n        'normalize-model',\n        '--model-path', model_path,\n        '--output-model', model_path,\n        '--set-scale', '0.5',\n        '--set-bias', '0.125',\n    ])\n@pytest.mark.parametrize('loss_function', ['QueryRMSE', 'GroupQuantile', 'PairLogit', 'YetiRank', 'PairLogitPairwise', 'YetiRankPairwise'])",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_loss_change_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_loss_change_fstr(loss_function):\n    return do_test_loss_change_fstr(loss_function, normalize=False)\ndef test_loss_change_fstr_normalized():\n    return do_test_loss_change_fstr('QueryRMSE', normalize=True)\ndef do_test_loss_change_fstr(loss_function, normalize):\n    model_path = yatest.common.test_output_path('model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    train_fstr_path = yatest.common.test_output_path('t_fstr.tsv')\n    def add_loss_specific_params(cmd, fstr_mode):\n        if loss_function in ['PairLogit', 'PairLogitPairwise']:",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_loss_change_fstr_normalized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_loss_change_fstr_normalized():\n    return do_test_loss_change_fstr('QueryRMSE', normalize=True)\ndef do_test_loss_change_fstr(loss_function, normalize):\n    model_path = yatest.common.test_output_path('model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    train_fstr_path = yatest.common.test_output_path('t_fstr.tsv')\n    def add_loss_specific_params(cmd, fstr_mode):\n        if loss_function in ['PairLogit', 'PairLogitPairwise']:\n            cmd += ('--column-description', data_file('querywise', 'train.cd.no_target'))\n            if fstr_mode:",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "do_test_loss_change_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def do_test_loss_change_fstr(loss_function, normalize):\n    model_path = yatest.common.test_output_path('model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    train_fstr_path = yatest.common.test_output_path('t_fstr.tsv')\n    def add_loss_specific_params(cmd, fstr_mode):\n        if loss_function in ['PairLogit', 'PairLogitPairwise']:\n            cmd += ('--column-description', data_file('querywise', 'train.cd.no_target'))\n            if fstr_mode:\n                cmd += ('--input-pairs', data_file('querywise', 'train.pairs'))\n            else:",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fstr_feature_importance_default_value",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fstr_feature_importance_default_value(boosting_type, ranking_parameters):\n    model_path = yatest.common.test_output_path('model.bin')\n    fstr_path_0 = yatest.common.test_output_path('fstr_0.tsv')\n    fstr_path_1 = yatest.common.test_output_path('fstr_1.tsv')\n    internal_fstr_path_0 = yatest.common.test_output_path('internal_fstr_0.tsv')\n    internal_fstr_path_1 = yatest.common.test_output_path('internal_fstr_1.tsv')\n    pool = 'adult' if ranking_parameters['loss-function'] == 'Logloss' else 'black_friday'\n    pool_path = data_file(pool, 'train_small' if pool == 'adult' else 'train')\n    cd_path = data_file(pool, 'train.cd' if pool == 'adult' else 'cd')\n    has_header_suffix = ('--has-header',) if pool == 'black_friday' else ()",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_loss_change_fstr_without_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_loss_change_fstr_without_pairs(boosting_type):\n    model_path = yatest.common.test_output_path('model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'PairLogit',\n        '--learn-set', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_loss_change_fstr_on_different_pool_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_loss_change_fstr_on_different_pool_type():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_dsv_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    output_quantized_fstr_path = yatest.common.test_output_path('fstr.tsv.quantized')\n    train_fstr_path = yatest.common.test_output_path('train_fstr.tsv')\n    def get_pool_path(set_name, is_quantized=False):\n        path = data_file('querywise', set_name)\n        return 'quantized://' + path + '.quantized' if is_quantized else path\n    cd_file = data_file('querywise', 'train.cd')\n    cmd = (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_zero_splits",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_zero_splits(grow_policy):\n    cmd = (\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_reproducibility",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_reproducibility(loss_function, grow_policy, dev_score_calc_obj_block_size):\n    def run_catboost(threads, model_path, eval_path):\n        cmd = [\n            '--use-best-model', 'false',\n            '--loss-function', loss_function,\n            '-f', data_file('adult', 'train_small'),\n            '-t', data_file('adult', 'test_small'),\n            '--column-description', data_file('adult', 'train.cd'),\n            '--grow-policy', grow_policy,\n            '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_border_types",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_border_types(border_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_deep_tree_classification",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_deep_tree_classification(depth, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_regularization",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_regularization(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_reg_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_reg_targets(loss_function, boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multi_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multi_targets(loss_function, boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_eval_path_dev_approxes = yatest.common.test_output_path('test_dev_approxes.eval')\n    cmd = [\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('cloudness_small', 'train_small'),\n        '-t', data_file('cloudness_small', 'test_small'),\n        '--column-description', data_file('cloudness_small', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ctr_target_quantization",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ctr_target_quantization(border_type, border_count, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_counter_calc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_counter_calc(counter_calc_method, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ctr_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ctr_type(ctr_type, boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_overfitting_detector_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_overfitting_detector_metric(boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '--eval-metric', 'AUC:hints=skip_train~false',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_same_metric_skip_different",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_same_metric_skip_different(boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path_with_custom_metric = yatest.common.test_output_path('test_error_with_custom_metric.tsv')\n    learn_error_path_with_custom_metric = yatest.common.test_output_path('learn_error_with_custom_metric.tsv')\n    cmd = [\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_loss_for_classification",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_loss_for_classification(loss_function, boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    custom_metrics = [\n        metric for metric in\n        [\n            'AUC:hints=skip_train~false',\n            'Logloss',\n            'CrossEntropy',\n            'Accuracy',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_loglikelihood_of_prediction",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_loglikelihood_of_prediction(boosting_type):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_loss_for_multiclassification",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_loss_for_multiclassification(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiClass',\n        '-f', data_file('cloudness_small', 'train_small'),\n        '-t', data_file('cloudness_small', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_calc_prediction_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_calc_prediction_type(boosting_type):\n    model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_calc_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_calc_no_target(boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    fit_output_eval_path = yatest.common.test_output_path('fit_test.eval')\n    calc_output_eval_path = yatest.common.test_output_path('calc_test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_classification_progress_restore",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_classification_progress_restore(boosting_type):\n    def run_catboost(iters, model_path, eval_path, additional_params=None):\n        import random\n        import shutil\n        import string\n        letters = string.ascii_lowercase\n        train_random_name = ''.join(random.choice(letters) for i in range(8))\n        shutil.copy(data_file('adult', 'train_small'), train_random_name)\n        cmd = [\n            '--loss-function', 'Logloss',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_prediction_type(prediction_type, loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_type_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_prediction_type_multilabel(prediction_type, dataset):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    loss_function = 'MultiCrossEntropy' if dataset == 'scene_crossentropy' else 'MultiLogloss'\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file(dataset, 'train'),\n        '-t', data_file(dataset, 'test'),\n        '--column-description', data_file(dataset, 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_const_feature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_const_feature(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    train_path = yatest.common.test_output_path('train_small')\n    test_path = yatest.common.test_output_path('test_small')\n    train_dataset = np.loadtxt(data_file('adult', 'train_small'), dtype=str, delimiter='\\t')\n    test_dataset = np.loadtxt(data_file('adult', 'test_small'), dtype=str, delimiter='\\t')\n    train_dataset[:, 14] = '0'\n    test_dataset[:, 14] = '0'\n    np.savetxt(train_path, train_dataset, fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_targets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantile_targets(loss_function, boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function + ':alpha=0.9',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_targets_exact",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantile_targets_exact(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Quantile:alpha=0.9',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantile_weights(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Quantile:alpha=0.9',\n        '-f', data_file('higgs', 'train_small'),\n        '-t', data_file('higgs', 'test_small'),\n        '--column-description', data_file('higgs', 'train_weight.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_categorical",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantile_categorical(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Quantile:alpha=0.9',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_exact_distributed",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantile_exact_distributed():\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='MAE',\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train.cd',\n        other_options=(\n            '--leaf-estimation-method', 'Exact',\n            '--boost-from-average', 'False'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_loss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_loss(custom_loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '-t', data_file('adult_crossentropy', 'test_proba'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_train_dir",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_train_dir():\n    output_model_path = 'model.bin'\n    output_eval_path = 'test.eval'\n    train_dir_path = 'trainDir'\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_train_on_binarized_equal_train_on_float",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_train_on_binarized_equal_train_on_float(boosting_type, qwise_loss):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_model_path_binarized = yatest.common.test_output_path('model_binarized.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    borders_file = yatest.common.test_output_path('borders.tsv')\n    borders_file_output = borders_file + '.out'\n    predictions_path_learn = yatest.common.test_output_path('predictions_learn.tsv')\n    predictions_path_learn_binarized = yatest.common.test_output_path('predictions_learn_binarized.tsv')\n    predictions_path_test = yatest.common.test_output_path('predictions_test.tsv')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_id_fstr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_id_fstr(boosting_type):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_fstr_path = yatest.common.test_output_path('fstr.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_names_logloss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_names_logloss(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_names_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_names_multiclass(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('precipitation_small', 'train_small'),\n        '-t', data_file('precipitation_small', 'test_small'),\n        '--column-description', data_file('precipitation_small', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_names_multiclass_last_class_missed",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_names_multiclass_last_class_missed(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('precipitation_small', 'train_small'),\n        '-t', data_file('precipitation_small', 'test_small'),\n        '--column-description', data_file('precipitation_small', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_names_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_names_multilabel():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiLogloss',\n        '-f', data_file('scene', 'train'),\n        '-t', data_file('scene', 'test'),\n        '--column-description', data_file('scene', 'train.cd'),\n        '--boosting-type', 'Plain',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_custom_metric_for_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_custom_metric_for_multilabel():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiLogloss',\n        '-f', data_file('scene', 'train'),\n        '-t', data_file('scene', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multilabel(cd, metrics):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiLogloss',\n        '-f', data_file('scene', 'train'),\n        '-t', data_file('scene', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_weight_logloss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_weight_logloss(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_weight_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_weight_multiclass(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_params_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_params_from_file(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_lost_class(boosting_type, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('cloudness_lost_class', 'train_small'),\n        '-t', data_file('cloudness_lost_class', 'test_small'),\n        '--column-description', data_file('cloudness_lost_class', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_class_weight_with_lost_class",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_class_weight_with_lost_class(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'MultiClass',\n        '-f', data_file('cloudness_lost_class', 'train_small'),\n        '-t', data_file('cloudness_lost_class', 'test_small'),\n        '--column-description', data_file('cloudness_lost_class', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_one_hot",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_one_hot(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_random_strength",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_random_strength(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_only_categorical_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_only_categorical_features(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult_all_categorical.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_weight_sampling_per_tree",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_weight_sampling_per_tree(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_allow_writing_files_and_used_ram_limit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_allow_writing_files_and_used_ram_limit(boosting_type, used_ram_limit, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--allow-writing-files', 'false',\n        '--used-ram-limit', used_ram_limit,\n        '--loss-function', 'Logloss',\n        '--max-ctr-complexity', '5',\n        '--depth', '7',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_with_permuted_columns",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_with_permuted_columns(ignored_features):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('airlines_5K', 'train'),\n        '-t', data_file('airlines_5K', 'test'),\n        '--column-description', data_file('airlines_5K', 'cd'),\n        '--has-header',\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_subsample_per_tree",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_subsample_per_tree(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_subsample_per_tree_level",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_subsample_per_tree_level(boosting_type, grow_policy, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_bagging_per_tree_level",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_bagging_per_tree_level(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_plain",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_plain(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_bootstrap(boosting_type, dev_score_calc_obj_block_size):\n    bootstrap_option = {\n        'no': ('--bootstrap-type', 'No',),\n        'bayes': ('--bootstrap-type', 'Bayesian', '--bagging-temperature', '0.0',),\n        'bernoulli': ('--bootstrap-type', 'Bernoulli', '--subsample', '1.0',)\n    }\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_json_logging",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_json_logging():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    json_path = yatest.common.test_output_path('catboost_training.json')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_json_logging_metric_period",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_json_logging_metric_period():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    json_path = yatest.common.test_output_path('catboost_training.json')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_output_columns_format",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_output_columns_format():\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        # Intentionally skipped: -t ...\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_output_auxiliary_columns_format",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_output_auxiliary_columns_format():\n    model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '-f', data_file('scene', 'train'),\n        '--cd', data_file('scene', 'train_1.cd'),\n        '-t', data_file('scene', 'train'),\n        '-i', '10',\n        '-T', '4',\n        '-m', model_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_period",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_period():\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',\n        '-m', model_path,\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_weights_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_weights_output():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('adult_weight', 'train.cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_baseline_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_baseline_output():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult_weight', 'train_weight'),\n        '-t', data_file('adult_weight', 'test_weight'),\n        '--column-description', data_file('train_adult_baseline.cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_baseline_from_file_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_baseline_from_file_output():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    eval_0_path = yatest.common.test_output_path('test_0.eval')\n    eval_1_path = yatest.common.test_output_path('test_1.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '--learn-set', data_file('higgs', 'train_small'),\n        '--test-set', data_file('higgs', 'test_small'),\n        '--column-description', data_file('higgs', 'train_baseline.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_weight_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_weight_output():\n    model_path = yatest.common.test_output_path('model.bin')\n    fit_eval_path = yatest.common.test_output_path('test_0.eval')\n    calc_eval_path = yatest.common.test_output_path('test_1.eval')\n    fit_cmd = (\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'QueryRMSE',\n        '--learn-set', data_file('querywise', 'train'),\n        '--test-set', data_file('querywise', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_baseline_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiclass_baseline_from_file(boosting_type, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path_0 = yatest.common.test_output_path('test_0.eval')\n    output_eval_path_1 = yatest.common.test_output_path('test_1.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', data_file('precipitation_small', 'train_small'),\n        '-t', data_file('precipitation_small', 'train_small'),\n        '--column-description', data_file('precipitation_small', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_baseline_from_file_output_on_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_baseline_from_file_output_on_quantized_pool():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    eval_0_path = yatest.common.test_output_path('test_0.eval')\n    eval_1_path = yatest.common.test_output_path('test_1.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '--learn-set', 'quantized://' + data_file('higgs', 'train_small_x128_greedylogsum.bin'),\n        '--test-set', 'quantized://' + data_file('higgs', 'train_small_x128_greedylogsum.bin'),\n        '--column-description', data_file('higgs', 'train_baseline.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_query_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_query_output():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_subgroup_output",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_subgroup_output():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd.subgroup_id'),\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_without_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_without_cat_features(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cox_regression",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_cox_regression():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_calc_path = yatest.common.test_output_path('test.calc')\n    output_metric_path = yatest.common.test_output_path('test.metric')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Cox',\n        '-f', data_file('patients', 'train'),\n        '-t', data_file('patients', 'test'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "make_deterministic_train_cmd",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def make_deterministic_train_cmd(loss_function, pool, train, test, cd, schema='', test_schema='', dev_score_calc_obj_block_size=None, other_options=(), iterations=None):\n    pool_path = schema + data_file(pool, train)\n    test_path = test_schema + data_file(pool, test)\n    cd_path = data_file(pool, cd)\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', pool_path,\n        '-t', test_path,\n        '--column-description', cd_path,\n        '-i', str(iterations) if iterations is not None else '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "run_dist_train",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def run_dist_train(cmd, output_file_switch='--eval-file'):\n    eval_0_path = yatest.common.test_output_path('test_0.eval')\n    execute_catboost_fit('CPU', cmd + (output_file_switch, eval_0_path,))\n    eval_1_path = yatest.common.test_output_path('test_1.eval')\n    execute_dist_train(cmd + (output_file_switch, eval_1_path,))\n    eval_0 = np.loadtxt(eval_0_path, dtype='float', delimiter='\\t', skiprows=1)\n    eval_1 = np.loadtxt(eval_1_path, dtype='float', delimiter='\\t', skiprows=1)\n    assert (np.allclose(eval_0, eval_1, atol=1e-5))\n    return eval_1_path\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_with_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_with_weights(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train_weight.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_with_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_with_baseline(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train_baseline.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_multiclass(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='MultiClass',\n        pool='cloudness_small',\n        train='train_small',\n        test='test_small',\n        cd='train_float.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_multiclass_weight",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_multiclass_weight(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='MultiClass',\n        pool='cloudness_small',\n        train='train_small',\n        test='test_small',\n        cd='train_float_weight.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_quantized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_quantized(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small_x128_greedylogsum.bin',\n        test='test_small',\n        cd='train.cd',\n        schema='quantized://',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('-x', '128', '--feature-border-type', 'GreedyLogSum'))))]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_quantized_groupid",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_quantized_groupid(dev_score_calc_obj_block_size, pairs_file, target):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function=target,\n        pool='querywise',\n        train='train_x128_greedylogsum_aqtaa.bin',\n        test='test',\n        cd='train.cd.query_id',\n        schema='quantized://',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('-x', '128', '--feature-border-type', 'GreedyLogSum',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_quantized_group_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_quantized_group_weights(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='QueryRMSE',\n        pool='querywise',\n        train='train.quantized',\n        test='test',\n        cd='train.cd.query_id',\n        schema='quantized://',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('-x', '128', '--feature-border-type', 'GreedyLogSum',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_quantized_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_quantized_baseline(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small_x128_greedylogsum.bin',\n        test='train_small_x128_greedylogsum.bin',\n        cd='train_baseline.cd',\n        schema='quantized://',\n        test_schema='quantized://',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_queryrmse",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_queryrmse(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='QueryRMSE',\n        pool='querywise',\n        train='train',\n        test='test',\n        cd='train.cd.subgroup_id',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_subgroup",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_subgroup(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='QueryRMSE',\n        pool='querywise',\n        train='train',\n        test='test',\n        cd='train.cd.subgroup_id',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('--eval-metric', 'PFound')\n    ), output_file_switch='--test-err-log'))]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_pairlogit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_pairlogit(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='PairLogit',\n        pool='querywise',\n        train='train',\n        test='test',\n        cd='train.cd.query_id',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('--learn-pairs', data_file('querywise', 'train.pairs'))\n    )))]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_pairlogitpairwise",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_pairlogitpairwise(pairs_file):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='PairLogitPairwise',\n        pool='querywise',\n        train='train',\n        test='test',\n        cd='train.cd',\n        other_options=('--learn-pairs', data_file('querywise', pairs_file))\n    )))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_querysoftmax",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_querysoftmax(dev_score_calc_obj_block_size):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='QuerySoftMax',\n        pool='querywise',\n        train='train',\n        test='test',\n        cd='train.cd.subgroup_id',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size)))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize('loss_func', ['Logloss', 'RMSE'])",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_auc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_auc(loss_func):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function=loss_func,\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train_baseline.cd',\n        other_options=('--eval-metric', 'AUC')\n    ), output_file_switch='--test-err-log'))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_auc_weight",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_auc_weight(loss_func):\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function=loss_func,\n        pool='higgs',\n        train='train_small',\n        test='test_small',\n        cd='train_weight.cd',\n        other_options=('--eval-metric', 'AUC', '--boost-from-average', '0')\n    ), output_file_switch='--test-err-log'))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_snapshot",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_snapshot(schema, train):\n    train_cmd = make_deterministic_train_cmd(\n        loss_function='RMSE',\n        pool='higgs',\n        train=train,\n        test='test_small',\n        schema=schema,\n        cd='train.cd')\n    eval_10_trees_path = yatest.common.test_output_path('10_trees.eval')\n    execute_catboost_fit('CPU', train_cmd + ('-i', '10', '--eval-file', eval_10_trees_path,))",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_yetirank",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_yetirank():\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='YetiRank',\n        pool='querywise',\n        train='repeat_same_query_8_times',\n        test='repeat_same_query_8_times',\n        cd='train.cd'\n    ), output_file_switch='--test-err-log'))]\n@pytest.mark.xfail(sys.platform == \"win32\", reason=\"known issue with getting worker addresses\")\n@pytest.mark.parametrize(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_with_cat_features(dev_score_calc_obj_block_size, one_hot_max_size):\n    cmd = make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='adult',\n        train='train_small',\n        test='test_small',\n        cd='train.cd',\n        dev_score_calc_obj_block_size=dev_score_calc_obj_block_size,\n        other_options=('--one-hot-max-size', str(one_hot_max_size))\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dist_train_overfitting_detector",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dist_train_overfitting_detector(od_type):\n    if od_type == 'Iter':\n        other_options = ('--od-type', 'Iter', '--od-wait', '3')\n    else:\n        other_options = ('--od-type', 'IncToDec', '--od-pval', '10.0e-2')\n    return [local_canonical_file(run_dist_train(make_deterministic_train_cmd(\n        loss_function='Logloss',\n        pool='higgs',\n        train='train_small',\n        test='test_small',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_no_target():\n    train_path = yatest.common.test_output_path('train')\n    cd_path = yatest.common.test_output_path('train.cd')\n    pairs_path = yatest.common.test_output_path('pairs')\n    np.savetxt(train_path, [[0], [1], [2], [3], [4]], delimiter='\\t', fmt='%.4f')\n    np.savetxt(cd_path, [('0', 'Num')], delimiter='\\t', fmt='%s')\n    np.savetxt(pairs_path, [[0, 1], [0, 2], [0, 3], [2, 4]], delimiter='\\t', fmt='%i')\n    cmd = (\n        '-f', train_path,\n        '--cd', cd_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_const_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_const_target(loss_function):\n    train_path = yatest.common.test_output_path('train')\n    cd_path = yatest.common.test_output_path('train.cd')\n    np.savetxt(\n        train_path,\n        [[0, 0, 0],\n         [0, 0, 1],\n         [0, 0, 2],\n         [0, 0, 3],\n         [0, 0, 4]],",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_negative_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_negative_weights():\n    train_path = yatest.common.test_output_path('train')\n    cd_path = yatest.common.test_output_path('train.cd')\n    open(cd_path, 'wt').write('0\\tNum\\n1\\tWeight\\n2\\tTarget\\n')\n    np.savetxt(train_path, [\n        [0, 1, 2],\n        [1, -1, 1]], delimiter='\\t', fmt='%.4f')\n    cmd = ('-f', train_path,\n           '--cd', cd_path,\n           )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_zero_learning_rate",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_zero_learning_rate():\n    train_path = yatest.common.test_output_path('train')\n    cd_path = yatest.common.test_output_path('train.cd')\n    open(cd_path, 'wt').write(\n        '0\\tNum\\n'\n        '1\\tNum\\n'\n        '2\\tTarget\\n')\n    np.savetxt(train_path, [\n        [0, 1, 2],\n        [1, 1, 1]], delimiter='\\t', fmt='%.4f')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "do_test_eval_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def do_test_eval_metrics(metric, metric_period, train, test, cd, loss_function, additional_train_params=(), additional_eval_params=()):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_path = yatest.common.test_output_path('output.tsv')\n    cmd = (\n        '--loss-function', loss_function,\n        '--eval-metric', metric,\n        '-f', train,\n        '-t', test,\n        '--column-description', cd,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics(metric, metric_period):\n    if metric == 'PFound':\n        train, test, cd, loss_function = data_file('querywise', 'train'), data_file('querywise', 'test'), data_file('querywise', 'train.cd'), 'QueryRMSE'\n    elif metric == 'PairAccuracy':\n        # note: pairs are autogenerated\n        train, test, cd, loss_function = data_file('querywise', 'train'), data_file('querywise', 'test'), data_file('querywise', 'train.cd'), 'PairLogitPairwise'\n    else:\n        train, test, cd, loss_function = data_file('adult', 'train_small'), data_file('adult', 'test_small'), data_file('adult', 'train.cd'), 'Logloss'\n    return do_test_eval_metrics(metric, metric_period, train, test, cd, loss_function)\n@pytest.mark.parametrize('metric', ['QueryRMSE', 'PFound', 'PairAccuracy'])",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_groupweights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_groupweights(metric):\n    if metric == 'PairAccuracy':\n        # note: pairs are autogenerated\n        train, test, cd, loss_function = data_file('querywise', 'train'), data_file('querywise', 'test'), data_file('querywise', 'train.cd.group_weight'), 'PairLogitPairwise'\n    else:\n        train, test, cd, loss_function = data_file('querywise', 'train'), data_file('querywise', 'test'), data_file('querywise', 'train.cd.group_weight'), 'QueryRMSE'\n    metric_period = '1'\n    return do_test_eval_metrics(metric, metric_period, train, test, cd, loss_function)\ndef test_eval_metrics_with_target_border():\n    return do_test_eval_metrics(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_target_border():\n    return do_test_eval_metrics(\n        metric='Logloss',\n        metric_period='1',\n        train=data_file('adult_not_binarized', 'train_small'),\n        test=data_file('adult_not_binarized', 'test_small'),\n        cd=data_file('adult_not_binarized', 'train.cd'),\n        loss_function='Logloss',\n        additional_train_params=('--target-border', '0.4')\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_class_weights():\n    return do_test_eval_metrics(\n        metric='Logloss',\n        metric_period='1',\n        train=data_file('adult', 'train_small'),\n        test=data_file('adult', 'test_small'),\n        cd=data_file('adult', 'train.cd'),\n        loss_function='Logloss',\n        additional_train_params=('--class-weights', '0.25,0.75')\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_target_border_and_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_target_border_and_class_weights():\n    return do_test_eval_metrics(\n        metric='Logloss',\n        metric_period='1',\n        train=data_file('adult_not_binarized', 'train_small'),\n        test=data_file('adult_not_binarized', 'test_small'),\n        cd=data_file('adult_not_binarized', 'train.cd'),\n        loss_function='Logloss',\n        additional_train_params=('--target-border', '0.4', '--class-weights', '0.25,0.75')\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_boost_from_average_and_model_shrinkage",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_boost_from_average_and_model_shrinkage(config):\n    mode, rate, lr = config\n    train = data_file('higgs', 'train_small')\n    test = data_file('higgs', 'test_small')\n    cd = data_file('higgs', 'train.cd')\n    loss_function = 'Logloss'\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_binarized_target",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_binarized_target(metrics):\n    train = data_file('adult', 'train_small')\n    test = data_file('adult', 'test_small')\n    cd = data_file('adult', 'train.cd')\n    loss_function = 'Logloss'\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', train,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_multiclass(metric, loss_function, dataset, metric_period):\n    if metric in MULTICLASS_LOSSES and metric != loss_function:\n        # MultiClass and MultiClassOneVsAll are incompatible\n        return\n    train, test, cd = data_file(dataset, 'train_small'), data_file(dataset, 'test_small'), data_file(dataset, 'train.cd')\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_path = yatest.common.test_output_path('output.tsv')\n    cmd = (\n        '--loss-function', loss_function,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_multilabel(metric, dataset, metric_period):\n    train, test, cd = data_file(dataset, 'train'), data_file(dataset, 'test'), data_file(dataset, 'train.cd')\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_path = yatest.common.test_output_path('output.tsv')\n    loss_function = 'MultiLogloss'\n    cmd = (\n        '--loss-function', loss_function,\n        '--custom-metric', metric,\n        '-f', train,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_baseline(metric_period, metric):\n    train = data_file('adult_weight', 'train_weight')\n    test = data_file('adult_weight', 'test_weight')\n    cd = data_file('train_adult_baseline.cd')\n    output_model_path = yatest.common.test_output_path('model.bin')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    eval_path = yatest.common.test_output_path('output.tsv')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '--eval-metric', metric,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_multiclass_with_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_multiclass_with_baseline(metric_period, metric):\n    labels = [0, 1, 2, 3]\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Baseline'], [2, 'Baseline'], [3, 'Baseline'], [4, 'Baseline']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    output_model_path = yatest.common.test_output_path('model.bin')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_ctr_leaf_count_limit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_ctr_leaf_count_limit(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_boost_from_average",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_boost_from_average(boosting_type, grow_policy, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_calc_eval_path = yatest.common.test_output_path('test_calc.eval')\n    output_eval_path_with_avg = yatest.common.test_output_path('test_avg.eval')\n    output_eval_path_with_baseline = yatest.common.test_output_path('test_baseline.eval')\n    baselined_train = yatest.common.test_output_path('baselined_train')\n    baselined_test = yatest.common.test_output_path('baselined_test')\n    baselined_cd = yatest.common.test_output_path('baselined.cd')\n    train_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_non_additive_metric",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_non_additive_metric(eval_period):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_eq_calc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_eq_calc(boosting_type, grow_policy, max_ctr_complexity):\n    one_hot_max_size = 2\n    cd_path = yatest.common.test_output_path('cd.txt')\n    train_path = yatest.common.test_output_path('train.txt')\n    test_path = yatest.common.test_output_path('test.txt')\n    model_path = yatest.common.test_output_path('model.bin')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    np.savetxt(cd_path, [['0', 'Target'],\n                         ['1', 'Categ'],",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "do_test_object_importances",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def do_test_object_importances(pool, loss_function, additional_train_params):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    object_importances_path = yatest.common.test_output_path('object_importances.tsv')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', data_file(pool, 'train_small'),\n        '-t', data_file(pool, 'test_small'),\n        '--column-description', data_file(pool, 'train.cd'),\n        '-i', '10',\n        '--boosting-type', 'Plain',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_object_importances",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_object_importances(loss_function, leaf_estimation_iteration):\n    additional_train_params = (\n        '--leaf-estimation-method', 'Gradient',\n        '--leaf-estimation-iterations', leaf_estimation_iteration\n    )\n    return do_test_object_importances(\n        pool='adult',\n        loss_function=loss_function,\n        additional_train_params=additional_train_params\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_object_importances_with_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_object_importances_with_target_border():\n    return do_test_object_importances(\n        pool='adult_not_binarized',\n        loss_function='Logloss',\n        additional_train_params=('--target-border', '0.4')\n    )\ndef test_object_importances_with_class_weights():\n    return do_test_object_importances(\n        pool='adult',\n        loss_function='Logloss',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_object_importances_with_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_object_importances_with_class_weights():\n    return do_test_object_importances(\n        pool='adult',\n        loss_function='Logloss',\n        additional_train_params=('--class-weights', '0.25,0.75')\n    )\ndef test_object_importances_with_target_border_and_class_weights():\n    return do_test_object_importances(\n        pool='adult_not_binarized',\n        loss_function='Logloss',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_object_importances_with_target_border_and_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_object_importances_with_target_border_and_class_weights():\n    return do_test_object_importances(\n        pool='adult_not_binarized',\n        loss_function='Logloss',\n        additional_train_params=('--target-border', '0.4', '--class-weights', '0.25,0.75')\n    )\n# Create `num_tests` test files from `test_input_path`.\ndef split_test_to(num_tests, test_input_path):\n    test_input_lines = open(test_input_path).readlines()\n    test_paths = [yatest.common.test_output_path('test{}'.format(i)) for i in range(num_tests)]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "split_test_to",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def split_test_to(num_tests, test_input_path):\n    test_input_lines = open(test_input_path).readlines()\n    test_paths = [yatest.common.test_output_path('test{}'.format(i)) for i in range(num_tests)]\n    for testno in range(num_tests):\n        test_path = test_paths[testno]\n        test_lines = test_input_lines[testno::num_tests]\n        open(test_path, 'wt').write(''.join(test_lines))\n    return test_paths\n# Create a few shuffles from list of test files, for use with `-t` option.\ndef create_test_shuffles(test_paths, seed=20181219, prng=None):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "create_test_shuffles",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def create_test_shuffles(test_paths, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=seed)\n    num_tests = len(test_paths)\n    num_shuffles = num_tests  # if num_tests < 3 else num_tests * (num_tests - 1)\n    test_shuffles = set()\n    while len(test_shuffles) < num_shuffles:\n        test_shuffles.add(tuple(prng.permutation(test_paths)))\n    return [','.join(shuffle) for shuffle in test_shuffles]\ndef fit_calc_cksum(fit_stem, calc_stem, test_shuffles):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "fit_calc_cksum",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def fit_calc_cksum(fit_stem, calc_stem, test_shuffles):\n    import hashlib\n    last_cksum = None\n    for i, shuffle in enumerate(test_shuffles):\n        model_path = yatest.common.test_output_path('model{}.bin'.format(i))\n        eval_path = yatest.common.test_output_path('eval{}.txt'.format(i))\n        execute_catboost_fit('CPU', fit_stem + (\n            '-t', shuffle,\n            '-m', model_path,\n        ))",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets_order_independent",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_eval_sets_order_independent(boosting_type, num_tests):\n    train_path = data_file('adult', 'train_small')\n    cd_path = data_file('adult', 'train.cd')\n    test_input_path = data_file('adult', 'test_small')\n    fit_stem = (\n        '--loss-function', 'RMSE',\n        '-f', train_path,\n        '--cd', cd_path,\n        '--boosting-type', boosting_type,\n        '-i', '5',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets_querywise_order_independent",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_eval_sets_querywise_order_independent(boosting_type, num_tests):\n    train_path = data_file('querywise', 'train')\n    cd_path = data_file('querywise', 'train.cd.query_id')\n    test_input_path = data_file('querywise', 'test')\n    fit_stem = (\n        '--loss-function', 'QueryRMSE',\n        '-f', train_path,\n        '--cd', cd_path,\n        '--boosting-type', boosting_type,\n        '-i', '5',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets_no_empty",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_eval_sets_no_empty():\n    train_path = data_file('adult', 'train_small')\n    cd_path = data_file('adult', 'train.cd')\n    test_input_path = data_file('adult', 'test_small')\n    fit_stem = ('--loss-function', 'RMSE',\n                '-f', train_path,\n                '--cd', cd_path,\n                '-i', '5',\n                '-T', '4',\n                '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_eval_sets(loss_function):\n    num_tests = 5\n    train_path = data_file('querywise', 'train')\n    cd_path = data_file('querywise', 'train.cd.query_id')\n    test_input_path = data_file('querywise', 'test')\n    eval_path = yatest.common.test_output_path('test.eval')\n    test_paths = list(reversed(split_test_to(num_tests, test_input_path)))\n    cmd = ('--loss-function', loss_function,\n           '-f', train_path,\n           '-t', ','.join(test_paths),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets_err_log",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiple_eval_sets_err_log():\n    num_tests = 3\n    train_path = data_file('querywise', 'train')\n    cd_path = data_file('querywise', 'train.cd.query_id')\n    test_input_path = data_file('querywise', 'test')\n    test_err_log_path = yatest.common.test_output_path('test-err.log')\n    json_log_path = yatest.common.test_output_path('json.log')\n    test_paths = reversed(split_test_to(num_tests, test_input_path))\n    cmd = ('--loss-function', 'RMSE',\n           '-f', train_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_const_cat_feature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_const_cat_feature(cat_value):\n    def make_a_set(nrows, value, seed=20181219, prng=None):\n        if prng is None:\n            prng = np.random.RandomState(seed=seed)\n        label = prng.randint(0, nrows, [nrows, 1])\n        feature = np.full([nrows, 1], value, dtype='|S{}'.format(len(value)))\n        return np.concatenate([label, feature], axis=1)\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target'], [1, 'Categ']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=20181219)",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_model_metadata",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_model_metadata():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '2',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_multiclass_with_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_multiclass_with_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    eval_path = yatest.common.test_output_path('eval.txt')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_extract_multiclass_labels_from_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_extract_multiclass_labels_from_class_names():\n    labels = ['a', 'b', 'c', 'd']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_save_class_labels_from_data",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_save_class_labels_from_data(loss_function):\n    labels = [10000000, 7, 0, 9999]\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    cmd = (\n        '--loss-function', loss_function,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_multiclass_labels_from_data",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_multiclass_labels_from_data(prediction_type):\n    labels = [10000000, 7, 0, 9999]\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_save_and_apply_multiclass_labels_from_classes_count",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_save_and_apply_multiclass_labels_from_classes_count(loss_function, prediction_type):\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, [1, 2], prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(100, 10, [0, 1, 2, 3], prng=prng), fmt='%s', delimiter='\\t')\n    eval_path = yatest.common.test_output_path('eval.txt')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_set_class_names_implicitly",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_set_class_names_implicitly():\n    INPUT_CLASS_LABELS = ['a', 'bc', '7.', '8.0', '19.2']\n    SAVED_CLASS_LABELS = ['19.2', '7.', '8.0', 'a', 'bc']\n    model_path = yatest.common.test_output_path('model.bin')\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, INPUT_CLASS_LABELS, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = yatest.common.test_output_path('test.txt')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_model_backward_compatibility",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multiclass_model_backward_compatibility(prediction_type):\n    model = catboost.CatBoost()\n    model.load_model(CANONICAL_CLOUDNESS_MINI_MULTICLASS_MODEL_PATH)\n    assert 'class_params' not in model.get_metadata()\n    pool = catboost.Pool(data_file('cloudness_small', 'train_small'),\n                         column_description=data_file('cloudness_small', 'train.cd'))\n    model.predict(data=pool, prediction_type='Class')\n    model.eval_metrics(data=pool, metrics=['Accuracy'])\n    output_path = yatest.common.test_output_path('out.txt')\n    calc_cmd = (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_learning_rate_auto_set",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_learning_rate_auto_set(boosting_type, use_best_model):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', use_best_model,\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_paths_with_dsv_scheme",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_paths_with_dsv_scheme():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', 'dsv://' + data_file('querywise', 'train'),\n        '-t', 'dsv://' + data_file('querywise', 'test'),\n        '--column-description', 'dsv://' + data_file('querywise', 'train.cd'),\n        '--boosting-type', 'Ordered',\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_skip_train",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_skip_train():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    json_log_path = yatest.common.test_output_path('json_log.json')\n    cmd = (\n        '--loss-function', 'QueryRMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-i', '20',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_weight",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_weight(boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    def run_catboost(train_path, test_path, cd_path, eval_path):\n        cmd = (\n            '--loss-function', 'YetiRank',\n            '-f', data_file('querywise', train_path),\n            '-t', data_file('querywise', test_path),\n            '--column-description', data_file('querywise', cd_path),\n            '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_weight_and_object_weight",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_weight_and_object_weight(boosting_type, grow_policy, loss_function, dev_score_calc_obj_block_size):\n    def run_catboost(train_path, test_path, cd_path, eval_path):\n        cmd = (\n            '--loss-function', loss_function,\n            '-f', data_file('querywise', train_path),\n            '-t', data_file('querywise', test_path),\n            '--column-description', data_file('querywise', cd_path),\n            '--boosting-type', boosting_type,\n            '--grow-policy', grow_policy,\n            '--dev-score-calc-obj-block-size', dev_score_calc_obj_block_size,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_snapshot_without_random_seed",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_snapshot_without_random_seed():\n    def run_catboost(iters, eval_path, additional_params=None):\n        cmd = [\n            '--loss-function', 'Logloss',\n            '--learning-rate', '0.5',\n            '-f', data_file('adult', 'train_small'),\n            '-t', data_file('adult', 'test_small'),\n            '--column-description', data_file('adult', 'train.cd'),\n            '-i', str(iters),\n            '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_snapshot_with_interval",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_snapshot_with_interval():\n    def run_with_timeout(cmd, timeout):\n        try:\n            execute_catboost_fit('CPU', cmd, timeout=timeout)\n        except ExecutionTimeoutError:\n            return True\n        return False\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_snapshot_with_different_params",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_snapshot_with_different_params():\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-T', '4',\n        '-i', '10',\n        '--snapshot-file', 'snapshot.cbp'\n    ]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_querysoftmax",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_querysoftmax(boosting_type, grow_policy, leaf_estimation_method, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'QuerySoftMax',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--boosting-type', boosting_type,\n        '--grow-policy', grow_policy,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_shap_verbose",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_shap_verbose():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_values_path = yatest.common.test_output_path('shapval')\n    output_log = yatest.common.test_output_path('log')\n    cmd_fit = [\n        '--loss-function', 'Logloss',\n        '--learning-rate', '0.5',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '250',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_shap_approximate",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_shap_approximate():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_values_path = yatest.common.test_output_path('shapval')\n    cmd_fit = [\n        '--loss-function', 'Logloss',\n        '--learning-rate', '0.5',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '250',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_shap_exact",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_shap_exact():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_values_path = yatest.common.test_output_path('shapval')\n    cmd_fit = [\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '--learning-rate', '0.5',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_sage_basic",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_sage_basic():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_values_path = yatest.common.test_output_path('sageval')\n    cmd_fit = [\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '--learning-rate', '0.5',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_sage_verbose",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_sage_verbose():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_values_path = yatest.common.test_output_path('sageval')\n    output_log = yatest.common.test_output_path('log')\n    cmd_fit = [\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '--learning-rate', '0.5',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_querywise_bayesian_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_querywise_bayesian_bootstrap(bagging_temperature, sampling_unit, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'RMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--bootstrap-type', 'Bayesian',\n        '--sampling-unit', sampling_unit,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_querywise_bernoulli_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_querywise_bernoulli_bootstrap(subsample, sampling_unit, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'RMSE',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--bootstrap-type', 'Bernoulli',\n        '--sampling-unit', sampling_unit,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairwise_bayesian_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairwise_bayesian_bootstrap(bagging_temperature, sampling_unit, loss_function, dev_score_calc_obj_block_size):\n    if loss_function == 'YetiRankPairwise' and sampling_unit == 'Group' and bagging_temperature == '1':\n        return pytest.xfail(reason='MLTOOLS-1801')\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_pairwise_bernoulli_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_pairwise_bernoulli_bootstrap(subsample, sampling_unit, loss_function, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '--learn-pairs', data_file('querywise', 'train.pairs'),\n        '--test-pairs', data_file('querywise', 'test.pairs'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_bad_metrics_combination",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_bad_metrics_combination(loss_function, metric):\n    BAD_PAIRS = {\n        'Logloss': ['RMSE', 'MultiClass', 'GroupQuantile'],\n        'RMSE': ['Logloss', 'MultiClass'],\n        'MultiClass': ['Logloss', 'RMSE', 'QuerySoftMax', 'PFound', 'GroupQuantile'],\n        'QuerySoftMax': ['RMSE', 'MultiClass', 'QueryRMSE', 'GroupQuantile'],\n        'QueryRMSE': ['Logloss', 'MultiClass', 'QuerySoftMax'],\n        'GroupQuantile': ['Logloss', 'MultiClass', 'QuerySoftMax'],\n        'YetiRank': ['Logloss', 'RMSE', 'MultiClass']\n    }",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_extra_commas",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_extra_commas(metric):\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-w', '0.03',\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "execute_fit_for_test_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def execute_fit_for_test_quantized_pool(loss_function, pool_path, test_path, cd_path, eval_path,\n                                        border_count=128, other_options=()):\n    model_path = yatest.common.test_output_path('model.bin')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', pool_path,\n        '-t', test_path,\n        '--cd', cd_path,\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool():\n    test_path = data_file('higgs', 'test_small')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='Logloss',\n        pool_path=data_file('higgs', 'train_small'),\n        test_path=test_path,\n        cd_path=data_file('higgs', 'train.cd'),\n        eval_path=tsv_eval_path\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool_ignored_features():\n    test_path = data_file('higgs', 'test_small')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='Logloss',\n        pool_path=data_file('higgs', 'train_small'),\n        test_path=test_path,\n        cd_path=data_file('higgs', 'train.cd'),\n        eval_path=tsv_eval_path,\n        other_options=('-I', '5',)",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_groupid",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool_groupid():\n    test_path = data_file('querywise', 'test')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='PairLogitPairwise',\n        pool_path=data_file('querywise', 'train'),\n        test_path=test_path,\n        cd_path=data_file('querywise', 'train.cd.query_id'),\n        eval_path=tsv_eval_path\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_ignored_during_quantization",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool_ignored_during_quantization():\n    test_path = data_file('querywise', 'test')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='PairLogitPairwise',\n        pool_path=data_file('querywise', 'train'),\n        test_path=test_path,\n        cd_path=data_file('querywise', 'train.cd.query_id'),\n        eval_path=tsv_eval_path,\n        other_options=('-I', '18-36',)",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_quantized_test",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool_quantized_test():\n    test_path = data_file('querywise', 'test')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='PairLogitPairwise',\n        pool_path=data_file('querywise', 'train'),\n        test_path=test_path,\n        cd_path=data_file('querywise', 'train.cd.query_id'),\n        eval_path=tsv_eval_path\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_with_large_grid",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_pool_with_large_grid():\n    test_path = data_file('querywise', 'test')\n    tsv_eval_path = yatest.common.test_output_path('tsv.eval')\n    execute_fit_for_test_quantized_pool(\n        loss_function='PairLogitPairwise',\n        pool_path=data_file('querywise', 'train'),\n        test_path=test_path,\n        cd_path=data_file('querywise', 'train.cd.query_id'),\n        eval_path=tsv_eval_path,\n        border_count=1024",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_learn_without_header_eval_with_header",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_learn_without_header_eval_with_header():\n    train_path = yatest.common.test_output_path('airlines_without_header')\n    with open(data_file('airlines_5K', 'train'), 'r') as with_header_file:\n        with open(train_path, 'w') as without_header_file:\n            without_header_file.writelines(with_header_file.readlines()[1:])\n    model_path = yatest.common.test_output_path('model.bin')\n    cmd_fit = (\n        '--loss-function', 'Logloss',\n        '-f', train_path,\n        '--cd', data_file('airlines_5K', 'cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_weights_file",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_weights_file():\n    first_eval_path = yatest.common.test_output_path('first.eval')\n    second_eval_path = yatest.common.test_output_path('second.eval')\n    def run_catboost(eval_path, cd_file, is_additional_query_weights):\n        cmd = [\n            '--use-best-model', 'false',\n            '--loss-function', 'QueryRMSE',\n            '-f', data_file('querywise', 'train'),\n            '-t', data_file('querywise', 'test'),\n            '--column-description', data_file('querywise', cd_file),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_weights_file_quantized",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_weights_file_quantized():\n    first_eval_path = yatest.common.test_output_path('first.eval')\n    second_eval_path = yatest.common.test_output_path('second.eval')\n    def run_catboost(eval_path, train, test, is_additional_query_weights):\n        cmd = [\n            '--use-best-model', 'false',\n            '--loss-function', 'QueryRMSE',\n            '-f', 'quantized://' + data_file('querywise', train),\n            '-t', 'quantized://' + data_file('querywise', test),\n            '-i', '5',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_mode_roc",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_mode_roc():\n    eval_path = yatest.common.test_output_path('eval.tsv')\n    output_roc_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_convert_model_to_json",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_convert_model_to_json(pool):\n    output_model_path = yatest.common.test_output_path('model')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', data_file(pool, 'train_small'),\n        '-t', data_file(pool, 'test_small'),\n        '--column-description', data_file(pool, 'train.cd'),\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_adult_pool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_adult_pool(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    quantized_train_file = 'quantized://' + data_file('quantized_adult', 'train.qbin')\n    quantized_test_file = 'quantized://' + data_file('quantized_adult', 'test.qbin')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function,\n        '-f', quantized_train_file,\n        '-t', quantized_test_file,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_with_one_thread",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_quantized_with_one_thread(boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    quantized_train_file = 'quantized://' + data_file('querywise', 'train.quantized')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', quantized_train_file,\n        '--boosting-type', boosting_type,\n        '-i', '10',\n        '-w', '0.03',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_result_on_different_pool_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_result_on_different_pool_type():\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_quantized_eval_path = yatest.common.test_output_path('test.eval.quantized')\n    def run_catboost(train, test, eval_path):\n        cmd = (\n            '--use-best-model', 'false',\n            '--loss-function', 'Logloss',\n            '--border-count', '128',\n            '-f', train,\n            '-t', test,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_on_different_pool_type",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_on_different_pool_type():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    output_quantized_eval_path = yatest.common.test_output_path('test.eval.quantized')\n    def get_pool_path(set_name, is_quantized=False):\n        path = data_file('querywise', set_name)\n        return 'quantized://' + path + '.quantized' if is_quantized else path\n    cd_file = data_file('querywise', 'train.cd')\n    cmd = (\n        '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_output_column_by_idx",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_output_column_by_idx():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn = data_file('black_friday', 'train')\n    test = data_file('black_friday', 'test')\n    cd = data_file('black_friday', 'cd')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '--learn-set', learn,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_broken_dsv_format",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_broken_dsv_format(dataset_name, loss_function, has_pairs, has_group_weights):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    # iterations and threads are specified just to finish fast if test is xpass\n    cmd = (\n        '--loss-function', loss_function,\n        '--learn-set', data_file('broken_format', dataset_name, 'train'),\n        '--test-set', data_file('broken_format', dataset_name, 'test'),\n        '--column-description', data_file('broken_format', dataset_name, 'train.cd'),\n        '-i', '1',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_groupwise_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_groupwise_with_cat_features(compressed_data, loss_function, eval_metric, boosting_type):\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    cmd = (\n        '--loss-function', loss_function,\n        '-f', os.path.join(compressed_data.name, 'mslr_web1k', 'train'),\n        '-t', os.path.join(compressed_data.name, 'mslr_web1k', 'test'),\n        '--column-description', os.path.join(compressed_data.name, 'mslr_web1k', 'cd.with_cat_features'),\n        '--boosting-type', boosting_type,\n        '-i', '100',\n        '-T', '8',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_gradient_walker",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_gradient_walker():\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '20',\n        '-T', '4',\n        '--eval-file', output_eval_path,\n        '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_groupwise_with_bad_one_hot_max_size",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_groupwise_with_bad_one_hot_max_size(loss_function):\n    cmd = (\n        '--loss-function', loss_function,\n        '--has-header',\n        '-f', data_file('black_friday', 'train'),\n        '-t', data_file('black_friday', 'test'),\n        '--column-description', data_file('black_friday', 'cd'),\n        '--boosting-type', 'Plain',\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_load_quantized_pool_with_double_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_load_quantized_pool_with_double_baseline():\n    # Dataset with 3 random columns, first column is Target, seconds columns is Num, third column\n    # is Baseline.\n    #\n    # There are only 10 rows in dataset.\n    cmd = (\n        '-f', 'quantized://' + data_file('quantized_with_baseline', 'dataset.qbin'),\n        '-i', '10')\n    execute_catboost_fit('CPU', cmd)\ndef test_write_predictions_to_streams():",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_write_predictions_to_streams",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_write_predictions_to_streams():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    calc_output_eval_path_redirected = yatest.common.test_output_path('calc_test.eval')\n    cmd = (\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--eval-file', output_eval_path,\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_mvs_bootstrap",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_mvs_bootstrap(boosting_type):\n    def run_catboost(eval_path, mvs_sample_rate):\n        cmd = [\n            '--use-best-model', 'false',\n            '--allow-writing-files', 'false',\n            '--loss-function', 'Logloss',\n            '--max-ctr-complexity', '5',\n            '-f', data_file('airlines_5K', 'train'),\n            '-t', data_file('airlines_5K', 'test'),\n            '--column-description', data_file('airlines_5K', 'cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_simple_ctr",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_simple_ctr():\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    simple_ctr = ','.join((\n        'Borders:TargetBorderCount=15',\n        'Buckets:TargetBorderCount=15',\n        'Borders:TargetBorderType=MinEntropy',\n        'Counter:CtrBorderCount=20',\n    ))\n    execute_catboost_fit('CPU', (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_output_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_output_options():\n    output_options_path = 'training_options.json'\n    train_dir = 'catboost_info'\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_target_border():\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('querywise', 'train'),\n        '-t', data_file('querywise', 'test'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-i', '20',\n        '-T', '4',\n        '--eval-file', output_eval_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_monotonic_constraint",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_monotonic_constraint():\n    train_pool = catboost.Pool(\n        data_file('higgs', 'train_small'),\n        column_description=data_file('higgs', 'train.cd')\n    )\n    test_pool = catboost.Pool(\n        data_file('higgs', 'test_small'),\n        column_description=data_file('higgs', 'train.cd')\n    )\n    monotone_constraints = [0, 0, 1, -1, 0, 0, 1, 0, -1, 1, 1, -1, 0, 1, 0, 0, -1, 1, 1, -1, 0, 0, 0, 0, 0, -1, 0, -1]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_monotone_constraints",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_different_formats_of_monotone_constraints():\n    eval_path = yatest.common.test_output_path('eval.tsv')\n    eval_path_with_monotone1 = yatest.common.test_output_path('eval_monotone1.tsv')\n    eval_path_with_monotone2 = yatest.common.test_output_path('eval_monotone2.tsv')\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--cd', data_file('adult', 'train_with_id.cd'),\n        '-i', '20'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_equal_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_equal_feature_names():\n    with pytest.raises(yatest.common.ExecutionError):\n        execute_catboost_fit('CPU', (\n            '--loss-function', 'RMSE',\n            '-f', data_file('querywise', 'train'),\n            '--column-description', data_file('querywise', 'train.cd.equal_names'),\n        ))\ndef enumerate_eval_feature_output_dirs(eval_mode, set_count, offset, fold_count, only_baseline=False):\n    if eval_mode == 'OneVsOthers':\n        baseline = 'Baseline_set_{set_idx}_fold_{fold_idx}'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "enumerate_eval_feature_output_dirs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def enumerate_eval_feature_output_dirs(eval_mode, set_count, offset, fold_count, only_baseline=False):\n    if eval_mode == 'OneVsOthers':\n        baseline = 'Baseline_set_{set_idx}_fold_{fold_idx}'\n    else:\n        baseline = 'Baseline_fold_{fold_idx}'\n    if not only_baseline:\n        testing = 'Testing_set_{set_idx}_fold_{fold_idx}'\n    dirs = []\n    for set_idx in range(set_count):\n        for fold_idx in range(offset, offset + fold_count):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature(eval_mode, features_to_eval, offset):\n    output_eval_path = yatest.common.test_output_path('feature.eval')\n    test_err_log = 'test_error.log'\n    fstr_file = 'fstrs'\n    train_dir = yatest.common.test_output_path('')\n    fold_count = 2\n    cmd = (\n        CATBOOST_PATH,\n        'eval-feature',\n        '--loss-function', 'RMSE',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_empty_feature_set",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_empty_feature_set(offset):\n    output_eval_path = yatest.common.test_output_path('feature.eval')\n    test_err_log = 'test_error.log'\n    fstr_file = 'fstrs'\n    train_dir = yatest.common.test_output_path('')\n    fold_count = 2\n    eval_mode = 'OneVsNone'\n    cmd = (\n        CATBOOST_PATH,\n        'eval-feature',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_timesplit",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_timesplit(eval_mode, fold_size_unit):\n    output_eval_path = yatest.common.test_output_path('feature.eval')\n    test_err_log = 'test_error.log'\n    fstr_file = 'fstrs'\n    train_dir = yatest.common.test_output_path('')\n    fold_count = 2\n    features_to_eval = '2-5;10-15'\n    offset = 2\n    fold_size = 500\n    cmd = (",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_snapshot",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_snapshot(eval_mode, features_to_eval, offset, fstr_mode):\n    test_err_log = 'test_error.log'\n    fstr_file = 'fstrs'\n    model_file = 'model.bin'\n    fold_count = 2\n    snapshot_interval = 1\n    def make_cmd(summary, train_dir):\n        cmd = (\n            CATBOOST_PATH,\n            'eval-feature',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_snapshot_wrong_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_snapshot_wrong_options():\n    summary = yatest.common.test_output_path('eval_feature_summary')\n    snapshot = yatest.common.test_output_path('eval_feature_snapshot')\n    def make_cmd(fold_size):\n        return (\n            CATBOOST_PATH,\n            'eval-feature',\n            '--loss-function', 'RMSE',\n            '-f', data_file('querywise', 'train'),\n            '--cd', data_file('querywise', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_parse_timestamps",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_parse_timestamps():\n    summary = yatest.common.test_output_path('eval_feature_summary')\n    def make_cmd(timestamps_file):\n        return (\n            CATBOOST_PATH,\n            'eval-feature',\n            '--loss-function', 'QueryRMSE',\n            '-f', data_file('querywise', 'train'),\n            '--cd', data_file('querywise', 'train.cd'),\n            '-i', '600',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_feature_relative_fold_size",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_feature_relative_fold_size():\n    summary = yatest.common.test_output_path('eval_feature_summary')\n    def make_cmd():\n        return (\n            CATBOOST_PATH,\n            'eval-feature',\n            '--loss-function', 'QueryRMSE',\n            '-f', data_file('querywise', 'train'),\n            '--cd', data_file('querywise', 'train.cd'),\n            '-i', '100',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_metric_description",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_metric_description(dataset_has_weights, eval_metric_loss, eval_metric_use_weights, custom_metric_loss, custom_metric_use_weights):\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    if dataset_has_weights:\n        train_pool_filename = data_file('adult_weight', 'train_weight')\n        test_pool_filename = data_file('adult_weight', 'test_weight')\n        pool_cd_filename = data_file('adult_weight', 'train.cd')\n    else:\n        train_pool_filename = data_file('adult', 'train_small')\n        test_pool_filename = data_file('adult', 'test_small')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_leafwise_scoring",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_leafwise_scoring():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '-r', '0',\n        '--learn-err-log', learn_error_path\n    ]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_group_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_group_features():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_predictions_path = yatest.common.test_output_path('test_predictions.tsv')\n    model_path = yatest.common.test_output_path('model.bin')\n    fit_cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '-r', '0',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_binclass_probability_threshold",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_binclass_probability_threshold():\n    test_predictions_path = yatest.common.test_output_path('test_predictions.tsv')\n    model_path = yatest.common.test_output_path('model.bin')\n    probability_threshold = '0.8'\n    fit_cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '10',\n        '-m', model_path",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_model_sum",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_model_sum(grow_policy, loss_function):\n    model_path = yatest.common.test_output_path('model.bin')\n    model_eval = yatest.common.test_output_path('model_eval.txt')\n    pool = 'adult'\n    execute_catboost_fit('CPU', [\n        '--loss-function', loss_function,\n        '-f', data_file(pool, 'train_small'),\n        '--cd', data_file(pool, 'train.cd'),\n        '-i', '10',\n        '-m', model_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_model_sum_with_multiple_target_classifiers",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_model_sum_with_multiple_target_classifiers():\n    model_0_path = yatest.common.test_output_path('model_0.bin')\n    model_1_path = yatest.common.test_output_path('model_1.bin')\n    model_2_path = yatest.common.test_output_path('model_2.bin')\n    simple_ctr = ','.join((\n        'Borders:TargetBorderCount=15',\n        'Buckets:TargetBorderCount=15',\n        'Borders:TargetBorderType=MinEntropy',\n        'Counter:CtrBorderCount=20',\n    ))",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_external_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_external_feature_names():\n    fstr_cd_with_id_path = yatest.common.test_output_path('fstr_cd_with_id.tsv')\n    fstr_cd_without_id_path = yatest.common.test_output_path('fstr_cd_without_id.tsv')\n    for cd_has_feature_names in [False, True]:\n        if cd_has_feature_names:\n            cd_file = data_file('adult', 'train_with_id.cd')\n            fstr_path = fstr_cd_with_id_path\n        else:\n            cd_file = data_file('adult', 'train.cd')\n            fstr_path = fstr_cd_without_id_path",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_diffusion_temperature",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_diffusion_temperature():\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '-r', '0',\n        '--langevin', 'True',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_model_shrink_correct",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_model_shrink_correct(config):\n    mode, rate, lr = config\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '-r', '0',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_model_shrink_incorrect",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_model_shrink_incorrect(config):\n    mode, rate, lr = config\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = [\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--cd', data_file('adult', 'train.cd'),\n        '-i', '50',\n        '-r', '0',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_total_f1_params",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_total_f1_params(average):\n    return do_test_eval_metrics(\n        metric='TotalF1:average=' + average,\n        metric_period='1',\n        train=data_file('cloudness_small', 'train_small'),\n        test=data_file('cloudness_small', 'test_small'),\n        cd=data_file('cloudness_small', 'train.cd'),\n        loss_function='MultiClass'\n    )\ndef test_eval_metrics_with_pairs():",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_with_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_eval_metrics_with_pairs():\n    do_test_eval_metrics(\n        metric='PairAccuracy',\n        metric_period='1',\n        train=data_file('querywise', 'train'),\n        test=data_file('querywise', 'test'),\n        cd=data_file('querywise', 'train.cd'),\n        loss_function='PairLogit',\n        additional_train_params=(\n            '--learn-pairs', data_file('querywise', 'train.pairs'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_tweedie",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_tweedie():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    cmd = (\n        '--loss-function', 'Tweedie:variance_power=1.5',\n        '-f', data_file('adult_crossentropy', 'train_proba'),\n        '--column-description', data_file('adult_crossentropy', 'train.cd'),\n        '-i', '100',\n        '--learning-rate', '0.5',\n        '--learn-err-log', learn_error_path\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_logcosh",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_logcosh():\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    cmd = (\n        '--loss-function', 'LogCosh',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '100',\n        '--learning-rate', '0.5',\n        '--learn-err-log', learn_error_path\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_binclass_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_binclass_with_text_features(boosting_type, separator_type, feature_estimators):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_multiclass_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_multiclass_with_text_features(separator_type, feature_estimators, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_multilabel_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_multilabel_with_text_features(separator_type, feature_estimators, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_regression_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_regression_with_text_features(boosting_type, separator_type, feature_estimators):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    tokenizers = [{'tokenizer_id': separator_type, 'separator_type': separator_type, 'token_types': ['Word']}]\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}\n    feature_processing = [{'feature_calcers': [calcer], 'dictionaries_names': dicts[calcer], 'tokenizers_names': [separator_type]} for calcer in feature_estimators.split(',')]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_shrink_model_with_text_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_shrink_model_with_text_features(grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    loss_function = 'MultiClass'\n    feature_estimators = 'BoW,NaiveBayes,BM25'\n    dictionaries = [{'dictionary_id': 'Word'}, {'dictionary_id': 'Bigram', 'gram_order': '2'}]\n    dicts = {'BoW': ['Bigram', 'Word'], 'NaiveBayes': ['Word'], 'BM25': ['Word']}",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_virtual_ensembles",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_virtual_ensembles(loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    train_path = data_file('querywise', 'train') if loss_function in REGRESSION_LOSSES else data_file('adult', 'train_small')\n    test_path = data_file('querywise', 'test') if loss_function in REGRESSION_LOSSES else data_file('adult', 'test_small')\n    cd_path = data_file('querywise', 'train.cd') if loss_function in REGRESSION_LOSSES else data_file('adult', 'train.cd')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = [\n        '--use-best-model', 'false',\n        '-f', train_path,\n        '-t', test_path,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_uncertainty_prediction",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_uncertainty_prediction(virtual_ensembles_count, prediction_type, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    pool_names = {\n        'RMSE' : 'querywise',\n        'RMSEWithUncertainty' : 'querywise',\n        'Logloss' : 'adult',\n        'MultiClass' : 'cloudness_small'\n    }\n    pool_name = pool_names[loss_function]\n    train_path = data_file(pool_name, 'train') if loss_function in REGRESSION_LOSSES else data_file(pool_name, 'train_small')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_uncertainty_prediction_requirements",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_uncertainty_prediction_requirements(loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    train_path = data_file('querywise', 'train')\n    test_path = data_file('querywise', 'test')\n    cd_path = data_file('querywise', 'train.cd')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', train_path,\n        '-t', test_path,\n        '--loss-function', loss_function,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_text_processing_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_text_processing_options(dictionaries, loss_function):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    dictionaries = ','.join([key + ':' + value for key, value in sorted(dictionaries.items())])\n    feature_estimators = 'BM25,BoW,NaiveBayes'\n    pool_name = 'rotten_tomatoes'\n    test_file = data_file(pool_name, 'test')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_fit_with_per_feature_text_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_fit_with_per_feature_text_options(problem_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    text_processing = {\n        'tokenizers': [\n            {'tokenizer_id': 'Space', 'delimiter': ' '},\n            {'tokenizer_id': 'Comma', 'delimiter': ','},",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_embeddings_train",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_embeddings_train(boosting_type, columns):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '--eval-metric', 'AUC',\n        '-f', ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_embeddings_processing_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_embeddings_processing_options(calcers_options):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    calc_eval_path = yatest.common.test_output_path('calc.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '--eval-metric', 'AUC',\n        '-f', ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dump_options",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dump_options():\n    snapshot_path = yatest.common.test_output_path('snapshot.bin')\n    key = 'summary'\n    value = '{\"key1\":\"value1\", \"key2\":\"value2\"}'\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '20',\n        '-T', '4',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "prepare_pool_metainfo_with_feature_tags",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def prepare_pool_metainfo_with_feature_tags():\n    pool_metainfo = {\n        'tags': {\n            'A': {\n                'features': [0, 1, 2, 3, 4, 5, 6, 7]\n            },\n            'B': {\n                'features': [12, 13, 14, 15, 16]\n            },\n            'C': {",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_tags_in_ignore_features",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_tags_in_ignore_features():\n    pool_metainfo, pool_metainfo_path = prepare_pool_metainfo_with_feature_tags()\n    base_cmd = (\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '50',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_tags_in_features_for_select",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_tags_in_features_for_select():\n    pool_metainfo, pool_metainfo_path = prepare_pool_metainfo_with_feature_tags()\n    base_cmd = (\n        CATBOOST_PATH,\n        'select-features',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '-i', '50',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_tags_in_features_to_evaluate",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_tags_in_features_to_evaluate():\n    pool_metainfo, pool_metainfo_path = prepare_pool_metainfo_with_feature_tags()\n    base_cmd = (\n        CATBOOST_PATH,\n        'eval-feature',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--feature-eval-mode', 'OneVsAll',\n        '-i', '30',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_feature_tags_in_options_file",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_feature_tags_in_options_file():\n    pool_metainfo, pool_metainfo_path = prepare_pool_metainfo_with_feature_tags()\n    training_options_path = yatest.common.test_output_path('training_options.json')\n    cmd = (\n        CATBOOST_PATH,\n        'fit',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '-t', data_file('adult', 'test_small'),\n        '--column-description', data_file('adult', 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_without_loss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_without_loss():\n    rmse_model_path = yatest.common.test_output_path('model_rmse.bin')\n    logloss_model_path = yatest.common.test_output_path('model_logloss.bin')\n    sum_model_path = yatest.common.test_output_path('model_sum.bin')\n    train_path = data_file('adult', 'train_small')\n    test_path = data_file('adult', 'test_small')\n    cd_path = data_file('adult', 'train.cd')\n    test_eval_path = yatest.common.test_output_path('test.eval')\n    for loss, model_path in [('RMSE', rmse_model_path), ('Logloss', logloss_model_path)]:\n        cmd = [",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_unit_feature_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_unit_feature_weights(grow_policy):\n    def run_cmd(eval_path, additional_params):\n        cmd = (\n            '--use-best-model', 'false',\n            '--loss-function', 'Logloss',\n            '--learn-set', data_file('higgs', 'train_small'),\n            '--column-description', data_file('higgs', 'train.cd'),\n            '--boosting-type', 'Plain',\n            '--grow-policy', grow_policy,\n            '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_zero_feature_weights",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_zero_feature_weights(grow_policy):\n    def run_cmd(eval_path, additional_params):\n        cmd = (\n            '--use-best-model', 'false',\n            '--loss-function', 'Logloss',\n            '--learn-set', data_file('adult', 'train_small'),\n            '--column-description', data_file('adult', 'train.cd'),\n            '--boosting-type', 'Plain',\n            '--grow-policy', grow_policy,\n            '-i', '10',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_hashed_categ",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_hashed_categ():\n    test_error_path = yatest.common.test_output_path('test_error.tsv')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path_with_hashed_categ = yatest.common.test_output_path('test_error_with_hashed_categ.tsv')\n    learn_error_path_with_hashed_categ = yatest.common.test_output_path('learn_error_with_hashed_categ.tsv')\n    cmd = [\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-i', '10',\n        '-w', '0.03',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_multi_quantile",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_multi_quantile(leaf_estimation_method):\n    def run_cmd(eval_path, additional_params):\n        cmd = (\n            '--use-best-model', 'false',\n            '--learn-set', data_file('querywise', 'train'),\n            '--column-description', data_file('querywise', 'train.cd'),\n            '--boosting-type', 'Plain',\n            '--leaf-estimation-method', leaf_estimation_method,\n            '-i', '10',\n            '-w', '0.03',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dataset_statistics",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dataset_statistics(with_groups, groups_stats_only, use_spots):\n    output_result_path = yatest.common.test_output_path('res.json')\n    command = [\n        CATBOOST_PATH,\n        'dataset-statistics',\n        '--input-path', data_file('querywise', 'train') if with_groups else data_file('adult', 'train_small'),\n        '--column-description', data_file('querywise' if with_groups else 'adult', 'train.cd'),\n        '-T', '4',\n        '--output-path', output_result_path,\n    ]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dataset_statistics_multitarget",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dataset_statistics_multitarget():\n    output_result_path = yatest.common.test_output_path('res.json')\n    command = [\n        CATBOOST_PATH,\n        'dataset-statistics',\n        '--input-path', data_file('multiregression', 'train'),\n        '--column-description', data_file('multiregression', 'train.cd'),\n        '-T', '4',\n        '--output-path', output_result_path,\n    ]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_dataset_statistics_custom_feature_limits",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_dataset_statistics_custom_feature_limits():\n    output_result_path = yatest.common.test_output_path('res.json')\n    command = [\n        CATBOOST_PATH,\n        'dataset-statistics',\n        '--input-path', data_file('querywise', 'train'),\n        '--column-description', data_file('querywise', 'train.cd'),\n        '-T', '4',\n        '--output-path', output_result_path,\n        '--custom-feature-limits', '1:0:1,3:0:0.5,4:-100001:-100000,5:10000:100001'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_bow_multilogoss",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_bow_multilogoss():\n    cd_path = yatest.common.test_output_path('cd.txt')\n    np.savetxt(cd_path, [['0', 'Label'],\n                         ['1', 'Label'],\n                         ['2', 'Text']\n                         ], fmt='%s', delimiter='\\t')\n    train_path = yatest.common.test_output_path('train.txt')\n    np.savetxt(train_path, [['1', '0', 'a e i'],\n                            ['1', '0', 'o u'],\n                            ['1', '1', 'a b c'],",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_apply_multiple_models",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "def test_apply_multiple_models():\n    dataset = 'cloudness_small'\n    train = data_file(dataset, 'train_small')\n    cd = data_file(dataset, 'train.cd')\n    common_train_params = (\n        '-f', train,\n        '--cd', cd,\n        '-i', '5',\n        '-T', '1',\n    )",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CATBOOST_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CATBOOST_PATH = yatest.common.binary_path(\"catboost/app/catboost\")\nBOOSTING_TYPE = ['Ordered', 'Plain']\nGROW_POLICIES = ['SymmetricTree', 'Lossguide', 'Depthwise']\nBOOSTING_TYPE_WITH_GROW_POLICIES = [('Ordered', 'SymmetricTree'), ('Plain', 'SymmetricTree'),\n                                    ('Plain', 'Lossguide'), ('Plain', 'Depthwise')]\nPREDICTION_TYPES = ['Probability', 'RawFormulaVal', 'Class']\nBINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "BOOSTING_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "BOOSTING_TYPE = ['Ordered', 'Plain']\nGROW_POLICIES = ['SymmetricTree', 'Lossguide', 'Depthwise']\nBOOSTING_TYPE_WITH_GROW_POLICIES = [('Ordered', 'SymmetricTree'), ('Plain', 'SymmetricTree'),\n                                    ('Plain', 'Lossguide'), ('Plain', 'Depthwise')]\nPREDICTION_TYPES = ['Probability', 'RawFormulaVal', 'Class']\nBINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "GROW_POLICIES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "GROW_POLICIES = ['SymmetricTree', 'Lossguide', 'Depthwise']\nBOOSTING_TYPE_WITH_GROW_POLICIES = [('Ordered', 'SymmetricTree'), ('Plain', 'SymmetricTree'),\n                                    ('Plain', 'Lossguide'), ('Plain', 'Depthwise')]\nPREDICTION_TYPES = ['Probability', 'RawFormulaVal', 'Class']\nBINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "BOOSTING_TYPE_WITH_GROW_POLICIES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "BOOSTING_TYPE_WITH_GROW_POLICIES = [('Ordered', 'SymmetricTree'), ('Plain', 'SymmetricTree'),\n                                    ('Plain', 'Lossguide'), ('Plain', 'Depthwise')]\nPREDICTION_TYPES = ['Probability', 'RawFormulaVal', 'Class']\nBINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "PREDICTION_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "PREDICTION_TYPES = ['Probability', 'RawFormulaVal', 'Class']\nBINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "BINCLASS_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "BINCLASS_LOSSES = ['Logloss', 'CrossEntropy']\nMULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "MULTICLASS_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "MULTICLASS_LOSSES = ['MultiClass', 'MultiClassOneVsAll']\nCLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CLASSIFICATION_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CLASSIFICATION_LOSSES = BINCLASS_LOSSES + MULTICLASS_LOSSES\nREGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "REGRESSION_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "REGRESSION_LOSSES = ['MAE', 'MAPE', 'Poisson', 'Quantile', 'RMSE', 'RMSEWithUncertainty', 'LogLinQuantile', 'Lq']\nPAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "PAIRWISE_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "PAIRWISE_LOSSES = ['PairLogit', 'PairLogitPairwise']\nGROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "GROUPWISE_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "GROUPWISE_LOSSES = ['YetiRank', 'YetiRankPairwise', 'QueryRMSE', 'GroupQuantile', 'QuerySoftMax']\nRANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "RANKING_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "RANKING_LOSSES = PAIRWISE_LOSSES + GROUPWISE_LOSSES\nALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "ALL_LOSSES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "ALL_LOSSES = CLASSIFICATION_LOSSES + REGRESSION_LOSSES + RANKING_LOSSES\nSAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "SAMPLING_UNIT_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "SAMPLING_UNIT_TYPES = ['Object', 'Group']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "OVERFITTING_DETECTOR_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "OVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nLOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "LOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile',\n                  'Poisson', 'MAPE', 'MultiClass', 'MultiClassOneVsAll']\nLEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [\n    'ByDelimiter',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "LEAF_ESTIMATION_METHOD",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "LEAF_ESTIMATION_METHOD = ['Gradient', 'Newton']\nDISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "DISTRIBUTION_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "DISTRIBUTION_TYPE = ['Normal', 'Logistic', 'Extreme']\n# test both parallel in and non-parallel modes\n# default block size (5000000) is too big to run in parallel on these tests\nSCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "SCORE_CALC_OBJ_BLOCK_SIZES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "SCORE_CALC_OBJ_BLOCK_SIZES = ['60', '5000000']\nSCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "SCORE_CALC_OBJ_BLOCK_SIZES_IDS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "SCORE_CALC_OBJ_BLOCK_SIZES_IDS = ['calc_block=60', 'calc_block=5000000']\nSEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',\n    'BoW,NaiveBayes',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "SEPARATOR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "SEPARATOR_TYPES = [\n    'ByDelimiter',\n    'BySense',\n]\nCLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',\n    'BoW,NaiveBayes',\n    'BoW,NaiveBayes,BM25'",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CLASSIFICATION_TEXT_FEATURE_ESTIMATORS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CLASSIFICATION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW',\n    'NaiveBayes',\n    'BM25',\n    'BoW,NaiveBayes',\n    'BoW,NaiveBayes,BM25'\n]\nREGRESSION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW'\n]",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "REGRESSION_TEXT_FEATURE_ESTIMATORS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "REGRESSION_TEXT_FEATURE_ESTIMATORS = [\n    'BoW'\n]\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_CD = {\n    'with_embeddings': data_file(\n        'rotten_tomatoes_small_with_embeddings',\n        'cd_binclass_without_texts'\n    ),\n    'only_embeddings': data_file(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_CD = {\n    'with_embeddings': data_file(\n        'rotten_tomatoes_small_with_embeddings',\n        'cd_binclass_without_texts'\n    ),\n    'only_embeddings': data_file(\n        'rotten_tomatoes_small_with_embeddings',\n        'cd_binclass_only_embeddings'\n    ),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_CD",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "ROTTEN_TOMATOES_CD = {\n    'with_embeddings': data_file(\n        'rotten_tomatoes_small_with_embeddings',\n        'cd_binclass_without_texts'\n    ),\n    'only_embeddings': data_file(\n        'rotten_tomatoes_small_with_embeddings',\n        'cd_binclass_only_embeddings'\n    ),\n    'with_embeddings_and_texts': data_file(",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "NAN_MODE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "NAN_MODE = ['Min', 'Max']\n@pytest.mark.parametrize('nan_mode', NAN_MODE)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_nan_mode(nan_mode, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '-f', data_file('adult_nan', 'train_small'),\n        '-t', data_file('adult_nan', 'test_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS_SHORT",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "LOSS_FUNCTIONS_SHORT = ['Logloss', 'MultiClass']\n@pytest.mark.parametrize(\n    'loss_function',\n    LOSS_FUNCTIONS_SHORT,\n    ids=['loss_function=%s' % loss_function for loss_function in LOSS_FUNCTIONS_SHORT]\n)\n@pytest.mark.parametrize(\n    'column_name',\n    ['doc_id', 'sample_id'],\n    ids=['column_name=doc_id', 'column_name=sample_id']",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "POOLS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "POOLS = ['amazon', 'adult']\n@pytest.mark.parametrize('boosting_type, grow_policy', BOOSTING_TYPE_WITH_GROW_POLICIES)\ndef test_apply_missing_vals(boosting_type, grow_policy):\n    model_path = yatest.common.test_output_path('adult_model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),\n        '--column-description', data_file('adult', 'train.cd'),\n        '--boosting-type', boosting_type,",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "FSTR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "FSTR_TYPES = ['PredictionValuesChange', 'InternalFeatureImportance', 'InternalInteraction', 'Interaction', 'ShapValues', 'PredictionDiff']\nDATASET_DEPENDENT_FSTR_TYPES = ['PredictionValuesChange', 'InternalFeatureImportance', 'LossFunctionChange', 'ShapValues', 'PredictionDiff']\n@pytest.mark.parametrize('fstr_type', FSTR_TYPES)\n@pytest.mark.parametrize('boosting_type, grow_policy', BOOSTING_TYPE_WITH_GROW_POLICIES)\ndef test_fstr(fstr_type, boosting_type, grow_policy):\n    pool = 'adult' if fstr_type != 'PredictionDiff' else 'higgs'\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=data_file(pool, 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "DATASET_DEPENDENT_FSTR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "DATASET_DEPENDENT_FSTR_TYPES = ['PredictionValuesChange', 'InternalFeatureImportance', 'LossFunctionChange', 'ShapValues', 'PredictionDiff']\n@pytest.mark.parametrize('fstr_type', FSTR_TYPES)\n@pytest.mark.parametrize('boosting_type, grow_policy', BOOSTING_TYPE_WITH_GROW_POLICIES)\ndef test_fstr(fstr_type, boosting_type, grow_policy):\n    pool = 'adult' if fstr_type != 'PredictionDiff' else 'higgs'\n    return do_test_fstr(\n        fstr_type,\n        loss_function='Logloss',\n        input_path=data_file(pool, 'train_small'),\n        cd_path=data_file(pool, 'train.cd'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "BORDER_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "BORDER_TYPES = ['Median', 'GreedyLogSum', 'UniformAndQuantiles', 'MinEntropy', 'MaxLogSum', 'Uniform']\n@pytest.mark.parametrize('border_type', BORDER_TYPES)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_feature_border_types(border_type, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'Logloss',\n        '-f', data_file('adult', 'train_small'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "REG_LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "REG_LOSS_FUNCTIONS = ['RMSE', 'RMSEWithUncertainty', 'MAE', 'Lq:q=1', 'Lq:q=1.5', 'Lq:q=3', 'Quantile', 'LogLinQuantile', 'Poisson', 'MAPE',\n                      'Huber:delta=1.0']\n@pytest.mark.parametrize('loss_function', REG_LOSS_FUNCTIONS)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)\ndef test_reg_targets(loss_function, boosting_type, dev_score_calc_obj_block_size):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "BORDER_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "BORDER_TYPES = ['MinEntropy', 'Median', 'UniformAndQuantiles', 'MaxLogSum', 'GreedyLogSum', 'Uniform']\n@pytest.mark.parametrize(\n    'border_type',\n    BORDER_TYPES,\n    ids=lambda border_type: 'border_type=%s' % border_type\n)\n@pytest.mark.parametrize(\n    'border_count',\n    [1, 3, 10],\n    ids=lambda border_count: 'border_count=%d' % border_count",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "COUNTER_METHODS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "COUNTER_METHODS = ['Full', 'SkipTest']\n@pytest.mark.parametrize('counter_calc_method', COUNTER_METHODS)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_counter_calc(counter_calc_method, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', 'RMSE',\n        '-f', data_file('adult_crossentropy', 'train_proba'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CTR_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CTR_TYPES = ['Borders', 'Buckets', 'BinarizedTargetMeanValue:TargetBorderCount=10', 'Borders,BinarizedTargetMeanValue:TargetBorderCount=10', 'Buckets,Borders']\n@pytest.mark.parametrize('ctr_type', CTR_TYPES)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)\ndef test_ctr_type(ctr_type, boosting_type, dev_score_calc_obj_block_size):\n    output_model_path = yatest.common.test_output_path('model.bin')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "QUANTILE_LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "QUANTILE_LOSS_FUNCTIONS = ['Quantile', 'GroupQuantile', 'LogLinQuantile']\n@pytest.mark.parametrize('loss_function', QUANTILE_LOSS_FUNCTIONS)\n@pytest.mark.parametrize('boosting_type, grow_policy', BOOSTING_TYPE_WITH_GROW_POLICIES)\ndef test_quantile_targets(loss_function, boosting_type, grow_policy):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    cmd = (\n        '--use-best-model', 'false',\n        '--loss-function', loss_function + ':alpha=0.9',\n        '-f', data_file('querywise', 'train'),",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CUSTOM_LOSS_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CUSTOM_LOSS_FUNCTIONS = ['RMSE,MAE', 'Quantile:alpha=0.9', 'MSLE,MedianAbsoluteError,SMAPE',\n                         'NumErrors:greater_than=0.01,NumErrors:greater_than=0.1,NumErrors:greater_than=0.5',\n                         'FairLoss:smoothness=0.9']\n@pytest.mark.parametrize('custom_loss_function', CUSTOM_LOSS_FUNCTIONS)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_custom_loss(custom_loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    learn_error_path = yatest.common.test_output_path('learn_error.tsv')\n    test_error_path = yatest.common.test_output_path('test_error.tsv')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "CANONICAL_CLOUDNESS_MINI_MULTICLASS_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "CANONICAL_CLOUDNESS_MINI_MULTICLASS_MODEL_PATH = data_file('', 'multiclass_model.bin')\n@pytest.mark.parametrize('prediction_type', ['Probability', 'RawFormulaVal', 'Class'])\ndef test_multiclass_model_backward_compatibility(prediction_type):\n    model = catboost.CatBoost()\n    model.load_model(CANONICAL_CLOUDNESS_MINI_MULTICLASS_MODEL_PATH)\n    assert 'class_params' not in model.get_metadata()\n    pool = catboost.Pool(data_file('cloudness_small', 'train_small'),\n                         column_description=data_file('cloudness_small', 'train.cd'))\n    model.predict(data=pool, prediction_type='Class')\n    model.eval_metrics(data=pool, metrics=['Accuracy'])",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS_WITH_PAIRWISE_SCORRING",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "LOSS_FUNCTIONS_WITH_PAIRWISE_SCORRING = ['YetiRankPairwise', 'PairLogitPairwise']\n@pytest.mark.parametrize('bagging_temperature', ['0', '1'])\n@pytest.mark.parametrize('sampling_unit', SAMPLING_UNIT_TYPES)\n@pytest.mark.parametrize('loss_function', LOSS_FUNCTIONS_WITH_PAIRWISE_SCORRING)\n@pytest.mark.parametrize(\n    'dev_score_calc_obj_block_size',\n    SCORE_CALC_OBJ_BLOCK_SIZES,\n    ids=SCORE_CALC_OBJ_BLOCK_SIZES_IDS\n)\ndef test_pairwise_bayesian_bootstrap(bagging_temperature, sampling_unit, loss_function, dev_score_calc_obj_block_size):",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "LOSS_FUNCTIONS_NO_MAPE",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "LOSS_FUNCTIONS_NO_MAPE = ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MAE', 'CrossEntropy', 'Quantile', 'LogLinQuantile', 'Poisson']\n@pytest.mark.parametrize('loss_function', LOSS_FUNCTIONS_NO_MAPE)\n@pytest.mark.parametrize('boosting_type', BOOSTING_TYPE)\ndef test_quantized_adult_pool(loss_function, boosting_type):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    output_eval_path = yatest.common.test_output_path('test.eval')\n    quantized_train_file = 'quantized://' + data_file('quantized_adult', 'train.qbin')\n    quantized_test_file = 'quantized://' + data_file('quantized_adult', 'test.qbin')\n    cmd = (\n        '--use-best-model', 'false',",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "TEST_METRIC_DESCRIPTION_METRICS_LIST",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "TEST_METRIC_DESCRIPTION_METRICS_LIST = ['Logloss', 'Precision', 'AUC']\n@pytest.mark.parametrize('dataset_has_weights', [True, False], ids=['dataset_has_weights=True', 'dataset_has_weights=False'])\n@pytest.mark.parametrize('eval_metric_loss', TEST_METRIC_DESCRIPTION_METRICS_LIST,\n                         ids=['eval_loss=' + mode for mode in TEST_METRIC_DESCRIPTION_METRICS_LIST])\n@pytest.mark.parametrize('eval_metric_use_weights', [True, False, None],\n                         ids=['eval_weights=' + str(mode) for mode in [True, False, None]])\n@pytest.mark.parametrize('custom_metric_loss', TEST_METRIC_DESCRIPTION_METRICS_LIST,\n                         ids=['custom_loss=' + mode for mode in TEST_METRIC_DESCRIPTION_METRICS_LIST])\n@pytest.mark.parametrize('custom_metric_use_weights', [True, False, None],\n                         ids=['custom_weights=' + str(mode) for mode in [True, False, None]])",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "DICTIONARIES_OPTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "DICTIONARIES_OPTIONS = [\n    {\n        \"Simple\": \"token_level_type=Word:occurrence_lower_bound=50\"\n    },\n    {\n        \"UniGramOccur5\": \"occurrence_lower_bound=5:token_level_type=Letter\",\n        \"BiGramOccur2\": \"occurrence_lower_bound=2:gram_order=2:token_level_type=Letter\",\n        \"WordDictOccur1\": \"occurrence_lower_bound=1:token_level_type=Word\",\n        \"WordDictOccur2\": \"occurrence_lower_bound=2:token_level_type=Word\",\n        \"WordDictOccur3\": \"occurrence_lower_bound=3:token_level_type=Word\"",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_CALCER_OPTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test",
        "description": "catboost.catboost.pytest.test",
        "peekOfCode": "EMBEDDING_CALCER_OPTIONS = {\n    \"LDAparam\": \"LDA:reg=0.05:likelihood=true\",\n    \"KNNparam\": \"KNN:k=20\",\n    \"KNNparam+LDAparam\": \"KNN:k=10,LDA:reg=0.05\",\n}\n@pytest.mark.parametrize('calcers_options', list(EMBEDDING_CALCER_OPTIONS.keys()))\ndef test_embeddings_processing_options(calcers_options):\n    output_model_path = yatest.common.test_output_path('model.bin')\n    learn_error_path = yatest.common.test_output_path('learn.tsv')\n    test_error_path = yatest.common.test_output_path('test.tsv')",
        "detail": "catboost.catboost.pytest.test",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.test_modes",
        "description": "catboost.catboost.pytest.test_modes",
        "peekOfCode": "class Dataset(object):\n    def __init__(self, data_dir):\n        self.train_file = data_file(data_dir, 'train_small')\n        self.test_file = data_file(data_dir, 'test_small')\n        self.cd_file = data_file(data_dir, 'train.cd')\nclass TestModeNormalizeModel(object):\n    def fit(self, loss_function, dataset):\n        model_file = get_test_output_path('model{}.bin')\n        yc.execute([\n            CATBOOST_PATH,",
        "detail": "catboost.catboost.pytest.test_modes",
        "documentation": {}
    },
    {
        "label": "TestModeNormalizeModel",
        "kind": 6,
        "importPath": "catboost.catboost.pytest.test_modes",
        "description": "catboost.catboost.pytest.test_modes",
        "peekOfCode": "class TestModeNormalizeModel(object):\n    def fit(self, loss_function, dataset):\n        model_file = get_test_output_path('model{}.bin')\n        yc.execute([\n            CATBOOST_PATH,\n            'fit',\n            '--loss-function', loss_function,\n            '-f', dataset.train_file,\n            '--cd', dataset.cd_file,\n            '-i', '10',",
        "detail": "catboost.catboost.pytest.test_modes",
        "documentation": {}
    },
    {
        "label": "diff_tool",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test_modes",
        "description": "catboost.catboost.pytest.test_modes",
        "peekOfCode": "def diff_tool(threshold=None):\n    return get_limited_precision_dsv_diff_tool(threshold, True)\ndef get_test_output_path(pattern):\n    assert '{}' in pattern\n    result = yc.test_output_path(pattern.format(''))\n    attempt = 0\n    while os.path.exists(result):\n        result = yc.test_output_path(pattern.format(attempt))\n        attempt += 1\n    return result",
        "detail": "catboost.catboost.pytest.test_modes",
        "documentation": {}
    },
    {
        "label": "get_test_output_path",
        "kind": 2,
        "importPath": "catboost.catboost.pytest.test_modes",
        "description": "catboost.catboost.pytest.test_modes",
        "peekOfCode": "def get_test_output_path(pattern):\n    assert '{}' in pattern\n    result = yc.test_output_path(pattern.format(''))\n    attempt = 0\n    while os.path.exists(result):\n        result = yc.test_output_path(pattern.format(attempt))\n        attempt += 1\n    return result\nclass Dataset(object):\n    def __init__(self, data_dir):",
        "detail": "catboost.catboost.pytest.test_modes",
        "documentation": {}
    },
    {
        "label": "CATBOOST_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.pytest.test_modes",
        "description": "catboost.catboost.pytest.test_modes",
        "peekOfCode": "CATBOOST_PATH = yc.binary_path(\"catboost/app/catboost\")\ndef diff_tool(threshold=None):\n    return get_limited_precision_dsv_diff_tool(threshold, True)\ndef get_test_output_path(pattern):\n    assert '{}' in pattern\n    result = yc.test_output_path(pattern.format(''))\n    attempt = 0\n    while os.path.exists(result):\n        result = yc.test_output_path(pattern.format(attempt))\n        attempt += 1",
        "detail": "catboost.catboost.pytest.test_modes",
        "documentation": {}
    },
    {
        "label": "FoldModel",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._fold_model",
        "description": "catboost.catboost.python-package.catboost.eval._fold_model",
        "peekOfCode": "class FoldModel:\n    def __init__(self, case, model_path, model_id):\n        self._id = model_id\n        self._case = case\n        self._model_path = model_path\n    def __repr__(self):\n        return 'Model_{}_id_{}'.format(str(self._case), self._id)\n    def create_metrics_calcer(self, metrics, thread_count, eval_step=1):\n        if not os.path.exists(self._model_path):\n            raise CatBoostError(\"Model was deleted. Can't create calcer now\")",
        "detail": "catboost.catboost.python-package.catboost.eval._fold_model",
        "documentation": {}
    },
    {
        "label": "FoldModelsHandler",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._fold_models_handler",
        "description": "catboost.catboost.python-package.catboost.eval._fold_models_handler",
        "peekOfCode": "class FoldModelsHandler(object):\n    \"\"\"\n    Class that is responsible for learning models and computing their metrics\n    \"\"\"\n    \"\"\"\n       All models are placed to the default directory \"models\".\n       \"\"\"\n    __MODEL_DIR = 'models'\n    @staticmethod\n    def _remove_model_dir():",
        "detail": "catboost.catboost.python-package.catboost.eval._fold_models_handler",
        "documentation": {}
    },
    {
        "label": "FoldStorage",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "description": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "peekOfCode": "class FoldStorage(object):\n    \"\"\"\n    Base class.\n    \"\"\"\n    default_dir = 'folds'\n    @staticmethod\n    def remove_dir():\n        \"\"\"\n        Remove default directory for folds if there're no files nut models. In other way it raises warning.\n        Args:",
        "detail": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "documentation": {}
    },
    {
        "label": "_FoldFile",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "description": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "peekOfCode": "class _FoldFile(FoldStorage):\n    \"\"\"\n    FoldFile is the realisation of the interface of FoldStorage. It always saves data to file before reset them.\n    All files place to the special directory 'folds'.\n    \"\"\"\n    def __init__(self, fold, storage_name, sep, column_description):\n        super(_FoldFile, self).__init__(\n            fold, storage_name,\n            sep=sep, column_description=column_description\n        )",
        "detail": "catboost.catboost.python-package.catboost.eval._fold_storage",
        "documentation": {}
    },
    {
        "label": "_BaseReader",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._readers",
        "description": "catboost.catboost.python-package.catboost.eval._readers",
        "peekOfCode": "class _BaseReader(object):\n    def __init__(self, sep, group_feature_num):\n        self._sep = sep\n        self._group_feature_num = group_feature_num\n    def get_separator(self):\n        return self._sep\n    def lines_generator(self):\n        raise NotImplementedError(\"The base class don't have any lines_reader\")\n    def pack_lines_generator(self, pack_size):\n        lines = []",
        "detail": "catboost.catboost.python-package.catboost.eval._readers",
        "documentation": {}
    },
    {
        "label": "_SimpleStreamingFileReader",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._readers",
        "description": "catboost.catboost.python-package.catboost.eval._readers",
        "peekOfCode": "class _SimpleStreamingFileReader(_BaseReader):\n    def __init__(self, file_name, sep, has_header, group_feature_num=None):\n        super(_SimpleStreamingFileReader, self).__init__(sep, group_feature_num)\n        self._has_header = has_header\n        self._file_name = file_name\n    def lines_generator(self):\n        with open(self._file_name, 'r') as file:\n            if self._has_header:\n                file.readline()\n            for num, line in enumerate(file):",
        "detail": "catboost.catboost.python-package.catboost.eval._readers",
        "documentation": {}
    },
    {
        "label": "_SimpleDataReader",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._readers",
        "description": "catboost.catboost.python-package.catboost.eval._readers",
        "peekOfCode": "class _SimpleDataReader(_BaseReader):\n    def __init__(self, data, sep, group_feature_num=None):\n        super(_SimpleDataReader, self).__init__(sep, group_feature_num)\n        self._data = pd.DataFrame(data)\n    def lines_generator(self):\n        for num, (index, line) in enumerate(self._data.iterrows()):\n            if self._group_feature_num is None:\n                yield num, series_to_line(line, self._sep) + '\\n'\n            else:\n                yield line.iloc[self._group_feature_num], series_to_line(line, self._sep) + '\\n'",
        "detail": "catboost.catboost.python-package.catboost.eval._readers",
        "documentation": {}
    },
    {
        "label": "Splitter",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._splitter",
        "description": "catboost.catboost.python-package.catboost.eval._splitter",
        "peekOfCode": "class Splitter.\nConvenient tool for creating and working with folds.\n\"\"\"\nimport random\nfrom ._fold_storage import FoldStorage\nfrom ._fold_storage import _FoldFile\nclass _Splitter(object):\n    \"\"\"\n     Splitter needs providing some parameters to create folds and some \"reader\",\n     that can read source.",
        "detail": "catboost.catboost.python-package.catboost.eval._splitter",
        "documentation": {}
    },
    {
        "label": "_Splitter",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval._splitter",
        "description": "catboost.catboost.python-package.catboost.eval._splitter",
        "peekOfCode": "class _Splitter(object):\n    \"\"\"\n     Splitter needs providing some parameters to create folds and some \"reader\",\n     that can read source.\n    \"\"\"\n    _REST_SIZE = 100000\n    def __init__(self, line_reader, column_description, seed, min_folds_count):\n        self._line_reader = line_reader\n        self._line_groups_ids, self._groups_ids = self._read_groups_ids()\n        # line_groups_ids -- group ids of each line",
        "detail": "catboost.catboost.python-package.catboost.eval._splitter",
        "documentation": {}
    },
    {
        "label": "EvalType",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "description": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "peekOfCode": "class EvalType(Enum):\n    \"\"\"\n        Type of feature evaluation:\n            All: All factors presented\n            SeqRem:  Each factor while other presented\n            SeqAdd:  Each factor while other removed\n            SeqAddAndAll:  SeqAdd + All\n    \"\"\"\n    All = 'All'\n    SeqRem = 'SeqRem'",
        "detail": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "documentation": {}
    },
    {
        "label": "CatboostEvaluation",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "description": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "peekOfCode": "class CatboostEvaluation(object):\n    def __init__(self,\n                 path_to_dataset,\n                 fold_size,\n                 fold_count,\n                 column_description,\n                 fold_offset=0,\n                 group_column=None,\n                 working_dir=None,\n                 remove_models=True,",
        "detail": "catboost.catboost.python-package.catboost.eval.catboost_evaluation",
        "documentation": {}
    },
    {
        "label": "ScoreType",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "class ScoreType(Enum):\n    Abs = \"AbsoluteDiff\"\n    Rel = \"RelativeDiff\"\nclass ScoreConfig:\n    \"\"\"\n        Config to present human-friendly evaluation results.\n    \"\"\"\n    def __init__(self,\n                 score_type=ScoreType.Rel,\n                 multiplier=100,",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "ScoreConfig",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "class ScoreConfig:\n    \"\"\"\n        Config to present human-friendly evaluation results.\n    \"\"\"\n    def __init__(self,\n                 score_type=ScoreType.Rel,\n                 multiplier=100,\n                 score_level=0.01,\n                 interval_level=0.01,\n                 overfit_iterations_info=True):",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "CaseEvaluationResult",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "class CaseEvaluationResult:\n    \"\"\"\n        CaseEvaluationResults stores aggregated statistics for one EvaluationCase and one metric.\n    \"\"\"\n    def __init__(self, case, metric_description, eval_step):\n        self._case = case\n        self._metric_description = metric_description\n        self._fold_metric = pd.Series()\n        self._fold_metric_iteration = pd.Series()\n        self._fold_curves = dict()",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "MetricEvaluationResult",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "class MetricEvaluationResult:\n    \"\"\"\n        Evaluation result for one metric.\n        Stores all ExecutionCases with specified metric scores\n        Computes human-friendly tables with results and some plots\n    \"\"\"\n    def __init__(self, case_results):\n        if len(case_results) <= 1:\n            raise CatBoostError(\"Need at least 2 case results, got {} \".format(len(case_results)))\n        self._case_results = dict()",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "EvaluationResults",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "class EvaluationResults:\n    def __init__(self, metric_results):\n        if len(metric_results) < 1:\n            raise CatBoostError(\"Need at least one result\")\n        self._results = dict()\n        self._metrics = dict()\n        self._cases = None\n        for result in metric_results:\n            metric_description = result.get_metric_description()\n            if metric_description in self._results:",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "calc_wilcoxon_test",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "def calc_wilcoxon_test(baseline, test):\n    return compute_wx_test(baseline, test)[\"pvalue\"]\nclass ScoreType(Enum):\n    Abs = \"AbsoluteDiff\"\n    Rel = \"RelativeDiff\"\nclass ScoreConfig:\n    \"\"\"\n        Config to present human-friendly evaluation results.\n    \"\"\"\n    def __init__(self,",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "calc_bootstrap_ci_for_mean",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "description": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "peekOfCode": "def calc_bootstrap_ci_for_mean(samples, level=0.05, tries=999):\n    \"\"\"\n    Count confidence intervals for difference each two samples.\n    Args:\n        :param samples: samples\n        :param level: (float) Level for the confidence interval.\n        :param tries: bootstrap samples to use\n        :return: (left, right) border of confidence interval\n    \"\"\"\n    if not (samples == 0).all():",
        "detail": "catboost.catboost.python-package.catboost.eval.evaluation_result",
        "documentation": {}
    },
    {
        "label": "ExecutionCase",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.execution_case",
        "description": "catboost.catboost.python-package.catboost.eval.execution_case",
        "peekOfCode": "class ExecutionCase:\n    def __init__(self,\n                 params,\n                 label=None,\n                 ignored_features=None,\n                 learning_rate=None):\n        \"\"\"\n            Instances of this class are cases which will be compared during evaluation\n            Params are CatBoost params\n            label is a string which will be used for plots and other visualisations",
        "detail": "catboost.catboost.python-package.catboost.eval.execution_case",
        "documentation": {}
    },
    {
        "label": "LabelMode",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "description": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "peekOfCode": "class LabelMode(Enum):\n    AddFeature = \"Feature\"\n    IgnoreFeature = \"Ignore\"\nclass FactorUtils(object):\n    @staticmethod\n    def extract_factors(string_factors):\n        string_factors = string_factors.strip()\n        if not string_factors:\n            return {}\n        list_factors = []",
        "detail": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "documentation": {}
    },
    {
        "label": "FactorUtils",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "description": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "peekOfCode": "class FactorUtils(object):\n    @staticmethod\n    def extract_factors(string_factors):\n        string_factors = string_factors.strip()\n        if not string_factors:\n            return {}\n        list_factors = []\n        eval_factor_units = string_factors.split(';')\n        for eval_factor_unit in eval_factor_units:\n            try:",
        "detail": "catboost.catboost.python-package.catboost.eval.factor_utils",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "def init():\n    global eval_logger\n    eval_logger_name = \"eval_feature\"\n    eval_logger = logging.getLogger(eval_logger_name)\n    eval_logger.setLevel(logging.CRITICAL)\n    global console_handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.CRITICAL)\n    formatter = logging.Formatter(\"[%(levelname)s]: %(message)s\")\n    console_handler.setFormatter(formatter)",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "set_logger_name",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "def set_logger_name(name):\n    global filename\n    filename = name\ndef get_eval_logger():\n    if eval_logger is None:\n        init()\n    return eval_logger\ndef set_level(level):\n    if eval_logger is None:\n        init()",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "get_eval_logger",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "def get_eval_logger():\n    if eval_logger is None:\n        init()\n    return eval_logger\ndef set_level(level):\n    if eval_logger is None:\n        init()\n    console_handler.setLevel(level)",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "set_level",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "def set_level(level):\n    if eval_logger is None:\n        init()\n    console_handler.setLevel(level)",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "filename = None\neval_logger = None\nconsole_handler = None\ndef init():\n    global eval_logger\n    eval_logger_name = \"eval_feature\"\n    eval_logger = logging.getLogger(eval_logger_name)\n    eval_logger.setLevel(logging.CRITICAL)\n    global console_handler\n    console_handler = logging.StreamHandler()",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "eval_logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "eval_logger = None\nconsole_handler = None\ndef init():\n    global eval_logger\n    eval_logger_name = \"eval_feature\"\n    eval_logger = logging.getLogger(eval_logger_name)\n    eval_logger.setLevel(logging.CRITICAL)\n    global console_handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.CRITICAL)",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "console_handler",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.eval.log_config",
        "description": "catboost.catboost.python-package.catboost.eval.log_config",
        "peekOfCode": "console_handler = None\ndef init():\n    global eval_logger\n    eval_logger_name = \"eval_feature\"\n    eval_logger = logging.getLogger(eval_logger_name)\n    eval_logger.setLevel(logging.CRITICAL)\n    global console_handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.CRITICAL)\n    formatter = logging.Formatter(\"[%(levelname)s]: %(message)s\")",
        "detail": "catboost.catboost.python-package.catboost.eval.log_config",
        "documentation": {}
    },
    {
        "label": "make_dirs_if_not_exists",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.utils",
        "description": "catboost.catboost.python-package.catboost.eval.utils",
        "peekOfCode": "def make_dirs_if_not_exists(name):\n    try:\n        os.makedirs(name)\n    except OSError:\n        pass\ndef series_to_line(row, sep):\n    return sep.join(map(str, row.tolist()))\ndef save_plot(fig, file_name=None):\n    try:\n        from plotly.offline import iplot, init_notebook_mode",
        "detail": "catboost.catboost.python-package.catboost.eval.utils",
        "documentation": {}
    },
    {
        "label": "series_to_line",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.utils",
        "description": "catboost.catboost.python-package.catboost.eval.utils",
        "peekOfCode": "def series_to_line(row, sep):\n    return sep.join(map(str, row.tolist()))\ndef save_plot(fig, file_name=None):\n    try:\n        from plotly.offline import iplot, init_notebook_mode\n        init_notebook_mode(connected=True)\n        iplot(fig, filename=file_name)\n    except Exception:\n        from plotly.offline import plot\n        plot(fig, auto_open=False, filename=file_name)",
        "detail": "catboost.catboost.python-package.catboost.eval.utils",
        "documentation": {}
    },
    {
        "label": "save_plot",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.eval.utils",
        "description": "catboost.catboost.python-package.catboost.eval.utils",
        "peekOfCode": "def save_plot(fig, file_name=None):\n    try:\n        from plotly.offline import iplot, init_notebook_mode\n        init_notebook_mode(connected=True)\n        iplot(fig, filename=file_name)\n    except Exception:\n        from plotly.offline import plot\n        plot(fig, auto_open=False, filename=file_name)",
        "detail": "catboost.catboost.python-package.catboost.eval.utils",
        "documentation": {}
    },
    {
        "label": "XGBPlottingCallback",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.widget.callbacks",
        "description": "catboost.catboost.python-package.catboost.widget.callbacks",
        "peekOfCode": "class XGBPlottingCallback(XGBTrainingCallback):\n    '''XGBoost callback with metrics plotting widget from CatBoost\n    '''\n    def __init__(self, total_iterations: int):\n        self.plotter = None\n        self.total_iterations = total_iterations\n    def after_iteration(self, model, epoch, evals_log):\n        data_names = evals_log.keys()\n        # if more than one sample is passed, consider first as train sample\n        first_train = (",
        "detail": "catboost.catboost.python-package.catboost.widget.callbacks",
        "documentation": {}
    },
    {
        "label": "lgbm_plotting_callback",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.widget.callbacks",
        "description": "catboost.catboost.python-package.catboost.widget.callbacks",
        "peekOfCode": "def lgbm_plotting_callback():\n    \"\"\"LightGBM callback with metrics plotting widget from CatBoost\n    \"\"\"\n    plotter = None\n    def _init(env):\n        train_metrics = []\n        test_metrics = []\n        for item in env.evaluation_result_list:\n            assert len(item) == 4, \"Plotting was run in not suppored mode\"\n            data_name, eval_name = item[:2]",
        "detail": "catboost.catboost.python-package.catboost.widget.callbacks",
        "documentation": {}
    },
    {
        "label": "MetricWidget",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "description": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "peekOfCode": "class MetricWidget(DOMWidget):\n    _view_name = Unicode('CatboostWidgetView').tag(sync=True)\n    _model_name = Unicode('CatboostWidgetModel').tag(sync=True)\n    _view_module = Unicode('catboost-widget').tag(sync=True)\n    _model_module = Unicode('catboost-widget').tag(sync=True)\n    _view_module_version = Unicode('^1.0.0').tag(sync=True)\n    _model_module_version = Unicode('^1.0.0').tag(sync=True)\n    data = Dict({}).tag(sync=True, **widget_serialization)\n    @default('layout')\n    def _default_layout(self):",
        "detail": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "documentation": {}
    },
    {
        "label": "MetricVisualizer",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "description": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "peekOfCode": "class MetricVisualizer(MetricWidget):\n    def __init__(self, train_dirs, subdirs=False):\n        super(self.__class__, self).__init__()\n        if isinstance(train_dirs, str):\n            train_dirs = [train_dirs]\n        if subdirs:\n            train_subdirs = []\n            for train_dir in train_dirs:\n                train_subdirs.extend(self._get_subdirectories(train_dir))\n            train_dirs = train_subdirs",
        "detail": "catboost.catboost.python-package.catboost.widget.ipythonwidget",
        "documentation": {}
    },
    {
        "label": "MetricsWidget",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "description": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "peekOfCode": "class MetricsWidget(MetricWidget):\n    def __init__(self):\n        super(self.__class__, self).__init__()\n    def update_data(self, data: tp.Dict) -> None:\n        # deepcopy is crucial here\n        self.data = deepcopy(data)\nclass MetricsPlotter:\n    \"\"\"\n    Context manager that enables widget with learning curves in\n    JupyterLab / Jupyter Notebook",
        "detail": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "documentation": {}
    },
    {
        "label": "MetricsPlotter",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "description": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "peekOfCode": "class MetricsPlotter:\n    \"\"\"\n    Context manager that enables widget with learning curves in\n    JupyterLab / Jupyter Notebook\n    \"\"\"\n    def __init__(self, train_metrics: List[Union[str, tp.Dict[str, str]]],\n                 test_metrics: Optional[List[Union[str, tp.Dict[str, str]]]] = None,\n                 total_iterations: Optional[int] = None) -> None:\n        \"\"\"\n        Constructor that defines metrics to be plotted and total iterations count.",
        "detail": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "description": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nclass MetricsWidget(MetricWidget):\n    def __init__(self):\n        super(self.__class__, self).__init__()\n    def update_data(self, data: tp.Dict) -> None:\n        # deepcopy is crucial here\n        self.data = deepcopy(data)\nclass MetricsPlotter:\n    \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.widget.metrics_plotter",
        "documentation": {}
    },
    {
        "label": "carry",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "def carry(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model\n    features :\n        must be a dict mapping strings (factor names) or integers (flat indexes) into floats\n        NOTE: values in a dict can be lists of floats, but in this case they must all be the same size\n    \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "uplift",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "def uplift(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model\n        NOTE: uplift allways use RawFormulaVal\n    features :\n        must be a dict mapping strings (factor names) or integers (flat indexes) into pairs of floats (base and next values)\n    \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "_carry_by_index",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "_carry_by_index = _catboost._carry_by_index\n_carry_by_name = _catboost._carry_by_name\n_uplift_by_index = _catboost._uplift_by_index\n_uplift_by_name = _catboost._uplift_by_index\ndef carry(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "_carry_by_name",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "_carry_by_name = _catboost._carry_by_name\n_uplift_by_index = _catboost._uplift_by_index\n_uplift_by_name = _catboost._uplift_by_index\ndef carry(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model\n    features :",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "_uplift_by_index",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "_uplift_by_index = _catboost._uplift_by_index\n_uplift_by_name = _catboost._uplift_by_index\ndef carry(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model\n    features :\n        must be a dict mapping strings (factor names) or integers (flat indexes) into floats",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "_uplift_by_name",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.carry",
        "description": "catboost.catboost.python-package.catboost.carry",
        "peekOfCode": "_uplift_by_name = _catboost._uplift_by_index\ndef carry(model, features):\n    \"\"\"\n    Parameters\n    ----------\n    model :\n        CatBoost / CatBoostClassifier / CatBoostRanker / CatBoostRegressor model\n    features :\n        must be a dict mapping strings (factor names) or integers (flat indexes) into floats\n        NOTE: values in a dict can be lists of floats, but in this case they must all be the same size",
        "detail": "catboost.catboost.python-package.catboost.carry",
        "documentation": {}
    },
    {
        "label": "_StreamLikeWrapper",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class _StreamLikeWrapper:\n    def __init__(self, callable_object):\n        self.callable_object = callable_object\n    def write(self, message):\n        self.callable_object(message)\nclass _CustomLoggersStack(object):\n    def __init__(self):\n        self._lock = threading.Lock()\n        self._owning_thread_id = None\n        self._stack = []  # contains (cout, cerr) pairs",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_CustomLoggersStack",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class _CustomLoggersStack(object):\n    def __init__(self):\n        self._lock = threading.Lock()\n        self._owning_thread_id = None\n        self._stack = []  # contains (cout, cerr) pairs\n    @staticmethod\n    def _get_stream_like_object(obj):\n        if hasattr(obj, 'write'):\n            return obj\n        if hasattr(obj, '__call__'):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "EFstrType",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class EFstrType(Enum):\n    \"\"\"Calculate score for every feature by values change.\"\"\"\n    PredictionValuesChange = 0\n    \"\"\"Calculate score for every feature by loss change\"\"\"\n    LossFunctionChange = 1\n    \"\"\"Use LossFunctionChange for ranking models and PredictionValuesChange otherwise\"\"\"\n    FeatureImportance = 2\n    \"\"\"Calculate pairwise score between every feature.\"\"\"\n    Interaction = 3\n    \"\"\"Calculate SHAP Values for every object.\"\"\"",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "EShapCalcType",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class EShapCalcType(Enum):\n    \"\"\"Calculate regular SHAP values\"\"\"\n    Regular = \"Regular\"\n    \"\"\"Calculate approximate SHAP values\"\"\"\n    Approximate = \"Approximate\"\n    \"\"\"Calculate exact SHAP values\"\"\"\n    Exact = \"Exact\"\nclass EFeaturesSelectionAlgorithm(Enum):\n    \"\"\"Use prediction values change as feature strength, eliminate batch of features at once\"\"\"\n    RecursiveByPredictionValuesChange = \"RecursiveByPredictionValuesChange\"",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "EFeaturesSelectionAlgorithm",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class EFeaturesSelectionAlgorithm(Enum):\n    \"\"\"Use prediction values change as feature strength, eliminate batch of features at once\"\"\"\n    RecursiveByPredictionValuesChange = \"RecursiveByPredictionValuesChange\"\n    \"\"\"Use loss function change as feature strength, eliminate batch of features at each step\"\"\"\n    RecursiveByLossFunctionChange = \"RecursiveByLossFunctionChange\"\n    \"\"\"Use shap values to estimate loss function change, eliminate features one by one\"\"\"\n    RecursiveByShapValues = \"RecursiveByShapValues\"\nclass EFeaturesSelectionGrouping(Enum):\n    \"\"\"Select individual features\"\"\"\n    Individual = \"Individual\"",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "EFeaturesSelectionGrouping",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class EFeaturesSelectionGrouping(Enum):\n    \"\"\"Select individual features\"\"\"\n    Individual = \"Individual\"\n    \"\"\"Select feature groups (marked by tags)\"\"\"\n    ByTags = \"ByTags\"\ndef _get_features_indices(features, feature_names):\n    \"\"\"\n        Parameters\n        ----------\n        features :",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "Pool",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class Pool(_PoolBase):\n    \"\"\"\n    Pool used in CatBoost as a data structure to train model from.\n    \"\"\"\n    def __init__(\n        self,\n        data,\n        label=None,\n        cat_features=None,\n        text_features=None,",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_CatBoostBase",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class _CatBoostBase(object):\n    def __init__(self, params):\n        init_params = params.copy() if params is not None else {}\n        stringify_builtin_metrics(init_params)\n        self._init_params = init_params\n        if 'thread_count' in self._init_params and self._init_params['thread_count'] == -1:\n            self._init_params.pop('thread_count')\n        if 'fixed_binary_splits' in self._init_params and self._init_params['fixed_binary_splits'] is None:\n            self._init_params['fixed_binary_splits'] = []\n        self._object = _CatBoost()",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "CatBoost",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class CatBoost(_CatBoostBase):\n    \"\"\"\n    CatBoost model. Contains training, prediction and evaluation methods.\n    \"\"\"\n    def __init__(self, params=None):\n        \"\"\"\n        Initialize the CatBoost.\n        Parameters\n        ----------\n        params : dict",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "CatBoostClassifier",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class CatBoostClassifier(CatBoost):\n    \"\"\"\n    Implementation of the scikit-learn API for CatBoost classification.\n    Parameters\n    ----------\n    iterations : int, [default=500]\n        Max count of trees.\n        range: [1,+inf)\n    learning_rate : float, [default value is selected automatically for binary classification with other parameters set to default. In all other cases default is 0.03]\n        Step size shrinkage used in update to prevents overfitting.",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "CatBoostRegressor",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class CatBoostRegressor(CatBoost):\n    \"\"\"\n    Implementation of the scikit-learn API for CatBoost regression.\n    Parameters\n    ----------\n    Like in CatBoostClassifier, except loss_function, classes_count, class_names and class_weights\n    loss_function : string, [default='RMSE']\n        'RMSE'\n        'MAE'\n        'Quantile:alpha=value'",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "CatBoostRanker",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class CatBoostRanker(CatBoost):\n    \"\"\"\n    Implementation of the scikit-learn API for CatBoost ranking.\n    Parameters\n    ----------\n    Like in CatBoostClassifier, except loss_function, classes_count, class_names and class_weights\n    loss_function : string, [default='YetiRank']\n        'YetiRank'\n        'YetiRankPairwise'\n        'StochasticFilter'",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "BatchMetricCalcer",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class BatchMetricCalcer(_MetricCalcerBase):\n    def __init__(self, catboost, metrics, ntree_start, ntree_end, eval_period, thread_count, tmp_dir):\n        super(BatchMetricCalcer, self).__init__(catboost)\n        if tmp_dir is None:\n            tmp_dir = tempfile.mkdtemp()\n            delete_temp_dir_flag = True\n        else:\n            delete_temp_dir_flag = False\n        if isinstance(metrics, STRING_TYPES) or isinstance(metrics, BuiltinMetric):\n            metrics = [metrics]",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_TrainCallbacksWrapper",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "class _TrainCallbacksWrapper(object):\n    def __init__(self, callbacks):\n        self._callbacks = callbacks\n    def after_iteration(self, info):\n        for cb in self._callbacks:\n            if not cb.after_iteration(info):\n                return False\n        return True",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "create_dir_if_not_exist",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def create_dir_if_not_exist(path):\n    if not os.path.exists(path):\n        os.mkdir(path)\nclass _StreamLikeWrapper:\n    def __init__(self, callable_object):\n        self.callable_object = callable_object\n    def write(self, message):\n        self.callable_object(message)\nclass _CustomLoggersStack(object):\n    def __init__(self):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "log_fixup",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def log_fixup(log_cout=None, log_cerr=None):\n    global _custom_loggers_stack\n    _custom_loggers_stack.push(log_cout, log_cerr)\n    try:\n        yield\n    finally:\n        _custom_loggers_stack.pop()\ndef _cast_to_base_types(value):\n    # NOTE: Special case, avoiding new list creation.\n    if isinstance(value, list):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "metric_description_or_str_to_str",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def metric_description_or_str_to_str(description):\n    return _metric_description_or_str_to_str(description)\ndef _check_param_type(value, name, types, or_none=True):\n    if not isinstance(value, types + ((type(None),) if or_none else ())):\n        raise CatBoostError('Parameter {} should have a type of {}, got {}'.format(name, types, type(value)))\ndef _process_verbose(metric_period=None, verbose=None, logging_level=None, verbose_eval=None, silent=None):\n    _check_param_type(metric_period, 'metric_period', (int,))\n    _check_param_type(verbose, 'verbose', (bool, int))\n    _check_param_type(logging_level, 'logging_level', (string_types,))\n    _check_param_type(verbose_eval, 'verbose_eval', (bool, int))",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "enum_from_enum_or_str",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def enum_from_enum_or_str(enum_type, arg):\n    if isinstance(arg, enum_type):\n        return arg\n    elif isinstance(arg, str):\n        return enum_type[arg]\n    else:\n        raise Exception(\"can't create enum \" + str(enum_type) + \" from type \" + str(type(arg)))\nclass EFstrType(Enum):\n    \"\"\"Calculate score for every feature by values change.\"\"\"\n    PredictionValuesChange = 0",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "plot_features_selection_loss_graph",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def plot_features_selection_loss_graph(\n    title,\n    entities_name,\n    entities_name_in_fields,\n    eliminated_entities_indices,\n    eliminated_entities_names,\n    loss_graph,\n    cost_graph=None\n):\n    warn_msg = \"To draw plots you should install plotly.\"",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "plot_features_selection_loss_graphs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def plot_features_selection_loss_graphs(summary):\n    result = {}\n    result['features'] = plot_features_selection_loss_graph(\n        'Loss by eliminated features',\n        'features',\n        'features',\n        summary['eliminated_features'],\n        summary['eliminated_features_names'],\n        summary['loss_graph']\n    )",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "plot_wrapper",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def plot_wrapper(plot, plot_file, plot_title, train_dirs):\n    if plot:\n        widget = _get_catboost_widget(train_dirs)\n        widget._run_update()\n    try:\n        yield\n    finally:\n        if plot:\n            widget._stop_update()\n    if plot_file is not None:",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "stringify_builtin_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def stringify_builtin_metrics(params):\n    \"\"\"Replace all occurrences of BuiltinMetric with their string representations.\"\"\"\n    for f in [\"loss_function\", \"objective\", \"eval_metric\", \"custom_metric\", \"custom_loss\"]:\n        if f not in params:\n            continue\n        val = params[f]\n        if isinstance(val, BuiltinMetric):\n            params[f] = str(val)\n        elif isinstance(val, STRING_TYPES):\n            continue",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "stringify_builtin_metrics_list",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def stringify_builtin_metrics_list(metrics):\n    return list(map(str, metrics))\ndef _get_loss_function_for_train(params, estimator_type, train_pool):\n    \"\"\"\n        estimator_type must be 'classifier', 'regressor', 'ranker' or None\n        train_pool must be Pool\n    \"\"\"\n    loss_function_param = params.get('loss_function')\n    if loss_function_param is not None:\n        return loss_function_param",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def train(pool=None, params=None, dtrain=None, logging_level=None, verbose=None, iterations=None,\n          num_boost_round=None, evals=None, eval_set=None, plot=None, plot_file=None, verbose_eval=None, metric_period=None,\n          early_stopping_rounds=None, save_snapshot=None, snapshot_file=None, snapshot_interval=None,\n          init_model=None, log_cout=None, log_cerr=None):\n    \"\"\"\n    Train CatBoost model.\n    Parameters\n    ----------\n    params : dict\n        Parameters for CatBoost.",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "sample_gaussian_process",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def sample_gaussian_process(X, y, eval_set=None,\n                            cat_features=None, text_features=None, embedding_features=None,\n                            random_seed=None, samples=10, posterior_iterations=900, prior_iterations=100, learning_rate=0.1,\n                            depth=6, sigma=0.1, delta=0, random_strength=0.1, random_score_type='Gumbel', eps=1e-4, verbose=False):\n    \"\"\"\n    Implementation of Gaussian process sampling (Kernel Gradient Boosting/Algorithm 4) from \"Gradient Boosting Performs Gaussian Process Inference\" https://arxiv.org/abs/2206.05608\n    Produces samples from posterior GP with prior assumption f ~ GP(0, sigma ** 2 K + delta ** 2 I)\n    Parameters\n    ----------\n    X : list or numpy.ndarray or pandas.DataFrame or pandas.Series or catboost.FeaturesData",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def cv(pool=None, params=None, dtrain=None, iterations=None, num_boost_round=None,\n       fold_count=None, nfold=None, inverted=False, partition_random_seed=0, seed=None,\n       shuffle=True, logging_level=None, stratified=None, as_pandas=True, metric_period=None,\n       verbose=None, verbose_eval=None, plot=False, plot_file=None, early_stopping_rounds=None,\n       save_snapshot=None, snapshot_file=None, snapshot_interval=None, metric_update_interval=0.5,\n       folds=None, type='Classical', return_models=False, log_cout=None, log_cerr=None):\n    \"\"\"\n    Cross-validate the CatBoost model.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "sum_models",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def sum_models(models, weights=None, ctr_merge_policy='IntersectingCountersAverage'):\n    result = CatBoost()\n    result._sum_models(models, weights, ctr_merge_policy)\n    return result\ndef _calc_feature_statistics_layout(go, xaxis, single_pool):\n    return go.Layout(\n        yaxis={\n            'title': 'Prediction and target',\n            'side': 'left',\n            'overlaying': 'y2'",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "to_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def to_regressor(model):\n    return _to_subclass(model, CatBoostRegressor)\ndef to_classifier(model):\n    return _to_subclass(model, CatBoostClassifier)\ndef to_ranker(model):\n    return _to_subclass(model, CatBoostRanker)\nclass _TrainCallbacksWrapper(object):\n    def __init__(self, callbacks):\n        self._callbacks = callbacks\n    def after_iteration(self, info):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "to_classifier",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def to_classifier(model):\n    return _to_subclass(model, CatBoostClassifier)\ndef to_ranker(model):\n    return _to_subclass(model, CatBoostRanker)\nclass _TrainCallbacksWrapper(object):\n    def __init__(self, callbacks):\n        self._callbacks = callbacks\n    def after_iteration(self, info):\n        for cb in self._callbacks:\n            if not cb.after_iteration(info):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "to_ranker",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "def to_ranker(model):\n    return _to_subclass(model, CatBoostRanker)\nclass _TrainCallbacksWrapper(object):\n    def __init__(self, callbacks):\n        self._callbacks = callbacks\n    def after_iteration(self, info):\n        for cb in self._callbacks:\n            if not cb.after_iteration(info):\n                return False\n        return True",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_typeof",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_typeof = type\n_PoolBase = _catboost._PoolBase\n_CatBoost = _catboost._CatBoost\n_MetricCalcerBase = _catboost._MetricCalcerBase\n_cv = _catboost._cv\n_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_PoolBase",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_PoolBase = _catboost._PoolBase\n_CatBoost = _catboost._CatBoost\n_MetricCalcerBase = _catboost._MetricCalcerBase\n_cv = _catboost._cv\n_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_CatBoost",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_CatBoost = _catboost._CatBoost\n_MetricCalcerBase = _catboost._MetricCalcerBase\n_cv = _catboost._cv\n_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_MetricCalcerBase",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_MetricCalcerBase = _catboost._MetricCalcerBase\n_cv = _catboost._cv\n_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_cv",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_cv = _catboost._cv\n_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_set_logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_set_logger = _catboost._set_logger\n_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_reset_logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_reset_logger = _catboost._reset_logger\n_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_configure_malloc",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_configure_malloc = _catboost._configure_malloc\nCatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "CatBoostError",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "CatBoostError = _catboost.CatBoostError\n_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_metric_description_or_str_to_str",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_metric_description_or_str_to_str = _catboost._metric_description_or_str_to_str\nis_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_classification_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_classification_objective = _catboost.is_classification_objective\nis_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_cv_stratified_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_cv_stratified_objective = _catboost.is_cv_stratified_objective\nis_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_regression_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_regression_objective = _catboost.is_regression_objective\nis_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_multiregression_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_multiregression_objective = _catboost.is_multiregression_objective\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_multitarget_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_multitarget_objective = _catboost.is_multitarget_objective\nis_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_survivalregression_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_survivalregression_objective = _catboost.is_survivalregression_objective\nis_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_groupwise_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_groupwise_metric = _catboost.is_groupwise_metric\nis_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_ranking_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_ranking_metric = _catboost.is_ranking_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_maximizable_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "is_minimizable_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "is_minimizable_metric = _catboost.is_minimizable_metric\n_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_PreprocessParams",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_PreprocessParams = _catboost._PreprocessParams\n_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_check_train_params",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_check_train_params = _catboost._check_train_params\n_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_MetadataHashProxy",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_MetadataHashProxy = _catboost._MetadataHashProxy\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_NumpyAwareEncoder",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\nFeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "FeaturesData",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "FeaturesData = _catboost.FeaturesData\n_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_have_equal_features",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_have_equal_features = _catboost._have_equal_features\nSPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "SPARSE_MATRIX_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "SPARSE_MATRIX_TYPES = _catboost.SPARSE_MATRIX_TYPES\nMultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "MultiTargetCustomMetric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "MultiTargetCustomMetric = _catboost.MultiTargetCustomMetric\nMultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "MultiTargetCustomObjective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "MultiTargetCustomObjective = _catboost.MultiTargetCustomObjective\nMultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "MultiRegressionCustomMetric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "MultiRegressionCustomMetric = _catboost.MultiTargetCustomMetric  # for compatibility\nMultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "MultiRegressionCustomObjective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "MultiRegressionCustomObjective = _catboost.MultiTargetCustomObjective  # for compatibility\nfspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "fspath",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "fspath = _catboost.fspath\n_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_eval_metric_util",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_eval_metric_util = _catboost._eval_metric_util\nlogger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "logger = logging.getLogger(__name__)\n_configure_malloc()\n_catboost._library_init()\nINTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)\nelif sys.version_info >= (3, 4):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "INTEGER_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "INTEGER_TYPES = (integer_types, np.integer)\nFLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)\nelif sys.version_info >= (3, 4):\n    from pathlib import Path\n    PATH_TYPES = STRING_TYPES + (Path,)\nelse:",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "FLOAT_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "FLOAT_TYPES = (float, np.floating)\nSTRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)\nelif sys.version_info >= (3, 4):\n    from pathlib import Path\n    PATH_TYPES = STRING_TYPES + (Path,)\nelse:\n    PATH_TYPES = STRING_TYPES",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "STRING_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "STRING_TYPES = (string_types,)\nARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)\nelif sys.version_info >= (3, 4):\n    from pathlib import Path\n    PATH_TYPES = STRING_TYPES + (Path,)\nelse:\n    PATH_TYPES = STRING_TYPES\ndef create_dir_if_not_exist(path):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "ARRAY_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "ARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\nif sys.version_info >= (3, 6):\n    PATH_TYPES = STRING_TYPES + (os.PathLike,)\nelif sys.version_info >= (3, 4):\n    from pathlib import Path\n    PATH_TYPES = STRING_TYPES + (Path,)\nelse:\n    PATH_TYPES = STRING_TYPES\ndef create_dir_if_not_exist(path):\n    if not os.path.exists(path):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "_custom_loggers_stack",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.core",
        "description": "catboost.catboost.python-package.catboost.core",
        "peekOfCode": "_custom_loggers_stack = _CustomLoggersStack()\n@contextmanager\ndef log_fixup(log_cout=None, log_cerr=None):\n    global _custom_loggers_stack\n    _custom_loggers_stack.push(log_cout, log_cerr)\n    try:\n        yield\n    finally:\n        _custom_loggers_stack.pop()\ndef _cast_to_base_types(value):",
        "detail": "catboost.catboost.python-package.catboost.core",
        "documentation": {}
    },
    {
        "label": "set_cache_path",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def set_cache_path(path):\n    assert isinstance(path, PATH_TYPES), 'expected string or pathlib.Path'\n    global _cache_path\n    _cache_path = fspath(path)\ndef _download_dataset(url, md5, dataset_name, train_file, test_file, cache=False):\n    # TODO(yazevnul): this is not thread safe (or process safe?), we should take a file lock when\n    # enter this function to avoid dataset being overwritten or corrupted or something else that may\n    # have happen when OS operated simultaneously on the same file. Same thing should probably be\n    # done with `_cached_download`.\n    dir_path = os.path.join(_get_cache_path(), dataset_name) if cache else tempfile.mkdtemp()",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "titanic",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def titanic():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/233854/titanic.tar.gz'\n    md5 = '9c8bc61d545c6af244a1d37494df3fc3'\n    dataset_name, train_file, test_file = 'titanic', 'train.csv', 'test.csv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file)\ndef amazon():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/250854/amazon.tar.gz'\n    md5 = '8fe3eec12bfd9c4c532b24a181d0aa2c'\n    dataset_name, train_file, test_file = 'amazon', 'train.csv', 'test.csv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file)",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "amazon",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def amazon():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/250854/amazon.tar.gz'\n    md5 = '8fe3eec12bfd9c4c532b24a181d0aa2c'\n    dataset_name, train_file, test_file = 'amazon', 'train.csv', 'test.csv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file)\ndef msrank():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/233854/msrank.tar.gz'\n    md5 = '34fee225d02419adc106581f4eb36f2e'\n    dataset_name, train_file, test_file = 'msrank', 'train.tsv', 'test.tsv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file, header=None, sep='\\t', cache=True)",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "msrank",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def msrank():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/233854/msrank.tar.gz'\n    md5 = '34fee225d02419adc106581f4eb36f2e'\n    dataset_name, train_file, test_file = 'msrank', 'train.tsv', 'test.tsv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file, header=None, sep='\\t', cache=True)\ndef msrank_10k():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/250854/msrank_10k.tar.gz'\n    md5 = '79c5b67397289c4c8b367c1f34629eae'\n    dataset_name, train_file, test_file = 'msrank_10k', 'train.csv', 'test.csv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file, header=None)",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "msrank_10k",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def msrank_10k():\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/250854/msrank_10k.tar.gz'\n    md5 = '79c5b67397289c4c8b367c1f34629eae'\n    dataset_name, train_file, test_file = 'msrank_10k', 'train.csv', 'test.csv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file, header=None)\ndef rotten_tomatoes():\n    \"\"\"\n    Contains information from kaggle [1], which is made available here under the Open Database License (ODbL) [2].\n    Download \"rotten_tomatoes\" [1] data set.\n    Will return two pandas.DataFrame-s, first with train part (rotten_tomatoes.data) and second with test part",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "rotten_tomatoes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def rotten_tomatoes():\n    \"\"\"\n    Contains information from kaggle [1], which is made available here under the Open Database License (ODbL) [2].\n    Download \"rotten_tomatoes\" [1] data set.\n    Will return two pandas.DataFrame-s, first with train part (rotten_tomatoes.data) and second with test part\n    (rotten_tomatoes.test) of the dataset.\n    NOTE: This is a preprocessed version of the dataset.\n    [1]: https://www.kaggle.com/rpnuser8182/rotten-tomatoes\n    [2]: https://opendatacommons.org/licenses/odbl/1-0/index.html\n    \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "imdb",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def imdb():\n    url = 'https://catboost-opensource.s3.yandex.net/imdb.tar.gz'\n    md5 = '0fd62578d631ac3d71a71c3e6ced6f8b'\n    dataset_name, train_file, test_file = 'imdb', 'learn.tsv', 'test.tsv'\n    return _load_dataset_pd(url, md5, dataset_name, train_file, test_file, sep='\\t')\ndef epsilon():\n    \"\"\"\n    Download \"epsilon\" [1] data set.\n    Will return two pandas.DataFrame-s, first with train part (epsilon_normalized) and second with\n    test part (epsilon_normalized.t) of the dataset. Object class will be located in the first",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def epsilon():\n    \"\"\"\n    Download \"epsilon\" [1] data set.\n    Will return two pandas.DataFrame-s, first with train part (epsilon_normalized) and second with\n    test part (epsilon_normalized.t) of the dataset. Object class will be located in the first\n    column of dataset.\n    NOTE: This is a preprocessed version of the dataset. It was converted from libsvm format into\n    tsv (CatBoost doesn't support libsvm format out of the box).\n    [1]: https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html#epsilon\n    \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "monotonic1",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def monotonic1():\n    \"\"\"\n    Dataset with monotonic constraints.\n    Can be used for poisson regression.\n    Has several numerical and several categorical features.\n    The first column contains target values. Columns with names Cat* contain categorical features.\n    Columns with names Num* contain numerical features.\n    Dataset also contains several numerical features, for which monotonic constraints must hold.\n    For features in columns named MonotonicNeg*, if feature value decreases, then prediction value must not decrease.\n    Thus, if there are two samples x1, x2 with all features being equal except",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "monotonic2",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def monotonic2():\n    \"\"\"\n    Dataset with monotonic constraints.\n    Can be used for regression.\n    The first column contains target values.\n    Other columns contain contain numerical features, for which monotonic constraints must hold.\n    For features in columns named MonotonicNeg*, if feature value decreases, then prediction\n    value must not decrease. Thus, if there are two samples x1, x2 with all features being\n    equal except for a monotonic negative feature MNeg, such that x1[MNeg] > x2[MNeg], then\n    the following inequality must hold for predictions: f(x1) <= f(x2)",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "adult",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def adult():\n    \"\"\"\n    Download \"Adult Data Set\" [1] from UCI Machine Learning Repository.\n    Will return two pandas.DataFrame-s, first with train part (adult.data) and second with test part\n    (adult.test) of the dataset.\n    [1]: https://archive.ics.uci.edu/ml/datasets/Adult\n    \"\"\"\n    # via https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names\n    names = (\n        'age', 'workclass', 'fnlwgt', 'education', 'education-num', 'marital-status', 'occupation',",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "higgs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "def higgs():\n    \"\"\"\n    Download \"higgs\" [1] data set.\n    Will return two pandas.DataFrame-s, first with train part and second with\n    test part of the dataset. Object class will be located in the first\n    column of dataset.\n    [1]: https://archive.ics.uci.edu/ml/datasets/HIGGS\n    \"\"\"\n    url = 'https://storage.mds.yandex.net/get-devtools-opensource/250854/higgs.tar.gz'\n    md5 = 'ad59ba8328a9afa3837d7bf1a0e10e7b'",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef _extract(src_file, dst_dir='.'):\n    cur_dir = os.getcwd()\n    os.chdir(dst_dir)\n    try:\n        with tarfile.open(src_file, 'r:gz') as f:\n            f.extractall()\n    finally:\n        os.chdir(cur_dir)\ndef _calc_md5(path):",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "_cache_path",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.datasets",
        "description": "catboost.catboost.python-package.catboost.datasets",
        "peekOfCode": "_cache_path = None\ndef _get_cache_path():\n    global _cache_path\n    if _cache_path is None:\n        _cache_path = os.path.join(os.getcwd(), 'catboost_cached_datasets')\n    return _cache_path\ndef set_cache_path(path):\n    assert isinstance(path, PATH_TYPES), 'expected string or pathlib.Path'\n    global _cache_path\n    _cache_path = fspath(path)",
        "detail": "catboost.catboost.python-package.catboost.datasets",
        "documentation": {}
    },
    {
        "label": "is_groupwise_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_groupwise_metric = _catboost.is_groupwise_metric\nis_multiclass_metric = _catboost.is_multiclass_metric\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_classification_objective = _catboost.is_classification_objective\nget_multi_quantile_approx_size = _catboost.get_multi_quantile_approx_size\nis_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_multiclass_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_multiclass_metric = _catboost.is_multiclass_metric\nis_multitarget_objective = _catboost.is_multitarget_objective\nis_classification_objective = _catboost.is_classification_objective\nget_multi_quantile_approx_size = _catboost.get_multi_quantile_approx_size\nis_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_multitarget_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_multitarget_objective = _catboost.is_multitarget_objective\nis_classification_objective = _catboost.is_classification_objective\nget_multi_quantile_approx_size = _catboost.get_multi_quantile_approx_size\nis_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_classification_objective",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_classification_objective = _catboost.is_classification_objective\nget_multi_quantile_approx_size = _catboost.get_multi_quantile_approx_size\nis_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "get_multi_quantile_approx_size",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "get_multi_quantile_approx_size = _catboost.get_multi_quantile_approx_size\nis_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_pairwise_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_pairwise_metric = _catboost.is_pairwise_metric\nis_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_maximizable_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_maximizable_metric = _catboost.is_maximizable_metric\nis_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_minimizable_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_minimizable_metric = _catboost.is_minimizable_metric\nis_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "is_user_defined_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "is_user_defined_metric = _catboost.is_user_defined_metric\nhas_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "has_gpu_implementation_metric",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "has_gpu_implementation_metric = _catboost.has_gpu_implementation_metric\nget_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "get_experiment_name",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "get_experiment_name = _catboost.get_experiment_name\nconvert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "convert_features_to_indices",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "convert_features_to_indices = _catboost.convert_features_to_indices\nget_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "get_num_feature_values_sample",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.dev_utils",
        "description": "catboost.catboost.python-package.catboost.dev_utils",
        "peekOfCode": "get_num_feature_values_sample = _catboost.get_num_feature_values_sample",
        "detail": "catboost.catboost.python-package.catboost.dev_utils",
        "documentation": {}
    },
    {
        "label": "BuiltinMetric",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.metrics",
        "description": "catboost.catboost.python-package.catboost.metrics",
        "peekOfCode": "class BuiltinMetric(object):\n    @staticmethod\n    def params_with_defaults():\n        \"\"\"\n        For each valid metric parameter, returns its default value and if this parameter is mandatory.\n        Implemented in child classes.\n        Returns\n        ----------\n        valid_params: dict: param_name -> {'default_value': default value or None, 'is_mandatory': bool}\n        \"\"\"",
        "detail": "catboost.catboost.python-package.catboost.metrics",
        "documentation": {}
    },
    {
        "label": "_MetricGenerator",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.metrics",
        "description": "catboost.catboost.python-package.catboost.metrics",
        "peekOfCode": "class _MetricGenerator(type):\n    def __new__(mcs, name, parents, attrs):\n        for k in attrs['_valid_params']:\n            attrs[k] = property(\n                partial(_get_param, name=k),\n                partial(_set_param, name=k),\n                partial(_del_param, name=k),\n                'Parameter {} of metric {}'.format(k, name),\n            )\n        attrs['params_with_defaults'] = staticmethod(lambda: {param: {'default_value': default_value,",
        "detail": "catboost.catboost.python-package.catboost.metrics",
        "documentation": {}
    },
    {
        "label": "_ARRAY_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.metrics",
        "description": "catboost.catboost.python-package.catboost.metrics",
        "peekOfCode": "_ARRAY_TYPES = (list, np.ndarray, DataFrame, Series)\n__all__ = []\nclass BuiltinMetric(object):\n    @staticmethod\n    def params_with_defaults():\n        \"\"\"\n        For each valid metric parameter, returns its default value and if this parameter is mandatory.\n        Implemented in child classes.\n        Returns\n        ----------",
        "detail": "catboost.catboost.python-package.catboost.metrics",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.metrics",
        "description": "catboost.catboost.python-package.catboost.metrics",
        "peekOfCode": "__all__ = []\nclass BuiltinMetric(object):\n    @staticmethod\n    def params_with_defaults():\n        \"\"\"\n        For each valid metric parameter, returns its default value and if this parameter is mandatory.\n        Implemented in child classes.\n        Returns\n        ----------\n        valid_params: dict: param_name -> {'default_value': default value or None, 'is_mandatory': bool}",
        "detail": "catboost.catboost.python-package.catboost.metrics",
        "documentation": {}
    },
    {
        "label": "to_polynom",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def to_polynom(model):\n    _check_model(model)\n    return _catboost.to_polynom(model._object)\ndef to_polynom_string(model):\n    _check_model(model)\n    return _catboost.to_polynom_string(model._object)\ndef explain_features(model):\n    _check_model(model)\n    return _catboost.explain_features(model._object)\ndef calc_features_strength(model):",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "to_polynom_string",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def to_polynom_string(model):\n    _check_model(model)\n    return _catboost.to_polynom_string(model._object)\ndef explain_features(model):\n    _check_model(model)\n    return _catboost.explain_features(model._object)\ndef calc_features_strength(model):\n    explanations = explain_features(model)\n    features_strength = [expl.calc_strength() for expl in explanations]\n    return features_strength",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "explain_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def explain_features(model):\n    _check_model(model)\n    return _catboost.explain_features(model._object)\ndef calc_features_strength(model):\n    explanations = explain_features(model)\n    features_strength = [expl.calc_strength() for expl in explanations]\n    return features_strength\ndef plot_pdp(arg, size_per_plot=(5, 5), plots_per_row=None):\n    with _import_matplotlib() as _plt:\n        plt = _plt",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "calc_features_strength",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def calc_features_strength(model):\n    explanations = explain_features(model)\n    features_strength = [expl.calc_strength() for expl in explanations]\n    return features_strength\ndef plot_pdp(arg, size_per_plot=(5, 5), plots_per_row=None):\n    with _import_matplotlib() as _plt:\n        plt = _plt\n    if isinstance(arg, CatBoost):\n        arg = explain_features(arg)\n    if isinstance(arg, _catboost.FeatureExplanation):",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "plot_pdp",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def plot_pdp(arg, size_per_plot=(5, 5), plots_per_row=None):\n    with _import_matplotlib() as _plt:\n        plt = _plt\n    if isinstance(arg, CatBoost):\n        arg = explain_features(arg)\n    if isinstance(arg, _catboost.FeatureExplanation):\n        arg = [arg]\n    assert len(arg) > 0\n    assert isinstance(arg, list)\n    for element in arg:",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "plot_features_strength",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "def plot_features_strength(model, height_per_feature=0.5, width_per_plot=5, plots_per_row=None):\n    with _import_matplotlib() as _plt:\n        plt = _plt\n    strengths = calc_features_strength(model)\n    dimension = len(strengths[0])\n    features = len(strengths)\n    if not plots_per_row:\n        plots_per_row = min(5, dimension)\n    rows = int(math.ceil(dimension / plots_per_row))\n    fig, axes = plt.subplots(rows, plots_per_row)",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "FeatureExplanation",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.monoforest",
        "description": "catboost.catboost.python-package.catboost.monoforest",
        "peekOfCode": "FeatureExplanation = _catboost.FeatureExplanation\ndef _check_model(model):\n    if not isinstance(model, CatBoost):\n        raise CatBoostError(\"Model should be CatBoost\")\ndef to_polynom(model):\n    _check_model(model)\n    return _catboost.to_polynom(model._object)\ndef to_polynom_string(model):\n    _check_model(model)\n    return _catboost.to_polynom_string(model._object)",
        "detail": "catboost.catboost.python-package.catboost.monoforest",
        "documentation": {}
    },
    {
        "label": "OfflineMetricVisualizer",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.catboost.plot_helpers",
        "description": "catboost.catboost.python-package.catboost.plot_helpers",
        "peekOfCode": "class OfflineMetricVisualizer(object):\n    def __init__(self, train_dirs):\n        if isinstance(train_dirs, str):\n            train_dirs = [train_dirs]\n        self._load_data(train_dirs)\n    def _update_data_from_dir(self, path):\n        data = {\n            'iterations': [],\n            'meta': {}\n        }",
        "detail": "catboost.catboost.python-package.catboost.plot_helpers",
        "documentation": {}
    },
    {
        "label": "try_plot_offline",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.plot_helpers",
        "description": "catboost.catboost.python-package.catboost.plot_helpers",
        "peekOfCode": "def try_plot_offline(figs):\n    try:\n        from plotly.offline import iplot\n        from plotly.offline import init_notebook_mode\n        init_notebook_mode(connected=True)\n    except ImportError as e:\n        warn_msg = \"To draw plots you should install plotly.\"\n        warnings.warn(warn_msg)\n        raise ImportError(str(e))\n    if not isinstance(figs, list):",
        "detail": "catboost.catboost.python-package.catboost.plot_helpers",
        "documentation": {}
    },
    {
        "label": "save_plot_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.plot_helpers",
        "description": "catboost.catboost.python-package.catboost.plot_helpers",
        "peekOfCode": "def save_plot_file(plot_file, plot_name, figs):\n    warn_msg = \"To draw plots you should install plotly.\"\n    try:\n        from plotly.offline import plot as plotly_plot\n    except ImportError as e:\n        warnings.warn(warn_msg)\n        raise ImportError(str(e))\n    def write_plot_file(plot_file_stream):\n        plot_file_stream.write('\\n'.join((\n            '<html>',",
        "detail": "catboost.catboost.python-package.catboost.plot_helpers",
        "documentation": {}
    },
    {
        "label": "fspath",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.plot_helpers",
        "description": "catboost.catboost.python-package.catboost.plot_helpers",
        "peekOfCode": "fspath = _catboost.fspath\ndef try_plot_offline(figs):\n    try:\n        from plotly.offline import iplot\n        from plotly.offline import init_notebook_mode\n        init_notebook_mode(connected=True)\n    except ImportError as e:\n        warn_msg = \"To draw plots you should install plotly.\"\n        warnings.warn(warn_msg)\n        raise ImportError(str(e))",
        "detail": "catboost.catboost.python-package.catboost.plot_helpers",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.text_processing",
        "description": "catboost.catboost.python-package.catboost.text_processing",
        "peekOfCode": "Tokenizer = _catboost.Tokenizer\nDictionary = _catboost.Dictionary",
        "detail": "catboost.catboost.python-package.catboost.text_processing",
        "documentation": {}
    },
    {
        "label": "Dictionary",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.text_processing",
        "description": "catboost.catboost.python-package.catboost.text_processing",
        "peekOfCode": "Dictionary = _catboost.Dictionary",
        "detail": "catboost.catboost.python-package.catboost.text_processing",
        "documentation": {}
    },
    {
        "label": "create_cd",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def create_cd(\n    label=None,\n    cat_features=None,\n    text_features=None,\n    embedding_features=None,\n    weight=None,\n    baseline=None,\n    doc_id=None,\n    group_id=None,\n    subgroup_id=None,",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "read_cd",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def read_cd(cd_file, column_count=None, data_file=None, canonize_column_types=False):\n    \"\"\"\n    Reads CatBoost column description file\n    (see https://catboost.ai/docs/concepts/input-data_column-descfile.html#input-data_column-descfile)\n    Parameters\n    ----------\n    cd_file : str or pathlib.Path\n        path to column description file\n    column_count : integer\n        total number of columns",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def eval_metric(label, approx, metric, weight=None, group_id=None, group_weight=None, subgroup_id=None, pairs=None, thread_count=-1):\n    \"\"\"\n    Evaluate metrics with raw approxes and labels.\n    Parameters\n    ----------\n    label : list or numpy.ndarrays or pandas.DataFrame or pandas.Series\n        Object labels with shape (n_objects,) or (n_object, n_target_dimension)\n    approx : list or numpy.ndarrays or pandas.DataFrame or pandas.Series\n        Object approxes with shape (n_objects,) or (n_object, n_approx_dimension).\n    metric : string",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_gpu_device_count",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def get_gpu_device_count():\n    return _catboost._get_gpu_device_count()\ndef reset_trace_backend(filename):\n    _catboost._reset_trace_backend(filename)\ndef get_confusion_matrix(model, data, thread_count=-1):\n    \"\"\"\n    Build confusion matrix.\n    Parameters\n    ----------\n    model : catboost.CatBoost",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "reset_trace_backend",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def reset_trace_backend(filename):\n    _catboost._reset_trace_backend(filename)\ndef get_confusion_matrix(model, data, thread_count=-1):\n    \"\"\"\n    Build confusion matrix.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_confusion_matrix",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def get_confusion_matrix(model, data, thread_count=-1):\n    \"\"\"\n    Build confusion matrix.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool\n        A set of samples to build confusion matrix with.\n    thread_count : int (default=-1)",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_roc_curve",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def get_roc_curve(model, data, thread_count=-1, plot=False):\n    \"\"\"\n    Build points of ROC curve.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool or list of catboost.Pool\n        A set of samples to build ROC curve with.\n    thread_count : int (default=-1)",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_fpr_curve",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def get_fpr_curve(model=None, data=None, curve=None, thread_count=-1, plot=False):\n    \"\"\"\n    Build points of FPR curve.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool or list of catboost.Pool\n        A set of samples to build ROC curve with.\n    curve : tuple of three arrays (fpr, tpr, thresholds)",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "get_fnr_curve",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def get_fnr_curve(model=None, data=None, curve=None, thread_count=-1, plot=False):\n    \"\"\"\n    Build points of FNR curve.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool or list of catboost.Pool\n        A set of samples to build ROC curve with.\n    curve : tuple of three arrays (fpr, tpr, thresholds)",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "select_threshold",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def select_threshold(model=None, data=None, curve=None, FPR=None, FNR=None, thread_count=-1):\n    \"\"\"\n    Selects a threshold for prediction.\n    Parameters\n    ----------\n    model : catboost.CatBoost\n        The trained model.\n    data : catboost.Pool or list of catboost.Pool\n        Set of samples to build ROC curve with.\n        If set, curve parameter must not be set.",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "quantize",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def quantize(\n    data_path,\n    column_description=None,\n    pairs=None,\n    delimiter='\\t',\n    has_header=False,\n    ignore_csv_quoting=False,\n    feature_names=None,\n    thread_count=-1,\n    ignored_features=None,",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "convert_to_onnx_object",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def convert_to_onnx_object(model, export_parameters=None, **kwargs):\n    \"\"\"\n    Convert given CatBoost model to ONNX-ML model.\n    Categorical Features are not supported.\n    Parameters\n    ----------\n    model : CatBoost trained model\n    export_parameters : dict [default=None]\n        Parameters for ONNX-ML export:\n            * onnx_graph_name : string",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "calculate_quantization_grid",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "def calculate_quantization_grid(values, border_count, border_type='Median'):\n    assert border_count > 0, 'Border count should be > 0'\n    return _calculate_quantization_grid(values, border_count, border_type)",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_eval_metric_util",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_eval_metric_util = _catboost._eval_metric_util\n_get_roc_curve = _catboost._get_roc_curve\n_get_confusion_matrix = _catboost._get_confusion_matrix\n_select_threshold = _catboost._select_threshold\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\n_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_get_roc_curve",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_get_roc_curve = _catboost._get_roc_curve\n_get_confusion_matrix = _catboost._get_confusion_matrix\n_select_threshold = _catboost._select_threshold\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\n_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_get_confusion_matrix",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_get_confusion_matrix = _catboost._get_confusion_matrix\n_select_threshold = _catboost._select_threshold\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\n_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_select_threshold",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_select_threshold = _catboost._select_threshold\n_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\n_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_NumpyAwareEncoder",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_NumpyAwareEncoder = _catboost._NumpyAwareEncoder\n_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_get_onnx_model",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_get_onnx_model = _catboost._get_onnx_model\n_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "_calculate_quantization_grid",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "_calculate_quantization_grid = _catboost._calculate_quantization_grid\ncompute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as e:",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "compute_wx_test",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "compute_wx_test = _catboost.compute_wx_test\nTargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as e:\n        warnings.warn(\"To draw plots you should install matplotlib.\")",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "TargetStats",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "TargetStats = _catboost.TargetStats\nDataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as e:\n        warnings.warn(\"To draw plots you should install matplotlib.\")\n        raise ImportError(str(e))",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "DataMetaInfo",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "DataMetaInfo = _catboost.DataMetaInfo\ncompute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as e:\n        warnings.warn(\"To draw plots you should install matplotlib.\")\n        raise ImportError(str(e))\n    yield plt",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "compute_training_options",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.utils",
        "description": "catboost.catboost.python-package.catboost.utils",
        "peekOfCode": "compute_training_options = _catboost.compute_training_options\n@contextmanager\ndef _import_matplotlib():\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError as e:\n        warnings.warn(\"To draw plots you should install matplotlib.\")\n        raise ImportError(str(e))\n    yield plt\ndef _draw(plt, x, y, x_label, y_label, title):",
        "detail": "catboost.catboost.python-package.catboost.utils",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.catboost.version",
        "description": "catboost.catboost.python-package.catboost.version",
        "peekOfCode": "VERSION = '1.2.5'",
        "detail": "catboost.catboost.python-package.catboost.version",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 2, 3, 14, 15, 31, 32, 37, 46, 47, 48,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 11\n    tree_count = 2\n    float_feature_borders = [\n        [0.323544502],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 10, 11, 14, 15, 16, 17, 18, 20, 22, 23, 24, 26, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 46, 47, 48, 49,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 31\n    tree_count = 40\n    float_feature_borders = [\n        [0.00530660013, 0.116081499, 0.171101987, 0.201321989, 0.323544502, 0.34700349, 0.349058509],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 2, 4,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 4\n    tree_count = 2\n    float_feature_borders = [\n        [36.5, 51.5],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 22\n    tree_count = 40\n    float_feature_borders = [\n        [17.5, 36.5, 46.5, 51.5, 58.5, 59.5],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0,\n    ]\n    float_feature_count = 1\n    cat_feature_count = 1\n    binary_feature_count = 2\n    tree_count = 5\n    float_feature_borders = [\n        [2]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"2\": -1284790409,\n    \"4\": -78686594,\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.5-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 2, 3, 14, 15, 31, 32, 37, 46, 47, 48,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 11\n    tree_count = 2\n    float_feature_borders = [\n        [0.323544502],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 10, 11, 14, 15, 16, 17, 18, 20, 22, 23, 24, 26, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 46, 47, 48, 49,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 31\n    tree_count = 40\n    float_feature_borders = [\n        [0.00530660013, 0.116081499, 0.171101987, 0.201321989, 0.323544502, 0.34700349, 0.349058509],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_no_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 2, 4,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 4\n    tree_count = 2\n    float_feature_borders = [\n        [36.5, 51.5],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-2__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 22\n    tree_count = 40\n    float_feature_borders = [\n        [17.5, 36.5, 46.5, 51.5, 58.5, 59.5],",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_CPU-40__.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0,\n    ]\n    float_feature_count = 1\n    cat_feature_count = 1\n    binary_feature_count = 2\n    tree_count = 5\n    float_feature_borders = [\n        [2]",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "description": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "peekOfCode": "cat_features_hashes = {\n    \"2\": -1284790409,\n    \"4\": -78686594,\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.",
        "detail": "catboost.catboost.python-package.ut.large.canondata.run_python3_tests.test_3.6-test_export_to_python_with_cat_features_from_pandas_CPU__.model",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "description": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "peekOfCode": "def data_file(*path):\n    return os.path.join(os.environ[\"DATA_PATH\"], *path)\ndef local_canonical_file(path, diff_tool=None):\n    with open(\"canonize\", \"a\") as f:\n        f.write(path)\n        if diff_tool:\n            f.write(\" \" + (diff_tool if isinstance(diff_tool, str) else ' '.join(diff_tool)))\n        f.write(\"\\n\")",
        "detail": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "description": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "peekOfCode": "def local_canonical_file(path, diff_tool=None):\n    with open(\"canonize\", \"a\") as f:\n        f.write(path)\n        if diff_tool:\n            f.write(\" \" + (diff_tool if isinstance(diff_tool, str) else ' '.join(diff_tool)))\n        f.write(\"\\n\")",
        "detail": "catboost.catboost.python-package.ut.large.catboost_pytest_lib",
        "documentation": {}
    },
    {
        "label": "unpack_python",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.conftest",
        "description": "catboost.catboost.python-package.ut.large.conftest",
        "peekOfCode": "def unpack_python(dst_path, py_ver):\n    arch_name = {\n        \"3.6\": \"python3.6.tar.gz\",\n    }[py_ver]\n    tar = tarfile.open(yatest.common.binary_path(\"catboost/python-package/ut/large/pkg/\" + arch_name))\n    tar.extractall(path=dst_path)\n    tar.close()\ndef unpack_deps(dst_path, py_ver):\n    curdir = os.getcwd()\n    try:",
        "detail": "catboost.catboost.python-package.ut.large.conftest",
        "documentation": {}
    },
    {
        "label": "unpack_deps",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.conftest",
        "description": "catboost.catboost.python-package.ut.large.conftest",
        "peekOfCode": "def unpack_deps(dst_path, py_ver):\n    curdir = os.getcwd()\n    try:\n        os.makedirs(dst_path, exist_ok=True)\n        os.chdir(dst_path)\n        deps_dir = \"deps\"\n        if not os.path.exists(deps_dir):\n            tar = tarfile.open(yatest.common.binary_path(\"catboost/python-package/ut/large/pkg/deps.tgz\"))\n            tar.extractall(path=deps_dir)\n            tar.close()",
        "detail": "catboost.catboost.python-package.ut.large.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_sessionstart",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.conftest",
        "description": "catboost.catboost.python-package.ut.large.conftest",
        "peekOfCode": "def pytest_sessionstart(session):\n    test_root = yatest.common.source_path('catboost/python-package/ut/large/')\n    python_envs_dir = os.path.join(test_root, 'py_envs')\n    python_envs_lock = FileLock(os.path.join(test_root, 'py_envs.lock'))\n    with python_envs_lock:\n        if os.path.exists(python_envs_dir):\n            return\n        os.mkdir(python_envs_dir)\n        for py_ver in ['3.6']:\n            dst_path = os.path.join(python_envs_dir, py_ver)",
        "detail": "catboost.catboost.python-package.ut.large.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_collection_modifyitems",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.list_plugin",
        "description": "catboost.catboost.python-package.ut.large.list_plugin",
        "peekOfCode": "def pytest_collection_modifyitems(items, config):\n    with open(\"test-list\", \"w\") as f:\n        for item in items:\n            f.write(item.nodeid + \"\\n\")",
        "detail": "catboost.catboost.python-package.ut.large.list_plugin",
        "documentation": {}
    },
    {
        "label": "update_env",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "description": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "peekOfCode": "def update_env(env):\n    env[\"DATA_PATH\"] = yatest.common.source_path(os.path.join(\"catboost/pytest/data\"))\n    env[\"BINARY_PATH\"] = yatest.common.build_path()\ndef pytest_generate_tests(metafunc):\n    tests = []\n    for py_ver in [\"3.6\"]:\n        python_bin, python_env = prepare_all(py_ver)\n        update_env(python_env)\n        yatest.common.execute(\n            [",
        "detail": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "description": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "peekOfCode": "def pytest_generate_tests(metafunc):\n    tests = []\n    for py_ver in [\"3.6\"]:\n        python_bin, python_env = prepare_all(py_ver)\n        update_env(python_env)\n        yatest.common.execute(\n            [\n                python_bin,\n                \"-m\",\n                \"pytest\",",
        "detail": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "description": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "peekOfCode": "def test(py_ver, case):\n    python_bin, python_env = prepare_all(py_ver)\n    update_env(python_env)\n    try:\n        yatest.common.execute(\n            [\n                python_bin,\n                \"-m\",\n                \"pytest\",\n                TEST_SCRIPT + \"::\" + case,",
        "detail": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "documentation": {}
    },
    {
        "label": "TEST_SCRIPT",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "description": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "peekOfCode": "TEST_SCRIPT = yatest.common.source_path(os.path.join(\"catboost/python-package/ut/medium/test.py\"))\ndef update_env(env):\n    env[\"DATA_PATH\"] = yatest.common.source_path(os.path.join(\"catboost/pytest/data\"))\n    env[\"BINARY_PATH\"] = yatest.common.build_path()\ndef pytest_generate_tests(metafunc):\n    tests = []\n    for py_ver in [\"3.6\"]:\n        python_bin, python_env = prepare_all(py_ver)\n        update_env(python_env)\n        yatest.common.execute(",
        "detail": "catboost.catboost.python-package.ut.large.run_python3_tests",
        "documentation": {}
    },
    {
        "label": "prepare_all",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.test_whl",
        "description": "catboost.catboost.python-package.ut.large.test_whl",
        "peekOfCode": "def prepare_all(py_ver):\n    dst_path = yatest.common.source_path(os.path.join(PYTHON_PACKAGE_DIR, \"ut\", \"large\", 'py_envs', py_ver))\n    python_binary = os.path.abspath(os.path.join(dst_path, \"python\", \"bin\", \"python\" + py_ver))\n    python_env = {\n        \"PYTHONPATH\": \":\".join([os.path.join(dst_path, d) for d in [\"catboost\", \"libs\", \"dynlibs\"]]),\n        \"LD_LIBRARY_PATH\": os.path.join(dst_path, \"python/lib/x86_64-linux-gnu\"),\n    }\n    return python_binary, python_env\n@pytest.mark.parametrize(\"py_ver\", [\"3.6\"])\ndef test_wheel(py_ver):",
        "detail": "catboost.catboost.python-package.ut.large.test_whl",
        "documentation": {}
    },
    {
        "label": "test_wheel",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.large.test_whl",
        "description": "catboost.catboost.python-package.ut.large.test_whl",
        "peekOfCode": "def test_wheel(py_ver):\n    python_binary, python_env = prepare_all(py_ver)\n    catboost_test_script = yatest.common.source_path(os.path.join(PYTHON_PACKAGE_DIR, \"ut\", \"medium\", \"run_catboost.py\"))\n    catboost_source_data_path = yatest.common.source_path(os.path.join(\"catboost\", \"pytest\", \"data\", \"adult\"))\n    catboost_temp_data_path = os.path.join(yatest.common.test_output_path(), \"data\", \"adult\")\n    shutil.copytree(catboost_source_data_path, catboost_temp_data_path)\n    yatest.common.execute(\n        [python_binary, catboost_test_script],\n        env=python_env,\n        cwd=yatest.common.test_output_path()",
        "detail": "catboost.catboost.python-package.ut.large.test_whl",
        "documentation": {}
    },
    {
        "label": "PYTHON_PACKAGE_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.large.test_whl",
        "description": "catboost.catboost.python-package.ut.large.test_whl",
        "peekOfCode": "PYTHON_PACKAGE_DIR = os.path.join(\"catboost\", \"python-package\")\ndef prepare_all(py_ver):\n    dst_path = yatest.common.source_path(os.path.join(PYTHON_PACKAGE_DIR, \"ut\", \"large\", 'py_envs', py_ver))\n    python_binary = os.path.abspath(os.path.join(dst_path, \"python\", \"bin\", \"python\" + py_ver))\n    python_env = {\n        \"PYTHONPATH\": \":\".join([os.path.join(dst_path, d) for d in [\"catboost\", \"libs\", \"dynlibs\"]]),\n        \"LD_LIBRARY_PATH\": os.path.join(dst_path, \"python/lib/x86_64-linux-gnu\"),\n    }\n    return python_binary, python_env\n@pytest.mark.parametrize(\"py_ver\", [\"3.6\"])",
        "detail": "catboost.catboost.python-package.ut.large.test_whl",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        1, 2, 14, 15, 16, 20, 31, 33, 35, 39,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 10\n    tree_count = 2\n    float_feature_borders = [\n        [0.156479999],",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 5, 7, 8, 9, 11, 13, 14, 15, 16, 17, 20, 22, 24, 27, 31, 32, 33, 35, 37, 38, 39, 46, 47, 48, 49,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 28\n    tree_count = 40\n    float_feature_borders = [\n        [8.42320005e-05, 0.156679004, 0.157880992, 0.1838945, 0.204584509, 0.23446101, 0.350599498],",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_no_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4,\n    ]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 6\n    tree_count = 2\n    float_feature_borders = [\n        [35.5],",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 24\n    tree_count = 40\n    float_feature_borders = [\n        [28.5, 33.5, 35.5, 36.5, 37.5, 48, 52.5, 53.5, 56],",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_CPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0,\n    ]\n    float_feature_count = 1\n    cat_feature_count = 1\n    binary_feature_count = 2\n    tree_count = 5\n    float_feature_borders = [\n        [2]",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "peekOfCode": "def apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"2\": -1284790409,\n    \"4\": -78686594,\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model_multi(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.",
        "detail": "catboost.catboost.python-package.ut.medium.canondata.test.test_export_to_python_with_cat_features_from_pandas_CPU_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        2, 15, 16, 20, 23, 36, 37, 39, 47, 48,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 10\n    tree_count = 2\n    float_feature_borders = [\n        [0.937671542],",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 20, 22, 23, 24, 27, 31, 32, 33, 35, 36, 37, 38, 39, 46, 47, 48, 49,\n    ]\n    float_feature_count = 50\n    cat_feature_count = 0\n    binary_feature_count = 34\n    tree_count = 40\n    float_feature_borders = [\n        [0.127833009, 0.130409002, 0.180202499, 0.191020012, 0.209220499, 0.246136993],",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "peekOfCode": "cat_features_hashes = {\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_no_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 2, 3, 4, 5,\n    ]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 2, 3, 4, 5,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 8\n    tree_count = 2\n    float_feature_borders = [\n        [30.5, 33.5, 44.5],",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-2_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_model_ctr(object):\n    def __init__(self, base_hash, base_ctr_type, target_border_idx, prior_num, prior_denom, shift, scale):\n        self.base_hash = base_hash\n        self.base_ctr_type = base_ctr_type\n        self.target_border_idx = target_border_idx\n        self.prior_num = prior_num\n        self.prior_denom = prior_denom\n        self.shift = shift\n        self.scale = scale\n    def calc(self, count_in_class, total_count):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_bin_feature_index_value",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_bin_feature_index_value(object):\n    def __init__(self, bin_index, check_value_equal, value):\n        self.bin_index = bin_index\n        self.check_value_equal = check_value_equal\n        self.value = value\nclass catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_mean_history",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_ctr_mean_history(object):\n    def __init__(self, sum, count):\n        self.sum = sum\n        self.count = count\nclass catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_value_table",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_ctr_value_table(object):\n    def __init__(self, index_hash_viewer, target_classes_count, counter_denominator, ctr_mean_history, ctr_total):\n        self.index_hash_viewer = index_hash_viewer\n        self.target_classes_count = target_classes_count\n        self.counter_denominator = counter_denominator\n        self.ctr_mean_history = ctr_mean_history\n        self.ctr_total = ctr_total\n    def resolve_hash_index(self, hash):\n        try:\n            return self.index_hash_viewer[hash]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_ctr_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_ctr_data(object):\n    def __init__(self, learn_ctrs):\n        self.learn_ctrs = learn_ctrs\nclass catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_projection",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_projection(object):\n    def __init__(self, transposed_cat_feature_indexes, binarized_indexes):\n        self.transposed_cat_feature_indexes = transposed_cat_feature_indexes\n        self.binarized_indexes = binarized_indexes\nclass catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_compressed_model_ctr",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_compressed_model_ctr(object):\n    def __init__(self, projection, model_ctrs):\n        self.projection = projection\n        self.model_ctrs = model_ctrs\nclass catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model_ctrs_container",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_model_ctrs_container(object):\n    def __init__(self, used_model_ctrs_count, compressed_model_ctrs, ctr_data):\n        self.used_model_ctrs_count = used_model_ctrs_count\n        self.compressed_model_ctrs = compressed_model_ctrs\n        self.ctr_data = ctr_data\n###  Model data\nclass catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0, 1, 2, 3, 4, 5,\n    ]\n    float_feature_count = 6\n    cat_feature_count = 11\n    binary_feature_count = 17\n    tree_count = 40\n    float_feature_borders = [\n        [27.5, 30.5, 33.5, 36.5, 38.5, 41.5, 44.5, 45.5, 48, 50, 52.5, 53.5, 56, 58.5, 60.5],",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "def calc_hash(a, b):\n    max_int = 0xffFFffFFffFFffFF\n    MAGIC_MULT = 0x4906ba494954cb65\n    return (MAGIC_MULT * ((a + MAGIC_MULT * b) & max_int)) & max_int\ndef calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_hashes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "def calc_hashes(binarized_features, hashed_cat_features, transposed_cat_feature_indexes, binarized_feature_indexes):\n    result = 0\n    for cat_feature_index in transposed_cat_feature_indexes:\n        result = calc_hash(result, hashed_cat_features[cat_feature_index])\n    for bin_feature_index in binarized_feature_indexes:\n        binary_feature = binarized_features[bin_feature_index.bin_index]\n        if not(bin_feature_index.check_value_equal):\n            result = calc_hash(result, 1 if (binary_feature >= bin_feature_index.value) else 0)\n        else:\n            result = calc_hash(result, 1 if (binary_feature == bin_feature_index.value) else 0)",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "calc_ctrs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "def calc_ctrs(model_ctrs, binarized_features, hashed_cat_features, result):\n    ctr_hash = 0\n    result_index = 0\n    for i in range(len(model_ctrs.compressed_model_ctrs)):\n        proj = model_ctrs.compressed_model_ctrs[i].projection\n        ctr_hash = calc_hashes(binarized_features, hashed_cat_features, proj.transposed_cat_feature_indexes, proj.binarized_indexes)\n        for j in range(len(model_ctrs.compressed_model_ctrs[i].model_ctrs)):\n            ctr = model_ctrs.compressed_model_ctrs[i].model_ctrs[j]\n            learn_ctr = model_ctrs.ctr_data.learn_ctrs[ctr.base_hash]\n            ctr_type = ctr.base_ctr_type",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"Female\": -2114564283,\n    \"Protective-serv\": -2075156126,\n    \"Assoc-voc\": -2029370604,\n    \"Married-civ-spouse\": -2019910086,\n    \"Federal-gov\": -1993066135,\n    \"Transport-moving\": -1903253868,\n    \"Farming-fishing\": -1888947309,\n    \"Prof-school\": -1742589394,\n    \"Self-emp-inc\": -1732053524,",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_GPU-40_.model",
        "documentation": {}
    },
    {
        "label": "catboost_model",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "peekOfCode": "class catboost_model(object):\n    float_features_index = [\n        0,\n    ]\n    float_feature_count = 1\n    cat_feature_count = 1\n    binary_feature_count = 2\n    tree_count = 5\n    float_feature_borders = [\n        [2]",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "documentation": {}
    },
    {
        "label": "hash_uint64",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "peekOfCode": "def hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "documentation": {}
    },
    {
        "label": "apply_catboost_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "peekOfCode": "def apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.\n    Parameters\n    ----------\n    float_features : list of float features\n    cat_features : list of categorical features\n        You need to pass float and categorical features separately in the same order they appeared in train dataset.\n        For example if you had features f1,f2,f3,f4, where f2 and f4 were considered categorical, you need to pass here float_features=f1,f3, cat_features=f2,f4\n    Returns",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "documentation": {}
    },
    {
        "label": "cat_features_hashes",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "description": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "peekOfCode": "cat_features_hashes = {\n    \"2\": -1284790409,\n    \"4\": -78686594,\n}\ndef hash_uint64(string):\n    return cat_features_hashes.get(str(string), 0x7fFFffFF)\n### Applicator for the CatBoost model\ndef apply_catboost_model(float_features, cat_features=[], ntree_start=0, ntree_end=catboost_model.tree_count):\n    \"\"\"\n    Applies the model built by CatBoost.",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.canondata.test.test_export_to_python_with_cat_features_from_pandas_GPU_.model",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "description": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "peekOfCode": "def pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\", \"fails_on_gpu(how): mark test that fails only on GPU\"\n    )\nGPU_DEVICE_COUNT = catboost.utils.get_gpu_device_count()\ndef get_fails_on_gpu_mark(metafunc):\n    \"\"\"\n    returns Mark or None\n    \"\"\"\n    for pytestmark in getattr(metafunc.function, 'pytestmark', []):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "documentation": {}
    },
    {
        "label": "get_fails_on_gpu_mark",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "description": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "peekOfCode": "def get_fails_on_gpu_mark(metafunc):\n    \"\"\"\n    returns Mark or None\n    \"\"\"\n    for pytestmark in getattr(metafunc.function, 'pytestmark', []):\n        if pytestmark.name == 'fails_on_gpu':\n            return pytestmark\n    return None\ndef pytest_generate_tests(metafunc):\n    have_param_task_type = 'task_type' in metafunc.fixturenames",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "description": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "peekOfCode": "def pytest_generate_tests(metafunc):\n    have_param_task_type = 'task_type' in metafunc.fixturenames\n    if have_param_task_type:\n        if GPU_DEVICE_COUNT > 0:\n            fails_on_gpu = get_fails_on_gpu_mark(metafunc)\n            if fails_on_gpu:\n                how = fails_on_gpu.kwargs.get('how', None)\n                xfail_reason = 'Needs fixing on GPU' + (': ' + how if how else '')\n                metafunc.parametrize(\n                    'task_type',",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "documentation": {}
    },
    {
        "label": "GPU_DEVICE_COUNT",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "description": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "peekOfCode": "GPU_DEVICE_COUNT = catboost.utils.get_gpu_device_count()\ndef get_fails_on_gpu_mark(metafunc):\n    \"\"\"\n    returns Mark or None\n    \"\"\"\n    for pytestmark in getattr(metafunc.function, 'pytestmark', []):\n        if pytestmark.name == 'fails_on_gpu':\n            return pytestmark\n    return None\ndef pytest_generate_tests(metafunc):",
        "detail": "catboost.catboost.python-package.ut.medium.gpu.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.conftest",
        "description": "catboost.catboost.python-package.ut.medium.conftest",
        "peekOfCode": "def pytest_configure(config):\n    config.addinivalue_line(\n        \"markers\", \"fails_on_gpu(how): mark test that fails only on GPU\"\n    )\n@pytest.fixture(params=['CPU'])\ndef task_type(request):\n    return request.param",
        "detail": "catboost.catboost.python-package.ut.medium.conftest",
        "documentation": {}
    },
    {
        "label": "task_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.conftest",
        "description": "catboost.catboost.python-package.ut.medium.conftest",
        "peekOfCode": "def task_type(request):\n    return request.param",
        "detail": "catboost.catboost.python-package.ut.medium.conftest",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.run_catboost",
        "description": "catboost.catboost.python-package.ut.medium.run_catboost",
        "peekOfCode": "def data_file(*path):\n    return os.path.join(os.getcwd(), \"data\", *path)\ndef test_adult():\n    train = data_file('adult', 'train_small')\n    test = data_file('adult', 'test_small')\n    cd = data_file('adult', 'train.cd')\n    learn_pool = Pool(data=train, column_description=cd)\n    test_pool = Pool(data=test, column_description=cd)\n    model = CatBoostClassifier(iterations=5, loss_function='Logloss')\n    model.fit(learn_pool, eval_set=test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.run_catboost",
        "documentation": {}
    },
    {
        "label": "test_adult",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.run_catboost",
        "description": "catboost.catboost.python-package.ut.medium.run_catboost",
        "peekOfCode": "def test_adult():\n    train = data_file('adult', 'train_small')\n    test = data_file('adult', 'test_small')\n    cd = data_file('adult', 'train.cd')\n    learn_pool = Pool(data=train, column_description=cd)\n    test_pool = Pool(data=test, column_description=cd)\n    model = CatBoostClassifier(iterations=5, loss_function='Logloss')\n    model.fit(learn_pool, eval_set=test_pool)\n    predictions = model.predict(test_pool)\nif __name__ == '__main__':",
        "detail": "catboost.catboost.python-package.ut.medium.run_catboost",
        "documentation": {}
    },
    {
        "label": "test_floats_60000",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.run_catboost_hnsw",
        "description": "catboost.catboost.python-package.ut.medium.run_catboost_hnsw",
        "peekOfCode": "def test_floats_60000():\n    data = np.fromfile(os.path.join(os.getcwd(), \"hnsw_data\", 'floats_60000'), dtype=np.dtype('float32'))\n    dimension = 40\n    distance = EDistance.DotProduct\n    data = data.reshape((data.size // dimension, dimension))\n    estimator = HnswEstimator(\n        distance=distance,\n        level_size_decay=2,\n        max_neighbors=5,\n        search_neighborhood_size=30,",
        "detail": "catboost.catboost.python-package.ut.medium.run_catboost_hnsw",
        "documentation": {}
    },
    {
        "label": "LoglossObjective",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class LoglossObjective(object):\n    def calc_ders_range(self, approxes, targets, weights):\n        assert len(approxes) == len(targets)\n        if weights is not None:\n            assert len(weights) == len(approxes)\n        exponents = []\n        for index in range(len(approxes)):\n            exponents.append(math.exp(approxes[index]))\n        result = []\n        for index in range(len(targets)):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "LoglossObjectiveNumpy",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class LoglossObjectiveNumpy(object):\n    def __init__(self):\n        self._objective = LoglossObjective()\n    def calc_ders_range(self, approxes, targets, weights):\n        return np.array(self._objective.calc_ders_range(approxes, targets, weights))\nclass LoglossObjectiveNumpy32(object):\n    def __init__(self):\n        self._objective = LoglossObjective()\n    def calc_ders_range(self, approxes, targets, weights):\n        return np.array(self._objective.calc_ders_range(approxes, targets, weights), dtype=np.float32)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "LoglossObjectiveNumpy32",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class LoglossObjectiveNumpy32(object):\n    def __init__(self):\n        self._objective = LoglossObjective()\n    def calc_ders_range(self, approxes, targets, weights):\n        return np.array(self._objective.calc_ders_range(approxes, targets, weights), dtype=np.float32)\n@pytest.mark.parametrize('loss_objective', [LoglossObjective, LoglossObjectiveNumpy, LoglossObjectiveNumpy32])\n@fails_on_gpu(how='User defined loss functions, metrics and callbacks are not supported for GPU')\ndef test_custom_objective(task_type, loss_objective):\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TestInvalidCustomLossAndMetric",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class TestInvalidCustomLossAndMetric(object):\n    class GoodCustomLoss(object):\n        def calc_ders_range(self, approxes, targets, weights):\n            assert len(approxes) == len(targets)\n            der1 = 2.0 * (np.array(approxes) - np.array(targets))\n            der2 = np.full(len(approxes), -2.0)\n            if weights is not None:\n                assert len(weights) == len(targets)\n                der1 *= np.array(weights)\n                der2 *= np.array(weights)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TestMissingValues",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class TestMissingValues(object):\n    def assert_expected(self, pool):\n        assert str(pool.get_features()) == str(np.array([[1.0], [float('nan')]]))\n    @pytest.mark.parametrize('value,value_acceptable_as_empty', [(None, True)] + Value_AcceptableAsEmpty)\n    @pytest.mark.parametrize('object', [list, np.array, DataFrame, Series])\n    def test_create_pool_from_object(self, value, value_acceptable_as_empty, object):\n        if value_acceptable_as_empty:\n            self.assert_expected(Pool(object([[1], [value]])))\n            self.assert_expected(Pool(object([1, value])))\n        else:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "Metrics",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class Metrics(object):\n    @staticmethod\n    def filter_regression(names):\n        supported_by = {\n            'MAE',\n            'MAPE',\n            'Poisson',\n            'Quantile',\n            'RMSE',\n            'LogLinQuantile',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TestUseWeights",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class TestUseWeights(object):\n    @pytest.fixture\n    def a_regression_learner(self, task_type):\n        train_features_df, cat_features = load_pool_features_as_df(TRAIN_FILE, CD_FILE)\n        test_features_df, _ = load_pool_features_as_df(TEST_FILE, CD_FILE)\n        prng = np.random.RandomState(seed=20181219)\n        train_pool = Pool(\n            data=train_features_df,\n            label=_generate_random_target(train_features_df.shape[0], prng=prng),\n            cat_features=cat_features",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TestModelWithoutParams",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "class TestModelWithoutParams(object):\n    @pytest.fixture(\n        params=[\n            ('cut-info', 'RMSE'),\n            ('cut-params', 'RMSE'),\n            ('cut-info', 'QueryRMSE'),\n            ('cut-params', 'QueryRMSE'),\n        ],\n        ids=lambda param: '-'.join(param),\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "JSON_LOG_CV_PATH",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def JSON_LOG_CV_PATH(foldIdx):\n    return 'catboost_info/fold-' + str(foldIdx) + '/catboost_training.json'\nnumpy_num_data_types = [\n    np.int8,\n    np.int16,\n    np.int32,\n    np.int64,\n    np.uint8,\n    np.uint16,\n    np.uint32,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "compare_canonical_models",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def compare_canonical_models(model, diff_limit=0):\n    return local_canonical_file(model, diff_tool=[model_diff_tool, '--diff-limit', str(diff_limit)])\ndef _check_shape(pool, object_count, features_count):\n    return pool.shape == (object_count, features_count)\ndef _check_data(data1, data2):\n    return np.all(np.isclose(data1, data2, rtol=0.001, equal_nan=True))\ndef _count_lines(afile):\n    with open(afile, 'r') as f:\n        num_lines = sum(1 for line in f)\n    return num_lines",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "set_random_weight",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def set_random_weight(pool, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=seed)\n    pool.set_weight(prng.random_sample(pool.num_row()))\n    if pool.num_pairs() > 0:\n        pool.set_pairs_weight(prng.random_sample(pool.num_pairs()))\ndef verify_finite(result):\n    inf = float('inf')\n    for r in result:\n        assert (r == r)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "verify_finite",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def verify_finite(result):\n    inf = float('inf')\n    for r in result:\n        assert (r == r)\n        assert (abs(r) < inf)\ndef append_param(metric_name, param):\n    return metric_name + (':' if ':' not in metric_name else ';') + param\n# returns (features_data, labels)\ndef load_simple_dataset_as_lists(is_test):\n    features_data = []",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "append_param",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def append_param(metric_name, param):\n    return metric_name + (':' if ':' not in metric_name else ';') + param\n# returns (features_data, labels)\ndef load_simple_dataset_as_lists(is_test):\n    features_data = []\n    labels = []\n    with open(TEST_FILE if is_test else TRAIN_FILE) as data_file:\n        for line in data_file:\n            elements = line[:-1].split('\\t')\n            features_data.append([])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "load_simple_dataset_as_lists",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def load_simple_dataset_as_lists(is_test):\n    features_data = []\n    labels = []\n    with open(TEST_FILE if is_test else TRAIN_FILE) as data_file:\n        for line in data_file:\n            elements = line[:-1].split('\\t')\n            features_data.append([])\n            for column_idx, element in enumerate(elements):\n                if column_idx == TARGET_IDX:\n                    labels.append(element)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression_custom_eval",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiregression_custom_eval(niter, n=10):\n    class MultiRMSE(MultiTargetCustomMetric):\n        def get_final_error(self, error, weight):\n            if (weight == 0):\n                return 0\n            else:\n                return (error / weight) ** 0.5\n        def is_max_optimal(self):\n            return False\n        def evaluate(self, approxes, target, weight):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiregression",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiregression(niter, n=10):\n    xs = np.arange(n).reshape((-1, 1)).astype(np.float32)\n    ys = np.hstack([\n        (xs > 0.5 * n),\n        (xs < 0.5 * n)\n    ]).astype(np.float32)\n    model = CatBoostRegressor(loss_function='MultiRMSE', iterations=niter)\n    model.fit(xs, ys)\n    ys_pred = model.predict(xs)\n    model.score(xs, ys)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_model_multiregression",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_model_multiregression(niter):\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    train_pool = Pool(train_file, column_description=cd_file)\n    test_pool = Pool(train_file, column_description=cd_file)\n    model = CatBoost(dict(loss_function='MultiRMSE', iterations=niter))\n    model.fit(train_pool)\n    model.save_model(output_model_path)\n    model2 = CatBoost()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_file():\n    assert _check_shape(Pool(TRAIN_FILE, column_description=CD_FILE), 101, 17)\ndef test_load_list():\n    features_data, labels = load_simple_dataset_as_lists(is_test=False)\n    assert _check_shape(Pool(features_data, labels, CAT_FEATURES), 101, 17)\ndatasets_for_test_ndarray = [\n    'adult',\n    'cloudness_small',\n    'higgs',\n    'rotten_tomatoes',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_list",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_list():\n    features_data, labels = load_simple_dataset_as_lists(is_test=False)\n    assert _check_shape(Pool(features_data, labels, CAT_FEATURES), 101, 17)\ndatasets_for_test_ndarray = [\n    'adult',\n    'cloudness_small',\n    'higgs',\n    'rotten_tomatoes',\n    'rotten_tomatoes_small_with_embeddings'\n]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_only_features_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_only_features_names(columns_metadata):\n    column_names = columns_metadata['column_names']\n    non_feature_column_indices = set(columns_metadata['non_feature_column_indices'])\n    feature_names = []\n    for i, column_name in enumerate(column_names):\n        if i not in non_feature_column_indices:\n            feature_names.append(column_name)\n    return feature_names\n@pytest.mark.parametrize(\n    'dataset',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_ndarray_vs_load_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_ndarray_vs_load_from_file(dataset, order):\n    n_objects = 101\n    if dataset == 'adult':  # mixed numeric and categorical features data, cat data is strings\n        train_file = TRAIN_FILE\n        cd_file = CD_FILE\n        dtypes = [object]\n        float_dtype_is_ok = False\n    elif dataset == 'cloudness_small':  # mixed numeric and categorical features data, cat data is integers\n        train_file = CLOUDNESS_TRAIN_FILE\n        cd_file = CLOUDNESS_CD_FILE",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_ndarray_vs_load_from_file_multitarget",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_ndarray_vs_load_from_file_multitarget(order):\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    dtypes = [np.float32, np.float64]\n    n_objects = np.loadtxt(train_file, delimiter='\\t').shape[0]\n    columns_metadata = read_cd(cd_file, data_file=train_file, canonize_column_types=True)\n    target_indices = columns_metadata['column_type_to_indices'].get('Label', [])\n    feature_indices = columns_metadata['column_type_to_indices'].get('Num', [])\n    pool_from_file = Pool(train_file, column_description=cd_file)\n    for dtype in dtypes:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_on_ndarray",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_on_ndarray(features_dtype):\n    if np.dtype(features_dtype).kind == 'f':\n        cat_features = []\n        lower_bound = -1.0\n        upper_bound = 1.0\n    else:\n        cat_features = [0, 7, 11]\n        lower_bound = max(np.iinfo(features_dtype).min, -32767)\n        upper_bound = min(np.iinfo(features_dtype).max, 32767)\n    n_features = 20",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_df_vs_load_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_df_vs_load_from_file(dataset):\n    train_file, cd_file, target_idx, group_id_idx, other_non_feature_columns = {\n        'adult': (TRAIN_FILE, CD_FILE, TARGET_IDX, None, []),\n        'adult_nan': (NAN_TRAIN_FILE, NAN_CD_FILE, TARGET_IDX, None, []),\n        'querywise': (QUERYWISE_TRAIN_FILE, QUERYWISE_CD_FILE, 2, 1, [0, 3, 4]),\n        'rotten_tomatoes': (ROTTEN_TOMATOES_TRAIN_FILE, ROTTEN_TOMATOES_CD_BINCLASS_FILE, 11, None, []),\n        'rotten_tomatoes_small_with_embeddings': (\n            ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,\n            ROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE,\n            14,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_df_vs_load_from_file_multitarget",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_df_vs_load_from_file_multitarget():\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    target_idx = [0, 1]\n    pool1 = Pool(train_file, column_description=cd_file)\n    data = read_csv(train_file, header=None, delimiter='\\t')\n    labels = data.iloc[:, target_idx]\n    data.drop(\n        target_idx,\n        axis=1,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_series",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_series():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    data = read_csv(TRAIN_FILE, header=None, delimiter='\\t')\n    labels = Series(data.iloc[:, TARGET_IDX])\n    data.drop([TARGET_IDX], axis=1, inplace=True)\n    data = Series(list(data.values))\n    cat_features = pool.get_cat_feature_indices()\n    pool2 = Pool(data, labels, cat_features)\n    assert _have_equal_features(pool, pool2)\n    assert _check_data([int(label) for label in pool.get_label()], pool2.get_label())",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_cat_features():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    assert np.all(pool.get_cat_feature_indices() == CAT_FEATURES)\ndef test_pool_cat_features_as_strings():\n    df = DataFrame(data=[[1, 2], [3, 4]], columns=['col1', 'col2'])\n    pool = Pool(df, cat_features=['col2'])\n    assert np.all(pool.get_cat_feature_indices() == [1])\n    data = [[1, 2, 3], [4, 5, 6]]\n    pool = Pool(data, feature_names=['col1', 'col2', 'col3'], cat_features=['col2', 'col3'])\n    assert np.all(pool.get_cat_feature_indices() == [1, 2])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_cat_features_as_strings",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_cat_features_as_strings():\n    df = DataFrame(data=[[1, 2], [3, 4]], columns=['col1', 'col2'])\n    pool = Pool(df, cat_features=['col2'])\n    assert np.all(pool.get_cat_feature_indices() == [1])\n    data = [[1, 2, 3], [4, 5, 6]]\n    pool = Pool(data, feature_names=['col1', 'col2', 'col3'], cat_features=['col2', 'col3'])\n    assert np.all(pool.get_cat_feature_indices() == [1, 2])\n    data = [[1, 2, 3], [4, 5, 6]]\n    with pytest.raises(CatBoostError):\n        Pool(data, cat_features=['col2', 'col3'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_generated",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_generated():\n    pool_size = (100, 10)\n    prng = np.random.RandomState(seed=20181219)\n    data = np.round(prng.normal(size=pool_size), decimals=3)\n    label = _generate_nontrivial_binary_target(pool_size[0], prng=prng)\n    pool = Pool(data, label)\n    assert _check_data(pool.get_features(), data)\n    assert _check_data(pool.get_label(), label)\ndef test_load_dumps():\n    pool_size = (100, 10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_dumps",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_dumps():\n    pool_size = (100, 10)\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.randint(10, size=pool_size)\n    labels = _generate_nontrivial_binary_target(pool_size[0], prng=prng)\n    pool1 = Pool(data, labels)\n    lines = []\n    for i in range(len(data)):\n        line = [str(labels[i])] + [str(x) for x in data[i]]\n        lines.append('\\t'.join(line))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_from_slices",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_from_slices(features_type):\n    full_size = (100, 30)\n    subset_size = (20, 17)\n    prng = np.random.RandomState(seed=20191120)\n    for start_offsets in ((0, 0), (5, 3)):\n        full_features_data = np.round(prng.normal(size=full_size), decimals=3)\n        full_label = _generate_nontrivial_binary_target(full_size[0], prng=prng)\n        subset_features_data = full_features_data[start_offsets[0]:subset_size[0], start_offsets[1]:subset_size[1]]\n        subset_label = full_label[start_offsets[0]:subset_size[0]]\n        if features_type == 'numpy.ndarray':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_dataframe_with_pandas_categorical_columns",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_dataframe_with_pandas_categorical_columns(cat_features_specified):\n    df = DataFrame()\n    df['num_feat_0'] = [0, 1, 0, 2, 3, 1, 2]\n    df['num_feat_1'] = [0.12, 0.8, 0.33, 0.11, 0.0, 1.0, 0.0]\n    df['cat_feat_2'] = Series(['A', 'B', 'A', 'C', 'A', 'A', 'A'], dtype='category')\n    df['cat_feat_3'] = Series(['x', 'x', 'y', 'y', 'y', 'x', 'x'])\n    df['cat_feat_4'] = Categorical(\n        ['large', 'small', 'medium', 'large', 'small', 'small', 'medium'],\n        categories=['small', 'medium', 'large'],\n        ordered=True",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_equivalence_of_pools_from_pandas_dataframe_with_different_cat_features_column_types",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_equivalence_of_pools_from_pandas_dataframe_with_different_cat_features_column_types():\n    df = DataFrame()\n    df['num_feat_0'] = [0, 1, 0, 2, 3, 1, 2]\n    df['num_feat_1'] = [0.12, 0.8, 0.33, 0.11, 0.0, 1.0, 0.0]\n    df['cat_feat_2'] = ['A', 'B', 'A', 'C', 'A', 'A', 'A']\n    df['cat_feat_3'] = ['x', 'x', 'y', 'y', 'y', 'x', 'x']\n    df['cat_feat_4'] = ['large', 'small', 'medium', 'large', 'small', 'small', 'medium']\n    df['cat_feat_5'] = [0, 1, 0, 2, 3, 1, 2]\n    labels = [0, 1, 1, 0, 1, 0, 1]\n    cat_features = ['cat_feat_%i' % i for i in range(2, 6)]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_with_external_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_with_external_feature_names():\n    for cd_has_feature_names in [False, True]:\n        if cd_has_feature_names:\n            cd_file = data_file('adult', 'train_with_id.cd')\n        else:\n            cd_file = data_file('adult', 'train.cd')\n        train_pool = Pool(\n            TRAIN_FILE,\n            column_description=cd_file,\n            feature_names=data_file('adult', 'feature_names')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_features_data_from_matrix",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_features_data_from_matrix(feature_matrix, cat_feature_indices, order='C'):\n    object_count = len(feature_matrix)\n    feature_count = len(feature_matrix[0])\n    cat_feature_count = len(cat_feature_indices)\n    num_feature_count = feature_count - cat_feature_count\n    result_num = np.empty((object_count, num_feature_count), dtype=np.float32, order=order)\n    result_cat = np.empty((object_count, cat_feature_count), dtype=object, order=order)\n    for object_idx in range(object_count):\n        num_feature_idx = 0\n        cat_feature_idx = 0",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_features_data_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_features_data_from_file(data_file, drop_columns, cat_feature_indices, order='C'):\n    data_matrix_from_file = read_csv(data_file, header=None, dtype=str, delimiter='\\t')\n    data_matrix_from_file.drop(drop_columns, axis=1, inplace=True)\n    return get_features_data_from_matrix(np.array(data_matrix_from_file), cat_feature_indices, order)\ndef test_features_data_with_empty_objects():\n    fd = FeaturesData(\n        cat_feature_data=np.empty((0, 4), dtype=object)\n    )\n    assert fd.get_object_count() == 0\n    assert fd.get_feature_count() == 4",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_features_data_with_empty_objects",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_features_data_with_empty_objects():\n    fd = FeaturesData(\n        cat_feature_data=np.empty((0, 4), dtype=object)\n    )\n    assert fd.get_object_count() == 0\n    assert fd.get_feature_count() == 4\n    assert fd.get_num_feature_count() == 0\n    assert fd.get_cat_feature_count() == 4\n    assert fd.get_feature_names() == [''] * 4\n    fd = FeaturesData(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_features_data_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_features_data_names():\n    # empty specification of names\n    fd = FeaturesData(\n        cat_feature_data=np.array([[b'amazon', b'bing'], [b'ebay', b'google']], dtype=object),\n        num_feature_data=np.array([[1.0, 2.0, 3.0], [22.0, 7.1, 10.2]], dtype=np.float32),\n    )\n    assert fd.get_feature_names() == [''] * 5\n    # full specification of names\n    fd = FeaturesData(\n        cat_feature_data=np.array([[b'amazon', b'bing'], [b'ebay', b'google']], dtype=object),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "compare_pools_from_features_data_and_generic_matrix",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def compare_pools_from_features_data_and_generic_matrix(\n    features_data,\n    generic_matrix,\n    cat_features_indices,\n    feature_names=None\n):\n    pool1 = Pool(data=features_data)\n    pool2 = Pool(data=generic_matrix, cat_features=cat_features_indices, feature_names=feature_names)\n    assert _have_equal_features(pool1, pool2)\n@pytest.mark.parametrize('order', ['C', 'F'], ids=['order=C', 'order=F'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_features_data_good",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_features_data_good(order):\n    # 0 objects\n    compare_pools_from_features_data_and_generic_matrix(\n        FeaturesData(cat_feature_data=np.empty((0, 4), dtype=object, order=order)),\n        np.empty((0, 4), dtype=object),\n        cat_features_indices=[0, 1, 2, 3]\n    )\n    # 0 objects\n    compare_pools_from_features_data_and_generic_matrix(\n        FeaturesData(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_features_data_bad",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_features_data_bad():\n    # empty\n    with pytest.raises(CatBoostError):\n        FeaturesData()\n    # names w/o data\n    with pytest.raises(CatBoostError):\n        FeaturesData(cat_feature_data=[[b'amazon', b'bing']], num_feature_names=['price'])\n    # bad matrix type\n    with pytest.raises(CatBoostError):\n        FeaturesData(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_regress",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_regress(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': 2, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    assert (model.is_fitted())\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_predict_sklearn_regress(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_sklearn_regress",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_sklearn_regress(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    assert (model.is_fitted())\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_predict_sklearn_class(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_sklearn_class",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_sklearn_class(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, loss_function='Logloss', task_type=task_type, devices='0')\n    model.fit(train_pool)\n    assert (model.is_fitted())\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_predict_class_raw(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_class_raw",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_class_raw(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred = model.predict(test_pool)\n    preds_path = test_output_path(PREDS_PATH)\n    np.save(preds_path, np.array(pred))\n    return local_canonical_file(preds_path)\ndef test_raw_predict_equals_to_model_predict(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_raw_predict_equals_to_model_predict",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_raw_predict_equals_to_model_predict(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10, task_type=task_type, devices='0')\n    model.fit(train_pool, eval_set=test_pool)\n    assert (model.is_fitted())\n    pred = model.predict(test_pool, prediction_type='RawFormulaVal')\n    assert np.all(np.isclose(model.get_test_eval(), pred, rtol=1.e-6))\n@pytest.mark.parametrize('problem', ['Classifier', 'Regressor'])\ndef test_predict_and_predict_proba_on_single_object(problem):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_and_predict_proba_on_single_object",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_and_predict_proba_on_single_object(problem):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    if problem == 'Classifier':\n        model = CatBoostClassifier(iterations=2)\n    else:\n        model = CatBoostRegressor(iterations=2)\n    model.fit(train_pool)\n    test_data = read_csv(TEST_FILE, header=None, delimiter='\\t')\n    test_data.drop([TARGET_IDX], axis=1, inplace=True)\n    pred = model.predict(test_data)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_on_gpu",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_on_gpu(task_type, problem, prediction_type, feature_types):\n    if task_type == 'CPU':\n        pytest.skip('test_predict_on_gpu is a GPU-specific test')\n    iterations = 1100\n    if problem == 'Regression':\n        model = CatBoostRegressor(iterations=iterations, task_type='GPU', devices='0')\n        if feature_types == 'Numeric':\n            pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n        if feature_types == 'NumericCateg':\n            pool = Pool(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_pickling",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_pickling(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10, task_type=task_type, devices='0')\n    model.fit(train_pool, eval_set=test_pool)\n    pred = model.predict(test_pool, prediction_type='RawFormulaVal')\n    model_unpickled = pickle.loads(pickle.dumps(model))\n    pred_new = model_unpickled.predict(test_pool, prediction_type='RawFormulaVal')\n    assert all(pred_new == pred)\ndef test_save_load_equality(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_load_equality",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_load_equality(task_type):\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    def check_equality(model1, model2):\n        assert model1 == model2\n        for attr in ('best_score_', 'evals_result_', 'best_iteration_'):\n            assert compare_with_limited_precision(getattr(model1, attr), getattr(model2, attr))\n    def check_load_from_stream(model):\n        cb_stream = CatBoost()\n        with open(output_model_path, 'rb') as stream:\n            cb_stream.load_model(stream=stream)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_model_incorrect_argument",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_model_incorrect_argument(task_type):\n    with pytest.raises(CatBoostError):\n        cb = CatBoost()\n        cb.load_model()\n    with pytest.raises(AssertionError):\n        cb = CatBoost()\n        cb.load_model(blob=42)\n    with pytest.raises(AssertionError):\n        cb = CatBoost()\n        cb.load_model(blob=u\"✓ means check\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_from_file(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': 2, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    predictions1 = model.predict(train_pool)\n    model.fit(TRAIN_FILE, column_description=CD_FILE)\n    predictions2 = model.predict(train_pool)\n    assert all(predictions1 == predictions2)\n    assert 'train_finish_time' in model.get_metadata()\ndef test_fit_from_empty_features_data(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_from_empty_features_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_from_empty_features_data(task_type):\n    model = CatBoost({'iterations': 2, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    with pytest.raises(CatBoostError):\n        model.fit(\n            X=FeaturesData(num_feature_data=np.empty((0, 2), dtype=np.float32)),\n            y=np.empty((0), dtype=np.int32)\n        )\ndef fit_from_df(params, learn_file, test_file, cd_file, dummy_multi_target=False):\n    learn_df = read_csv(learn_file, header=None, sep='\\t', na_filter=False)\n    test_df = read_csv(test_file, header=None, sep='\\t', na_filter=False)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "fit_from_df",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def fit_from_df(params, learn_file, test_file, cd_file, dummy_multi_target=False):\n    learn_df = read_csv(learn_file, header=None, sep='\\t', na_filter=False)\n    test_df = read_csv(test_file, header=None, sep='\\t', na_filter=False)\n    columns_metadata = read_cd(cd_file, data_file=learn_file)\n    target_column_idx = columns_metadata['column_type_to_indices']['Label'][0]\n    cat_feature_indices = columns_metadata['cat_feature_indices']\n    text_feature_indices = columns_metadata['text_feature_indices']\n    def get_split_on_features_and_label(df, label_idx):\n        y = df[label_idx]\n        X = df.drop(label_idx, axis=1)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "fit_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def fit_from_file(params, learn_file, test_file, cd_file):\n    learn_pool = Pool(learn_file, column_description=cd_file)\n    test_pool = Pool(test_file, column_description=cd_file)\n    model = CatBoost(params)\n    model.fit(learn_pool)\n    return model, model.predict(test_pool)\n@pytest.mark.parametrize('problem_type', ['binclass', 'multiclass', 'regression', 'multiregression'])\ndef test_fit_with_texts(task_type, problem_type):\n    if (task_type == 'GPU') and (problem_type == 'multiregression'):\n        pytest.xfail('Catboost does not support MultiRMSE on GPU yet for categorical features')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_with_texts",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_with_texts(task_type, problem_type):\n    if (task_type == 'GPU') and (problem_type == 'multiregression'):\n        pytest.xfail('Catboost does not support MultiRMSE on GPU yet for categorical features')\n    params = {\n        'dictionaries': [\n            {'dictionary_id': 'UniGram', 'token_level_type': 'Letter', 'occurrence_lower_bound': '1'},\n            {'dictionary_id': 'BiGram', 'token_level_type': 'Letter', 'occurrence_lower_bound': '1', 'gram_order': '2'},\n            {'dictionary_id': 'Word', 'occurrence_lower_bound': '1'},\n        ],\n        'feature_calcers': ['BoW:top_tokens_count=10'] if 'regression' in problem_type else ['NaiveBayes', 'BoW:top_tokens_count=10'],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_coreml_import_export",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_coreml_import_export(task_type):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 20, 'thread_count': 8, 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_coreml_model_path = test_output_path(OUTPUT_COREML_MODEL_PATH)\n    model.save_model(output_coreml_model_path, format=\"coreml\")\n    canon_pred = model.predict(test_pool)\n    coreml_loaded_model = CatBoostRegressor()\n    coreml_loaded_model.load_model(output_coreml_model_path, format=\"coreml\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_coreml_import_export_one_hot_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_coreml_import_export_one_hot_features(task_type):\n    train_pool = Pool(SMALL_CATEGORIAL_FILE, column_description=SMALL_CATEGORIAL_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 2, 'task_type': task_type, 'devices': '0', 'one_hot_max_size': 4})\n    model.fit(train_pool)\n    output_coreml_model_path = test_output_path(OUTPUT_COREML_MODEL_PATH)\n    model.save_model(output_coreml_model_path, format=\"coreml\", pool=train_pool)\n    pred = model.predict(train_pool)\n    coreml_loaded_model = CatBoostRegressor()\n    coreml_loaded_model.load_model(output_coreml_model_path, format=\"coreml\")\n    assert all(pred == coreml_loaded_model.predict(train_pool))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_convert_model_to_json",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_convert_model_to_json(task_type, pool, parameters):\n    train_pool = Pool(data_file(pool, 'train_small'), column_description=data_file(pool, 'train.cd'))\n    test_pool = Pool(data_file(pool, 'test_small'), column_description=data_file(pool, 'train.cd'))\n    converted_model_path = test_output_path(\"converted_model.bin\")\n    parameters.update({'iterations': 20, 'task_type': task_type, 'devices': '0'})\n    model = CatBoost(parameters)\n    model.fit(train_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    output_json_model_path = test_output_path(OUTPUT_JSON_MODEL_PATH)\n    model.save_model(output_model_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_coreml_cbm_import_export",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_coreml_cbm_import_export(task_type):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 20, 'thread_count': 8, 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    canon_pred = model.predict(test_pool)\n    output_coreml_model_path = test_output_path(OUTPUT_COREML_MODEL_PATH)\n    model.save_model(output_coreml_model_path, format=\"coreml\")\n    coreml_loaded_model = CatBoost()\n    coreml_loaded_model.load_model(output_coreml_model_path, format=\"coreml\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cpp_export_no_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cpp_export_no_cat_features(task_type):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    model = CatBoost({'iterations': 2, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_cpp_model_path = test_output_path(OUTPUT_CPP_MODEL_PATH)\n    model.save_model(output_cpp_model_path, format=\"cpp\")\n    return local_canonical_file(output_cpp_model_path)\ndef test_cpp_export_with_cat_features(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': 20, 'task_type': task_type, 'devices': '0'})",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cpp_export_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cpp_export_with_cat_features(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': 20, 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_cpp_model_path = test_output_path(OUTPUT_CPP_MODEL_PATH)\n    model.save_model(output_cpp_model_path, format=\"cpp\", pool=train_pool)\n    return local_canonical_file(output_cpp_model_path)\n@pytest.mark.parametrize('iterations', [2, 40])\ndef test_export_to_python_no_cat_features(task_type, iterations):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_export_to_python_no_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_export_to_python_no_cat_features(task_type, iterations):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    model = CatBoost({'iterations': iterations, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_python_model_path = test_output_path(OUTPUT_PYTHON_MODEL_PATH)\n    model.save_model(output_python_model_path, format=\"python\")\n    return local_canonical_file(output_python_model_path)\n@pytest.mark.parametrize('iterations', [2, 40])\ndef test_export_to_python_with_cat_features(task_type, iterations):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_export_to_python_with_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_export_to_python_with_cat_features(task_type, iterations):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': iterations, 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_python_model_path = test_output_path(OUTPUT_PYTHON_MODEL_PATH)\n    model.save_model(output_python_model_path, format=\"python\", pool=train_pool)\n    return local_canonical_file(output_python_model_path)\ndef test_export_to_python_with_cat_features_from_pandas(task_type):\n    model = CatBoost({'iterations': 5, 'task_type': task_type, 'devices': '0'})\n    X = DataFrame([[1, 2], [3, 4]], columns=['Num', 'Categ'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_export_to_python_with_cat_features_from_pandas",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_export_to_python_with_cat_features_from_pandas(task_type):\n    model = CatBoost({'iterations': 5, 'task_type': task_type, 'devices': '0'})\n    X = DataFrame([[1, 2], [3, 4]], columns=['Num', 'Categ'])\n    y = [1, 0]\n    cat_features = [1]\n    model.fit(X, y, cat_features)\n    output_python_model_path = test_output_path(OUTPUT_PYTHON_MODEL_PATH)\n    model.save_model(output_python_model_path, format=\"python\", pool=X)\n    return local_canonical_file(output_python_model_path)\nONNX_TEST_PARAMETERS = [",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_onnx_export",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_onnx_export(problem_type, boost_from_average):\n    if problem_type == 'binclass':\n        loss_function = 'Logloss'\n        train_path = TRAIN_FILE\n        cd_path = CD_FILE\n    elif problem_type == 'multiclass':\n        loss_function = 'MultiClass'\n        train_path = CLOUDNESS_TRAIN_FILE\n        cd_path = CLOUDNESS_CD_FILE\n    elif problem_type == 'regression':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_onnx_import",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_onnx_import(problem_type, boost_from_average):\n    if (problem_type == 'binclass') and boost_from_average:\n        pytest.xfail('CatBoost does not support importing classification onnx models with bias')\n    if problem_type == 'binclass':\n        loss_function = 'Logloss'\n        train_path = TRAIN_FILE\n        test_path = TEST_FILE\n        cd_path = CD_FILE\n    elif problem_type == 'multiclass':\n        loss_function = 'MultiClass'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_onnx_export_lightgbm_import_catboost",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_onnx_export_lightgbm_import_catboost():\n    lightgbm_predict = np.loadtxt(CONVERT_LIGHT_GBM_PREDICTIONS)\n    test = np.loadtxt(CONVERT_RANDOM_GENERATED_TEST)\n    model = CatBoostRegressor()\n    model.load_model(CONVERT_MODEL_ONNX, format='onnx')\n    catboost_predict = model.predict(test.astype(np.float32))\n    assert (np.allclose(lightgbm_predict, catboost_predict, atol=1e-4))\n@pytest.mark.parametrize('problem_type', ['binclass', 'multiclass', 'regression'])\ndef test_pmml_export(problem_type):\n    if problem_type == 'binclass':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pmml_export",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pmml_export(problem_type):\n    if problem_type == 'binclass':\n        loss_function = 'Logloss'\n        train_path = TRAIN_FILE\n        cd_path = CD_FILE\n    elif problem_type == 'multiclass':\n        loss_function = 'MultiClass'\n        train_path = CLOUDNESS_TRAIN_FILE\n        cd_path = CLOUDNESS_CD_FILE\n    elif problem_type == 'regression':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_class",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_class(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred = model.predict(test_pool, prediction_type=\"Class\")\n    preds_path = test_output_path(PREDS_PATH)\n    np.save(preds_path, np.array(pred))\n    return local_canonical_file(preds_path)\ndef test_zero_learning_rate(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_zero_learning_rate",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_zero_learning_rate(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0, task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(train_pool)\ndef test_predict_class_proba(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_class_proba",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_class_proba(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred = model.predict_proba(test_pool)\n    preds_path = test_output_path(PREDS_PATH)\n    np.save(preds_path, np.array(pred))\n    return local_canonical_file(preds_path)\ndef test_no_cat_in_predict(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_no_cat_in_predict",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_no_cat_in_predict(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    test_features_data, _ = load_simple_dataset_as_lists(is_test=True)\n    pred1 = model.predict(test_features_data)\n    pred2 = model.predict(Pool(test_features_data, cat_features=CAT_FEATURES))\n    assert np.all(pred1 == pred2)\ndef test_save_model(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_model(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoost({'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    model2 = CatBoost()\n    model2.load_model(output_model_path)\n    pred1 = model.predict(test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass(task_type):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=2, loss_function='MultiClass', thread_count=8, task_type=task_type, devices='0')\n    classifier.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    classifier.save_model(output_model_path)\n    new_classifier = CatBoostClassifier()\n    new_classifier.load_model(output_model_path)\n    pred = new_classifier.predict_proba(pool)\n    preds_path = test_output_path(PREDS_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_classes_count",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass_classes_count(task_type, missed_classes):\n    object_count = 100\n    feature_count = 10\n    classes_count = 4\n    if missed_classes:\n        unique_labels = [1, 3]\n    else:\n        unique_labels = [0, 1, 2, 3]\n    expected_classes_attr = [i for i in range(4)]\n    prng = np.random.RandomState(seed=0)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_custom_class_labels",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_custom_class_labels(loss_function, label_type, class_count, task_type):\n    if label_type == 'boolean':\n        assert (class_count == 2)\n        labels = [False, True]\n    elif label_type == 'int':\n        labels = {2 : [1, 2], 5 : [1, 3, 2, 10, 20]}[class_count]\n    elif label_type == 'string':\n        labels = {\n            2 : ['Class1', 'Class2'],\n            5 : ['Class1', 'Class3', 'Class2', 'Class10', 'Class20']",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_custom_class_labels_from_files",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass_custom_class_labels_from_files(task_type):\n    labels = ['a', 'b', 'c', 'd']\n    cd_path = test_output_path('cd.txt')\n    np.savetxt(cd_path, [[0, 'Target']], fmt='%s', delimiter='\\t')\n    prng = np.random.RandomState(seed=0)\n    train_path = test_output_path('train.txt')\n    np.savetxt(train_path, generate_concatenated_random_labeled_dataset(100, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    test_path = test_output_path('test.txt')\n    np.savetxt(test_path, generate_concatenated_random_labeled_dataset(25, 10, labels, prng=prng), fmt='%s', delimiter='\\t')\n    train_pool = Pool(train_path, column_description=cd_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multilabel",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multilabel(prediction_type):\n    pool = Pool(SCENE_TRAIN_FILE, column_description=SCENE_CD_FILE)\n    classifier = CatBoostClassifier(iterations=2, loss_function='MultiLogloss', thread_count=8)\n    classifier.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    classifier.save_model(output_model_path)\n    new_classifier = CatBoostClassifier()\n    new_classifier.load_model(output_model_path)\n    pred = new_classifier.predict(pool, prediction_type=prediction_type)\n    preds_path = test_output_path(PREDS_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_compare_multilogloss_with_logloss",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_compare_multilogloss_with_logloss(target_count):\n    object_count = 100\n    feature_count = 10\n    iterations = 100\n    np.random.seed(42)\n    X = np.random.random((object_count, feature_count))\n    y = np.random.randint(low=0, high=2, size=object_count)\n    Y = np.vstack([y for _ in range(target_count)]).T\n    logloss_clf = CatBoostClassifier(iterations=iterations, loss_function='Logloss')\n    logloss_clf.fit(X, y)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multilabel_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multilabel_class_names():\n    pool = Pool(SCENE_TRAIN_FILE, column_description=SCENE_CD_FILE)\n    classifier = CatBoostClassifier(\n        iterations=100,\n        loss_function='MultiLogloss',\n        class_names=['a', 'b', 'c', 'd', 'e', 'f']\n    )\n    classifier.fit(pool)\n    pred = classifier.predict(pool, prediction_type='Class')\n    assert np.array_equal(classifier.classes_, ['a', 'b', 'c', 'd', 'e', 'f'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multilabel_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multilabel_eval_metric():\n    train_pool = Pool(SCENE_TRAIN_FILE, column_description=SCENE_CD_FILE)\n    test_pool = Pool(SCENE_TEST_FILE, column_description=SCENE_CD_FILE)\n    classifier = CatBoostClassifier(iterations=100, loss_function='MultiLogloss')\n    classifier.fit(train_pool, eval_set=test_pool)\n    target = test_pool.get_label().astype(int)\n    num_classes = target.shape[1]\n    approx = classifier.predict(test_pool, prediction_type='RawFormulaVal')\n    prediction = classifier.predict(test_pool, prediction_type='Class')\n    accuracy = eval_metric(target, approx, 'Accuracy')[0]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_class_names(task_type):\n    class_names = ['Small', 'Medium', 'Large']\n    prng = np.random.RandomState(seed=0)\n    train_pool = Pool(prng.random_sample(size=(100, 10)), label=prng.choice(class_names, size=100))\n    test_pool = Pool(prng.random_sample(size=(25, 10)))\n    classifier = CatBoostClassifier(\n        iterations=2,\n        loss_function='MultiClass',\n        class_names=class_names,\n        thread_count=8,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_inconsistent_labels_and_class_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_inconsistent_labels_and_class_names():\n    class_names = ['Small', 'Medium', 'Large']\n    prng = np.random.RandomState(seed=0)\n    train_pool = Pool(prng.random_sample(size=(100, 10)), label=prng.choice([0, 1, 2], size=100))\n    classifier = CatBoostClassifier(\n        iterations=2,\n        loss_function='MultiClass',\n        class_names=class_names,\n    )\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_inconsistent_class_labels_count",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_inconsistent_class_labels_count():\n    classifier = CatBoostClassifier(\n        iterations=2,\n        loss_function='Logloss',\n        class_names=[0, 1, 2],\n    )\n    with pytest.raises(CatBoostError):\n        classifier.fit([[0], [1], [2]], [0, 1, 2])\n    classifier = CatBoostClassifier(\n        iterations=2,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_unknown_class_labels_in_eval_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_unknown_class_labels_in_eval_dataset():\n    classifier = CatBoostClassifier(\n        iterations=2,\n        loss_function='Logloss',\n        class_names=[0, 1, 2],\n    )\n    with pytest.raises(CatBoostError):\n        classifier.fit([[0], [1], [2]], [0, 1, 2])\n    classifier = CatBoostClassifier(\n        iterations=2,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_querywise",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_querywise(features_dtype, task_type):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    model = CatBoostRanker(loss_function='QueryRMSE', iterations=2, thread_count=8, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred1 = model.predict(test_pool)\n    df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    train_query_id = df.loc[:, 1]\n    train_target = df.loc[:, 2]\n    train_data = df.drop([0, 1, 2, 3, 4], axis=1).astype(eval(features_dtype))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_group_weight",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_group_weight(task_type):\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE_WITH_GROUP_WEIGHT)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE_WITH_GROUP_WEIGHT)\n    model = CatBoostRanker(loss_function='YetiRank', iterations=10, thread_count=8, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred1 = model.predict(test_pool)\n    df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    train_query_weight = df.loc[:, 0]\n    train_query_id = df.loc[:, 1]\n    train_target = df.loc[:, 2]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_zero_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_zero_baseline(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    baseline = np.zeros(pool.num_row())\n    pool.set_baseline(baseline)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_ones_weight(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ones_weight",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ones_weight(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    weight = np.ones(pool.num_row())\n    pool.set_weight(weight)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_non_ones_weight(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_non_ones_weight",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_non_ones_weight(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    weight = np.arange(1, pool.num_row() + 1)\n    pool.set_weight(weight)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_ones_weight_equal_to_nonspecified_weight(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ones_weight_equal_to_nonspecified_weight",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ones_weight_equal_to_nonspecified_weight(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    predictions = []\n    for set_weights in [False, True]:\n        if set_weights:\n            weight = np.ones(train_pool.num_row())\n            train_pool.set_weight(weight)\n        model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_py_data_group_id",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_py_data_group_id(task_type):\n    train_pool_from_files = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE_WITH_GROUP_ID)\n    test_pool_from_files = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE_WITH_GROUP_ID)\n    model = CatBoostRanker(loss_function='QueryRMSE', iterations=2, thread_count=4, task_type=task_type, devices='0')\n    model.fit(train_pool_from_files)\n    predictions_from_files = model.predict(test_pool_from_files)\n    train_df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    train_target = train_df.loc[:, 2]\n    raw_train_group_id = train_df.loc[:, 1]\n    train_data = train_df.drop([0, 1, 2, 3, 4], axis=1).astype(np.float32)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_py_data_subgroup_id",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_py_data_subgroup_id(task_type):\n    train_pool_from_files = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE_WITH_SUBGROUP_ID)\n    test_pool_from_files = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE_WITH_SUBGROUP_ID)\n    model = CatBoostRanker(loss_function='QueryRMSE', iterations=2, thread_count=4, task_type=task_type, devices='0')\n    model.fit(train_pool_from_files)\n    predictions_from_files = model.predict(test_pool_from_files)\n    train_df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    train_group_id = train_df.loc[:, 1]\n    raw_train_subgroup_id = train_df.loc[:, 4]\n    train_target = train_df.loc[:, 2]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_data(task_type):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    eval_pool = Pool(CLOUDNESS_TEST_FILE, column_description=CLOUDNESS_CD_FILE)\n    base_model = CatBoostClassifier(iterations=10, learning_rate=0.05, loss_function=\"MultiClass\", task_type=task_type, devices='0')\n    base_model.fit(pool)\n    baseline = np.array(base_model.predict(pool, prediction_type='RawFormulaVal'))\n    eval_baseline = np.array(base_model.predict(eval_pool, prediction_type='RawFormulaVal'))\n    eval_pool.set_baseline(eval_baseline)\n    model = CatBoostClassifier(iterations=90, learning_rate=0.05, loss_function=\"MultiClass\")\n    data = get_features_data_from_file(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_predict_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_predict_baseline(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_pool.set_baseline(np.arange(1, train_pool.num_row() + 1))\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    test_baseline = np.arange(0, test_pool.num_row())\n    test_pool.set_baseline(test_baseline)\n    test_pool_without_baseline = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=100, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred = model.predict(test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ntree_limit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ntree_limit(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=100, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    pred = model.predict_proba(test_pool, ntree_end=10)\n    preds_path = test_output_path(PREDS_PATH)\n    np.save(preds_path, np.array(pred))\n    return local_canonical_file(preds_path)\ndef test_ntree_invalid_range():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ntree_invalid_range",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ntree_invalid_range():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=100, learning_rate=0.03)\n    model.fit(train_pool)\n    with pytest.raises(CatBoostError):\n        model.predict_proba(test_pool, ntree_end=10000000)\n        model.predict_proba(test_pool, ntree_start=10000000)\n        model.predict_proba(test_pool, ntree_start=20, ntree_end=10)\ndef test_staged_predict(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_staged_predict",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_staged_predict(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    preds = []\n    for pred in model.staged_predict(test_pool):\n        preds.append(pred)\n    preds_path = test_output_path(PREDS_PATH)\n    np.save(preds_path, np.array(preds))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_staged_predict_with_bad_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_staged_predict_with_bad_params(task_type, eval_period):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    preds = []\n    with pytest.raises(CatBoostError):\n        for pred in model.staged_predict(test_pool, eval_period=eval_period):\n            preds.append(pred)\n@pytest.mark.parametrize('problem', ['Classifier', 'Regressor'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_staged_predict_and_predict_proba_on_single_object",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_staged_predict_and_predict_proba_on_single_object(problem):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    if problem == 'Classifier':\n        model = CatBoostClassifier(iterations=10)\n    else:\n        model = CatBoostRegressor(iterations=10)\n    model.fit(train_pool)\n    test_data = read_csv(TEST_FILE, header=None, delimiter='\\t')\n    test_data.drop([TARGET_IDX], axis=1, inplace=True)\n    preds = []",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_invalid_loss_base",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_invalid_loss_base(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost({\"loss_function\": \"abcdef\", 'task_type': task_type, 'devices': '0'})\n    with pytest.raises(CatBoostError):\n        model.fit(pool)\ndef test_invalid_loss_classifier(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(loss_function=\"abcdef\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_invalid_loss_classifier",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_invalid_loss_classifier(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(loss_function=\"abcdef\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)\ndef test_invalid_loss_regressor(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(loss_function=\"fee\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_invalid_loss_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_invalid_loss_regressor(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(loss_function=\"fee\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)\ndef test_invalid_loss_ranker(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(loss_function=\"MultiClass\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_invalid_loss_ranker",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_invalid_loss_ranker(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(loss_function=\"MultiClass\", task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)\ndef test_fit_no_label(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool.get_features())",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_no_label",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_no_label(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool.get_features())\ndef test_predict_without_fit(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.predict(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_without_fit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_without_fit(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.predict(pool)\ndef test_real_numbers_cat_features():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_real_numbers_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_real_numbers_cat_features():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    with pytest.raises(CatBoostError):\n        Pool(data, label, [1, 2])\ndef test_wrong_ctr_for_classification(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(ctr_description=['Borders:TargetBorderCount=5:TargetBorderType=Uniform'], task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_ctr_for_classification",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_ctr_for_classification(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(ctr_description=['Borders:TargetBorderCount=5:TargetBorderType=Uniform'], task_type=task_type, devices='0')\n    with pytest.raises(CatBoostError):\n        model.fit(pool)\ndef test_wrong_feature_count(task_type):\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoostClassifier(task_type=task_type, devices='0')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_feature_count",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_feature_count(task_type):\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoostClassifier(task_type=task_type, devices='0')\n    model.fit(data, label)\n    with pytest.raises(CatBoostError):\n        model.predict(data[:, :-1])\ndef test_wrong_params_classifier():\n    with pytest.raises(TypeError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_params_classifier",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_params_classifier():\n    with pytest.raises(TypeError):\n        CatBoostClassifier(wrong_param=1)\ndef test_wrong_params_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoost({'wrong_param': 1})\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_params_base",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_params_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoost({'wrong_param': 1})\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)\ndef test_wrong_params_regressor():\n    with pytest.raises(TypeError):\n        CatBoostRegressor(wrong_param=1)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_params_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_params_regressor():\n    with pytest.raises(TypeError):\n        CatBoostRegressor(wrong_param=1)\ndef test_wrong_params_ranker():\n    with pytest.raises(TypeError):\n        CatBoostRegressor(wrong_param=1)\ndef test_wrong_kwargs_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_params_ranker",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_params_ranker():\n    with pytest.raises(TypeError):\n        CatBoostRegressor(wrong_param=1)\ndef test_wrong_kwargs_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoost({'kwargs': {'wrong_param': 1}})\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_wrong_kwargs_base",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_wrong_kwargs_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoost({'kwargs': {'wrong_param': 1}})\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)\ndef test_duplicate_params_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_duplicate_params_base",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_duplicate_params_base():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoost({'iterations': 100, 'n_estimators': 50})\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)\ndef test_duplicate_params_classifier():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_duplicate_params_classifier",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_duplicate_params_classifier():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoostClassifier(depth=3, max_depth=4, random_seed=42, random_state=12)\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)\ndef test_duplicate_params_regressor():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_duplicate_params_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_duplicate_params_regressor():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model = CatBoostRegressor(learning_rate=0.1, eta=0.03, border_count=10, max_bin=12)\n    with pytest.raises(CatBoostError):\n        model.fit(data, label)\ndef test_clearing_parameters_in_loading_model():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_clearing_parameters_in_loading_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_clearing_parameters_in_loading_model():\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.rand(100, 10)\n    label = _generate_nontrivial_binary_target(100, prng=prng)\n    model_path = test_output_path(OUTPUT_MODEL_PATH)\n    fit = CatBoostRegressor(max_depth=3, verbose=False).fit(data, label)\n    fit.save_model(model_path)\n    fit.load_model(model_path).predict(label)\n    CatBoostRegressor(depth=3).load_model(model_path).predict(label)\ndef test_generated_metrics_default_params():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_metrics_default_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_metrics_default_params():\n    metrics_without_default_params = (\n        metrics.TotalF1, metrics.AUC, metrics.NDCG, metrics.CtrFactor, metrics.RecallAt, metrics.QueryCrossEntropy,\n        metrics.Logloss, metrics.LogLikelihoodOfPrediction, metrics.MultiClassOneVsAll, metrics.R2, metrics.MAPE,\n        metrics.UserQuerywiseMetric, metrics.MSLE, metrics.Expectile, metrics.FilteredDCG, metrics.DCG, metrics.MCC,\n        metrics.PrecisionAt, metrics.CrossEntropy, metrics.ERR, metrics.SMAPE, metrics.PairAccuracy, metrics.FairLoss,\n        metrics.QuerySoftMax, metrics.PRAUC, metrics.MAP, metrics.MedianAbsoluteError, metrics.F1,\n        metrics.NormalizedGini, metrics.BrierScore, metrics.Precision, metrics.HingeLoss, metrics.ZeroOneLoss,\n        metrics.WKappa, metrics.Combination, metrics.MAE, metrics.PairLogit, metrics.Kappa, metrics.MRR, metrics.RMSE,\n        metrics.Poisson, metrics.BalancedAccuracy, metrics.Accuracy, metrics.MultiClass, metrics.HammingLoss,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_f1_vs_fbeta",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_f1_vs_fbeta():\n    model = CatBoost({'loss_function': metrics.CrossEntropy(), 'iterations': 50})\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)\n    model.fit(train_pool, eval_set=test_pool)\n    results = model.eval_metrics(test_pool, ['F1', 'F:beta=1'])\n    assert np.allclose(results['F1'], results['F:beta=1']), \"Different results for F1 and F:beta=1\"\ndef test_generated_classification_metrics():\n    _test_generated_metrics(\n        'Logloss',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_classification_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_classification_metrics():\n    _test_generated_metrics(\n        'Logloss',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'Logloss': metrics.Logloss(), 'CrossEntropy': metrics.CrossEntropy(), 'Precision': metrics.Precision(),\n            'Recall': metrics.Recall(), 'F1': metrics.F1(), 'BalancedAccuracy': metrics.BalancedAccuracy(),\n            'BalancedErrorRate': metrics.BalancedErrorRate(), 'MCC': metrics.MCC(), 'Accuracy': metrics.Accuracy(),\n            'CtrFactor': metrics.CtrFactor(), 'AUC': metrics.AUC(), 'AUC:type=Ranking': metrics.AUC(type='Ranking'),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_regression_metrics_with_default_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_regression_metrics_with_default_params():\n    _test_generated_metrics(\n        'RMSE',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'MAE': metrics.MAE(), 'MAPE': metrics.MAPE(), 'Poisson': metrics.Poisson(),\n            # Metric description should be 'Quantile' instead of 'Quantile:alpha=0.5'\n            'Quantile:alpha=0.5': metrics.Quantile(), 'RMSE': metrics.RMSE(),\n            'LogLinQuantile': metrics.LogLinQuantile(), 'Expectile': metrics.Expectile(),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_regression_metrics_with_specified_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_regression_metrics_with_specified_params():\n    _test_generated_metrics(\n        'RMSE',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'Quantile:alpha=0.2': metrics.Quantile(alpha=0.2), 'Quantile:alpha=0.8': metrics.Quantile(alpha=0.8),\n            'LogLinQuantile:alpha=0.2': metrics.LogLinQuantile(alpha=0.2),\n            'LogLinQuantile:alpha=0.8': metrics.LogLinQuantile(alpha=0.8),\n            'Lq:q=1.0': metrics.Lq(q=1.0), 'Lq:q=2.0': metrics.Lq(q=2.0), 'Lq:q=10.0': metrics.Lq(q=10.0),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_multiclassification_aggregate_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_multiclassification_aggregate_metrics():\n    _test_generated_metrics(\n        'MultiClass',\n        Pool(data=CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE),\n        Pool(data=CLOUDNESS_TEST_FILE, column_description=CLOUDNESS_CD_FILE),\n        {\n            'MultiClass': metrics.MultiClass(), 'MultiClassOneVsAll': metrics.MultiClassOneVsAll(),\n            'TotalF1': metrics.TotalF1(), 'TotalF1:average=Macro': metrics.TotalF1(average='Macro'),\n            'TotalF1:average=Micro': metrics.TotalF1(average='Micro'),\n            'MCC': metrics.MCC(),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_multiclassification_class_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_multiclassification_class_metrics():\n    train_pool = Pool(data=CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    test_pool = Pool(data=CLOUDNESS_TEST_FILE, column_description=CLOUDNESS_CD_FILE)\n    n_classes = len(set(train_pool.get_label()))\n    model = CatBoost({'loss_function': 'MultiClass', 'iterations': 50})\n    model.fit(train_pool, eval_set=test_pool)\n    class_metrics = (\n        {'name': 'Precision', 'text': 'Precision', 'instance': metrics.Precision()},\n        {'name': 'Recall', 'text': 'Recall', 'instance': metrics.Recall()},\n        {'name': 'F1', 'text': 'F1', 'instance': metrics.F1()},",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_ranking_pairwise_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_ranking_pairwise_metric():\n    _test_generated_metrics(\n        'PairLogit',\n        Pool(data=QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE),\n        Pool(data=QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE),\n        {\n            'PairLogit': metrics.PairLogit(), 'PairAccuracy': metrics.PairAccuracy(),\n            'AUC': metrics.AUC(), 'AUC:type=Ranking': metrics.AUC(type='Ranking')\n        },\n        \"ranking\"",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_ranking_groupwise_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_ranking_groupwise_metric():\n    _test_generated_metrics(\n        'QueryRMSE',\n        Pool(data=QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE),\n        Pool(data=QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE),\n        {\n            'QueryRMSE': metrics.QueryRMSE(), 'GroupQuantile:alpha=0.5': metrics.GroupQuantile(), 'PFound': metrics.PFound(),\n            # Metric descriptions should be 'NDCG' & 'DCG' instead of 'NDCG:type=Base' & 'DCG:type=Base' respectively\n            'NDCG:type=Base': metrics.NDCG(), 'DCG:type=Base': metrics.DCG(),\n            'FilteredDCG': metrics.FilteredDCG(), 'AverageGain:top=5': metrics.AverageGain(top=5),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_survival_aft",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_survival_aft():\n    cd_file = data_file('survival_aft', 'train.cd')\n    _test_generated_metrics(\n        'SurvivalAft',\n        Pool(data=data_file('survival_aft', 'train'), column_description=cd_file),\n        Pool(data=data_file('survival_aft', 'test'), column_description=cd_file),\n        {\n            'SurvivalAft': metrics.SurvivalAft()\n        },\n        \"survival_regression\"",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_cox",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_cox():\n    _test_generated_metrics(\n        'Cox',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'Cox': metrics.Cox()\n        },\n        \"survival_regression\"\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_multiregression_metric_and_loss",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_multiregression_metric_and_loss():\n    _test_generated_metrics(\n        metrics.MultiRMSE(),\n        Pool(data=MULTIREGRESSION_TRAIN_FILE, column_description=MULTIREGRESSION_CD_FILE),\n        Pool(data=MULTIREGRESSION_TEST_FILE, column_description=MULTIREGRESSION_CD_FILE),\n        {\n            'MultiRMSE': metrics.MultiRMSE()\n        },\n        \"multiregression\"\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_classification_losses",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_classification_losses():\n    _test_generated_losses(\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'Logloss': metrics.Logloss(),\n            'CrossEntropy': metrics.CrossEntropy(),\n            'Focal:focal_alpha=0.75;focal_gamma=2.0': metrics.Focal(focal_alpha=0.75, focal_gamma=2.0)\n        },\n        int",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_regression_losses_with_default_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_regression_losses_with_default_params():\n    _test_generated_losses(\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'MAE': metrics.MAE(), 'MAPE': metrics.MAPE(), 'Poisson': metrics.Poisson(),\n            'Quantile:alpha=0.5': metrics.Quantile(), 'RMSE': metrics.RMSE(),\n            'RMSEWithUncertainty': metrics.RMSEWithUncertainty(), 'LogLinQuantile': metrics.LogLinQuantile(),\n            # BUG: Expectile incorrectly expects alpha in catboost.core.Catboost({'loss_function': 'Expectile'})\n            # 'Expectile': metrics.Expectile()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_regression_losses_with_specified_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_regression_losses_with_specified_params():\n    _test_generated_losses(\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        {\n            'Quantile:alpha=0.2': metrics.Quantile(alpha=0.2), 'Quantile:alpha=0.8': metrics.Quantile(alpha=0.8),\n            'LogLinQuantile:alpha=0.2': metrics.LogLinQuantile(alpha=0.2),\n            'LogLinQuantile:alpha=0.8': metrics.LogLinQuantile(alpha=0.8),\n            'Lq:q=1.0': metrics.Lq(q=1.0), 'Lq:q=2.0': metrics.Lq(q=2.0), 'Lq:q=10.0': metrics.Lq(q=10.0),\n            'Huber:delta=1.0': metrics.Huber(delta=1.0), 'Huber:delta=0.5': metrics.Huber(delta=0.5),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_multiclassification_losses",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_multiclassification_losses():\n    _test_generated_losses(\n        Pool(data=CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE),\n        Pool(data=CLOUDNESS_TEST_FILE, column_description=CLOUDNESS_CD_FILE),\n        {'MultiClass': metrics.MultiClass(), 'MultiClassOneVsAll': metrics.MultiClassOneVsAll()}\n    )\ndef test_generated_pairwise_ranking_losses():\n    _test_generated_losses(\n        Pool(data=QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE),\n        Pool(data=QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_pairwise_ranking_losses",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_pairwise_ranking_losses():\n    _test_generated_losses(\n        Pool(data=QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE),\n        Pool(data=QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE),\n        {\n            'PairLogit': metrics.PairLogit(), 'PairLogit:max_pairs=2': metrics.PairLogit(max_pairs=2),\n            'PairLogit:max_pairs=5': metrics.PairLogit(max_pairs=5)\n        }\n    )\ndef test_generated_groupwise_ranking_losses():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_groupwise_ranking_losses",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_groupwise_ranking_losses():\n    _test_generated_losses(\n        Pool(data=QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE),\n        Pool(data=QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE),\n        {\n            'QueryRMSE': metrics.QueryRMSE(), 'QuerySoftMax': metrics.QuerySoftMax(),\n            'QuerySoftMax:beta=0.5': metrics.QuerySoftMax(beta=0.5),\n            'QuerySoftMax:beta=2.0': metrics.QuerySoftMax(beta=2.0)\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantile_with_default_params_description",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantile_with_default_params_description():\n    _test_metric_with_default_params_description(\n        'RMSE',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        'Quantile'\n    )\n@pytest.mark.xfail\ndef test_dcg_with_default_params_description():\n    _test_metric_with_default_params_description(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_dcg_with_default_params_description",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_dcg_with_default_params_description():\n    _test_metric_with_default_params_description(\n        'QueryRMSE',\n        Pool(data=TRAIN_FILE, column_description=CD_FILE),\n        Pool(data=TEST_FILE, column_description=CD_FILE),\n        'DCG'\n    )\n@pytest.mark.xfail\ndef test_expectile_loss_with_default_params():\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_expectile_loss_with_default_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_expectile_loss_with_default_params():\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)\n    model = CatBoost({'iterations': 50, 'loss_function': 'Expectile'})\n    model.fit(train_pool, eval_set=test_pool)\ndef test_generated_metrics():\n    # Test equivalence of the generated metric classes to string representations.\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_generated_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_generated_metrics():\n    # Test equivalence of the generated metric classes to string representations.\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor()\n    model.fit(train_pool)\n    eval_metrics = [metrics.Lq(q=3)]\n    metrics_evals = model.eval_metrics(test_pool, eval_metrics)\n    for metric in eval_metrics:\n        assert str(metric) in metrics_evals",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_metrics_is_min_max_optimal",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_metrics_is_min_max_optimal():\n    logloss = metrics.Logloss()\n    assert logloss.is_min_optimal() and not logloss.is_max_optimal()\n    assert is_minimizable_metric('Logloss') and not is_maximizable_metric('Logloss')\n    auc = metrics.AUC()\n    assert auc.is_max_optimal() and not auc.is_min_optimal()\n    assert is_maximizable_metric('AUC') and not is_minimizable_metric('AUC')\ndef test_custom_eval():\n    class LoglossMetric(object):\n        def get_final_error(self, error, weight):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_custom_eval",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_custom_eval():\n    class LoglossMetric(object):\n        def get_final_error(self, error, weight):\n            return error / (weight + 1e-38)\n        def is_max_optimal(self):\n            return True\n        def evaluate(self, approxes, target, weight):\n            assert len(approxes) == 1\n            assert len(target) == len(approxes[0])\n            approx = approxes[0]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_custom_objective",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_custom_objective(task_type, loss_objective):\n    train_pool = Pool(data=TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(data=TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, use_best_model=True,\n                               loss_function=loss_objective(), eval_metric=\"Logloss\",\n                               # Leaf estimation method and gradient iteration are set to match\n                               # defaults for Logloss.\n                               leaf_estimation_method=\"Newton\", leaf_estimation_iterations=1, task_type=task_type, devices='0')\n    model.fit(train_pool, eval_set=test_pool)\n    pred1 = model.predict(test_pool, prediction_type='RawFormulaVal')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multilabel_custom_objective",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multilabel_custom_objective(task_type, n=10):\n    class MultiRMSEObjective(MultiTargetCustomObjective):\n        def calc_ders_multi(self, approxes, targets, weight):\n            assert len(approxes) == len(targets)\n            grad = []\n            hess = [[0 for j in range(len(targets))] for i in range(len(targets))]\n            for index in range(len(targets)):\n                der1 = (targets[index] - approxes[index]) * weight\n                der2 = -weight\n                grad.append(der1)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_after_fit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_after_fit(task_type):\n    pool1 = Pool(TRAIN_FILE, column_description=CD_FILE)\n    pool2 = Pool(TRAIN_FILE, column_description=CD_FILE)\n    assert _have_equal_features(pool1, pool2)\n    model = CatBoostClassifier(iterations=5, task_type=task_type, devices='0')\n    model.fit(pool2)\n    assert _have_equal_features(pool1, pool2)\ndef test_priors(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_priors",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_priors(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        has_time=True,\n        ctr_description=[\"Borders:Prior=0:Prior=0.6:Prior=1:Prior=5\",\n                         (\"FeatureFreq\" if task_type == 'GPU' else \"Counter\") + \":Prior=0:Prior=0.6:Prior=1:Prior=5\"],\n        task_type=task_type, devices='0',\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ignored_features(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model1 = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', max_ctr_complexity=1)\n    model1.fit(train_pool)\n    fstr = model1.get_feature_importance()\n    model2 = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', max_ctr_complexity=1, ignored_features=np.argsort(fstr)[-2:])\n    model2.fit(train_pool)\n    predictions1 = model1.predict_proba(test_pool)\n    predictions2 = model2.predict_proba(test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multi_reload_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multi_reload_model(task_type):\n    friday_train_pool = Pool(data=BLACK_FRIDAY_TRAIN_FILE, column_description=BLACK_FRIDAY_CD_FILE, has_header=True)\n    friday_params = dict(\n        iterations=20,\n        learning_rate=0.5,\n        task_type=task_type,\n        devices='0',\n        max_ctr_complexity=1,\n        target_border=5000,\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ignored_features_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ignored_features_names(task_type):\n    train_pool = Pool(data=BLACK_FRIDAY_TRAIN_FILE, column_description=BLACK_FRIDAY_CD_FILE, has_header=True)\n    test_pool = Pool(data=BLACK_FRIDAY_TEST_FILE, column_description=BLACK_FRIDAY_CD_FILE, has_header=True)\n    params = dict(\n        iterations=20,\n        learning_rate=0.5,\n        task_type=task_type,\n        devices='0',\n        max_ctr_complexity=1,\n        target_border=5000,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_class_weights_list_binclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_class_weights_list_binclass(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, class_weights=[1, 2], task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_auto_class_weights():\n    rnd = np.random.RandomState(2020)\n    data = rnd.rand(10, 2)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_auto_class_weights",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_auto_class_weights():\n    rnd = np.random.RandomState(2020)\n    data = rnd.rand(10, 2)\n    target = rnd.randint(2, size=10)\n    counts = Counter(target)\n    max_class_count = max(counts.values())\n    expected_balanced = np.array([max_class_count / counts[class_id] if counts[class_id] > 0 else 1.\n                                  for class_id in range(2)])\n    expected_sqrt_balanced = np.sqrt(expected_balanced)\n    balanced_model = CatBoostClassifier(iterations=5, auto_class_weights='Balanced')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_class_weights_dict_binclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_class_weights_dict_binclass(dict_type, label_type):\n    if label_type is int:\n        uniq_labels = [0, 1]\n    elif label_type is str:\n        uniq_labels = ['a', 'b']\n    features, labels = generate_random_labeled_dataset(100, 5, uniq_labels)\n    weights = [0.5, 2.0]\n    class_weights_dict = dict_type(zip(uniq_labels, weights))\n    model_with_class_weights_as_list = CatBoostClassifier(\n        iterations=5,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_bad_class_weights_dict_binclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_bad_class_weights_dict_binclass(label_type):\n    if label_type is int:\n        uniq_labels = [0, 1, 2]\n    elif label_type is str:\n        uniq_labels = ['a', 'b', 'c']\n    features, labels = generate_random_labeled_dataset(100, 5, uniq_labels[:2])\n    model = CatBoostClassifier(\n        class_weights={uniq_labels[0]: 0.5, uniq_labels[1]: 2.0, uniq_labels[2]: 0.3}\n    )\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_class_weights_dict_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_class_weights_dict_multiclass(dict_type, label_type):\n    if label_type is int:\n        uniq_labels = [0, 1, 2, 3]\n    elif label_type is str:\n        uniq_labels = ['a', 'b', 'c', 'd']\n    features, labels = generate_random_labeled_dataset(100, 5, uniq_labels)\n    weights = [0.1, 2.0, 3.0, 0.4]\n    class_weights_dict = dict_type(zip(uniq_labels, weights))\n    model_with_class_weights_as_list = CatBoostClassifier(\n        loss_function='MultiClass',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_bad_class_weights_dict_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_bad_class_weights_dict_multiclass(label_type):\n    if label_type is int:\n        uniq_labels = [0, 1, 2, 3]\n    elif label_type is str:\n        uniq_labels = ['a', 'b', 'c', 'd']\n    features, labels = generate_random_labeled_dataset(100, 5, uniq_labels)\n    model = CatBoostClassifier(\n        loss_function='MultiClass',\n        class_weights={uniq_labels[0]: 0.5, uniq_labels[1]: 2.0, uniq_labels[2]: 0.3}\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_classification_ctr",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_classification_ctr(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03,\n                               ctr_description=['Borders', 'FeatureFreq' if task_type == 'GPU' else 'Counter'],\n                               task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\n@fails_on_gpu(how=\"private/libs/options/catboost_options.cpp:280: Error: GPU doesn't not support target binarization per CTR description currently. Please use ctr_target_border_count option instead\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_regression_ctr",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_regression_ctr(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, ctr_description=['Borders:TargetBorderCount=5:TargetBorderType=Uniform', 'Counter'], task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_ctr_target_border_count(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, ctr_target_border_count=5, task_type=task_type, devices='0')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ctr_target_border_count",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ctr_target_border_count(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, ctr_target_border_count=5, task_type=task_type, devices='0')\n    model.fit(pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_copy_model():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model1 = CatBoostRegressor(iterations=5)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_copy_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_copy_model():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model1 = CatBoostRegressor(iterations=5)\n    model1.fit(pool)\n    model2 = model1.copy()\n    predictions1 = model1.predict(pool)\n    predictions2 = model2.predict(pool)\n    assert _check_data(predictions1, predictions2)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model2.save_model(output_model_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_query",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_query(task_type, loss_function):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    train_dir_prefix = test_output_path('')\n    computed_metric = {\n        'QueryRMSE': 'QueryRMSE',\n        'YetiRank': 'PFound'\n    }[loss_function]\n    results = cv(\n        pool,\n        {\"iterations\": 20, \"learning_rate\": 0.03, \"loss_function\": loss_function, \"task_type\": task_type,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_pairs(task_type):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE, pairs=QUERYWISE_TRAIN_PAIRS_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"random_seed\": 8,\n            \"loss_function\": \"PairLogit\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_pairs_generated",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_pairs_generated(task_type):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 10,\n            \"learning_rate\": 0.03,\n            \"random_seed\": 8,\n            \"loss_function\": \"PairLogit\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_custom_loss",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_custom_loss(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 5,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"custom_loss\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_skip_train",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_skip_train(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss:hints=skip_train~true\",\n            \"eval_metric\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_skip_train_default",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_skip_train_default(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"custom_loss\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_metric_period",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_metric_period(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_overfitting_detector",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_overfitting_detector(with_metric_period, task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_with_cat_features_param",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_with_cat_features_param(param_type):\n    if param_type == 'indices':\n        cat_features_param = [1, 2]\n        feature_names_param = None\n    else:\n        cat_features_param = ['feat1', 'feat2']\n        feature_names_param = ['feat' + str(i) for i in range(20)]\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.randint(10, size=(20, 20))\n    label = _generate_nontrivial_binary_target(20, prng=prng)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_with_text",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_with_text(problem_type):\n    cats_words = ['Meow', 'Kitten', 'Paw', 'Tail', 'Purring', 'Crouch', 'Whisker']\n    dogs_words = ['Puppy', 'Whelp', 'Woof', 'Tail', 'Paw', 'Snarl', 'Barking']\n    words = [cats_words, dogs_words]\n    np.random.seed(1)\n    labels = np.random.choice(2, 1000)\n    texts = [[' '.join(np.random.choice(words[label], 3, replace=False))] for label in labels]\n    data_pool = Pool(data=texts, label=labels, text_features=[0])\n    train_dir_prefix = test_output_path('')\n    params = {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_with_save_snapshot",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_with_save_snapshot(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    with pytest.raises(CatBoostError):\n        cv(\n            pool,\n            {\n                \"iterations\": 20,\n                \"learning_rate\": 0.03,\n                \"loss_function\": \"Logloss\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_return_models",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_return_models(params):\n    train_dir_prefix = test_output_path('')\n    params.update(\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"train_dir\": os.path.join(train_dir_prefix, 'catboost_info')\n        }\n    )\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_small_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_small_data():\n    cv_data = [[\"France\", 1924, 44],\n               [\"USA\", 1932, 37],\n               [\"Switzerland\", 1928, 25],\n               [\"Norway\", 1952, 30],\n               [\"Japan\", 1972, 35],\n               [\"Mexico\", 1968, 112]]\n    labels = [1, 1, 0, 0, 0, 1]\n    pool = Pool(data=cv_data,\n                label=labels,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_without_loss_function",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_without_loss_function():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    with pytest.raises(CatBoostError):\n        cv(pool, {})\n        pytest.fail(\"Parameter loss_function should be specified for cross-validation\")\ndef test_tune_hyperparams_small_data():\n    train_data = [[1, 4, 5, 6],\n                  [4, 5, 6, 7],\n                  [30, 40, 50, 60],\n                  [20, 30, 70, 60],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_tune_hyperparams_small_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_tune_hyperparams_small_data():\n    train_data = [[1, 4, 5, 6],\n                  [4, 5, 6, 7],\n                  [30, 40, 50, 60],\n                  [20, 30, 70, 60],\n                  [10, 80, 40, 30],\n                  [10, 10, 20, 30]]\n    train_labels = [10, 20, 30, 15, 10, 25]\n    grid = {\n        'learning_rate': [0.03, 0.1],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_aliases",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_aliases(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"task_type\": task_type,\n            \"iterations\": 10,\n        }\n    )\n    grid = {\n        \"num_boost_round\": [5, 10],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_and_get_best_result",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_and_get_best_result(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    for refit in [True, False]:\n        for search_by_train_test_split in [True, False]:\n            model = CatBoost(\n                {\n                    \"loss_function\": \"Logloss\",\n                    \"eval_metric\": \"AUC\",\n                    \"task_type\": task_type,\n                    \"custom_metric\": [\"CrossEntropy\", \"F1\", \"F:beta=2\"]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type,\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_for_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_for_multiclass():\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    model = CatBoostClassifier(iterations=10)\n    grid = {\n        'learning_rate': [0.03, 0.1],\n        'depth': [4, 6, 10],\n        'l2_leaf_reg': [1, 3, 5, 7, 9]\n    }\n    results = model.grid_search(grid, pool, shuffle=False, verbose=False)\n    for key, value in results[\"params\"].items():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_randomized_search",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_randomized_search(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_randomized_search_only_dist",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_randomized_search_only_dist(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_randomized_search_refit_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_randomized_search_refit_model(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_randomized_search_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_randomized_search_cv(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type\n        }\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_with_class_weights_lists",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_with_class_weights_lists():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10)\n    grid = {\n        'learning_rate': [0.03, 0.1],\n        'depth': [4, 6, 8],\n        'l2_leaf_reg': [1, 3, 5, 7],\n        'class_weights': [[1, 2], [1, 3]]\n    }\n    results = model.grid_search(grid, pool, shuffle=False, verbose=False)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_wrong_param_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_wrong_param_type(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type,\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_trivial",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_trivial(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"iterations\": 20,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type,\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_several_grids",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_several_grids(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"iterations\": 10,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"eval_metric\": \"AUC\",\n            \"task_type\": task_type,\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grid_search_complex_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grid_search_complex_params(task_type):\n    n25_index = 25\n    n75_index = 75\n    train_labels = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]\n    prng = np.random.RandomState(seed=0)\n    pool = Pool(prng.random_sample(size=(1000, 100)), label=prng.choice(train_labels, size=1000))\n    params = {\n        'depth': [4, 7, 10],\n        'per_float_feature_quantization': [\n            None,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    pool_querywise = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    model = CatBoostRanker(iterations=5, learning_rate=0.03, task_type=task_type, devices=\"0\", loss_function=\"QueryRMSE\")\n    model.fit(pool_querywise)\n    assert len(model.feature_importances_.shape) == 0\n    model.get_feature_importance(type=EFstrType.LossFunctionChange, data=pool_querywise)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_interaction_asymmetric_grow_policy",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_interaction_asymmetric_grow_policy():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=3)\n    model.fit(pool)\n    fstr_symm = np.array(model.get_feature_importance(type='Interaction', data=pool))\n    model._convert_to_asymmetric_representation()\n    fstr_asymm = np.array(model.get_feature_importance(type='Interaction', data=pool))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_asymmetric_prediction_value_change",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_asymmetric_prediction_value_change(task_type, grow_policy):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    pool_querywise = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    params = {\n        \"iterations\": 5,\n        \"learning_rate\": 0.03,\n        \"task_type\": task_type,\n        \"devices\": \"0\",\n        \"loss_function\": \"QueryRMSE\",",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_explicit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_explicit(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.array(model.get_feature_importance(type=EFstrType.PredictionValuesChange)))\n    return local_canonical_file(fimp_npy_path)\ndef test_feature_importance_prettified(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_prettified",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_prettified(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    feature_importances = model.get_feature_importance(type=EFstrType.PredictionValuesChange, prettified=True)\n    fimp_txt_path = test_output_path(FIMP_TXT_PATH)\n    with open(fimp_txt_path, 'w') as ofile:\n        for f_id, f_imp in feature_importances.values:\n            ofile.write('{}\\t{}\\n'.format(f_id, f_imp))\n    return local_canonical_file(fimp_txt_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_interaction_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_interaction_feature_importance(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.array(model.get_feature_importance(type=EFstrType.Interaction)))\n    return local_canonical_file(fimp_npy_path)\ndef make_reference_data(pool, calc_shap_mode):\n    reference_data = None\n    if calc_shap_mode == \"IndependentTreeSHAP\":",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "make_reference_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def make_reference_data(pool, calc_shap_mode):\n    reference_data = None\n    if calc_shap_mode == \"IndependentTreeSHAP\":\n        quarter_size = pool.num_row() // 4\n        reference_data = pool.slice(list(range(quarter_size)))\n    return reference_data\n@pytest.mark.parametrize('calc_shap_mode', ['TreeSHAP', 'IndependentTreeSHAP'])\ndef test_shap_feature_importance(task_type, calc_shap_mode):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, calc_shap_mode)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance(task_type, calc_shap_mode):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, max_ctr_complexity=1, task_type=task_type, devices='0')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data)\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_with_user_metrics_and_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_with_user_metrics_and_no_target(task_type):\n    if task_type != 'CPU':\n        return\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        loss_function=LoglossObjective(),\n        eval_metric=metrics.Logloss(),\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, max_ctr_complexity=1, task_type=task_type, devices='0')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Approximate\")\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_exact_shap_feature_importance(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exact_shap_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exact_shap_feature_importance(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, max_ctr_complexity=1, task_type=task_type, devices='0')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Exact\")\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)\n@pytest.mark.parametrize('calc_shap_mode', ['TreeSHAP', 'IndependentTreeSHAP'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_multiclass(task_type, calc_shap_mode):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiClass', random_strength=0, bootstrap_type='No', has_time=True)\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data)), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_approximate_shap_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiClass', random_strength=0, bootstrap_type='No', has_time=True)\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool,\n                                                                           shap_calc_type=\"Approximate\")), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_exact_shap_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exact_shap_feature_importance_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exact_shap_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiClass', random_strength=0, bootstrap_type='No', has_time=True)\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool,\n                                                                           shap_calc_type=\"Exact\")), 9))\n    return local_canonical_file(fimp_npy_path)\n@pytest.mark.parametrize('calc_shap_mode', ['TreeSHAP', 'IndependentTreeSHAP'])\ndef test_shap_feature_importance_multirmse(task_type, calc_shap_mode):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_multirmse",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_multirmse(task_type, calc_shap_mode):\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    pool = Pool(train_file, column_description=cd_file)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiRMSE')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data)), 9))\n    return local_canonical_file(fimp_npy_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance_multirmse",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance_multirmse(task_type):\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    pool = Pool(train_file, column_description=cd_file)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiRMSE')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool,\n                                                                           shap_calc_type=\"Approximate\")), 9))\n    return local_canonical_file(fimp_npy_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exact_shap_feature_importance_multirmse",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exact_shap_feature_importance_multirmse(task_type):\n    train_file = MULTIREGRESSION_TRAIN_FILE\n    cd_file = MULTIREGRESSION_CD_FILE\n    pool = Pool(train_file, column_description=cd_file)\n    model = CatBoostRegressor(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiRMSE')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool,\n                                                                           shap_calc_type=\"Exact\")), 9))\n    return local_canonical_file(fimp_npy_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_ranking",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_ranking(task_type):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE, pairs=QUERYWISE_TRAIN_PAIRS_FILE)\n    model = CatBoostRanker(iterations=20, learning_rate=0.03, task_type=task_type, devices='0', loss_function='PairLogit')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool)\n    assert np.allclose(model.predict(pool), np.sum(shaps, axis=1))\n    if task_type == 'GPU':\n        return pytest.xfail(reason=\"On GPU models with loss Pairlogit are too unstable. MLTOOLS-4722\")\n    else:\n        fimp_npy_path = test_output_path(FIMP_NPY_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance_ranking",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance_ranking(task_type):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE, pairs=QUERYWISE_TRAIN_PAIRS_FILE)\n    model = CatBoostRanker(iterations=20, learning_rate=0.03, task_type=task_type, devices='0', loss_function='PairLogit')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Approximate\")\n    assert np.allclose(model.predict(pool), np.sum(shaps, axis=1))\n    if task_type == 'GPU':\n        return pytest.xfail(reason=\"On GPU models with loss Pairlogit are too unstable. MLTOOLS-4722\")\n    else:\n        fimp_npy_path = test_output_path(FIMP_NPY_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exact_shap_feature_importance_ranking",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exact_shap_feature_importance_ranking(task_type):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE, pairs=QUERYWISE_TRAIN_PAIRS_FILE)\n    model = CatBoostRanker(iterations=20, learning_rate=0.03, task_type=task_type, devices='0', loss_function='PairLogit')\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Exact\")\n    assert np.allclose(model.predict(pool), np.sum(shaps, axis=1))\n    if task_type == 'GPU':\n        return pytest.xfail(reason=\"On GPU models with loss Pairlogit are too unstable. MLTOOLS-4722\")\n    else:\n        fimp_npy_path = test_output_path(FIMP_NPY_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_asymmetric_and_symmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_asymmetric_and_symmetric(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        devices='0')\n    model.fit(pool)\n    shap_symm = np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance_asymmetric_and_symmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance_asymmetric_and_symmetric(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        devices='0')\n    model.fit(pool)\n    shap_symm = np.array(model.get_feature_importance(type=EFstrType.ShapValues, data=pool,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_with_langevin",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_with_langevin(calc_shap_mode):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, depth=10, langevin=True, diffusion_temperature=1000)\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data)\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_approximate_shap_feature_importance_with_langevin",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_approximate_shap_feature_importance_with_langevin():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, depth=10, langevin=True, diffusion_temperature=1000)\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Approximate\")\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_exact_shap_feature_importance_with_langevin():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exact_shap_feature_importance_with_langevin",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exact_shap_feature_importance_with_langevin():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, depth=10, langevin=True, diffusion_temperature=1000)\n    model.fit(pool)\n    shaps = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_calc_type=\"Exact\")\n    assert np.allclose(model.predict(pool, prediction_type='RawFormulaVal'), np.sum(shaps, axis=1))\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(shaps), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_loss_function_change_asymmetric_and_symmetric(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loss_function_change_asymmetric_and_symmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loss_function_change_asymmetric_and_symmetric(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        devices='0')\n    model.fit(pool)\n    shap_symm = np.array(model.get_feature_importance(type=EFstrType.LossFunctionChange, data=pool))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_asymmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_asymmetric(task_type, grow_policy):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        grow_policy=grow_policy,\n        devices='0')\n    model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loss_function_change_asymmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loss_function_change_asymmetric(task_type, grow_policy):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        grow_policy=grow_policy,\n        devices='0')\n    model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_importance_modes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_importance_modes(task_type, calc_shap_mode):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoostClassifier(iterations=5, task_type=task_type)\n    model.fit(pool)\n    modes = [\"Auto\", \"UsePreCalc\", \"NoPreCalc\"]\n    shaps_for_modes = []\n    for mode in modes:\n        shaps_for_modes.append(model.get_feature_importance(type=EFstrType.ShapValues, data=pool, shap_mode=mode, reference_data=reference_data))\n    for i in range(len(modes) - 1):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_probability",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_probability(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, \"IndependentTreeSHAP\")\n    model = CatBoostClassifier(iterations=50, task_type=task_type)\n    model.fit(pool)\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data, model_output=\"Probability\")\n    predictions = model.predict(pool, \"Probability\")\n    for doc_idx in range(len(shap_values)):\n        assert abs(sum(shap_values[doc_idx]) - predictions[doc_idx][1]) < 1e-6\ndef test_shap_feature_multiclass_probability(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_multiclass_probability",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_multiclass_probability(task_type):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    reference_data = make_reference_data(pool, \"IndependentTreeSHAP\")\n    model = CatBoostClassifier(iterations=50, loss_function='MultiClass', task_type=task_type)\n    classes_count = 3\n    model.fit(pool)\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data, model_output=\"Probability\")\n    predictions = model.predict(pool, \"Probability\")\n    for doc_idx in range(len(shap_values)):\n        for class_idx in range(classes_count):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_log_loss",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_log_loss(task_type):\n    def log_loss(yt, yp):\n        return (-(yt * np.log(yp) + (1 - yt) * np.log(1 - yp)))\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, \"IndependentTreeSHAP\")\n    model = CatBoostClassifier(iterations=50, loss_function='Logloss', task_type=task_type)\n    model.fit(pool)\n    label = pool.get_label()\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data, model_output=\"LossFunction\")\n    predictions = model.predict(pool, \"Probability\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_feature_rmse",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_feature_rmse(task_type):\n    def rmse(yt, yp):\n        return np.absolute(yt - yp)\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(train_pool, \"IndependentTreeSHAP\")\n    model = CatBoostRegressor(iterations=10, loss_function='RMSE')\n    model.fit(train_pool)\n    label = test_pool.get_label()\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=test_pool, reference_data=reference_data, model_output=\"LossFunction\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_sage_basic",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_sage_basic():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, devices='0')\n    model.fit(pool)\n    feature_importances = model.get_feature_importance(pool, type=EFstrType.SageValues, sage_n_samples=32,\n                                                       sage_batch_size=512)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(feature_importances), 2))\n    return local_canonical_file(fimp_npy_path)\ndef test_feature_importance_sage_querywise():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_sage_querywise",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_sage_querywise():\n    pool_querywise = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    params = {\n        \"iterations\": 5,\n        \"learning_rate\": 0.03,\n        \"devices\": \"0\",\n        \"loss_function\": \"QueryRMSE\"\n    }\n    model = CatBoostRanker(**params)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_importance_sage_all_feature_types",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_importance_sage_all_feature_types():\n    pool = Pool(ROTTEN_TOMATOES_TRAIN_FILE, column_description=ROTTEN_TOMATOES_CD_BINCLASS_FILE)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    params = {\n        \"iterations\": 5,\n        \"learning_rate\": 0.03,\n        \"devices\": \"0\"\n    }\n    model = CatBoostClassifier(**params)\n    model.fit(pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_diff_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_prediction_diff_feature_importance(task_type):\n    pool_file = 'higgs'\n    pool = Pool(data_file(pool_file, 'train_small'), column_description=data_file(pool_file, 'train.cd'))\n    model = CatBoostClassifier(iterations=110, task_type=task_type, learning_rate=0.03, max_ctr_complexity=1, devices='0')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(\n        type=EFstrType.PredictionDiff,\n        data=pool.get_features()[:2]\n    )), 9))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_diff_nonsym_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_prediction_diff_nonsym_feature_importance(task_type, grow_policy):\n    pool_file = 'higgs'\n    pool = Pool(data_file(pool_file, 'train_small'), column_description=data_file(pool_file, 'train.cd'))\n    model = CatBoostClassifier(iterations=110, task_type=task_type, grow_policy=grow_policy, learning_rate=0.03, max_ctr_complexity=1, devices='0')\n    model.fit(pool)\n    fimp_txt_path = test_output_path(FIMP_TXT_PATH)\n    np.savetxt(fimp_txt_path, np.around(np.array(model.get_feature_importance(\n        type=EFstrType.PredictionDiff,\n        data=pool.get_features()[:2]\n    )), 9))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_od",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_od(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=1000, learning_rate=0.03, od_type='Iter', od_wait=20, random_seed=42, task_type=task_type, devices='0')\n    model.fit(train_pool, eval_set=test_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)\n    return compare_canonical_models(output_model_path)\ndef test_clone(task_type):\n    estimator = CatBoostClassifier(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_clone",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_clone(task_type):\n    estimator = CatBoostClassifier(\n        custom_metric=\"Accuracy\",\n        loss_function=\"MultiClass\",\n        iterations=400,\n        learning_rate=0.03,\n        task_type=task_type, devices='0')\n    # This is important for sklearn.base.clone since\n    # it uses get_params for cloning estimator.\n    params = estimator.get_params()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_cat_features_order",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_cat_features_order(task_type):\n    dataset = np.array([[2, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])\n    labels = [1.2, 3.4, 9.5, 24.5]\n    pool1 = Pool(dataset, labels, cat_features=[0, 1])\n    pool2 = Pool(dataset, labels, cat_features=[1, 0])\n    model = CatBoost({'learning_rate': 1, 'loss_function': 'RMSE', 'iterations': 2, 'random_seed': 42, 'task_type': task_type, 'devices': '0'})\n    model.fit(pool1)\n    assert (model.predict(pool1) == model.predict(pool2)).all()\n@fails_on_gpu(how='private/libs/options/json_helper.h:198: Error: change of option approx_on_full_history is unimplemented for task type GPU and was not default in previous run')\ndef test_full_history(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_full_history",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_full_history(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=1000, learning_rate=0.03, od_type='Iter', od_wait=20, random_seed=42,\n        approx_on_full_history=True, task_type=task_type, devices='0', boosting_type='Ordered'\n    )\n    model.fit(train_pool, eval_set=test_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)\n    model.save_model(output_model_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_logging",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_logging(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    cv(\n        pool,\n        {\n            \"iterations\": 14,\n            \"learning_rate\": 0.03,\n            \"loss_function\": \"Logloss\",\n            \"task_type\": task_type,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_with_not_binarized_target",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_with_not_binarized_target(task_type):\n    train_file = data_file('adult_not_binarized', 'train_small')\n    cd = data_file('adult_not_binarized', 'train.cd')\n    pool = Pool(train_file, column_description=cd)\n    train_dir_prefix = test_output_path('')\n    cv(\n        pool,\n        {\n            \"iterations\": 10,\n            \"learning_rate\": 0.03,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_metrics(loss_function, metric_period, task_type):\n    train, test, cd, metric = TRAIN_FILE, TEST_FILE, CD_FILE, loss_function\n    if loss_function == 'QueryRMSE':\n        train, test, cd, metric = QUERYWISE_TRAIN_FILE, QUERYWISE_TEST_FILE, QUERYWISE_CD_FILE, 'PFound'\n    if loss_function == 'Logloss':\n        metric = 'AUC'\n    train_pool = Pool(train, column_description=cd)\n    test_pool = Pool(test, column_description=cd)\n    model = CatBoost(\n        params={'loss_function': loss_function, 'iterations': 20, 'thread_count': 8,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metrics_batch_calcer",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_metrics_batch_calcer(loss_function, metric_period, task_type):\n    metric = loss_function\n    if loss_function == 'QueryRMSE':\n        train, test, cd = QUERYWISE_TRAIN_FILE, QUERYWISE_TEST_FILE, QUERYWISE_CD_FILE\n        metric = 'PFound'\n    else:\n        train, test, cd = TRAIN_FILE, TEST_FILE, CD_FILE\n    train_pool = Pool(train, column_description=cd)\n    test_pool = Pool(test, column_description=cd)\n    model = CatBoost(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_verbose_int",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_verbose_int(verbose, task_type):\n    expected_line_count = {5: 3, False: 0, True: 10}\n    expected_cv_line_count = {5: 24, False: 15, True: 45}\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    tmpfile = 'test_data_dumps'\n    with open(tmpfile, 'w') as cout:\n        cv(\n            pool,\n            {\"iterations\": 10, \"learning_rate\": 0.03, \"loss_function\": \"Logloss\", \"task_type\": task_type},\n            verbose=verbose,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_set",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_set(task_type):\n    dataset = [(1, 2, 3, 4), (2, 2, 3, 4), (3, 2, 3, 4), (4, 2, 3, 4)]\n    labels = [1, 2, 3, 4]\n    train_pool = Pool(dataset, labels, cat_features=[0, 3, 2])\n    model = CatBoost({'learning_rate': 1, 'loss_function': 'RMSE', 'iterations': 2, 'task_type': task_type, 'devices': '0'})\n    eval_dataset = [(5, 6, 6, 6), (6, 6, 6, 6)]\n    eval_labels = [5, 6]\n    eval_pool = (eval_dataset, eval_labels)\n    model.fit(train_pool, eval_set=eval_pool)\n    eval_pools = [eval_pool]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_object_importances",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_object_importances(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoost({'loss_function': 'RMSE', 'iterations': 10, 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool)\n    indices, scores = model.get_object_importance(pool, train_pool, top_size=10)\n    oimp_path = test_output_path(OIMP_PATH)\n    np.savetxt(oimp_path, scores)\n    return local_canonical_file(oimp_path)\ndef test_positive_object_importance_per_object():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_positive_object_importance_per_object",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_positive_object_importance_per_object():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoost({'loss_function': 'RMSE', 'iterations': 10})\n    model.fit(train_pool)\n    indices, scores = model.get_object_importance(pool, train_pool, type='PerObject', importance_values_sign='Positive')\ndef test_shap(task_type):\n    train_pool = Pool([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 5, 8], cat_features=[])\n    test_pool = Pool([[0, 0], [0, 1], [1, 0], [1, 1]])\n    model = CatBoostRegressor(iterations=1, max_ctr_complexity=1, depth=2, task_type=task_type, devices='0')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap(task_type):\n    train_pool = Pool([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 5, 8], cat_features=[])\n    test_pool = Pool([[0, 0], [0, 1], [1, 0], [1, 1]])\n    model = CatBoostRegressor(iterations=1, max_ctr_complexity=1, depth=2, task_type=task_type, devices='0')\n    model.fit(train_pool)\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=test_pool)\n    dataset = [(0.5, 1.2), (1.6, 0.5), (1.8, 1.0), (0.4, 0.6), (0.3, 1.6), (1.5, 0.2)]\n    labels = [1.1, 1.85, 2.3, 0.7, 1.1, 1.6]\n    train_pool = Pool(dataset, labels, cat_features=[])\n    model = CatBoost({'iterations': 10, 'max_ctr_complexity': 1, 'task_type': task_type, 'devices': '0'})",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_complex_ctr",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_complex_ctr(task_type, calc_shap_mode):\n    pool = Pool([[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 2]], [0, 0, 5, 8], cat_features=[0, 1, 2])\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = train(pool, {'random_seed': 12302113, 'iterations': 100, 'task_type': task_type, 'devices': '0'})\n    shap_values = model.get_feature_importance(type=EFstrType.ShapValues, data=pool, reference_data=reference_data)\n    predictions = model.predict(pool)\n    assert (len(predictions) == len(shap_values))\n    for pred_idx in range(len(predictions)):\n        assert (abs(sum(shap_values[pred_idx]) - predictions[pred_idx]) < 1e-9)\n    fimp_txt_path = test_output_path(FIMP_TXT_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_feature_importance(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, max_ctr_complexity=1, task_type=task_type, devices='0')\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapInteractionValues, data=pool)), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_shap_interaction_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiClass', random_strength=0, bootstrap_type='No', has_time=True)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_feature_importance_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_feature_importance_multiclass(task_type):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    model = CatBoostClassifier(iterations=5, learning_rate=0.03, task_type=task_type, devices='0', loss_function='MultiClass', random_strength=0, bootstrap_type='No', has_time=True)\n    model.fit(pool)\n    fimp_npy_path = test_output_path(FIMP_NPY_PATH)\n    np.save(fimp_npy_path, np.around(np.array(model.get_feature_importance(type=EFstrType.ShapInteractionValues, data=pool)), 9))\n    return local_canonical_file(fimp_npy_path)\ndef test_shap_interaction_feature_on_symmetric(task_type):\n    pool = Pool(SMALL_CATEGORIAL_FILE, column_description=SMALL_CATEGORIAL_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 2, 'task_type': task_type, 'devices': '0', 'one_hot_max_size': 4})",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_feature_on_symmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_feature_on_symmetric(task_type):\n    pool = Pool(SMALL_CATEGORIAL_FILE, column_description=SMALL_CATEGORIAL_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 2, 'task_type': task_type, 'devices': '0', 'one_hot_max_size': 4})\n    model.fit(pool)\n    shap_interaction_values = model.get_feature_importance(\n        type=EFstrType.ShapInteractionValues,\n        data=pool,\n        thread_count=8\n    )\n    doc_count = pool.num_row()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_feature_importance_asymmetric_and_symmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_feature_importance_asymmetric_and_symmetric(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=5,\n        learning_rate=0.03,\n        max_ctr_complexity=1,\n        task_type=task_type,\n        devices='0')\n    model.fit(pool)\n    shap_interaction_symm = np.array(model.get_feature_importance(type=EFstrType.ShapInteractionValues, data=pool))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_properties_shap_interaction_values",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_properties_shap_interaction_values(task_type):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=50, loss_function='MultiClass', thread_count=8, task_type=task_type, devices='0')\n    classifier.fit(pool)\n    shap_values = classifier.get_feature_importance(\n        type=EFstrType.ShapValues,\n        data=pool,\n        thread_count=8\n    )\n    shap_interaction_values = classifier.get_feature_importance(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_value_between_pair",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_value_between_pair():\n    pool = Pool(SMALL_CATEGORIAL_FILE, column_description=SMALL_CATEGORIAL_CD_FILE)\n    model = CatBoost(params={'loss_function': 'RMSE', 'iterations': 2, 'devices': '0', 'one_hot_max_size': 4})\n    model.fit(pool)\n    shap_interaction_values = model.get_feature_importance(\n        type=EFstrType.ShapInteractionValues,\n        data=pool,\n        thread_count=8\n    )\n    features_count = pool.num_col()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_interaction_value_between_pair_multi",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_interaction_value_between_pair_multi():\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=10, loss_function='MultiClass', thread_count=8, devices='0')\n    classifier.fit(pool)\n    shap_interaction_values = classifier.get_feature_importance(\n        type=EFstrType.ShapInteractionValues,\n        data=pool,\n        thread_count=8\n    )\n    features_count = pool.num_col()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "random_xy",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def random_xy(num_rows, num_cols_x, seed=20181219, prng=None):\n    if prng is None:\n        prng = np.random.RandomState(seed=20181219)\n    x = prng.randint(100, 104, size=(num_rows, num_cols_x))  # three cat values\n    y = _generate_nontrivial_binary_target(num_rows, prng=prng)\n    return x, y\ndef save_and_give_path(y, x, filename):\n    file = test_output_path(filename)\n    np.savetxt(file, np.hstack((np.transpose([y]), x)), delimiter='\\t', fmt='%i')\n    return file",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "save_and_give_path",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def save_and_give_path(y, x, filename):\n    file = test_output_path(filename)\n    np.savetxt(file, np.hstack((np.transpose([y]), x)), delimiter='\\t', fmt='%i')\n    return file\ndef test_multiple_eval_sets_no_empty():\n    cat_features = [0, 3, 2]\n    cd_file = test_output_path('cd.txt')\n    with open(cd_file, 'wt') as cd:\n        cd.write('0\\tTarget\\n')\n        for feature_no in sorted(cat_features):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets_no_empty",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiple_eval_sets_no_empty():\n    cat_features = [0, 3, 2]\n    cd_file = test_output_path('cd.txt')\n    with open(cd_file, 'wt') as cd:\n        cd.write('0\\tTarget\\n')\n        for feature_no in sorted(cat_features):\n            cd.write('{}\\tCateg\\n'.format(1 + feature_no))\n    prng = np.random.RandomState(seed=20181219)\n    x, y = random_xy(6, 4, prng=prng)\n    train_pool = Pool(x, y, cat_features=cat_features)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiple_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiple_eval_sets():\n    # Know the seed to report it if assertion below fails\n    seed = 20181219\n    prng = np.random.RandomState(seed=seed)\n    def model_fit_with(train_set, test_sets, cd_file):\n        model = CatBoost({'use_best_model': False, 'loss_function': 'RMSE', 'iterations': 12})\n        model.fit(train_set, eval_set=list(reversed(test_sets)), column_description=cd_file)\n        return model\n    num_features = 11\n    cat_features = list(range(num_features))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_get_metadata_notrain",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_get_metadata_notrain():\n    model = CatBoost()\n    with pytest.raises(CatBoostError):\n        model.get_metadata()[1] = '1'\n        pytest.fail('Only string keys should be allowed')\n    with pytest.raises(CatBoostError):\n        model.get_metadata()['1'] = 1\n        pytest.fail('Only string values should be allowed')\n    model.get_metadata()['1'] = '1'\n    assert model.get_metadata().get('1', 'EMPTY') == '1'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_metadata",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_metadata():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=2,\n        learning_rate=0.03,\n        loss_function='Logloss',\n        metadata={\"type\": \"AAA\", \"postprocess\": \"BBB\"}\n    )\n    model.fit(train_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_util_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_util_eval_metric(metric):\n    metric_results = eval_metric([1, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0.88, 0.22, 1.0, 0.6, 0.12, 0.1, 0.0, 0.5, 0.95, 0.8], metric)\n    preds_path = test_output_path(PREDS_PATH)\n    np.savetxt(preds_path, np.array(metric_results))\n    return local_canonical_file(preds_path)\n@pytest.mark.parametrize('metric', ['MultiClass', 'AUC', 'AUC:type=OneVsAll', 'AUC:misclass_cost_matrix=0/1/0.33/0/0/0.239/-1/1.2/0', 'PRAUC', 'PRAUC:type=OneVsAll'])\ndef test_util_eval_metric_multiclass(metric):\n    metric_results = eval_metric([1, 0, 2], [[0.88, 0.22, 0.3], [0.21, 0.45, 0.1], [0.12, 0.32, 0.9]], metric)\n    preds_path = test_output_path(PREDS_PATH)\n    np.savetxt(preds_path, np.array(metric_results))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_util_eval_metric_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_util_eval_metric_multiclass(metric):\n    metric_results = eval_metric([1, 0, 2], [[0.88, 0.22, 0.3], [0.21, 0.45, 0.1], [0.12, 0.32, 0.9]], metric)\n    preds_path = test_output_path(PREDS_PATH)\n    np.savetxt(preds_path, np.array(metric_results))\n    return local_canonical_file(preds_path)\n@pytest.mark.parametrize('metric', ['PairLogit', 'PairAccuracy'])\ndef test_util_eval_metric_pairwise(metric):\n    metric_results = eval_metric(\n        [0, 1, 2, 3, 4, 5, 6, 7],\n        [0, 0.1, 0.1, 0, -1, 0.1, 1, 2],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_util_eval_metric_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_util_eval_metric_pairwise(metric):\n    metric_results = eval_metric(\n        [0, 1, 2, 3, 4, 5, 6, 7],\n        [0, 0.1, 0.1, 0, -1, 0.1, 1, 2],\n        metric,\n        group_id=[1, 1, 1, 1, 1, 1, 1, 1],\n        pairs=[[0, 1], [1, 4], [7, 6], [7, 4], [1, 6], [2, 3], [3, 6], [5, 4]]\n    )\n    preds_path = test_output_path(PREDS_PATH)\n    np.savetxt(preds_path, np.array(metric_results))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_util_eval_metric_subgroups",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_util_eval_metric_subgroups(metric):\n    metric_results = eval_metric(\n        [-1, 0, 0, 0.5, 0.2, 0.1, -2.39, 1.9],\n        [0, 1, 0, -1, 0.7, 0, -2, 2],\n        metric,\n        group_id=[1, 1, 1, 1, 1, 2, 2, 2],\n        subgroup_id=['r', 'r', 'g', 'b', 'g', 'r', 'r', 'g']\n    )\n    preds_path = test_output_path(PREDS_PATH)\n    np.savetxt(preds_path, np.array(metric_results))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_util_eval_metric_groupwise_metric_without_group_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_util_eval_metric_groupwise_metric_without_group_data():\n    with pytest.raises(CatBoostError):\n        eval_metric(\n            [-1, 0, 0, 0.5, 0.2, 0.1, -2.39, 1.9],\n            [0, 1, 0, -1, 0.7, 0, -2, 2],\n            'NDCG'\n        )\ndef test_option_used_ram_limit():\n    for limit in [1000, 1234.56, 0, 0.0, 0.5,\n                  '100', '34.56', '0', '0.0', '0.5',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_option_used_ram_limit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_option_used_ram_limit():\n    for limit in [1000, 1234.56, 0, 0.0, 0.5,\n                  '100', '34.56', '0', '0.0', '0.5',\n                  '1.2mB', '1000b', '', None, 'none', 'inf']:\n        CatBoost({'used_ram_limit': limit}).fit([[0, 1], [2, 3]], [0, 1])\n    for limit in [-1000, 'any', '-0.5', 'nolimit', 'oo']:\n        with pytest.raises(Exception):\n            CatBoost({'used_ram_limit': limit, 'iterations': 1}).fit([[0, 1], [2, 3]], [0, 1])\ndef get_values_that_json_dumps_breaks_on():\n    name_dtype = {name: value for name, value in np.__dict__.items() if (",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_values_that_json_dumps_breaks_on",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_values_that_json_dumps_breaks_on():\n    name_dtype = {name: value for name, value in np.__dict__.items() if (\n        isinstance(value, type) and\n        re.match('(int|uint|float|bool).*', name)\n    )}\n    name_value = {}\n    for name, dtype in name_dtype.items():\n        try:\n            value = dtype(1)\n            if str(value).startswith('<'):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_serialization_of_numpy_objects_internal",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_serialization_of_numpy_objects_internal():\n    from catboost._catboost import _PreprocessParams\n    _PreprocessParams(get_values_that_json_dumps_breaks_on())\ndef test_serialization_of_numpy_objects_save_model():\n    prng = np.random.RandomState(seed=20181219)\n    train_pool = Pool(*random_xy(10, 5, prng=prng))\n    model = CatBoostClassifier(\n        iterations=np.int64(2),\n        random_seed=np.int32(0),\n        loss_function='Logloss'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_serialization_of_numpy_objects_save_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_serialization_of_numpy_objects_save_model():\n    prng = np.random.RandomState(seed=20181219)\n    train_pool = Pool(*random_xy(10, 5, prng=prng))\n    model = CatBoostClassifier(\n        iterations=np.int64(2),\n        random_seed=np.int32(0),\n        loss_function='Logloss'\n    )\n    model.fit(train_pool)\n    output_model_path = test_output_path(OUTPUT_MODEL_PATH)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_serialization_of_numpy_objects_execution_case",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_serialization_of_numpy_objects_execution_case():\n    from catboost.eval.execution_case import ExecutionCase\n    ExecutionCase(get_values_that_json_dumps_breaks_on())\ndef test_metric_period_redefinition(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    tmpfile1 = test_output_path('tmpfile1')\n    tmpfile2 = test_output_path('tmpfile2')\n    model = CatBoost(dict(iterations=10, metric_period=3, task_type=task_type, devices='0'))\n    with open(tmpfile1, 'w') as cout:\n        model.fit(pool, log_cout=cout)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_metric_period_redefinition",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_metric_period_redefinition(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    tmpfile1 = test_output_path('tmpfile1')\n    tmpfile2 = test_output_path('tmpfile2')\n    model = CatBoost(dict(iterations=10, metric_period=3, task_type=task_type, devices='0'))\n    with open(tmpfile1, 'w') as cout:\n        model.fit(pool, log_cout=cout)\n    with open(tmpfile2, 'w') as cout:\n        model.fit(pool, metric_period=2, log_cout=cout)\n    assert (_count_lines(tmpfile1) == 5)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_verbose_redefinition",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_verbose_redefinition(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    tmpfile1 = test_output_path('tmpfile1')\n    tmpfile2 = test_output_path('tmpfile2')\n    model = CatBoost(dict(iterations=10, verbose=False, task_type=task_type, devices='0'))\n    with open(tmpfile1, 'w') as cout:\n        model.fit(pool, log_cout=cout)\n    with open(tmpfile2, 'w') as cout:\n        model.fit(pool, verbose=True, log_cout=cout)\n    assert (_count_lines(tmpfile1) == 0)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_silent",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_silent():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    tmpfile1 = test_output_path('tmpfile1')\n    tmpfile2 = test_output_path('tmpfile2')\n    tmpfile3 = test_output_path('tmpfile3')\n    tmpfile4 = test_output_path('tmpfile4')\n    tmpfile5 = test_output_path('tmpfile5')\n    with open(tmpfile1, 'w') as cout:\n        model = CatBoost(dict(iterations=10, silent=True))\n        model.fit(pool, log_cout=cout)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_set_params_with_synonyms",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_set_params_with_synonyms(task_type):\n    params = {'num_trees': 20,\n              'max_depth': 5,\n              'learning_rate': 0.001,\n              'logging_level': 'Silent',\n              'loss_function': 'RMSE',\n              'eval_metric': 'RMSE',\n              'od_wait': 150,\n              'random_seed': 8888,\n              'task_type': task_type,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_names_from_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_names_from_model():\n    input_file = test_output_path('pool')\n    with open(input_file, 'w') as inp:\n        inp.write('0\\t1\\t2\\t0\\n1\\t2\\t3\\t1\\n')\n    column_description1 = test_output_path('description1.cd')\n    create_cd(\n        label=3,\n        cat_features=[0, 1],\n        feature_names={0: 'a', 1: 'b', 2: 'ab'},\n        output_path=column_description1",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_names_from_loaded_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_names_from_loaded_model(format):\n    df = DataFrame({\n        'a': np.random.choice(['X', 'Y', 'Z'], 100),\n        'b': np.random.randint(0, 10, 100),\n        'c': np.random.randint(0, 10, 100),\n        'target': np.random.randint(0, 10, 100),\n    })\n    feature_names = ['a', 'b', 'c']\n    cat_features = ['a']\n    pool = Pool(data=df[feature_names], label=df['target'], cat_features=cat_features, feature_names=feature_names)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_and_pool_compatibility",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_and_pool_compatibility():\n    features = [\n        [0, 0, 0],\n        [0, 0, 1],\n        [0, 1, 0],\n        [0, 1, 1],\n        [1, 0, 0],\n        [1, 0, 1],\n        [1, 1, 0],\n        [1, 1, 1]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_verbose",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_verbose(calc_shap_mode):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    reference_data = make_reference_data(pool, calc_shap_mode)\n    model = CatBoost(dict(iterations=250))\n    model.fit(pool)\n    tmpfile = test_output_path('test_data_dumps')\n    with open(tmpfile, 'w') as cout:\n        model.get_feature_importance(type=EFstrType.ShapValues, data=pool, verbose=12, reference_data=reference_data, log_cout=cout)\n    if calc_shap_mode == \"TreeSHAP\":\n        assert (_count_lines(tmpfile) == 5)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_set_with_nans",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_set_with_nans(task_type):\n    prng = np.random.RandomState(seed=20181219)\n    features = prng.random_sample((10, 200))\n    labels = prng.random_sample((10,))\n    features_with_nans = features.copy()\n    np.putmask(features_with_nans, features_with_nans < 0.5, np.nan)\n    model = CatBoost({'iterations': 2, 'loss_function': 'RMSE', 'task_type': task_type, 'devices': '0'})\n    train_pool = Pool(features, label=labels)\n    test_pool = Pool(features_with_nans, label=labels)\n    model.fit(train_pool, eval_set=test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_sum_and_init_with_differing_nan_processing_strategy",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_sum_and_init_with_differing_nan_processing_strategy(task_type):\n    prng = np.random.RandomState(seed=20200803)\n    features = prng.random_sample((10, 200))\n    labels = prng.random_sample((10,))\n    features_with_nans = features.copy()\n    np.putmask(features_with_nans, features_with_nans < 0.5, np.nan)\n    no_nan_pool = Pool(features, label=labels)\n    nan_pool = Pool(features_with_nans, label=labels)\n    def make_model(nan_mode=None, init_model=None):\n        model = CatBoostRegressor(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_learning_rate_auto_set",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_learning_rate_auto_set(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model1 = CatBoostClassifier(iterations=10, task_type=task_type, devices='0')\n    model1.fit(train_pool)\n    predictions1 = model1.predict_proba(test_pool)\n    model2 = CatBoostClassifier(iterations=10, learning_rate=model1.learning_rate_, task_type=task_type, devices='0')\n    model2.fit(train_pool)\n    predictions2 = model2.predict_proba(test_pool)\n    assert _check_data(predictions1, predictions2)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_learning_rate_auto_set_in_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_learning_rate_auto_set_in_cv(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results = cv(\n        pool,\n        {\"iterations\": 14, \"loss_function\": \"Logloss\", \"task_type\": task_type,\n            \"train_dir\": os.path.join(train_dir_prefix, 'catboost_info')},\n    )\n    assert \"train-Logloss-mean\" in results\n    prev_value = results[\"train-Logloss-mean\"][0]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_multiclass(task_type):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=50, loss_function='MultiClass', thread_count=8, task_type=task_type, devices='0', random_strength=0, bootstrap_type='No', has_time=True)\n    classifier.fit(pool)\n    pred = classifier.predict(pool, prediction_type='Probability')\n    shap_values = classifier.get_feature_importance(\n        type=EFstrType.ShapValues,\n        data=pool,\n        thread_count=8\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loading_pool_with_numpy_int",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loading_pool_with_numpy_int():\n    assert _check_shape(Pool(np.array([[2, 2], [1, 2]]), [1.2, 3.4], cat_features=[0]), object_count=2, features_count=2)\ndef test_loading_pool_with_numpy_str():\n    assert _check_shape(\n        Pool(\n            np.array([['abc', '2', 'the cat'], ['1', '2', 'on the road']]),\n            np.array([1, 3]),\n            cat_features=[0],\n            text_features=[2]\n        ),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loading_pool_with_numpy_str",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loading_pool_with_numpy_str():\n    assert _check_shape(\n        Pool(\n            np.array([['abc', '2', 'the cat'], ['1', '2', 'on the road']]),\n            np.array([1, 3]),\n            cat_features=[0],\n            text_features=[2]\n        ),\n        object_count=2,\n        features_count=3",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loading_pool_with_lists",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loading_pool_with_lists():\n    assert _check_shape(\n        Pool(\n            [['abc', 2, 'the cat'], ['1', 2, 'on the road']],\n            [1, 3],\n            cat_features=[0],\n            text_features=[2]\n        ),\n        object_count=2,\n        features_count=3",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_group_id_hash",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_group_id_hash():\n    def get_group_sizes(group_id):\n        assert group_id is not None and len(group_id) > 0\n        neighbors_diff = abs(np.diff(group_id))\n        group_end_ids = [-1] + list(np.where(neighbors_diff > 0)[0]) + [len(group_id) - 1]\n        return np.diff(group_end_ids)\n    np.random.seed(42)\n    num_rows = 10000\n    cnt_groups = 100\n    group_id = sorted(np.random.randint(0, cnt_groups, num_rows))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pairs_generation(task_type):\n    model = CatBoost({\"loss_function\": \"PairLogit\", \"iterations\": 2, \"task_type\": task_type})\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    model.fit(pool)\n    return local_canonical_file(remove_time_from_json(JSON_LOG_PATH))\ndef test_pairs_generation_generated(task_type):\n    model = CatBoostRanker(loss_function='PairLogit', iterations=10, thread_count=8, task_type=task_type, devices='0')\n    df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    df = df.loc[:10, :]\n    train_target = df.loc[:, 2]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation_generated",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pairs_generation_generated(task_type):\n    model = CatBoostRanker(loss_function='PairLogit', iterations=10, thread_count=8, task_type=task_type, devices='0')\n    df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    df = df.loc[:10, :]\n    train_target = df.loc[:, 2]\n    train_data = df.drop([0, 1, 2, 3, 4], axis=1).astype(np.float32)\n    df = read_csv(QUERYWISE_TEST_FILE, delimiter='\\t', header=None)\n    test_data = df.drop([0, 1, 2, 3, 4], axis=1).astype(np.float32)\n    prng = np.random.RandomState(seed=20181219)\n    train_group_id = np.sort(prng.randint(len(train_target) // 3, size=len(train_target)) + 1)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_generation_with_max_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pairs_generation_with_max_pairs(task_type):\n    model = CatBoost({\"loss_function\": \"PairLogit:max_pairs=30\", \"iterations\": 2, \"task_type\": task_type})\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    model.fit(pool)\n    return local_canonical_file(remove_time_from_json(JSON_LOG_PATH))\ndef test_early_stopping_rounds(task_type):\n    train_pool = Pool([[0], [1]], [0, 1])\n    test_pool = Pool([[0], [1]], [1, 0])\n    model = CatBoostRegressor(od_type='Iter', od_pval=2)\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_early_stopping_rounds",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_early_stopping_rounds(task_type):\n    train_pool = Pool([[0], [1]], [0, 1])\n    test_pool = Pool([[0], [1]], [1, 0])\n    model = CatBoostRegressor(od_type='Iter', od_pval=2)\n    with pytest.raises(CatBoostError):\n        model.fit(train_pool, eval_set=test_pool)\n    model = CatBoost(params={'od_pval': 0.001, 'early_stopping_rounds': 2})\n    model.fit(train_pool, eval_set=test_pool, early_stopping_rounds=1)\n    model = CatBoostClassifier(loss_function='Logloss:hints=skip_train~true', iterations=1000,\n                               learning_rate=0.03, od_type='Iter', od_wait=10)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_slice_pool",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_slice_pool():\n    pool = Pool(\n        [[0], [1], [2], [3], [4], [5]],\n        label=[0, 1, 2, 3, 4, 5],\n        group_id=[0, 0, 0, 1, 1, 2],\n        pairs=[(0, 1), (0, 2), (1, 2), (3, 4)])\n    for bad_indices in [[0], [2], [0, 0, 0]]:\n        with pytest.raises(CatBoostError):\n            pool.slice(bad_indices)\n    rindexes = [",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_and_predict_on_sliced_pools",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_and_predict_on_sliced_pools(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    np.random.seed(42)\n    train_subset_indices = np.random.choice(\n        train_pool.num_row(),\n        size=int(train_pool.num_row() * 0.6),\n        replace=False\n    )\n    train_subset_pool = train_pool.slice(train_subset_indices)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_str_metrics_in_eval_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_str_metrics_in_eval_metrics(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=40, task_type=task_type, devices='0')\n    model.fit(train_pool, eval_set=test_pool)\n    first_metrics = model.eval_metrics(data=train_pool, metrics='Logloss')\n    second_metrics = model.eval_metrics(data=train_pool, metrics=['Logloss'])\n    assert np.all(np.array(first_metrics['Logloss']) == np.array(second_metrics['Logloss']))\ndef test_str_eval_metrics_in_eval_features():\n    learn_params = {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_str_eval_metrics_in_eval_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_str_eval_metrics_in_eval_features():\n    learn_params = {\n        'iterations': 20, 'learning_rate': 0.5, 'logging_level': 'Silent', 'loss_function': 'RMSE',\n        'boosting_type': 'Plain', 'allow_const_label': True, 'bootstrap_type': 'No',\n    }\n    evaluator = CatboostEvaluation(\n        TRAIN_FILE, fold_size=2, fold_count=2,\n        column_description=CD_FILE, partition_random_seed=0)\n    first_result = evaluator.eval_features(learn_config=learn_params, eval_metrics='MAE', features_to_eval=[6, 7, 8])\n    second_result = evaluator.eval_features(learn_config=learn_params, eval_metrics=['MAE'], features_to_eval=[6, 7, 8])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_compare",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_compare():\n    dataset = np.array([[1, 4, 5, 6], [4, 5, 6, 7], [30, 40, 50, 60], [20, 15, 85, 60]])\n    train_labels = [1.2, 3.4, 9.5, 24.5]\n    model = CatBoostRegressor(learning_rate=1, depth=6, loss_function='RMSE', bootstrap_type='No')\n    model.fit(dataset, train_labels)\n    model2 = CatBoostRegressor(learning_rate=0.1, depth=1, loss_function='MAE', bootstrap_type='No')\n    model2.fit(dataset, train_labels)\n    try:\n        model.compare(model2, Pool(dataset, label=train_labels), [\"RMSE\"])\n    except ImportError as ie:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_fold_count_alias",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_fold_count_alias(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_dir_prefix = test_output_path('')\n    results_fold_count = cv(pool=pool, params={\n        \"iterations\": 5,\n        \"learning_rate\": 0.03,\n        \"loss_function\": \"Logloss\",\n        \"eval_metric\": \"AUC\",\n        \"task_type\": task_type,\n        \"train_dir\": os.path.join(train_dir_prefix, 'catboost_info'),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_predict_loss_function_alias",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_predict_loss_function_alias(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test = Pool(TEST_FILE, column_description=CD_FILE)\n    booster = train(params={'loss_function': 'MultiClassOneVsAll', 'num_trees': 5}, pool=pool)\n    shape_if_loss_function = booster.predict(test).shape\n    booster = train(params={'objective': 'MultiClassOneVsAll', 'num_trees': 5}, pool=pool)\n    shape_if_objective = booster.predict(test).shape\n    assert shape_if_loss_function == shape_if_objective\n# check different sizes as well as passing as int as well as str\n@pytest.mark.parametrize('used_ram_limit', ['1024', '2Gb'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_allow_writing_files_and_used_ram_limit",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_allow_writing_files_and_used_ram_limit(used_ram_limit, task_type):\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    model = CatBoostClassifier(\n        use_best_model=False,\n        allow_writing_files=False,\n        used_ram_limit=int(used_ram_limit) if used_ram_limit.isdigit() else used_ram_limit,\n        max_ctr_complexity=8,\n        depth=10,\n        boosting_type='Plain',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_permuted_columns_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_permuted_columns_dataset():\n    permuted_test, permuted_cd = permute_dataset_columns(AIRLINES_5K_TEST_FILE, AIRLINES_5K_CD_FILE)\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    permuted_test_pool = Pool(permuted_test, column_description=permuted_cd, has_header=True)\n    model = CatBoostClassifier(\n        use_best_model=False,\n        max_ctr_complexity=8,\n        depth=10,\n        boosting_type='Plain',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "non_decreasing",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def non_decreasing(sequence):\n    for i in range(1, len(sequence)):\n        if sequence[i] < sequence[i - 1]:\n            return False\n    return True\n@pytest.mark.parametrize('iterations', [5, 20, 110], ids=['iterations=5', 'iterations=20', 'iterations=110'])\ndef do_test_roc(task_type, pool, iterations, additional_train_params={}):\n    train_pool = Pool(data_file(pool, 'train_small'), column_description=data_file(pool, 'train.cd'))\n    test_pool = Pool(data_file(pool, 'test_small'), column_description=data_file(pool, 'train.cd'))\n    model = CatBoostClassifier(loss_function='Logloss', iterations=iterations, **additional_train_params)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "do_test_roc",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def do_test_roc(task_type, pool, iterations, additional_train_params={}):\n    train_pool = Pool(data_file(pool, 'train_small'), column_description=data_file(pool, 'train.cd'))\n    test_pool = Pool(data_file(pool, 'test_small'), column_description=data_file(pool, 'train.cd'))\n    model = CatBoostClassifier(loss_function='Logloss', iterations=iterations, **additional_train_params)\n    model.fit(train_pool)\n    curve = get_roc_curve(model, test_pool, thread_count=4)\n    (fpr, tpr, thresholds) = curve\n    assert non_decreasing(fpr)\n    assert non_decreasing(tpr)\n    table = np.array(list(zip(curve[2], [1 - x for x in curve[1]], curve[0])))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_roc",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_roc(task_type, iterations):\n    return do_test_roc(task_type, pool='adult', iterations=iterations)\ndef test_roc_with_target_border():\n    return do_test_roc(\n        task_type='CPU',\n        pool='adult_not_binarized',\n        iterations=20,\n        additional_train_params={'target_border': 0.4}\n    )\ndef test_roc_cv(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_roc_with_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_roc_with_target_border():\n    return do_test_roc(\n        task_type='CPU',\n        pool='adult_not_binarized',\n        iterations=20,\n        additional_train_params={'target_border': 0.4}\n    )\ndef test_roc_cv(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    cv(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_roc_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_roc_cv(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    cv(\n        train_pool,\n        params={\n            'loss_function': 'Logloss',\n            'iterations': 10,\n            'roc_file': 'out_roc',\n            'thread_count': 4,\n            'task_type': task_type",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_overfit_detector_with_resume_from_snapshot_and_metric_period",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_overfit_detector_with_resume_from_snapshot_and_metric_period(boosting_type, overfitting_detector_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    FIRST_ITERATIONS = 8\n    FINAL_ITERATIONS = 100\n    OD_WAIT = 10\n    # Overfitting must occur between the FIRST_ITERATIONS and FINAL_ITERATIONS.\n    models = []\n    for metric_period in [1, 5]:\n        final_training_stdout_len_wo_snapshot = None",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_use_loss_if_no_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_use_loss_if_no_eval_metric():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 100,\n        'loss_function': 'Logloss',\n        'use_best_model': True,\n    }\n    model_1 = CatBoostClassifier(**args)\n    model_1.fit(train_pool, eval_set=test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_use_loss_if_no_eval_metric_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_use_loss_if_no_eval_metric_cv(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 50,\n        'loss_function': 'Logloss',\n        'logging_level': 'Silent',\n        'task_type': task_type,\n        'metric_period': (5 if task_type == 'GPU' else 1)\n    }\n    cv_params = {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_target_with_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_target_with_file():\n    with pytest.raises(CatBoostError):\n        Pool(TRAIN_FILE, label=[1, 2, 3, 4, 5], column_description=CD_FILE)\n@pytest.mark.parametrize('metrics', [\n    {'custom_metric': ['Accuracy', 'Logloss'], 'eval_metric': None},\n    {'custom_metric': ['Accuracy', 'Accuracy'], 'eval_metric': None},\n    {'custom_metric': ['Accuracy'], 'eval_metric': 'Logloss'},\n    {'custom_metric': ['Accuracy'], 'eval_metric': 'Accuracy'},\n    {'custom_metric': ['Accuracy', 'Logloss'], 'eval_metric': 'Logloss'}])\ndef test_no_fail_if_metric_is_repeated_cv(task_type, metrics):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_no_fail_if_metric_is_repeated_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_no_fail_if_metric_is_repeated_cv(task_type, metrics):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 10,\n        'loss_function': 'Logloss',\n        'custom_metric': metrics['custom_metric'],\n        'logging_level': 'Silent',\n        'task_type': task_type\n    }\n    if metrics['eval_metric'] is not None:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_cv_with_ignored_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_cv_with_ignored_features(task_type, data_type, has_missing):\n    pool = Pool(TRAIN_FILE, column_description=data_file('adult', 'train_with_id.cd'))\n    if (data_type, has_missing) == ('integer', False):\n        ignored_features = [0, 2, 5]\n    elif (data_type, has_missing) == ('integer', True):\n        ignored_features = [0, 2, 5, 23, 100]\n    elif (data_type, has_missing) == ('string', False):\n        ignored_features = ['C6', 'C9', 'F4', 'F5']\n    elif (data_type, has_missing) == ('string', True):\n        return pytest.xfail(reason=\"Not working at the moment. TODO(akhropov): MLTOOLS-4783\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_use_last_testset_for_best_iteration",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_use_last_testset_for_best_iteration():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    test_size = test_pool.num_row()\n    half_size = test_size // 2\n    test_pool_1 = test_pool.slice(list(range(half_size)))\n    test_pool_2 = test_pool.slice(list(range(half_size, test_size)))\n    metric = 'Logloss'\n    args = {\n        'iterations': 100,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_best_model_min_trees",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_best_model_min_trees(task_type):\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    learn_params = {\n        'iterations': 200,\n        'use_best_model': True,\n        'task_type': task_type,\n        'learning_rate': 0.3\n    }\n    model_1 = CatBoostClassifier(**learn_params)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_lambda_mart",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_lambda_mart():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    cb = CatBoostRanker(loss_function='LambdaMart', iterations=3, devices='0')\n    cb.fit(pool)\n@pytest.mark.parametrize('param_type', ['indices', 'strings'])\ndef test_set_cat_features_in_init(param_type):\n    if param_type == 'indices':\n        cat_features_param = [1, 2]\n        feature_names_param = None\n    else:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_set_cat_features_in_init",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_set_cat_features_in_init(param_type):\n    if param_type == 'indices':\n        cat_features_param = [1, 2]\n        feature_names_param = None\n    else:\n        cat_features_param = ['feat1', 'feat2']\n        feature_names_param = ['feat' + str(i) for i in range(20)]\n    prng = np.random.RandomState(seed=20181219)\n    data = prng.randint(10, size=(20, 20))\n    label = _generate_nontrivial_binary_target(20, prng=prng)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_no_yatest_common",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_no_yatest_common():\n    assert \"yatest\" not in globals()\ndef test_keep_metric_params_precision():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=10)\n    model.fit(train_pool)\n    metrics = ['Quantile:alpha=0.6']\n    metrics_evals = model.eval_metrics(test_pool, metrics)\n    for metric in metrics:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_keep_metric_params_precision",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_keep_metric_params_precision():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=10)\n    model.fit(train_pool)\n    metrics = ['Quantile:alpha=0.6']\n    metrics_evals = model.eval_metrics(test_pool, metrics)\n    for metric in metrics:\n        assert metric in metrics_evals\ndef test_shrink():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shrink",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shrink():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'Logloss',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }\n    model = CatBoostClassifier(**args)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shrink_with_bias",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shrink_with_bias():\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE_WITH_GROUP_ID)\n    args = {\n        'iterations': 30,\n        'loss_function': 'RMSE',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }\n    model = CatBoostRegressor(**args)\n    model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_set_scale_and_bias",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_set_scale_and_bias():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'Logloss',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }\n    model = CatBoostClassifier(**args)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_get_metric_evals",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_get_metric_evals(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10, eval_metric='Accuracy', task_type=task_type)\n    model.fit(train_pool, eval_set=test_pool)\n    evals_path = test_output_path('evals.txt')\n    with open(evals_path, 'w') as f:\n        pprint.PrettyPrinter(stream=f).pprint(model.evals_result_)\n    return local_canonical_file(evals_path)\ndef test_get_evals_result_without_eval_set():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_get_evals_result_without_eval_set",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_get_evals_result_without_eval_set():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10, custom_metric=['AUC', 'Accuracy'], random_state=0)\n    model.fit(train_pool)\n    evals_path = test_output_path('evals.txt')\n    with open(evals_path, 'w') as f:\n        pprint.PrettyPrinter(stream=f).pprint(model.get_evals_result())\n    return local_canonical_file(evals_path)\ndef test_best_score(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_best_score",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_best_score(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 100,\n        'learning_rate': 0.1,\n        'eval_metric': 'ZeroOneLoss',\n        'custom_metric': ['Precision', 'CtrFactor'],\n        'task_type': task_type,\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_best_iteration",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_best_iteration(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 100,\n        'learning_rate': 0.1,\n        'eval_metric': 'ZeroOneLoss',\n        'custom_metric': ['Precision', 'Recall'],\n        'task_type': task_type,\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "assert_sum_models_equal_sliced_copies",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def assert_sum_models_equal_sliced_copies(train, test, cd):\n    train_pool = Pool(train, column_description=cd)\n    test_pool = Pool(test, column_description=cd)\n    iter_step = 10\n    model_count = 2\n    model = CatBoostClassifier(iterations=iter_step * model_count)\n    model.fit(train_pool)\n    truncated_copies = [model.copy() for _ in range(model_count)]\n    for i, truncated_model in enumerate(truncated_copies):\n        truncated_model.shrink(ntree_start=i * iter_step, ntree_end=(i + 1) * iter_step)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_merging",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_merging():\n    assert_sum_models_equal_sliced_copies(TRAIN_FILE, TEST_FILE, CD_FILE)\n    # multiclass\n    assert_sum_models_equal_sliced_copies(CLOUDNESS_TRAIN_FILE, CLOUDNESS_TEST_FILE, CLOUDNESS_ONLY_NUM_CD_FILE)\ndef test_model_sum_labels():\n    n_samples = 100\n    n_features = 10\n    \"\"\"\n        list of (expected_sum_classes, lists of (loss_function, class_names, label_set))\n        if expected_sum_classes is False it means sum should fail",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_sum_labels",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_sum_labels():\n    n_samples = 100\n    n_features = 10\n    \"\"\"\n        list of (expected_sum_classes, lists of (loss_function, class_names, label_set))\n        if expected_sum_classes is False it means sum should fail\n    \"\"\"\n    params_list = [\n        (\n            False,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_tree_depth_pairwise",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_tree_depth_pairwise(task_type):\n    if task_type == 'GPU':\n        with pytest.raises(CatBoostError):\n            CatBoost({'iterations': 2, 'loss_function': 'PairLogitPairwise', 'task_type': task_type, 'devices': '0', 'depth': 9})\n        CatBoost({'iterations': 2, 'loss_function': 'PairLogitPairwise', 'task_type': task_type, 'devices': '0', 'depth': 8})\ndef test_eval_set_with_no_target(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    eval_set_pool = Pool(TEST_FILE, column_description=data_file('train_notarget.cd'))\n    model = CatBoost({'iterations': 2, 'loss_function': 'Logloss', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool, eval_set=eval_set_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_set_with_no_target",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_set_with_no_target(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    eval_set_pool = Pool(TEST_FILE, column_description=data_file('train_notarget.cd'))\n    model = CatBoost({'iterations': 2, 'loss_function': 'Logloss', 'task_type': task_type, 'devices': '0'})\n    model.fit(train_pool, eval_set=eval_set_pool)\n    evals_path = test_output_path('evals.txt')\n    with open(evals_path, 'w') as f:\n        pprint.PrettyPrinter(stream=f).pprint(model.get_evals_result())\n    return local_canonical_file(evals_path)\ndef test_eval_set_with_no_target_with_eval_metric(task_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_set_with_no_target_with_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_set_with_no_target_with_eval_metric(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    eval_set_pool = Pool(TEST_FILE, column_description=data_file('train_notarget.cd'))\n    model = CatBoost(\n        {\n            'iterations': 2,\n            'loss_function': 'Logloss',\n            'eval_metric': 'AUC',\n            'task_type': task_type,\n            'devices': '0'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_period_size",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_period_size():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=10)\n    model.fit(train_pool, eval_set=test_pool)\n    eval_metrics_all_trees_path = test_output_path('eval_metrics_all_trees.txt')\n    with open(eval_metrics_all_trees_path, 'w') as f:\n        pprint.PrettyPrinter(stream=f).pprint(\n            model.eval_metrics(test_pool, ['AUC', 'Recall'], eval_period=20)\n        )",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_output_border_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_output_border_file(task_type):\n    OUTPUT_BORDERS_FILE = 'output_border_file.dat'\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'Logloss',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_output_border_file_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_output_border_file_regressor(task_type):\n    OUTPUT_BORDERS_FILE = 'output_border_file.dat'\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'RMSE',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_output_border_file_ranker",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_output_border_file_ranker(task_type):\n    OUTPUT_BORDERS_FILE = 'output_border_file.dat'\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'YetiRank',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_border_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_border_file():\n    output_borders_file = test_output_path('output_borders_file.dat')\n    save_borders_file = test_output_path('save_borders_file.dat')\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'Logloss',\n        'use_best_model': False,\n        'learning_rate': 0.3\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_set_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_set_feature_names():\n    train_pool = Pool(\n        ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,\n        column_description=ROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE\n    )\n    model = CatBoostClassifier(loss_function='Logloss', iterations=10)\n    model.fit(train_pool)\n    names = [\"feature_{}\".format(x) for x in range(train_pool.num_col())]\n    model.set_feature_names(names)\n    assert names == model.feature_names_",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_bad_set_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_bad_set_feature_names():\n    train_pool = Pool(\n        ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE,\n        column_description=ROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE\n    )\n    model = CatBoostClassifier(loss_function='Logloss', iterations=10)\n    model.fit(train_pool)\n    names = [\"feature_{}\".format(x) for x in range(3)]\n    with pytest.raises(CatBoostError):\n        model.set_feature_names(names)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_model_comparison",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_model_comparison():\n    def fit_model(iterations):\n        pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n        model = CatBoostClassifier(iterations=iterations)\n        model.fit(pool)\n        return model\n    model0 = CatBoostClassifier()\n    model1 = fit_model(42)\n    model2 = fit_model(5)\n    # Test checks that model is fitted.",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_param_synonyms",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_param_synonyms(task_type):\n    # list of  ([synonyms list], value)\n    synonym_params = [\n        (['loss_function', 'objective'], 'CrossEntropy'),\n        (['iterations', 'num_boost_round', 'n_estimators', 'num_trees'], 5),\n        (['learning_rate', 'eta'], 0.04),\n        (['random_seed', 'random_state'], 1),\n        (['l2_leaf_reg', 'reg_lambda'], 4),\n        (['depth', 'max_depth'], 7),\n        (['rsm', 'colsample_bylevel'], 0.5),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grow_policy_fails",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grow_policy_fails(task_type, grow_policy):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    args = {\n        'iterations': 30,\n        'loss_function': 'Logloss',\n        'use_best_model': False,\n        'learning_rate': 0.3,\n        'grow_policy': grow_policy,\n        'boosting_type': 'Plain',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_grow_policy",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass_grow_policy(task_type, grow_policy):\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    # MultiClass\n    classifier = CatBoostClassifier(\n        iterations=2,\n        loss_function='MultiClass',\n        thread_count=8,\n        task_type=task_type,\n        devices='0',\n        boosting_type='Plain',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_grow_policy_restriction",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_grow_policy_restriction(task_type, grow_policy):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 2,\n        'thread_count': 8,\n        'task_type': task_type,\n        'devices': '0',\n        'grow_policy': grow_policy\n    }\n    with pytest.raises(Exception):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_use_all_cpus",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_use_all_cpus(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE, thread_count=-1)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE, thread_count=-1)\n    model = CatBoostClassifier(iterations=10, task_type=task_type, thread_count=-1, devices='0')\n    model.fit(train_pool)\n    model.predict(test_pool, thread_count=-1)\n    model.predict_proba(test_pool, thread_count=-1)\n    model.staged_predict(test_pool, thread_count=-1)\n    model.staged_predict_proba(test_pool, thread_count=-1)\ndef test_baseline():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_baseline",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_baseline():\n    input_pool = Pool(np.ones((5, 4)))\n    baseline = np.array([[1, 3, 2, 1, 2]], dtype=np.float32).reshape(5, 1)\n    input_pool.set_baseline(baseline)\n    assert (input_pool.get_baseline() == baseline).all()\nEVAL_TYPES = ['All', 'SeqRem', 'SeqAdd', 'SeqAddAndAll']\nEVAL_PROBLEMS = ['binclass', 'multiclass', 'regression', 'ranking']\n@pytest.mark.parametrize('eval_type', EVAL_TYPES, ids=['eval_type=%s' % eval_type for eval_type in EVAL_TYPES])\n@pytest.mark.parametrize('problem', EVAL_PROBLEMS, ids=['problem=%s' % problem for problem in EVAL_PROBLEMS])\ndef test_eval_features(task_type, eval_type, problem):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_features(task_type, eval_type, problem):\n    if problem == 'binclass':\n        loss_function = 'Logloss'\n        eval_metrics = ['AUC']\n        train_file = TRAIN_FILE\n        cd_file = CD_FILE\n        features_to_eval = [6, 7, 8]\n        group_column = None\n    elif problem == 'multiclass':\n        loss_function = 'MultiClass'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_metric_period_with_verbose_true",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_metric_period_with_verbose_true():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(dict(iterations=16, metric_period=4))\n    tmpfile = test_output_path('tmpfile')\n    with open(tmpfile, 'w') as cout:\n        model.fit(pool, verbose=True, log_cout=cout)\n    assert (_count_lines(tmpfile) == 6)\ndef test_eval_features_with_file_header():\n    learn_params = {\n        'iterations': 20,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_features_with_file_header",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_features_with_file_header():\n    learn_params = {\n        'iterations': 20,\n        'learning_rate': 0.5,\n        'logging_level': 'Silent',\n        'loss_function': 'RMSE',\n        'boosting_type': 'Plain',\n        'allow_const_label': True\n    }\n    evaluator = CatboostEvaluation(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_compute_options",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_compute_options():\n    data_meta_info = DataMetaInfo(\n        object_count=100000,\n        feature_count=10,\n        max_cat_features_uniq_values_on_learn=0,\n        target_stats=TargetStats(min_value=0, max_value=1),\n        has_pairs=False\n    )\n    options = compute_training_options(\n        options={'thread_count': 1},",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_statistics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_statistics(combination):\n    n_features = 3\n    n_samples = 500\n    np.random.seed(42)\n    X = np.random.rand(n_samples, n_features)\n    y = np.random.rand(n_samples)\n    if combination == 'no':\n        model = CatBoostRegressor(iterations=200)\n        model.fit(X, y, silent=True)\n    elif combination == 'init_model_same_loss':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_plot",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_prediction_plot():\n    preds_path = test_output_path('predictions.json')\n    n_features = 3\n    n_samples = 500\n    np.random.seed(42)\n    X = np.random.rand(n_samples, n_features)\n    y = np.random.rand(n_samples)\n    model = CatBoostRegressor(iterations=200)\n    model.fit(X, y, silent=True)\n    res, _ = model.plot_predictions(data=X[:2, ], features_to_change=[0, 1], plot=False)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_binclass_with_nontrivial_classes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_binclass_with_nontrivial_classes():\n    catboost_training_path = test_output_path('catboost_training.json')\n    model = CatBoostClassifier(iterations=10, loss_function='Logloss')\n    model.set_params(json_log=catboost_training_path)\n    X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    y = [1, 2, 1]\n    model.fit(X, y)\n    json_log = json.load(open(remove_time_from_json(catboost_training_path)))\n    json_log['iterations'] = [\n        dict({'iteration': row['iteration'], 'learn': [np.round(row['learn'][0], decimals=4)]})",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loss_function_auto_set",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loss_function_auto_set():\n    X = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    bin_y = [1, 2, 1]\n    multi_y = [1, 2, 3]\n    def test_one_case(params, X, y, expected_loss):\n        model = CatBoostClassifier(**params).fit(X, y)\n        assert model.get_all_params()['loss_function'] == expected_loss\n        model = CatBoostClassifier(**params).fit(Pool(X, y))\n        assert model.get_all_params()['loss_function'] == expected_loss\n    test_one_case({'iterations': 10}, X, bin_y, 'Logloss')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_loss_function_auto_set_from_file",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_loss_function_auto_set_from_file(dataset_target_type):\n    dataset_path = {\n        'binarized': 'adult',\n        'not_binarized': 'adult_not_binarized',\n        'multiclass': 'cloudness_small'\n    }[dataset_target_type]\n    params = {'iterations': 3}\n    if dataset_target_type == 'not_binarized':\n        params['target_border'] = 0.5\n    model = CatBoostClassifier(**params).fit(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_params_for_problem_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_params_for_problem_type(problem_type):\n    if problem_type == 'binclass':\n        return {\n            'loss_function': 'Logloss',\n            'train_path': TRAIN_FILE,\n            'test_path': TEST_FILE,\n            'cd_path': CD_FILE,\n            'boosting_types': BOOSTING_TYPE\n        }\n    elif problem_type == 'multiclass':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_continue_learning_with_same_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_continue_learning_with_same_params(problem_type):\n    params = get_params_for_problem_type(problem_type)\n    train_pool = Pool(params['train_path'], column_description=params['cd_path'])\n    for boosting_type in params['boosting_types']:\n        train_params = {\n            'task_type': 'CPU',  # TODO(akhropov): GPU support\n            'loss_function': params['loss_function'],\n            'boosting_type': boosting_type,\n            'learning_rate': 0.3  # fixed, because automatic value depends on number of iterations\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_continue_learning_with_changing_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_continue_learning_with_changing_params(problem_type, param_set):\n    params = get_params_for_problem_type(problem_type)\n    train_pool = Pool(params['train_path'], column_description=params['cd_path'])\n    test_pool = Pool(params['test_path'], column_description=params['cd_path'])\n    if param_set == 'iterations,learning_rate':\n        updated_params_list = [\n            {'iterations': 5, 'learning_rate': 0.3},\n            {'iterations': 2, 'learning_rate': 0.1},\n            {'iterations': 3, 'learning_rate': 0.2},\n        ]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_continue_learning_with_changing_dataset",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_continue_learning_with_changing_dataset(samples, features):\n    all_df = read_csv(TRAIN_FILE, header=None, delimiter='\\t')\n    all_labels = Series(all_df.iloc[:, TARGET_IDX])\n    all_df.drop([TARGET_IDX], axis=1, inplace=True)\n    all_features_df = all_df\n    if samples == 'same':\n        features_df_1 = all_features_df.copy()\n        labels_1 = all_labels.copy()\n        features_df_2 = all_features_df\n        labels_2 = all_labels",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_equal_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_equal_feature_names():\n    train_data = [[1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1]]\n    with pytest.raises(CatBoostError):\n        Pool(train_data, feature_names=['first', 'second', 'third', 'fourth', 'second', 'sixth'])\n@pytest.mark.parametrize('feature_names', [0, 'text'])\ndef test_not_sequence_feature_names(feature_names):\n    train_data = DataFrame({'text_f': ['у попа была собака',\n                                       'он ее любил',\n                                       'she ate a piece of meat',\n                                       'he killed her...']})",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_not_sequence_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_not_sequence_feature_names(feature_names):\n    train_data = DataFrame({'text_f': ['у попа была собака',\n                                       'он ее любил',\n                                       'she ate a piece of meat',\n                                       'he killed her...']})\n    with pytest.raises(CatBoostError):\n        Pool(train_data, feature_names=feature_names)\n@pytest.mark.parametrize('variance_power', [1.001, 1.42, 1.8, 1.999])\ndef test_tweedie_loss_on_gpu(task_type, variance_power):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_tweedie_loss_on_gpu",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_tweedie_loss_on_gpu(task_type, variance_power):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            'iterations': 10,\n            'loss_function': 'Tweedie:variance_power=' + str(variance_power),\n            'task_type': task_type,\n            'devices': '0-7'\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_huber_loss_on_gpu",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_huber_loss_on_gpu(task_type, delta):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            'iterations': 10,\n            'loss_function': 'Huber:delta=' + str(delta),\n            'task_type': task_type,\n            'devices': '0-7'\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_get_all_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_get_all_params():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(dict(iterations=16, thread_count=4))\n    model.fit(pool, verbose=True)\n    options = model.get_all_params()\n    model2 = CatBoost(options)\n    model2.fit(pool, verbose=True)\n    assert all(model.predict(pool) == model2.predict(pool))\n    options_file = test_output_path('options.json')\n    with open(options_file, 'w') as f:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_weights_in_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_weights_in_eval_metric(metric):\n    predictions = [1, 1, 2, 3, 1, 4, 1, 2, 3, 4]\n    label = [1, 0, 1, 1, 0, 1, 1, 1, 0, 0]\n    weights = [1, 0.75, 2.39, 0.5, 1, 1.3, 0.7, 1, 1.1, 0.67]\n    result_with_no_weights = eval_metric(label, predictions, metric)\n    result_with_weights = eval_metric(label, predictions, metric, weights)\n    assert not np.isclose(result_with_no_weights, result_with_weights)\n@pytest.mark.parametrize('metric_name', ['Accuracy', 'Precision', 'Recall', 'F1'])\n@pytest.mark.parametrize('proba_border', [0.25, 0.55, 0.75])\ndef test_prediction_border_in_eval_metric(metric_name, proba_border):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_prediction_border_in_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_prediction_border_in_eval_metric(metric_name, proba_border):\n    metric_with_border = \"{metric_name}:proba_border={proba_border}\".format(\n        metric_name=metric_name,\n        proba_border=proba_border\n    )\n    metric_no_params = metric_name\n    prediction_probas = np.array([0.06314072, 0.77672081, 0.00885847, 0.87585758, 0.70030717,\n                                  0.42210464, 0.00698532, 0.08357631, 0.87840924, 0.71889332,\n                                  0.27881971, 0.03881581, 0.12708005, 0.04321602, 0.46778848,\n                                  0.34862325, 0.95195515, 0.08093261, 0.79914953, 0.50639467])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_dataframe_with_custom_index",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_dataframe_with_custom_index():\n    np.random.seed(0)\n    X = DataFrame(np.random.randint(0, 9, (3, 2)), index=[55, 675, 34])\n    X[0] = X[0].astype('category')\n    y = X[1]\n    model = CatBoost(dict(iterations=10))\n    model.fit(X, y, cat_features=[0])\n@pytest.mark.parametrize('features_type', [\n    'numerical_only',\n    'numerical_and_categorical',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_model_from_snapshot",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_model_from_snapshot(features_type):\n    model = CatBoost(dict(iterations=16, thread_count=4))\n    filename = test_output_path('snapshot.bak')\n    try:\n        os.remove(filename)\n    except OSError:\n        pass\n    if features_type == 'numerical_only':\n        pool = Pool(data=[[0, 1, 2, 3],\n                          [1, 2, 3, 4],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_regress_with_per_float_feature_binarization_param",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_regress_with_per_float_feature_binarization_param(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    per_float_feature_quantization_list = ['0:nan_mode=Forbidden,border_count=2,border_type=GreedyLogSum',\n                                           '1:nan_mode=Forbidden,border_count=3,border_type=GreedyLogSum',\n                                           '2:nan_mode=Forbidden,border_count=8,border_type=GreedyLogSum',\n                                           '3:nan_mode=Forbidden,border_count=14,border_type=GreedyLogSum',\n                                           '4:nan_mode=Forbidden,border_count=31,border_type=GreedyLogSum',\n                                           '5:nan_mode=Forbidden,border_count=32,border_type=GreedyLogSum']\n    model = CatBoostRegressor(iterations=2,\n                              learning_rate=0.03,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pairs_without_groupid",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pairs_without_groupid():\n    model = CatBoost(params={'loss_function': 'PairLogit', 'iterations': 10, 'thread_count': 8})\n    pairs = read_csv(QUERYWISE_TRAIN_PAIRS_FILE, delimiter='\\t', header=None)\n    df = read_csv(QUERYWISE_TRAIN_FILE, delimiter='\\t', header=None)\n    train_target = df.loc[:, 2]\n    train_data = df.drop([0, 1, 2, 3, 4], axis=1).astype(np.float32)\n    model.fit(train_data, train_target, pairs=pairs)\n    return local_canonical_file(remove_time_from_json(JSON_LOG_PATH))\ndef test_groupwise_sampling_without_groups(task_type):\n    params = {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_groupwise_sampling_without_groups",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_groupwise_sampling_without_groups(task_type):\n    params = {\n        'task_type': task_type,\n        'iterations': 10,\n        'thread_count': 4,\n        'bootstrap_type': 'Bernoulli',\n        'sampling_unit': 'Group',\n        'subsample': 0.5\n    }\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_convert_to_asymmetric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_convert_to_asymmetric(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    train_params = {\n        'iterations': 10,\n        'learning_rate': 0.03,\n        'task_type': task_type\n    }\n    model = CatBoost(train_params)\n    model.fit(train_pool)\n    model._convert_to_asymmetric_representation()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_quantized_path",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_quantized_path(fname):\n    return 'quantized://' + fname\ndef test_pool_is_quantized():\n    quantized_pool = Pool(data=get_quantized_path(QUANTIZED_TRAIN_FILE), column_description=QUANTIZED_CD_FILE)\n    assert quantized_pool.is_quantized()\n    raw_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    assert not raw_pool.is_quantized()\ndef test_quantized_pool_with_all_features_ignored():\n    quantized_pool = Pool(data=get_quantized_path(QUANTIZED_TRAIN_FILE), column_description=QUANTIZED_CD_FILE)\n    with pytest.raises(CatBoostError):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_is_quantized",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_is_quantized():\n    quantized_pool = Pool(data=get_quantized_path(QUANTIZED_TRAIN_FILE), column_description=QUANTIZED_CD_FILE)\n    assert quantized_pool.is_quantized()\n    raw_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    assert not raw_pool.is_quantized()\ndef test_quantized_pool_with_all_features_ignored():\n    quantized_pool = Pool(data=get_quantized_path(QUANTIZED_TRAIN_FILE), column_description=QUANTIZED_CD_FILE)\n    with pytest.raises(CatBoostError):\n        CatBoostClassifier(ignored_features=list(range(100))).fit(quantized_pool)\n@pytest.fixture(params=[",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_with_all_features_ignored",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_with_all_features_ignored():\n    quantized_pool = Pool(data=get_quantized_path(QUANTIZED_TRAIN_FILE), column_description=QUANTIZED_CD_FILE)\n    with pytest.raises(CatBoostError):\n        CatBoostClassifier(ignored_features=list(range(100))).fit(quantized_pool)\n@pytest.fixture(params=[\n    ('adult', TRAIN_FILE, TEST_FILE, CD_FILE, 'Logloss'),\n    ('higgs', HIGGS_TRAIN_FILE, HIGGS_TEST_FILE, HIGGS_CD_FILE, 'Logloss'),\n    ('querywise', QUERYWISE_TRAIN_FILE, QUERYWISE_TEST_FILE, QUERYWISE_CD_FILE, 'RMSE'),\n], ids=[\n    'adult',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "train_on_raw_and_quantized_data_params_fixture",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def train_on_raw_and_quantized_data_params_fixture(request):\n    pool_name, train_pool_file, test_pool_file, column_description, loss_function = request.param\n    borders_file = test_output_path('{}_borders.dat'.format(pool_name))\n    train_pool = Pool(train_pool_file, column_description=column_description)\n    test_pool = Pool(test_pool_file, column_description=column_description)\n    train_quantized_pool = Pool(train_pool_file, column_description=column_description)\n    test_quantized_pool = Pool(test_pool_file, column_description=column_description)\n    params = {\n        'task_type': 'CPU',\n        'loss_function': loss_function,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "models_trained_on_raw_and_quantized_data_fixture",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def models_trained_on_raw_and_quantized_data_fixture(train_on_raw_and_quantized_data_params_fixture):\n    train_pool = train_on_raw_and_quantized_data_params_fixture['train_pool']\n    test_pool = train_on_raw_and_quantized_data_params_fixture['test_pool']\n    train_quantized_pool = train_on_raw_and_quantized_data_params_fixture['train_quantized_pool']\n    test_quantized_pool = train_on_raw_and_quantized_data_params_fixture['test_quantized_pool']\n    loss_function = train_on_raw_and_quantized_data_params_fixture['loss_function']\n    params = train_on_raw_and_quantized_data_params_fixture['params']\n    model = CatBoost(params=params)\n    model_fitted_with_quantized_pool = CatBoost(params=params)\n    model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_cv",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_cv(train_on_raw_and_quantized_data_params_fixture):\n    train_quantized_pool = train_on_raw_and_quantized_data_params_fixture['train_quantized_pool']\n    params = train_on_raw_and_quantized_data_params_fixture['params']\n    results_with_quantized_pool = cv(train_quantized_pool, params).round(decimals=4)\n    preds_path = test_output_path(CV_CSV_PATH)\n    results_with_quantized_pool.to_csv(preds_path)\n    return local_canonical_file(preds_path)\ndef test_quantized_pool_train_predict(train_on_raw_and_quantized_data_params_fixture):\n    train_pool = train_on_raw_and_quantized_data_params_fixture['train_pool']\n    test_pool = train_on_raw_and_quantized_data_params_fixture['test_pool']",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_train_predict",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_train_predict(train_on_raw_and_quantized_data_params_fixture):\n    train_pool = train_on_raw_and_quantized_data_params_fixture['train_pool']\n    test_pool = train_on_raw_and_quantized_data_params_fixture['test_pool']\n    train_quantized_pool = train_on_raw_and_quantized_data_params_fixture['train_quantized_pool']\n    test_quantized_pool = train_on_raw_and_quantized_data_params_fixture['test_quantized_pool']\n    params = train_on_raw_and_quantized_data_params_fixture['params']\n    model = train(train_pool, params=params)\n    model_fitted_with_quantized_pool = train(train_quantized_pool, params=params)\n    predictions = model.predict(test_pool)\n    predictions_with_quantized_pool = model_fitted_with_quantized_pool.predict(test_quantized_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_predict",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_predict(models_trained_on_raw_and_quantized_data_fixture):\n    test_pool = models_trained_on_raw_and_quantized_data_fixture['test_pool']\n    test_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['test_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    predictions = model.predict(test_pool)\n    predictions_with_quantized_pool = model_fitted_with_quantized_pool.predict(test_quantized_pool)\n    assert np.all(predictions == predictions_with_quantized_pool)\n@pytest.mark.parametrize('pool_type', ['train', 'test'])\ndef test_quantized_pool_calc_feature_statistics(models_trained_on_raw_and_quantized_data_fixture, pool_type):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_calc_feature_statistics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_calc_feature_statistics(models_trained_on_raw_and_quantized_data_fixture, pool_type):\n    pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_pool']\n    quantized_pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    class NumpyEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, np.ndarray):\n                return obj.tolist()\n            return json.JSONEncoder.default(self, obj)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_eval_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_eval_metrics(models_trained_on_raw_and_quantized_data_fixture, pool_type):\n    pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_pool']\n    quantized_pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    loss_function = models_trained_on_raw_and_quantized_data_fixture['loss_function']\n    metrics = model.eval_metrics(pool, metrics=[loss_function])\n    metrics_with_quantized_pool = model_fitted_with_quantized_pool.eval_metrics(quantized_pool, metrics=[loss_function])\n    assert metrics == metrics_with_quantized_pool\n@pytest.mark.parametrize('pool_type', ['train', 'test'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_get_feature_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_get_feature_importance(models_trained_on_raw_and_quantized_data_fixture, pool_type, fstr_type):\n    pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_pool']\n    quantized_pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    fstr = model.get_feature_importance(data=pool, type=fstr_type)\n    fstr_with_quantized_pool = \\\n        model_fitted_with_quantized_pool.get_feature_importance(data=quantized_pool, type=fstr_type)\n    assert np.all(fstr == fstr_with_quantized_pool)\ndef test_quantized_pool_get_object_importance(models_trained_on_raw_and_quantized_data_fixture):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_get_object_importance",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_get_object_importance(models_trained_on_raw_and_quantized_data_fixture):\n    train_pool = models_trained_on_raw_and_quantized_data_fixture['train_pool']\n    test_pool = models_trained_on_raw_and_quantized_data_fixture['test_pool']\n    train_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['train_quantized_pool']\n    test_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['test_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    importance = model.get_object_importance(test_pool, train_pool)\n    importance_with_quantized_pool = \\\n        model_fitted_with_quantized_pool.get_object_importance(test_quantized_pool, train_quantized_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantized_pool_select_threshold",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantized_pool_select_threshold(models_trained_on_raw_and_quantized_data_fixture, pool_type):\n    pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_pool']\n    quantized_pool = models_trained_on_raw_and_quantized_data_fixture[pool_type + '_quantized_pool']\n    model = models_trained_on_raw_and_quantized_data_fixture['model']\n    model_fitted_with_quantized_pool = models_trained_on_raw_and_quantized_data_fixture['model_fitted_with_quantized_pool']\n    threshold = select_threshold(model, pool)\n    threshold_with_quantized_pool = select_threshold(model_fitted_with_quantized_pool, quantized_pool)\n    assert threshold == threshold_with_quantized_pool\ndef check_save_quantized_pool(train_pool, train_pool_copy, test_pool, params):\n    feature_names = train_pool.get_feature_names()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "check_save_quantized_pool",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def check_save_quantized_pool(train_pool, train_pool_copy, test_pool, params):\n    feature_names = train_pool.get_feature_names()\n    train_quantized_pool = train_pool_copy\n    train_quantized_pool.quantize()\n    assert (train_quantized_pool.is_quantized())\n    train_quantized_pool.save(OUTPUT_QUANTIZED_POOL_PATH)\n    train_quantized_load_pool = Pool(get_quantized_path(OUTPUT_QUANTIZED_POOL_PATH))\n    model = CatBoost(params=params)\n    model_fitted_with_load_quantized_pool = CatBoost(params=params)\n    model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_quantized_pool_with_source_pool_from_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_quantized_pool_with_source_pool_from_dataframe(features_types):\n    n_train_samples = 200\n    n_test_samples = 50\n    if features_types == 'num':\n        n_num_features = 5\n        n_cat_features = 0\n    elif features_types == 'cat':\n        n_num_features = 0\n        n_cat_features = 5\n    elif features_types == 'num_and_cat':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_save_quantized_pool_with_source_pool_from_files",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_save_quantized_pool_with_source_pool_from_files(features_types):\n    if features_types == 'num':\n        dataset_name = 'higgs'\n    elif features_types == 'num_and_cat':\n        dataset_name = 'adult'\n    train_path = data_file(dataset_name, 'train_small')\n    test_path = data_file(dataset_name, 'test_small')\n    cd_path = data_file(dataset_name, 'train.cd')\n    check_save_quantized_pool(\n        train_pool=Pool(train_path, column_description=cd_path),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_dataset_specification_for_sparse_input_tests",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def get_dataset_specification_for_sparse_input_tests():\n    return {\n        'adult': {\n            'train_file': TRAIN_FILE,\n            'test_file': TEST_FILE,\n            'data_files_have_header': False,\n            'cd_file': CD_FILE,\n            'loss_function': 'Logloss'\n        },\n        'airlines_5k': {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "convert_cat_columns_to_hashed",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def convert_cat_columns_to_hashed(src_features_dataframe):\n    def create_hashed_categorical_column(src_column):\n        hashed_column = []\n        for value in src_column:\n            hashed_column.append(np.uint32(hash(value)))\n        return hashed_column\n    new_columns_data = OrderedDict()\n    for column_name, column_data in src_features_dataframe.items():\n        if column_data.dtype.name == 'category':\n            new_columns_data[column_name] = create_hashed_categorical_column(column_data)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pools_equal_on_dense_and_scipy_sparse_input",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pools_equal_on_dense_and_scipy_sparse_input(dataset):\n    metadata = get_dataset_specification_for_sparse_input_tests()[dataset]\n    columns_metadata = read_cd(\n        metadata['cd_file'],\n        data_file=metadata['train_file'],\n        canonize_column_types=True\n    )\n    data = load_dataset_as_dataframe(\n        metadata['train_file'],\n        columns_metadata,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_on_scipy_sparse_spmatrix",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_on_scipy_sparse_spmatrix(features_dtype, features_density):\n    if np.dtype(features_dtype).kind == 'f':\n        cat_features = []\n        lower_bound = -1.0\n        upper_bound = 1.0\n    else:\n        cat_features = [0, 7, 11]\n        lower_bound = max(np.iinfo(features_dtype).min, -32767)\n        upper_bound = min(np.iinfo(features_dtype).max, 32767)\n    features, labels = generate_random_labeled_dataset(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "make_catboost_compatible_categorical_missing_values",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def make_catboost_compatible_categorical_missing_values(src_features_dataframe):\n    new_columns_data = OrderedDict()\n    for column_name, column_data in src_features_dataframe.items():\n        if column_data.dtype.name == 'category':\n            column_data = column_data.cat.rename_categories([str(x) for x in column_data.cat.categories])\n            column_data = column_data.cat.add_categories('').fillna('')\n        new_columns_data[column_name] = column_data\n    return DataFrame(new_columns_data)\ndef convert_to_sparse(src_features_dataframe, indexing_kind):\n    new_columns_data = OrderedDict()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "convert_to_sparse",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def convert_to_sparse(src_features_dataframe, indexing_kind):\n    new_columns_data = OrderedDict()\n    for column_name, column_data in src_features_dataframe.items():\n        if column_data.dtype.name == 'category':\n            fill_value = ''\n        else:\n            fill_value = 0.0\n        new_columns_data[column_name] = SparseArray(column_data, fill_value=fill_value, kind=indexing_kind)\n    return DataFrame(new_columns_data)\n@pytest.mark.parametrize('dataset', list(get_dataset_specification_for_sparse_input_tests().keys()))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pools_equal_on_pandas_dense_and_sparse_input",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pools_equal_on_pandas_dense_and_sparse_input(dataset, indexing_kind):\n    metadata = get_dataset_specification_for_sparse_input_tests()[dataset]\n    columns_metadata = read_cd(\n        metadata['cd_file'],\n        data_file=metadata['train_file'],\n        canonize_column_types=True\n    )\n    data = load_dataset_as_dataframe(\n        metadata['train_file'],\n        columns_metadata,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_training_and_prediction_equal_on_pandas_dense_and_sparse_input",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_training_and_prediction_equal_on_pandas_dense_and_sparse_input(task_type, dataset, indexing_kind, boosting_type):\n    metadata = get_dataset_specification_for_sparse_input_tests()[dataset]\n    if (task_type == 'GPU') and (boosting_type == 'Ordered') and (metadata['loss_function'] == 'MultiClass'):\n        return pytest.xfail(reason=\"On GPU loss MultiClass can't be used with ordered boosting\")\n    columns_metadata = read_cd(\n        metadata['cd_file'],\n        data_file=metadata['train_file'],\n        canonize_column_types=True\n    )\n    def get_dense_and_sparse_pools(data_file):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_sparse_input_with_categorical_features_with_default_value_present_only_in_eval",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_sparse_input_with_categorical_features_with_default_value_present_only_in_eval():\n    cat_features = [1, 2]\n    \"\"\"\n        1 x 2\n        x x 3\n        4 5 6\n        1 x 3\n    \"\"\"\n    row = np.array([0, 0, 1, 2, 2, 2, 3, 3])\n    col = np.array([0, 2, 2, 0, 1, 2, 0, 2])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_monotone_constraints",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_formats_of_monotone_constraints(model_shrink_rate):\n    from catboost.datasets import monotonic2, set_cache_path\n    set_cache_path(test_output_path())  # specify cache dir to fix potential data race while downloading dataset\n    monotonic2_train, monotonic2_test = monotonic2()\n    X_train, y_train = monotonic2_train.drop(columns=['Target']), monotonic2_train['Target']\n    X_test, y_test = monotonic2_test.drop(columns=['Target']), monotonic2_test['Target']\n    feature_names = list(X_train.columns)\n    train_pool = Pool(data=X_train, label=y_train, feature_names=feature_names)\n    test_pool = Pool(data=X_test, label=y_test, feature_names=feature_names)\n    monotone_constraints_array = np.array([-1, 1, 1, -1])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_monotone_constraints_in_different_modes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_formats_of_monotone_constraints_in_different_modes():\n    from catboost.datasets import monotonic2, set_cache_path\n    set_cache_path(test_output_path())  # specify cache dir to fix potential data race while downloading dataset\n    monotonic2_train, monotonic2_test = monotonic2()\n    X_train, y_train = monotonic2_train.drop(columns=['Target']), monotonic2_train['Target']\n    feature_names = list(X_train.columns)\n    train_pool = Pool(data=X_train, label=y_train, feature_names=feature_names)\n    monotone_constraints_array = np.array([-1, 1, 1, -1])\n    monotone_constraints_list = [-1, 1, 1, -1]\n    monotone_constraints_dict_1 = {0: -1, 1: 1, 2: 1, 3: -1}",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_same_values_with_different_types",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_same_values_with_different_types(task_type):\n    # take integers from [0, 127] because they can be represented by any of this types\n    canon_predictions = None\n    n_features = 20\n    n_objects = 500\n    params = {\n        'task_type': task_type,\n        'loss_function': 'Logloss',\n        'iterations': 5\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_default_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_default_eval_metric(loss_function):\n    X = np.array([[1, 2, 3], [5, 4, 23], [8954, 4, 22]])\n    y = np.array([1, 0, 1])\n    p = Pool(X, y)\n    model = CatBoostClassifier(task_type='CPU', loss_function=loss_function, iterations=15, metric_period=100)\n    model.fit(p)\n    assert model.get_all_params()[\"eval_metric\"] == loss_function\ndef test_multiclass_train_on_constant_data(task_type):\n    features = np.asarray(\n        [[0.27290749, 0.63002519, 0., 0.38624339, 0.],",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_train_on_constant_data",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass_train_on_constant_data(task_type):\n    features = np.asarray(\n        [[0.27290749, 0.63002519, 0., 0.38624339, 0.],\n         [0.27290748, 0.63002519, 0., 0.38624339, 0.],\n         [0.27290747, 0.63002519, 0., 0.38624339, 0.]]\n    )\n    classes = ['0', '1', '2']\n    labels = np.asarray(classes)\n    clf = CatBoostClassifier(\n        iterations=2,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_classes_attribute_binclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_classes_attribute_binclass(label_type, loss_function):\n    params = {'loss_function': loss_function, 'iterations': 2}\n    if label_type == 'consecutive_integers':\n        unique_labels = [0, 1]\n    elif label_type == 'nonconsecutive_integers':\n        unique_labels = [2, 5]\n    elif label_type == 'string':\n        unique_labels = ['class0', 'class1']\n    elif label_type == 'float':\n        unique_labels = [0.0, 0.1, 0.2, 0.5, 1.0]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_classes_attribute_multiclass",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_classes_attribute_multiclass(label_type):\n    params = {'loss_function': 'MultiClass', 'iterations': 2}\n    if label_type == 'consecutive_integers':\n        unique_labels = [0, 1, 2, 3]\n    elif label_type == 'nonconsecutive_integers':\n        unique_labels = [2, 5, 9, 11]\n    elif label_type == 'string':\n        unique_labels = ['class0', 'class1', 'class2', 'class3']\n    elif label_type == 'float':\n        unique_labels = [0.0, 0.1, 0.2, 0.5, 1.0]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_multiclass_non_positive_definite_from_github",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_multiclass_non_positive_definite_from_github():\n    train = np.array([\n        [\n            0., 0., 0., 0., 0., 0., 0., 0., 0., 0.\n        ],\n        [\n            0.00473934, 0.05, 0., 0., 0., 0., 0., 0., 0., 0.\n        ],\n        [\n            0.04739336, 0.1, 0., 0., 0., 0.03191489, 0., 0., 0., 0.",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_snapshot_checksum",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_snapshot_checksum(task_type):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        task_type=task_type,\n        iterations=15,\n        save_snapshot=True,\n        snapshot_file='snapshot',\n    )\n    model.fit(train_pool, eval_set=test_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_bootstrap_defaults",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_bootstrap_defaults():\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=1)\n    model.fit(pool)\n    params = model.get_all_params()\n    assert params['bootstrap_type'] == 'MVS'\n    assert abs(params['subsample'] - 0.8) < EPS\n    model = CatBoostClassifier(iterations=1, bootstrap_type='Bernoulli')\n    model.fit(pool)\n    params = model.get_all_params()",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_monoforest_regression",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_monoforest_regression():\n    train_pool = Pool(HIGGS_TRAIN_FILE, column_description=HIGGS_CD_FILE)\n    model = CatBoostRegressor(loss_function='RMSE', iterations=10)\n    model.fit(train_pool)\n    from catboost.monoforest import to_polynom_string, plot_features_strength\n    poly = to_polynom_string(model)\n    assert poly, \"Unexpected empty poly\"\n    plot = plot_features_strength(model)\n    assert plot, \"Unexpected empty plot\"\ndef test_text_processing_tokenizer():",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_text_processing_tokenizer",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_text_processing_tokenizer():\n    from catboost.text_processing import Tokenizer\n    assert Tokenizer(lowercasing=True).tokenize('Aba caba') == ['aba', 'caba']\ndef test_text_processing_dictionary():\n    from catboost.text_processing import Dictionary\n    dictionary = Dictionary(occurence_lower_bound=0).fit([\n        ['aba', 'caba'],\n        ['ala', 'caba'],\n        ['caba', 'aba']\n    ])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_text_processing_dictionary",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_text_processing_dictionary():\n    from catboost.text_processing import Dictionary\n    dictionary = Dictionary(occurence_lower_bound=0).fit([\n        ['aba', 'caba'],\n        ['ala', 'caba'],\n        ['caba', 'aba']\n    ])\n    assert dictionary.size == 3\n    assert dictionary.get_top_tokens(2) == ['caba', 'aba']\n    assert dictionary.apply([['ala', 'caba'], ['aba']]) == [[2, 0], [1]]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_log_proba",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_log_proba():\n    # multiclass with softmax\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=50, thread_count=8, devices='0')\n    classifier.fit(pool)\n    pred = classifier.predict(pool, prediction_type='Probability')\n    log_pred = classifier.predict(pool, prediction_type='LogProbability')\n    assert np.allclose(log_pred, np.log(pred))\n    # multiclass OneVsAll\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_binclass_probability_threshold",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_binclass_probability_threshold():\n    # binary classification\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    classifier = CatBoostClassifier(iterations=2)\n    with pytest.raises(CatBoostError):\n        classifier.set_probability_threshold(0.6)  # can't set before training\n    with pytest.raises(CatBoostError):\n        classifier.get_probability_threshold()  # can't get before training\n    classifier.fit(pool)\n    assert classifier.get_probability_threshold() == 0.5  # check default value",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_exponent_prediction_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_exponent_prediction_type():\n    # poisson regression\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    regressor = CatBoostRegressor(iterations=2, objective='Poisson')\n    regressor.fit(pool)\n    pred = regressor.predict(pool, prediction_type='RawFormulaVal')\n    exp_pred = regressor.predict(pool)\n    assert np.allclose(exp_pred, np.exp(pred))\ndef test_rmse_with_uncertainty_prediction_type():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_rmse_with_uncertainty_prediction_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_rmse_with_uncertainty_prediction_type():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=CD_FILE)\n    regressor = CatBoostRegressor(iterations=2, objective='RMSEWithUncertainty')\n    regressor.fit(pool)\n    pred = np.transpose(regressor.predict(pool, prediction_type='RawFormulaVal'))\n    exp_pred = np.transpose(regressor.predict(pool))\n    assert np.allclose(exp_pred[0], pred[0])\n    assert np.allclose(exp_pred[1], np.exp(pred[1] * 2))\ndef test_bad_uncertainty_prediction_types_usage():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_bad_uncertainty_prediction_types_usage",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_bad_uncertainty_prediction_types_usage():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=CD_FILE)\n    regressor = CatBoostRegressor(iterations=100, posterior_sampling=True)\n    regressor.fit(pool)\n    for prediction_type in ['TotalUncertainty', 'VirtEnsembles']:\n        with pytest.raises(Exception):\n            regressor.predict(pool, prediction_type=prediction_type)\n@pytest.mark.parametrize('virtual_ensembles_count', [1, 5])\n@pytest.mark.parametrize('prediction_type', ['TotalUncertainty', 'VirtEnsembles'])\n@pytest.mark.parametrize('loss_function', ['RMSE', 'RMSEWithUncertainty', 'Logloss', 'MultiClass'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_uncertainty_prediction_types",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_uncertainty_prediction_types(virtual_ensembles_count, prediction_type, loss_function):\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE) \\\n        if loss_function != 'Logloss' \\\n        else Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoost(\n        {\n            \"iterations\": 100,\n            \"loss_function\": loss_function,\n            \"posterior_sampling\": True,\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_staged_log_proba",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_staged_log_proba():\n    # multiclass with softmax\n    pool = Pool(CLOUDNESS_TRAIN_FILE, column_description=CLOUDNESS_CD_FILE)\n    classifier = CatBoostClassifier(iterations=50, thread_count=8, devices='0')\n    classifier.fit(pool)\n    pred_it = classifier.staged_predict(pool, prediction_type='Probability')\n    log_pred_it = classifier.staged_predict(pool, prediction_type='LogProbability')\n    for pred, log_pred in zip(pred_it, log_pred_it):\n        assert np.allclose(log_pred, np.log(pred))\n    # multiclass OneVsAll",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_shap_assert",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_shap_assert():\n    model_path = test_output_path('model.json')\n    pool = Pool([[0, ], [1, ], ], [0, 1])\n    model = train(pool, {'iterations': 1, 'task_type': 'CPU', 'devices': '0'})\n    model.save_model(model_path, format='json')\n    json_model = json.load(open(model_path))\n    json_model['scale_and_bias'] = [1, [1]]\n    json.dump(json_model, open(model_path, 'w'))\n    model = CatBoost().load_model(model_path, format='json')\n    shap_values = model.get_feature_importance(type='ShapValues', data=pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_diffusion_temperature_with_shrink_mode",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_diffusion_temperature_with_shrink_mode(shrink_mode, shrink_rate, diffusion):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 50,\n        'learning_rate': 0.03,\n        'model_shrink_mode': shrink_mode,\n        'model_shrink_rate': shrink_rate,\n        'diffusion_temperature': diffusion\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_langevin_with_empty_leafs",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_langevin_with_empty_leafs():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    params = {\n        'iterations': 10,\n        'depth': 10,\n        'learning_rate': 0.03,\n        'langevin': True,\n        'diffusion_temperature': 1000\n    }\n    model = CatBoostClassifier(**params)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_classifier",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_classifier():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    models = []\n    for learning_rate in [.03, .05]:\n        models.append(CatBoostClassifier(iterations=2, learning_rate=learning_rate))\n        models[-1].fit(train_pool, eval_set=test_pool)\n    merged_model = sum_models(models)\n    prediction = merged_model.predict(test_pool, prediction_type='Probability')\n    assert type(merged_model) is CatBoost",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_classifier_wrong_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_classifier_wrong_type():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostRegressor(iterations=2, learning_rate=.05, objective='RMSE')\n    model.fit(train_pool)\n    with pytest.raises(CatBoostError):\n        to_classifier(model)\ndef test_to_regressor():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    models = []",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_regressor",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_regressor():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test_pool = Pool(TEST_FILE, column_description=CD_FILE)\n    models = []\n    for learning_rate in [.03, .05]:\n        models.append(CatBoostRegressor(iterations=2, learning_rate=learning_rate))\n        models[-1].fit(train_pool, eval_set=test_pool)\n    merged_model = sum_models(models)\n    prediction = merged_model.predict(test_pool)\n    assert type(merged_model) is CatBoost",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_regressor_wrong_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_regressor_wrong_type():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)\n    with pytest.raises(CatBoostError):\n        to_regressor(model)\ndef test_to_ranker():\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    models = []",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_ranker",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_ranker():\n    train_pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    test_pool = Pool(QUERYWISE_TEST_FILE, column_description=QUERYWISE_CD_FILE)\n    models = []\n    for learning_rate in [.03, .05]:\n        models.append(CatBoostRanker(iterations=2, learning_rate=learning_rate))\n        models[-1].fit(train_pool, eval_set=test_pool)\n    merged_model = sum_models(models)\n    prediction = merged_model.predict(test_pool)\n    assert type(merged_model) is CatBoost",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_to_ranker_wrong_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_to_ranker_wrong_type():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)\n    with pytest.raises(CatBoostError):\n        to_ranker(model)\ndef test_load_and_save_quantization_borders():\n    borders_32_file = test_output_path('borders_32.dat')\n    borders_10_file = test_output_path('borders_10.dat')\n    borders_from_input_borders_file = test_output_path('borders_from_input_borders.dat')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_load_and_save_quantization_borders",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_load_and_save_quantization_borders():\n    borders_32_file = test_output_path('borders_32.dat')\n    borders_10_file = test_output_path('borders_10.dat')\n    borders_from_input_borders_file = test_output_path('borders_from_input_borders.dat')\n    pool_border_count_32 = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    pool_border_count_32.quantize(border_count=32)\n    pool_border_count_32.save_quantization_borders(borders_32_file)\n    pool_border_count_10 = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    pool_border_count_10.quantize(border_count=10)\n    pool_border_count_10.save_quantization_borders(borders_10_file)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_weights_work",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_weights_work():\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    most_important_feature_index = 3\n    classifier_params = {\n        'iterations': 5,\n        'learning_rate': 0.03,\n        'task_type': 'CPU',\n        'devices': '0',\n        'loss_function': 'MultiClass',\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_feature_weights",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_formats_of_feature_weights():\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    feature_weights_array = np.array([1, 1, 1, 0.1, 1, 1, 1, 2])\n    feature_weights_list = [1, 1, 1, 0.1, 1, 1, 1, 2]\n    feature_weights_dict_1 = {3: 0.1, 7: 2}\n    feature_weights_dict_2 = {'DepTime': 0.1, 'Distance': 2}\n    feature_weights_string_1 = \"(1,1,1,0.1,1,1,1,2)\"\n    feature_weights_string_2 = \"3:0.1,7:2\"\n    feature_weights_string_3 = \"DepTime:0.1,Distance:2\"",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_feature_tags_interface",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_feature_tags_interface():\n    data = np.arange(80).reshape((10, 8))\n    label = np.arange(10) % 2\n    pool = Pool(\n        data,\n        label=label,\n        feature_names=[\"c_0\", \"c_1\", \"c_2\", \"num_3\", \"c_4\", \"c_5\", \"c_6\", \"num_7\"],\n        feature_tags={\n            \"tag1\" : {\n                \"features\": np.arange(4),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_first_feature_use_penalties_work",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_first_feature_use_penalties_work():\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    most_important_feature_index = 3\n    classifier_params = {\n        'iterations': 5,\n        'learning_rate': 0.03,\n        'task_type': 'CPU',\n        'devices': '0',\n        'loss_function': 'MultiClass',\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_first_feature_use_penalties",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_formats_of_first_feature_use_penalties():\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    first_feature_use_penalties_array = np.array([0, 0, 0, 10, 0, 0, 0, 2])\n    first_feature_use_penalties_list = [0, 0, 0, 10, 0, 0, 0, 2]\n    first_feature_use_penalties_dict_1 = {3: 10, 7: 2}\n    first_feature_use_penalties_dict_2 = {'DepTime': 10, 'Distance': 2}\n    first_feature_use_penalties_string_1 = \"(0,0,0,10,0,0,0,2)\"\n    first_feature_use_penalties_string_2 = \"3:10,7:2\"\n    first_feature_use_penalties_string_3 = \"DepTime:10,Distance:2\"",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_penalties_coefficient_work",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_penalties_coefficient_work():\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    most_important_feature_index = 3\n    classifier_params = {\n        'iterations': 5,\n        'learning_rate': 0.03,\n        'task_type': 'CPU',\n        'devices': '0',\n        'loss_function': 'MultiClass',\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_partial_dependence",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_partial_dependence(features):\n    pool_file = 'higgs'\n    pool = Pool(data_file(pool_file, 'train_small'), column_description=data_file(pool_file, 'train.cd'))\n    model = CatBoostClassifier(iterations=100, learning_rate=0.03, max_ctr_complexity=1, devices='0')\n    model.fit(pool)\n    fimp_txt_path = test_output_path(FIMP_TXT_PATH)\n    np.savetxt(fimp_txt_path, np.around(np.array(model.plot_partial_dependence(pool, features, plot=False)[0]).flatten(), 8))\n    return local_canonical_file(fimp_txt_path)\n@pytest.mark.parametrize('grow_policy', ['SymmetricTree', 'Depthwise', 'Lossguide'])\ndef test_per_object_feature_penalties_work(grow_policy):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_per_object_feature_penalties_work",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_per_object_feature_penalties_work(grow_policy):\n    pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    most_important_feature_index = 3\n    classifier_params = {\n        'iterations': 5,\n        'learning_rate': 0.03,\n        'task_type': 'CPU',\n        'loss_function': 'MultiClass',\n        'grow_policy': grow_policy,\n    }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_different_formats_of_per_object_feature_penalties",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_different_formats_of_per_object_feature_penalties():\n    train_pool = Pool(AIRLINES_5K_TRAIN_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    test_pool = Pool(AIRLINES_5K_TEST_FILE, column_description=AIRLINES_5K_CD_FILE, has_header=True)\n    per_row_feature_penalties_array = np.array([0, 0, 0, 10, 0, 0, 0, 2])\n    per_row_feature_penalties_list = [0, 0, 0, 10, 0, 0, 0, 2]\n    per_row_feature_penalties_dict_1 = {3: 10, 7: 2}\n    per_row_feature_penalties_dict_2 = {'DepTime': 10, 'Distance': 2}\n    per_row_feature_penalties_string_1 = \"(0,0,0,10,0,0,0,2)\"\n    per_row_feature_penalties_string_2 = \"3:10,7:2\"\n    per_row_feature_penalties_string_3 = \"DepTime:10,Distance:2\"",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_load_and_quantize",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_load_and_quantize(pool_file, column_description, load_params, quantize_params,\n                                subset_quantization_differs):\n    SMALL_BLOCK_SIZE = 500\n    SMALL_SUBSET_SIZE_FOR_BUILD_BORDERS = 100\n    quantized_pool = Pool(pool_file, column_description=column_description, **load_params)\n    quantized_pool.quantize(**quantize_params)\n    quantized_pool_small_subset = Pool(pool_file, column_description=column_description, **load_params)\n    quantized_pool_small_subset.quantize(\n        dev_max_subset_size_for_build_borders=SMALL_SUBSET_SIZE_FOR_BUILD_BORDERS,\n        **quantize_params)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_load_and_quantize_unknown_param",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_load_and_quantize_unknown_param():\n    with pytest.raises(CatBoostError):\n        quantize(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE, this_param_is_unknown=123)\ndef test_quantize_unknown_param():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    with pytest.raises(CatBoostError):\n        pool.quantize(this_param_is_unknown=123)\ndef test_iterate_leaf_indexes():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_quantize_unknown_param",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_quantize_unknown_param():\n    pool = Pool(QUERYWISE_TRAIN_FILE, column_description=QUERYWISE_CD_FILE)\n    with pytest.raises(CatBoostError):\n        pool.quantize(this_param_is_unknown=123)\ndef test_iterate_leaf_indexes():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)\n    for _ in model.iterate_leaf_indexes(train_pool):\n        pass",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_iterate_leaf_indexes",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_iterate_leaf_indexes():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)\n    for _ in model.iterate_leaf_indexes(train_pool):\n        pass\ndef test_plot_tree():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_plot_tree",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_plot_tree():\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(iterations=2, learning_rate=.05, objective='Logloss')\n    model.fit(train_pool)\n    model.plot_tree(0)\n@pytest.mark.parametrize('params', [{},\n                                    {'verbose': True},\n                                    {'verbose': False},\n                                    {'logging_level': 'Silent'},\n                                    {'logging_level': 'Verbose'},",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_same_params",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_same_params(params):\n    train_pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    model_path = test_output_path('model.bin')\n    params['iterations'] = 10\n    params['loss_function'] = 'Logloss'\n    CatBoost(params).fit(train_pool).save_model(model_path)\n    assert CatBoost().load_model(model_path).get_params() == params\n@pytest.mark.parametrize('task', ['binclass', 'multiclass'])\n@pytest.mark.parametrize('metric', ['TotalF1', 'MCC', 'F1', 'Precision', 'Recall'])\n@pytest.mark.parametrize('use_weights', [True, False])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metric_with_weights",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_metric_with_weights(task_type, task, metric, use_weights):\n    X = np.random.random()\n    if task == 'multiclass' and metric in ('F1', 'Precision', 'Recall'):\n        pytest.skip('Metric with multiple values is not allowed to use as eval_metric')\n    np.random.seed(0)\n    X = np.random.random(size=(100, 10))\n    if task == 'binclass':\n        y = [0] * 30 + [1] * 70\n    else:\n        y = [0] * 20 + [1] * 30 + [2] * 50",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_callbacks_early_stop",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_callbacks_early_stop(problem):\n    np.random.seed(0)\n    train_data = np.random.randint(0, 100, size=(100, 5))\n    train_labels = np.random.randint(0, 2, size=100)\n    if problem == 'Classifier':\n        loss = 'Logloss'\n        model = CatBoostClassifier(iterations=10, loss_function=loss)\n    else:\n        loss = 'RMSE'\n        model = CatBoostRegressor(iterations=10, loss_function=loss)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_callbacks_metrics",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_callbacks_metrics():\n    np.random.seed(0)\n    def generate_dataset():\n        return np.random.randint(0, 100, size=(100, 5)), np.random.randint(0, 2, size=100)\n    train_data, train_labels = generate_dataset()\n    validation_0 = generate_dataset()\n    validation_1 = generate_dataset()\n    metric_names = ['Logloss', 'CrossEntropy']\n    model = CatBoostClassifier(iterations=10, custom_metric=metric_names)\n    class MetricsCheckerCallback:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_cat_features_type",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_cat_features_type():\n    X = DataFrame(\n        data=np.random.randint(0, 100, size=(100, 5)),\n        columns=['feature{}'.format(i) for i in range(5)]\n    )\n    y = np.random.randint(0, 2, size=100)\n    model = CatBoostClassifier(iterations=2,\n                               depth=2,\n                               learning_rate=1,\n                               loss_function='CrossEntropy',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_sklearn_meta_algo",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_sklearn_meta_algo():\n    from sklearn.calibration import CalibratedClassifierCV\n    X_train = [[1, 2, 3, 4], [2, 3, 4, 5]]\n    y_train = [1, 0]\n    model = CatBoostClassifier()\n    model.fit(X_train, y_train)\n    cc_model = CalibratedClassifierCV(model, cv='prefit', method='isotonic')\n    model = cc_model.fit(X_train, y_train)\ndef test_pool_with_timestamp(task_type):\n    features, labels = generate_random_labeled_dataset(n_samples=20, n_features=5, labels=[0, 1])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_with_timestamp",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_with_timestamp(task_type):\n    features, labels = generate_random_labeled_dataset(n_samples=20, n_features=5, labels=[0, 1])\n    np.random.seed(42)\n    timestamp = np.arange(20)\n    np.random.shuffle(timestamp)\n    pool = Pool(features, label=labels, timestamp=timestamp)\n    model = CatBoostClassifier(\n        has_time=True,\n        iterations=2,\n        learning_rate=0.03,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pool_set_timestamp",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pool_set_timestamp(task_type):\n    pool = Pool(TRAIN_FILE, column_description=CD_FILE)\n    np.random.seed(42)\n    timestamp = np.arange(pool.num_row())\n    np.random.shuffle(timestamp)\n    pool.set_timestamp(timestamp)\n    model = CatBoostClassifier(\n        has_time=True,\n        iterations=2,\n        learning_rate=0.03,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_select_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_select_features(task_type, train_final_model):\n    learn = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test = Pool(TEST_FILE, column_description=CD_FILE)\n    model = CatBoostClassifier(\n        iterations=10,\n        learning_rate=0.03,\n        task_type=task_type,\n        devices='0'\n    )\n    summary = model.select_features(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_select_features_with_custom_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_select_features_with_custom_eval_metric():\n    class CustomMetric(object):\n        def get_final_error(self, error, weight):\n            return 0.35\n        def is_max_optimal(self):\n            return True\n        def evaluate(self, approxes, target, weight):\n            return (0.0, 0.0)\n    learn = Pool(TRAIN_FILE, column_description=CD_FILE)\n    test = Pool(TEST_FILE, column_description=CD_FILE)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_select_features_by_single_feature_tags",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_select_features_by_single_feature_tags(task_type, train_final_model, algorithm):\n    # use querywise dataset because it contains more features to select from\n    columns_metadata = read_cd(\n        QUERYWISE_CD_FILE,\n        data_file=QUERYWISE_TRAIN_FILE,\n        canonize_column_types=True\n    )\n    learn_data = load_dataset_as_dataframe(QUERYWISE_TRAIN_FILE, columns_metadata)\n    test_data = load_dataset_as_dataframe(QUERYWISE_TEST_FILE, columns_metadata)\n    n_features = learn_data['features'].columns.size",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_select_features_by_multi_feature_tags",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_select_features_by_multi_feature_tags(task_type, train_final_model, algorithm):\n    n_features = 30\n    learn_features, learn_labels = generate_random_labeled_dataset(\n        n_samples=4000,\n        n_features=n_features,\n        labels=[0, 1],\n        seed=1\n    )\n    test_features, test_labels = generate_random_labeled_dataset(\n        n_samples=1500,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_embedding_features_data_list_with_data_with_features_order",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_embedding_features_data_list_with_data_with_features_order():\n    pool1 = Pool(\n        data=DataFrame(\n            {\n                'f0': [0, 1, 2],\n                'f1': [3, 4, 5],\n                '_embedding_feature_2': [[0.1, 0.2], [0.12, 0.3], [1.0, 0.0]],\n                '_embedding_feature_3': [[0.8, 0.3, 0.1], [0.0, 0.2, 0.8], [1.0, 0.0, 0.5]]\n            }\n        ),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_embedding_features_data_dict_with_data_with_features_order",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_embedding_features_data_dict_with_data_with_features_order():\n    pool1 = Pool(\n        data=DataFrame(\n            {\n                'f0': [0, 1, 2],\n                'f1': [3, 4, 5],\n                'f2': [[0.1, 0.2], [0.12, 0.3], [1.0, 0.0]],\n                'f3': [[0.8, 0.3, 0.1], [0.0, 0.2, 0.8], [1.0, 0.0, 0.5]]\n            }\n        ),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_embedding_features_data_list_with_data_with_objects_order",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_embedding_features_data_list_with_data_with_objects_order():\n    pool1 = Pool(\n        data=[\n            [0, 3, [0.1, 0.2], [0.8, 0.3, 0.1], 6],\n            [1, 4, [0.12, 0.3], [0.0, 0.2, 0.8], 7],\n            [2, 5, [1.0, 0.0], [1.0, 0.0, 0.5], 8]\n        ],\n        embedding_features=[2, 3]\n    )\n    pool2 = Pool(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_embedding_features_data_dict_with_data_with_objects_order",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_embedding_features_data_dict_with_data_with_objects_order():\n    pool1 = Pool(\n        data=[\n            [0, 3, [0.1, 0.2], [0.8, 0.3, 0.1], 6],\n            [1, 4, [0.12, 0.3], [0.0, 0.2, 0.8], 7],\n            [2, 5, [1.0, 0.0], [1.0, 0.0, 0.5], 8]\n        ],\n        embedding_features=[2, 3]\n    )\n    pool2 = Pool(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pandas_integer_array",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pandas_integer_array():\n    X = DataFrame({'feature': list(range(10))}, dtype=pd.Int64Dtype())\n    y = list(range(10))\n    cb = CatBoostRegressor(iterations=1)\n    cb.fit(X, y)\ndef test_pandas_categorical_with_categories_as_string_array():\n    X = pd.DataFrame({\n        \"ints\": pd.Series([1, 9, 5]),\n        \"strs\": pd.Series([\"a\", \"b\", \"c\"], dtype=\"category\")\n    })",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_pandas_categorical_with_categories_as_string_array",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_pandas_categorical_with_categories_as_string_array():\n    X = pd.DataFrame({\n        \"ints\": pd.Series([1, 9, 5]),\n        \"strs\": pd.Series([\"a\", \"b\", \"c\"], dtype=\"category\")\n    })\n    y = pd.Series([1, 2, 5])\n    X = X.astype({\"strs\": \"string\"}).astype({\"strs\": \"category\"})\n    clf = CatBoostClassifier(iterations=10, cat_features=[\"strs\"])\n    clf.fit(X, y)\n@pytest.mark.parametrize('problem_type', ['classification', 'regression', 'ranking', 'multilabel'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_train_with_embedding_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_train_with_embedding_features(task_type, problem_type):\n    def make_train_y(problem_type):\n        if problem_type == 'classification':\n            return [0, 1, 1, 0, 1, 0, 1]\n        elif problem_type == 'multilabel':\n            return [[0, 1], [1, 0], [1, 0], [1, 1], [0, 0], [1, 0], [1, 1]]\n        else:\n            return [0.0, 0.1, 0.2, 0.12, 0.3, 0.1, 0.13]\n    train_pool = Pool(\n        data=[",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_fraction_on_ndarray",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_fraction_on_ndarray(estimator_type, with_cat_features):\n    if estimator_type == 'classifier':\n        loss_function = 'Logloss'\n    else:\n        loss_function = 'RMSE'\n    if with_cat_features:\n        features_dtype = np.int32\n        cat_features = [0, 7, 11]\n        lower_bound = -32000\n        upper_bound = 32000",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_fraction_on_pool",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_fraction_on_pool(estimator_type, with_cat_features):\n    if estimator_type == 'classifier':\n        loss_function = 'Logloss'\n    else:\n        loss_function = 'RMSE'\n    if with_cat_features:\n        features_dtype = np.int32\n        cat_features = [0, 7, 11]\n        lower_bound = -32000\n        upper_bound = 32000",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_with_fixed_splits",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_with_fixed_splits(task_type):\n    if task_type == 'CPU':\n        pytest.xfail('CatBoost does not support fixed binary splits on CPU')\n    params = {\n        'task_type': task_type,\n        'fixed_binary_splits': [0, 1],\n        'iterations': 2,\n        'learning_rate': 1,\n        'depth': 3,\n        'grow_policy': 'Depthwise',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_regressor_with_fixed_splits",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_regressor_with_fixed_splits(task_type):\n    if task_type == 'CPU':\n        pytest.xfail('CatBoostRegressor does not support fixed binary splits on CPU')\n    model = CatBoostRegressor(\n        task_type=task_type,\n        fixed_binary_splits=[0, 1],\n        iterations=2,\n        learning_rate=1,\n        depth=3,\n        grow_policy='Depthwise',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_classifier_with_fixed_splits",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_classifier_with_fixed_splits(task_type):\n    if task_type == 'CPU':\n        pytest.xfail('CatBoostClassifier does not support fixed binary splits on CPU')\n    model = CatBoostClassifier(\n        task_type=task_type,\n        loss_function='Logloss',\n        fixed_binary_splits=[0, 1],\n        iterations=2,\n        learning_rate=1,\n        depth=3,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_ranker_with_fixed_splits",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_ranker_with_fixed_splits(task_type):\n    if task_type == 'CPU':\n        pytest.xfail('CatBoostRanker does not support fixed binary splits on CPU')\n    model = CatBoostRanker(\n        task_type=task_type,\n        fixed_binary_splits=[0, 1],\n        iterations=2,\n        learning_rate=1,\n        depth=3,\n        grow_policy='Depthwise',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_github_issue_2378_numpy_int_is_deprecated",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_github_issue_2378_numpy_int_is_deprecated():\n    train_data = [[1, 4, 5, 6],\n                  [4, 5, 6, 7],\n                  [30, 40, 50, 60]]\n    train_labels = [10, 20, 30]\n    model = CatBoostRegressor(iterations=2,\n                              learning_rate=1,\n                              depth=2)\n    model.fit(train_data, train_labels)\n    model.calc_feature_statistics(train_data, train_labels, plot=False)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_sample_gaussian_process",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_sample_gaussian_process(random_score_type):\n    samples = 10\n    columns_metadata = read_cd(\n        QUERYWISE_CD_FILE,\n        data_file=QUERYWISE_TRAIN_FILE,\n        canonize_column_types=True\n    )\n    learn_data = load_dataset_as_dataframe(QUERYWISE_TRAIN_FILE, columns_metadata)\n    test_data = load_dataset_as_dataframe(QUERYWISE_TEST_FILE, columns_metadata)\n    output_models = sample_gaussian_process(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_carry_model",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_carry_model():\n    prng = np.random.RandomState(seed=20230927)\n    test_features = prng.random_sample((10, 200))\n    train_pool = Pool(prng.random_sample((10, 200)), label=prng.random_sample((10,)))\n    model = CatBoostRegressor(iterations=10)\n    model.fit(train_pool)\n    as_is_predict = model.predict(test_features)\n    assert np.min(as_is_predict) < np.max(as_is_predict), 'formula produce with constant score'\n    # search for factor wich can change formula score if be replaced by constant\n    factor_id = None",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_custom_gpu_objective_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_custom_gpu_objective_metric(task_type):\n    if (task_type == 'CPU'):\n        return\n    if (task_type == 'GPU'):\n        try:\n            from numba import cuda\n        except ImportError:\n            return\n    class GPURMSEObjective(object):\n        def calc_ders_range_gpu(self, approxes, target, weights, value_output, der1_output, der2_output):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_custom_gpu_eval_metric",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_custom_gpu_eval_metric(task_type):\n    if (task_type == 'GPU'):\n        try:\n            from numba import cuda\n        except ImportError:\n            pass\n    class LoglossMetric(object):\n        def get_final_error(self, error, weight):\n            return error / (weight + 1e-38)\n        def is_max_optimal(self):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_eval_metric_correct_selection",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_eval_metric_correct_selection(task_type, add_evaluate, add_gpu_evaluate):\n    if (task_type == 'GPU'):\n        try:\n            from numba import cuda\n        except ImportError:\n            add_gpu_evaluate = False\n            pass\n    # Base class for metric mocks\n    class EvaluationMetricMockBase(object):\n        def __init__(self):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_fit_with_256_categories",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_fit_with_256_categories(task_type):\n    train = np.array([[c] * 5 for c in range(128)])\n    label = np.array([c % 2 for c in range(128)])\n    test = np.array([[c + 128] * 5 for c in range(128)])\n    test_label = label\n    model = CatBoostClassifier(iterations=5, task_type=task_type)\n    model.fit(train, y=label, eval_set=tuple((test, test_label)), cat_features=list(range(5)))\n@pytest.mark.parametrize('problem_type', PROBLEM_TYPES, ids=['problem_type=%s' % pt for pt in PROBLEM_TYPES])\n@pytest.mark.parametrize('allow_const_label', [False, True], ids=['allow_const_label=False', 'allow_const_label=True'])\ndef test_allow_const_label(task_type, problem_type, allow_const_label):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_allow_const_label",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_allow_const_label(task_type, problem_type, allow_const_label):\n    label = {\n        'binclass': True,\n        'multiclass': 'Class',\n        'regression': 0.0,\n        'ranking': 1.0\n    }[problem_type]\n    loss_function = {\n        'binclass': 'Logloss',\n        'multiclass': 'MultiClass',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_text_features_missing_border_for_feature_github_2657",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "def test_text_features_missing_border_for_feature_github_2657(task_type):\n    csv_content = \"\"\"idx,ad_text,latitude,log_closed_price\n    0,\"Amazing Freehold With No Condo Fees! This Sought After 2 Story Freehold Unit Town Offers 3 Generous Sized Bedrooms And 3.5 Baths \\\nIn A Family Friendly Neighborhood That Is Close To Parks, Schools, Shopping Amenities, And Highway Access. Enjoy The Bright Open Concept \\\nKitchen, Living, And Dining Room Provides Plenty Of Room For Relaxing Or Entertaining, Where The Kitchen Includes S.S Appliances, Quartz \\\nCountertops And A Great Island. Main Level Includes A 2-piece Bath and Sliding Glass Doors That Open To A Spacious Back Deck With Great \\\nViews Of The Park. The Second Level Features A Primary Bedroom With Walk-In Closet And 4-Piece Ensuite, Other 2 Spacious Bedrooms, A 4-Piece \\\nBath And Upper Level Laundry. Downstairs You Will fully Appreciate An Amazing Family Room With 3-Pc Washroom And An Abundance Of Light From \\\nThe Large Window And Sliding Glass Doors Walk-Out To The Oversize Private Backyard.<br/><br/><b>EXTRAS:</b> \",43.213356300000,13.652991628466498\n    1,\"Charming Big Cedar Lake Cottage! Not much comes for sale on this pristine lake. 100ft of clean waterfront and west sunsets! Year \\",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "DelayedTee",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "DelayedTee = lib.DelayedTee\nbinary_path = lib.binary_path\ndata_file = lib.data_file\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nget_limited_precision_json_diff_tool = lib.get_limited_precision_json_diff_tool\nget_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "binary_path",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "binary_path = lib.binary_path\ndata_file = lib.data_file\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nget_limited_precision_json_diff_tool = lib.get_limited_precision_json_diff_tool\nget_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "data_file = lib.data_file\nget_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nget_limited_precision_json_diff_tool = lib.get_limited_precision_json_diff_tool\nget_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_dsv_diff_tool",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "get_limited_precision_dsv_diff_tool = lib.get_limited_precision_dsv_diff_tool\nget_limited_precision_json_diff_tool = lib.get_limited_precision_json_diff_tool\nget_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_json_diff_tool",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "get_limited_precision_json_diff_tool = lib.get_limited_precision_json_diff_tool\nget_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "get_limited_precision_numpy_diff_tool",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "get_limited_precision_numpy_diff_tool = lib.get_limited_precision_numpy_diff_tool\nlocal_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "local_canonical_file = lib.local_canonical_file\npermute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "permute_dataset_columns",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "permute_dataset_columns = lib.permute_dataset_columns\nremove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "remove_time_from_json",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "remove_time_from_json = lib.remove_time_from_json\ntest_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_output_path",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "test_output_path = lib.test_output_path\ngenerate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "generate_concatenated_random_labeled_dataset",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "generate_concatenated_random_labeled_dataset = lib.generate_concatenated_random_labeled_dataset\ngenerate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "generate_random_labeled_dataset",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "generate_random_labeled_dataset = lib.generate_random_labeled_dataset\ngenerate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "generate_dataset_with_num_and_cat_features",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "generate_dataset_with_num_and_cat_features = lib.generate_dataset_with_num_and_cat_features\nload_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "load_dataset_as_dataframe",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "load_dataset_as_dataframe = lib.load_dataset_as_dataframe\nload_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "load_pool_features_as_df",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "load_pool_features_as_df = lib.load_pool_features_as_df\ncompare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "compare_with_limited_precision",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "compare_with_limited_precision = lib.compare_with_limited_precision\nis_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "is_canonical_test_run",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "is_canonical_test_run = lib.is_canonical_test_run\nfails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "fails_on_gpu",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "fails_on_gpu = pytest.mark.fails_on_gpu\nEPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "EPS = 1e-5\nBOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "BOOSTING_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "BOOSTING_TYPE = ['Ordered', 'Plain']\nOVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OVERFITTING_DETECTOR_TYPE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OVERFITTING_DETECTOR_TYPE = ['IncToDec', 'Iter']\nNONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "NONSYMMETRIC",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "NONSYMMETRIC = ['Lossguide', 'Depthwise']\nTRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "TRAIN_FILE = data_file('adult', 'train_small')\nTEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "TEST_FILE = data_file('adult', 'test_small')\nCD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CD_FILE = data_file('adult', 'train.cd')\nCD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CD_FILE_NO_TARGET",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CD_FILE_NO_TARGET = data_file('adult', 'train_no_target.cd')\nNAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "NAN_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "NAN_TRAIN_FILE = data_file('adult_nan', 'train_small')\nNAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "NAN_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "NAN_TEST_FILE = data_file('adult_nan', 'test_small')\nNAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "NAN_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "NAN_CD_FILE = data_file('adult_nan', 'train.cd')\nFLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "FLOAT_WITH_NAN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "FLOAT_WITH_NAN_FILE = data_file('float_with_nan.tsv')\nCLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CLOUDNESS_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CLOUDNESS_TRAIN_FILE = data_file('cloudness_small', 'train_small')\nCLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CLOUDNESS_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CLOUDNESS_TEST_FILE = data_file('cloudness_small', 'test_small')\nCLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CLOUDNESS_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CLOUDNESS_CD_FILE = data_file('cloudness_small', 'train.cd')\nCLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CLOUDNESS_ONLY_NUM_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CLOUDNESS_ONLY_NUM_CD_FILE = data_file('cloudness_small', 'train_float.cd')\nMULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "MULTIREGRESSION_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "MULTIREGRESSION_TRAIN_FILE = data_file('multiregression', 'train')\nMULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "MULTIREGRESSION_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "MULTIREGRESSION_TEST_FILE = data_file('multiregression', 'test')\nMULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "MULTIREGRESSION_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "MULTIREGRESSION_CD_FILE = data_file('multiregression', 'train.cd')\nSCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SCENE_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SCENE_TRAIN_FILE = data_file('scene', 'train')\nSCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SCENE_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SCENE_TEST_FILE = data_file('scene', 'test')\nSCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SCENE_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SCENE_CD_FILE = data_file('scene', 'train.cd')\nQUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_TRAIN_FILE = data_file('querywise', 'train')\nQUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_TEST_FILE = data_file('querywise', 'test')\nQUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_CD_FILE = data_file('querywise', 'train.cd')\nQUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_CD_FILE_WITH_GROUP_WEIGHT",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_CD_FILE_WITH_GROUP_WEIGHT = data_file('querywise', 'train.cd.group_weight')\nQUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_CD_FILE_WITH_GROUP_ID",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_CD_FILE_WITH_GROUP_ID = data_file('querywise', 'train.cd.query_id')\nQUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_CD_FILE_WITH_SUBGROUP_ID",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_CD_FILE_WITH_SUBGROUP_ID = data_file('querywise', 'train.cd.subgroup_id')\nQUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_TRAIN_PAIRS_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_TRAIN_PAIRS_FILE = data_file('querywise', 'train.pairs')\nQUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_TRAIN_PAIRS_FILE_WITH_PAIR_WEIGHT = data_file('querywise', 'train.pairs.weighted')\nQUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_TEST_PAIRS_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_TEST_PAIRS_FILE = data_file('querywise', 'test.pairs')\nQUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_FEATURE_NAMES_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_FEATURE_NAMES_FILE = data_file('querywise', 'train.feature_names')\nQUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUERYWISE_QUANTIZATION_BORDERS_EXAMPLE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUERYWISE_QUANTIZATION_BORDERS_EXAMPLE = data_file('querywise', 'train.quantization_borders_example')\nQUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUANTIZED_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUANTIZED_TRAIN_FILE = data_file('quantized_adult', 'train.qbin')\nQUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUANTIZED_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUANTIZED_TEST_FILE = data_file('quantized_adult', 'test.qbin')\nQUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "QUANTIZED_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "QUANTIZED_CD_FILE = data_file('quantized_adult', 'pool.cd')\nAIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_5K_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_5K_TRAIN_FILE = data_file('airlines_5K', 'train')\nAIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_5K_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_5K_TEST_FILE = data_file('airlines_5K', 'test')\nAIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_5K_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_5K_CD_FILE = data_file('airlines_5K', 'cd')\nSMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SMALL_CATEGORIAL_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SMALL_CATEGORIAL_FILE = data_file('small_categorial', 'train')\nSMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SMALL_CATEGORIAL_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SMALL_CATEGORIAL_CD_FILE = data_file('small_categorial', 'train.cd')\nBLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "BLACK_FRIDAY_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "BLACK_FRIDAY_TRAIN_FILE = data_file('black_friday', 'train')\nBLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "BLACK_FRIDAY_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "BLACK_FRIDAY_TEST_FILE = data_file('black_friday', 'test')\nBLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "BLACK_FRIDAY_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "BLACK_FRIDAY_CD_FILE = data_file('black_friday', 'cd')\nHIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "HIGGS_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "HIGGS_TRAIN_FILE = data_file('higgs', 'train_small')\nHIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "HIGGS_5K_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "HIGGS_5K_TRAIN_FILE = data_file('higgs', 'train_5K')\nHIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "HIGGS_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "HIGGS_TEST_FILE = data_file('higgs', 'test_small')\nHIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "HIGGS_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "HIGGS_CD_FILE = data_file('higgs', 'train.cd')\nROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_TRAIN_FILE = data_file('rotten_tomatoes', 'train')\nROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_TRAIN_SMALL_NO_QUOTES_FILE = data_file('rotten_tomatoes', 'train_small_no_quotes')\nROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_TEST_FILE = data_file('rotten_tomatoes', 'test')\nROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_CD_FILE = data_file('rotten_tomatoes', 'cd')\nROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_CD_BINCLASS_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_CD_BINCLASS_FILE = data_file('rotten_tomatoes', 'cd_binclass')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_TRAIN_FILE = data_file('rotten_tomatoes_small_with_embeddings', 'train')\nROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ROTTEN_TOMATOES_WITH_EMBEDDINGS_CD_BINCLASS_FILE = data_file(\n    'rotten_tomatoes_small_with_embeddings',\n    'cd_binclass'\n)\nAIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_ONEHOT_TRAIN_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_ONEHOT_TRAIN_FILE = data_file('airlines_onehot_250', 'train_small')\nAIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_ONEHOT_TEST_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_ONEHOT_TEST_FILE = data_file('airlines_onehot_250', 'test_small')\nAIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "AIRLINES_ONEHOT_CD_FILE",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "AIRLINES_ONEHOT_CD_FILE = data_file('airlines_onehot_250', 'train.cd')\nCONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CONVERT_LIGHT_GBM_PREDICTIONS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CONVERT_LIGHT_GBM_PREDICTIONS = data_file('convertions_models', 'predict')\nCONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CONVERT_RANDOM_GENERATED_TEST",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CONVERT_RANDOM_GENERATED_TEST = data_file('convertions_models', 'test')\nCONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CONVERT_MODEL_ONNX",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CONVERT_MODEL_ONNX = data_file('convertions_models', 'model_gbm.onnx')\nOUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_MODEL_PATH = 'model.bin'\nOUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_COREML_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_COREML_MODEL_PATH = 'model.mlmodel'\nOUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_CPP_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_CPP_MODEL_PATH = 'model.cpp'\nOUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_PYTHON_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_PYTHON_MODEL_PATH = 'model.py'\nOUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_JSON_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_JSON_MODEL_PATH = 'model.json'\nOUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_ONNX_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_ONNX_MODEL_PATH = 'model.onnx'\nOUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_PMML_MODEL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_PMML_MODEL_PATH = 'model.pmml'\nPREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "PREDS_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "PREDS_PATH = 'predictions.npy'\nPREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "PREDS_TXT_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "PREDS_TXT_PATH = 'predictions.txt'\nCV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CV_CSV_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CV_CSV_PATH = 'result.csv'\nFIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "FIMP_NPY_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "FIMP_NPY_PATH = 'feature_importance.npy'\nFIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "FIMP_TXT_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "FIMP_TXT_PATH = 'feature_importance.txt'\nOIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OIMP_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OIMP_PATH = 'object_importances.txt'\nSCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SCORE_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SCORE_PATH = 'score.txt'\nOUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_QUANTIZED_POOL_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "OUTPUT_QUANTIZED_POOL_PATH = 'quantized_pool.bin'\nTARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "TARGET_IDX",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "TARGET_IDX = 1\nCAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}\ndef JSON_LOG_CV_PATH(foldIdx):",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CAT_FEATURES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CAT_FEATURES = [0, 1, 2, 4, 6, 8, 9, 10, 11, 12, 16]\nCAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}\ndef JSON_LOG_CV_PATH(foldIdx):\n    return 'catboost_info/fold-' + str(foldIdx) + '/catboost_training.json'",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "CAT_COLUMNS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "CAT_COLUMNS = [0, 2, 3, 5, 7, 9, 10, 11, 12, 13, 17]\nJSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}\ndef JSON_LOG_CV_PATH(foldIdx):\n    return 'catboost_info/fold-' + str(foldIdx) + '/catboost_training.json'\nnumpy_num_data_types = [",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "JSON_LOG_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "JSON_LOG_PATH = 'catboost_info/catboost_training.json'\nNO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}\ndef JSON_LOG_CV_PATH(foldIdx):\n    return 'catboost_info/fold-' + str(foldIdx) + '/catboost_training.json'\nnumpy_num_data_types = [\n    np.int8,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "NO_RANDOM_PARAMS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "NO_RANDOM_PARAMS = {\n    'random_strength': 0,\n    'bootstrap_type': 'No',\n    'has_time': True\n}\ndef JSON_LOG_CV_PATH(foldIdx):\n    return 'catboost_info/fold-' + str(foldIdx) + '/catboost_training.json'\nnumpy_num_data_types = [\n    np.int8,\n    np.int16,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "numpy_num_data_types",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "numpy_num_data_types = [\n    np.int8,\n    np.int16,\n    np.int32,\n    np.int64,\n    np.uint8,\n    np.uint16,\n    np.uint32,\n    np.uint64,\n    np.float32,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "sparse_matrix_types",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "sparse_matrix_types = [\n    scipy.sparse.csr_matrix,\n    scipy.sparse.bsr_matrix,\n    scipy.sparse.coo_matrix,\n    scipy.sparse.csc_matrix,\n    scipy.sparse.dok_matrix,\n    scipy.sparse.lil_matrix\n]\nlabel_types = ['consecutive_integers', 'nonconsecutive_integers', 'string', 'float']\nmodel_diff_tool = binary_path(\"catboost/tools/model_comparator/model_comparator\")",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "label_types",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "label_types = ['consecutive_integers', 'nonconsecutive_integers', 'string', 'float']\nmodel_diff_tool = binary_path(\"catboost/tools/model_comparator/model_comparator\")\nnp.set_printoptions(legacy='1.13')\ndef compare_canonical_models(model, diff_limit=0):\n    return local_canonical_file(model, diff_tool=[model_diff_tool, '--diff-limit', str(diff_limit)])\ndef _check_shape(pool, object_count, features_count):\n    return pool.shape == (object_count, features_count)\ndef _check_data(data1, data2):\n    return np.all(np.isclose(data1, data2, rtol=0.001, equal_nan=True))",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "model_diff_tool",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "model_diff_tool = binary_path(\"catboost/tools/model_comparator/model_comparator\")\nnp.set_printoptions(legacy='1.13')\ndef compare_canonical_models(model, diff_limit=0):\n    return local_canonical_file(model, diff_tool=[model_diff_tool, '--diff-limit', str(diff_limit)])\ndef _check_shape(pool, object_count, features_count):\n    return pool.shape == (object_count, features_count)\ndef _check_data(data1, data2):\n    return np.all(np.isclose(data1, data2, rtol=0.001, equal_nan=True))\ndef _count_lines(afile):\n    with open(afile, 'r') as f:",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "datasets_for_test_ndarray",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "datasets_for_test_ndarray = [\n    'adult',\n    'cloudness_small',\n    'higgs',\n    'rotten_tomatoes',\n    'rotten_tomatoes_small_with_embeddings'\n]\ndef get_only_features_names(columns_metadata):\n    column_names = columns_metadata['column_names']\n    non_feature_column_indices = set(columns_metadata['non_feature_column_indices'])",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "ONNX_TEST_PARAMETERS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "ONNX_TEST_PARAMETERS = [\n    ('binclass', False),\n    ('binclass', True),\n    ('multiclass', False),\n    ('regression', False),\n    ('regression', True)\n]\n@pytest.mark.parametrize(\n    'problem_type,boost_from_average',\n    ONNX_TEST_PARAMETERS,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "Value_AcceptableAsEmpty",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "Value_AcceptableAsEmpty = [\n    ('', True),\n    ('nan', True),\n    ('NaN', True),\n    ('NAN', True),\n    ('NA', True),\n    ('Na', True),\n    ('na', True),\n    (\"#N/A\", True),\n    (\"#N/A N/A\", True),",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "IGNORED_FEATURES_DATA_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "IGNORED_FEATURES_DATA_TYPES = ['integer', 'string']\n@pytest.mark.parametrize(\n    'data_type',\n    IGNORED_FEATURES_DATA_TYPES,\n    ids=['data_type=' + data_type for data_type in IGNORED_FEATURES_DATA_TYPES]\n)\n@pytest.mark.parametrize(\n    'has_missing',\n    [False, True],\n    ids=['has_missing=%s' % has_missing for has_missing in [False, True]]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "EVAL_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "EVAL_TYPES = ['All', 'SeqRem', 'SeqAdd', 'SeqAddAndAll']\nEVAL_PROBLEMS = ['binclass', 'multiclass', 'regression', 'ranking']\n@pytest.mark.parametrize('eval_type', EVAL_TYPES, ids=['eval_type=%s' % eval_type for eval_type in EVAL_TYPES])\n@pytest.mark.parametrize('problem', EVAL_PROBLEMS, ids=['problem=%s' % problem for problem in EVAL_PROBLEMS])\ndef test_eval_features(task_type, eval_type, problem):\n    if problem == 'binclass':\n        loss_function = 'Logloss'\n        eval_metrics = ['AUC']\n        train_file = TRAIN_FILE\n        cd_file = CD_FILE",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "EVAL_PROBLEMS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "EVAL_PROBLEMS = ['binclass', 'multiclass', 'regression', 'ranking']\n@pytest.mark.parametrize('eval_type', EVAL_TYPES, ids=['eval_type=%s' % eval_type for eval_type in EVAL_TYPES])\n@pytest.mark.parametrize('problem', EVAL_PROBLEMS, ids=['problem=%s' % problem for problem in EVAL_PROBLEMS])\ndef test_eval_features(task_type, eval_type, problem):\n    if problem == 'binclass':\n        loss_function = 'Logloss'\n        eval_metrics = ['AUC']\n        train_file = TRAIN_FILE\n        cd_file = CD_FILE\n        features_to_eval = [6, 7, 8]",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "COMBINATION_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "COMBINATION_TYPES = [\n    'no',\n    'init_model_same_loss',\n    'init_model_different_losses',\n    'sum_models_same_loss',\n    'sum_models_different_losses'\n]\n@pytest.mark.parametrize(\n    'combination',\n    COMBINATION_TYPES,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "DATASET_TARGET_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "DATASET_TARGET_TYPES = ['binarized', 'not_binarized', 'multiclass']\n@pytest.mark.parametrize(\n    'dataset_target_type',\n    DATASET_TARGET_TYPES,\n    ids=['dataset_target_type=%s' % dtt for dtt in DATASET_TARGET_TYPES]\n)\ndef test_loss_function_auto_set_from_file(dataset_target_type):\n    dataset_path = {\n        'binarized': 'adult',\n        'not_binarized': 'adult_not_binarized',",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "PROBLEM_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "PROBLEM_TYPES = ['binclass', 'multiclass', 'regression', 'ranking']\ndef get_params_for_problem_type(problem_type):\n    if problem_type == 'binclass':\n        return {\n            'loss_function': 'Logloss',\n            'train_path': TRAIN_FILE,\n            'test_path': TEST_FILE,\n            'cd_path': CD_FILE,\n            'boosting_types': BOOSTING_TYPE\n        }",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "PARAM_SETS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "PARAM_SETS = ['iterations,learning_rate', 'iterations,depth,rsm']\n@pytest.mark.parametrize('problem_type', PROBLEM_TYPES, ids=['problem_type=%s' % pt for pt in PROBLEM_TYPES])\n@pytest.mark.parametrize('param_set', PARAM_SETS, ids=['param_set=%s' % pt for pt in PARAM_SETS])\ndef test_continue_learning_with_changing_params(problem_type, param_set):\n    params = get_params_for_problem_type(problem_type)\n    train_pool = Pool(params['train_path'], column_description=params['cd_path'])\n    test_pool = Pool(params['test_path'], column_description=params['cd_path'])\n    if param_set == 'iterations,learning_rate':\n        updated_params_list = [\n            {'iterations': 5, 'learning_rate': 0.3},",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "SAMPLES_AND_FEATURES_FOR_CONTINUATION",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "SAMPLES_AND_FEATURES_FOR_CONTINUATION = [\n    ('same', 'more'),\n    ('more', 'same'),\n    ('new', 'same'),\n    ('more', 'more'),\n    ('new', 'more'),\n]\n@pytest.mark.parametrize(\n    'samples,features',\n    SAMPLES_AND_FEATURES_FOR_CONTINUATION,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "FEATURES_TYPES",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "FEATURES_TYPES = ['num', 'cat', 'num_and_cat']\n@pytest.mark.parametrize(\n    'features_types',\n    FEATURES_TYPES,\n    ids=['features_types=%s' % ft for ft in FEATURES_TYPES]\n)\ndef test_save_quantized_pool_with_source_pool_from_dataframe(features_types):\n    n_train_samples = 200\n    n_test_samples = 50\n    if features_types == 'num':",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "LOAD_AND_QUANTIZE_TEST_PARAMS",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test",
        "description": "catboost.catboost.python-package.ut.medium.test",
        "peekOfCode": "LOAD_AND_QUANTIZE_TEST_PARAMS = {\n    'querywise_without_params': (\n        QUERYWISE_TRAIN_FILE,\n        QUERYWISE_CD_FILE,\n        {},  # load_params\n        {},  # quantize_params\n        True,  # subset_quantization_differs\n    ),\n    'querywise_pairs': (\n        QUERYWISE_TRAIN_FILE,",
        "detail": "catboost.catboost.python-package.ut.medium.test",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_only",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_only():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        output_path=cd_path\n    )\n    return local_canonical_file(cd_path)\ndef test_create_cd_label_and_cat_features():\n    cd_path = test_output_path('column_description')\n    create_cd(",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_and_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_and_cat_features():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        cat_features=[2, 4, 6],\n        output_path=cd_path\n    )\n    return local_canonical_file(cd_path)\ndef test_create_cd_label_cat_text_and_emb_features():\n    cd_path = test_output_path('column_description')",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_cat_text_and_emb_features",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_cat_text_and_emb_features():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        cat_features=[2, 4],\n        text_features=[8, 9, 3],\n        embedding_features=[5, 12],\n        output_path=cd_path\n    )\n    return local_canonical_file(cd_path)",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_and_feature_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_and_feature_names():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        feature_names={1: 'f0', 2: 'f1', 3: 'f2', 4: 'f3'},\n        output_path=cd_path\n    )\n    return local_canonical_file(cd_path)\ndef test_create_cd_label_cat_text_and_emb_features_with_names():\n    cd_path = test_output_path('column_description')",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_cat_text_and_emb_features_with_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_cat_text_and_emb_features_with_names():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        cat_features=[2, 4],\n        text_features=[8, 9, 3],\n        embedding_features=[5, 12],\n        feature_names={\n            1: 'f0',\n            2: 'c1',",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_create_cd_label_cat_text_and_emb_features_with_partial_names",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "description": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "peekOfCode": "def test_create_cd_label_cat_text_and_emb_features_with_partial_names():\n    cd_path = test_output_path('column_description')\n    create_cd(\n        label=0,\n        cat_features=[2, 4],\n        text_features=[8, 9, 3],\n        embedding_features=[5, 12],\n        feature_names={2: 'c1', 4: 'c3', 5: 'e4', 12: 'e11'},\n        output_path=cd_path\n    )",
        "detail": "catboost.catboost.python-package.ut.medium.test_catboost_utils",
        "documentation": {}
    },
    {
        "label": "test_wheel",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.medium.test_whl",
        "description": "catboost.catboost.python-package.ut.medium.test_whl",
        "peekOfCode": "def test_wheel():\n    try:\n        import catboost_pytest_lib  # noqa\n    except ImportError:\n        pytest.skip('test_wheel requires YA build')\n    shutil.copy(yatest.common.source_path(os.path.join(PYTHON_PACKAGE_DIR, \"mk_wheel.py\")), 'mk_wheel.py')\n    from mk_wheel import BUILD_SYSTEM, PythonTrait, make_wheel\n    py_trait = PythonTrait(BUILD_SYSTEM.YA, '', '', [])\n    so_modules = {}\n    for module_name, arc_path, dst_subdir in (",
        "detail": "catboost.catboost.python-package.ut.medium.test_whl",
        "documentation": {}
    },
    {
        "label": "PYTHON_PACKAGE_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.ut.medium.test_whl",
        "description": "catboost.catboost.python-package.ut.medium.test_whl",
        "peekOfCode": "PYTHON_PACKAGE_DIR = os.path.join(\"catboost\", \"python-package\")\ndef test_wheel():\n    try:\n        import catboost_pytest_lib  # noqa\n    except ImportError:\n        pytest.skip('test_wheel requires YA build')\n    shutil.copy(yatest.common.source_path(os.path.join(PYTHON_PACKAGE_DIR, \"mk_wheel.py\")), 'mk_wheel.py')\n    from mk_wheel import BUILD_SYSTEM, PythonTrait, make_wheel\n    py_trait = PythonTrait(BUILD_SYSTEM.YA, '', '', [])\n    so_modules = {}",
        "detail": "catboost.catboost.python-package.ut.medium.test_whl",
        "documentation": {}
    },
    {
        "label": "test_float_or_none",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.small.test_pyx_funcs",
        "description": "catboost.catboost.python-package.ut.small.test_pyx_funcs",
        "peekOfCode": "def test_float_or_none():\n    equality_pairs = (\n        (1, 1.0),\n        (3.1415, 3.1415),\n        (10000000000000000, 1e+16),\n        (\"1\", 1.0),\n        (\"3.14\", 3.14),\n    )\n    for value, canon_value in equality_pairs:\n        assert _float_or_nan(value) == np.float32(canon_value)",
        "detail": "catboost.catboost.python-package.ut.small.test_pyx_funcs",
        "documentation": {}
    },
    {
        "label": "test_quantization_calculator",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.ut.small.test_utils",
        "description": "catboost.catboost.python-package.ut.small.test_utils",
        "peekOfCode": "def test_quantization_calculator():\n    assert calculate_quantization_grid([1, 2], 2) == [1.5]\n    assert calculate_quantization_grid([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2], 1, 'Median') == []\n    assert calculate_quantization_grid([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2], 1, 'GreedyLogSum') == [1.5]\n    assert calculate_quantization_grid([11, 1, 1, 1, 1, 1, 1, 2], 2, 'GreedyLogSum') == [1.5, 6.5]",
        "detail": "catboost.catboost.python-package.ut.small.test_utils",
        "documentation": {}
    },
    {
        "label": "BUILD_SYSTEM",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "class BUILD_SYSTEM(Enum):\n    CMAKE = 1\n    YA = 2\nclass PythonVersion(object):\n    def __init__(self, major, minor, from_sandbox=False):\n        self.major = major\n        self.minor = minor\n        self.from_sandbox = from_sandbox\nclass PythonTrait(object):\n    def __init__(self, build_system, arc_root, out_root, tail_args):",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PythonVersion",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "class PythonVersion(object):\n    def __init__(self, major, minor, from_sandbox=False):\n        self.major = major\n        self.minor = minor\n        self.from_sandbox = from_sandbox\nclass PythonTrait(object):\n    def __init__(self, build_system, arc_root, out_root, tail_args):\n        self.build_system = build_system\n        self.arc_root = arc_root\n        self.out_root = out_root",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PythonTrait",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "class PythonTrait(object):\n    def __init__(self, build_system, arc_root, out_root, tail_args):\n        self.build_system = build_system\n        self.arc_root = arc_root\n        self.out_root = out_root\n        self.tail_args = tail_args\n        self.python_version = mine_system_python_ver(self.tail_args)\n        self.platform_tag_string = mine_platform_tag_string(self.tail_args)\n        self.py_config, self.lang = self.get_python_info()\n    def gen_cmd(self, arc_path, module_name, task_type):",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "mine_platform_tag_string",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def mine_platform_tag_string(tail_args):\n    target_platforms = find_target_platforms(tail_args)\n    platform_tags = transform_target_platforms(target_platforms) if target_platforms else gen_platform_tags()\n    if all([tag.startswith('macos') for tag in platform_tags]) and ('--lipo' in tail_args):\n        platform_tags = PL_MACOS_UNIVERSAL\n    return '.'.join(sorted(platform_tags))\ndef gen_platform_tags():\n    import setuptools\n    import distutils.util\n    value = distutils.util.get_platform().replace(\"linux\", \"manylinux1\")",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "gen_platform_tags",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def gen_platform_tags():\n    import setuptools\n    import distutils.util\n    value = distutils.util.get_platform().replace(\"linux\", \"manylinux1\")\n    value = value.replace('-', '_').replace('.', '_')\n    if 'macosx' in value:\n        return PL_MACOS_X86_64\n    return [value]\ndef find_target_platforms(tail_args):\n    target_platforms = []",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "find_target_platforms",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def find_target_platforms(tail_args):\n    target_platforms = []\n    arg_idx = 0\n    while arg_idx < len(tail_args):\n        arg = tail_args[arg_idx]\n        if arg.startswith('--target-platform'):\n            if len(arg) == len('--target-platform'):\n                target_platforms.append(tail_args[arg_idx + 1])\n                arg_idx += 2\n            elif arg[len('--target-platform')] == '=':",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "transform_target_platforms",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def transform_target_platforms(target_platforms):\n    platform_tags = set()\n    for platform in target_platforms:\n        if 'linux' in platform:\n            platform_tags = platform_tags.union(PL_LINUX)\n        elif 'darwin' in platform:\n            if 'arm64' in platform:\n               platform_tags = platform_tags.union(PL_MACOS_ARM64)\n            else:\n               platform_tags = platform_tags.union(PL_MACOS_X86_64)",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "get_version",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def get_version(version_py):\n    exec(compile(open(version_py, \"rb\").read(), version_py, 'exec'))\n    return locals()['VERSION']\ndef extra_opts(on_win=False):\n    if on_win:\n        py_dir = os.path.dirname(sys.executable)\n        include_path = os.path.join(py_dir, 'include')\n        py_libs = os.path.join(py_dir, 'libs', 'python{}{}.lib'.format(sys.version_info.major, sys.version_info.minor))\n        return ['-DPYTHON_INCLUDE=/I ' + include_path, '-DPYTHON_LIBRARIES=' + py_libs]\n    return []",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "extra_opts",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def extra_opts(on_win=False):\n    if on_win:\n        py_dir = os.path.dirname(sys.executable)\n        include_path = os.path.join(py_dir, 'include')\n        py_libs = os.path.join(py_dir, 'libs', 'python{}{}.lib'.format(sys.version_info.major, sys.version_info.minor))\n        return ['-DPYTHON_INCLUDE=/I ' + include_path, '-DPYTHON_LIBRARIES=' + py_libs]\n    return []\ndef find_info_in_args(tail_args):\n    def prepare_info(arg):\n        _, version = arg.split('=')",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "find_info_in_args",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def find_info_in_args(tail_args):\n    def prepare_info(arg):\n        _, version = arg.split('=')\n        major, minor = version.split('.')\n        py_config = 'python-config' if major == '2' else 'python3-config'\n        lang = 'cp{major}{minor}'.format(major=major, minor=minor)\n        return py_config, lang\n    for arg in tail_args:\n        if 'USE_SYSTEM_PYTHON' in arg:\n            return prepare_info(arg)",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "mine_system_python_ver",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def mine_system_python_ver(tail_args):\n    for arg in tail_args:\n        if 'USE_SYSTEM_PYTHON' in arg:\n            _, version = arg.split('=')\n            major, minor = version.split('.')\n            return PythonVersion(int(major), int(minor), from_sandbox=True)\n    return PythonVersion(sys.version_info.major, sys.version_info.minor)\ndef allow_to_write(path):\n    st = os.stat(path)\n    os.chmod(path, st.st_mode | stat.S_IWRITE)",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "allow_to_write",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def allow_to_write(path):\n    st = os.stat(path)\n    os.chmod(path, st.st_mode | stat.S_IWRITE)\ndef calc_sha256_digest(filename):\n    sha256 = hashlib.sha256()\n    with open(filename, 'rb') as f:\n        while True:\n            chunk_size = 65536\n            data = f.read(chunk_size)\n            if not data:",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "calc_sha256_digest",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def calc_sha256_digest(filename):\n    sha256 = hashlib.sha256()\n    with open(filename, 'rb') as f:\n        while True:\n            chunk_size = 65536\n            data = f.read(chunk_size)\n            if not data:\n                break\n            sha256.update(data)\n    return sha256.digest()",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "make_record",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def make_record(dir_path, dist_info_dir):\n    record_filename = os.path.join(dist_info_dir, 'RECORD')\n    with open(record_filename, 'w') as record:\n        wheel_items = []\n        for root, dirnames, filenames in os.walk(dir_path):\n            for filename in filenames:\n                wheel_items.append(os.path.join(root, filename))\n        tmp_dir_length = len(dir_path) + 1\n        for item in wheel_items:\n            if item != record_filename:",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "make_wheel",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def make_wheel(wheel_name, pkg_name, ver, build_system, arc_root, dst_so_modules, should_build_widget):\n    dir_path = tempfile.mkdtemp()\n    try:\n        # Create py files\n        os.makedirs(os.path.join(dir_path, pkg_name))\n        catboost_package_dir = os.path.join(arc_root, 'catboost/python-package')\n        for file_name in ['__init__.py', 'version.py', 'core.py', 'datasets.py', 'utils.py', 'eval', 'widget/__init__.py',\n                          'widget/ipythonwidget.py','widget/metrics_plotter.py', 'widget/callbacks.py',\n                          'metrics.py', 'monoforest.py', 'plot_helpers.py', 'text_processing.py']:\n            src = os.path.join(catboost_package_dir, 'catboost', file_name)",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "build_widget",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def build_widget(arc_root):\n    js_dir = os.path.join(arc_root, 'catboost', 'python-package', 'catboost', 'widget', 'js')\n    subprocess.check_call('\"{}\" -m pip install -U jupyterlab'.format(sys.executable), shell=True, cwd=js_dir)\n    subprocess.check_call('yarn clean', shell=True, cwd=js_dir)\n    subprocess.check_call('yarn install', shell=True, cwd=js_dir)\n    subprocess.check_call('yarn build', shell=True, cwd=js_dir)\n    # workaround for https://github.com/yarnpkg/yarn/issues/6685\n    for directory in glob.glob(os.path.join(tempfile.gettempdir(), 'yarn--*')):\n        shutil.rmtree(directory, ignore_errors=True)\ndef build(build_system, arc_root, out_root, tail_args, should_build_widget, should_build_with_cuda):",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "def build(build_system, arc_root, out_root, tail_args, should_build_widget, should_build_with_cuda):\n    os.chdir(os.path.join(arc_root, 'catboost', 'python-package', 'catboost'))\n    py_trait = PythonTrait(build_system, arc_root, out_root, tail_args)\n    ver = get_version(os.path.join(os.getcwd(), 'version.py'))\n    pkg_name = os.environ.get('CATBOOST_PACKAGE_NAME', 'catboost')\n    for task_type in (['GPU', 'CPU'] if should_build_with_cuda else ['CPU']):\n        try:\n            print('Trying to build {} version'.format(task_type), file=sys.stderr)\n            dst_so_modules = {}\n            for module_name, arc_path, dst_subdir in (",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "sys.dont_write_bytecode",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "sys.dont_write_bytecode = True\nPL_LINUX = ['manylinux1_x86_64']\nPL_MACOS_X86_64 = [\n    'macosx_10_6_intel',\n    'macosx_10_9_intel',\n    'macosx_10_9_x86_64',\n    'macosx_10_10_intel',\n    'macosx_10_10_x86_64'\n]\nPL_MACOS_ARM64 = ['macosx_11_0_arm64', 'macosx_12_0_arm64']",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PL_LINUX",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "PL_LINUX = ['manylinux1_x86_64']\nPL_MACOS_X86_64 = [\n    'macosx_10_6_intel',\n    'macosx_10_9_intel',\n    'macosx_10_9_x86_64',\n    'macosx_10_10_intel',\n    'macosx_10_10_x86_64'\n]\nPL_MACOS_ARM64 = ['macosx_11_0_arm64', 'macosx_12_0_arm64']\nPL_MACOS_UNIVERSAL = ['macosx_10_6_universal2']",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PL_MACOS_X86_64",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "PL_MACOS_X86_64 = [\n    'macosx_10_6_intel',\n    'macosx_10_9_intel',\n    'macosx_10_9_x86_64',\n    'macosx_10_10_intel',\n    'macosx_10_10_x86_64'\n]\nPL_MACOS_ARM64 = ['macosx_11_0_arm64', 'macosx_12_0_arm64']\nPL_MACOS_UNIVERSAL = ['macosx_10_6_universal2']\nPL_WIN = ['win_amd64']",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PL_MACOS_ARM64",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "PL_MACOS_ARM64 = ['macosx_11_0_arm64', 'macosx_12_0_arm64']\nPL_MACOS_UNIVERSAL = ['macosx_10_6_universal2']\nPL_WIN = ['win_amd64']\nclass BUILD_SYSTEM(Enum):\n    CMAKE = 1\n    YA = 2\nclass PythonVersion(object):\n    def __init__(self, major, minor, from_sandbox=False):\n        self.major = major\n        self.minor = minor",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PL_MACOS_UNIVERSAL",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "PL_MACOS_UNIVERSAL = ['macosx_10_6_universal2']\nPL_WIN = ['win_amd64']\nclass BUILD_SYSTEM(Enum):\n    CMAKE = 1\n    YA = 2\nclass PythonVersion(object):\n    def __init__(self, major, minor, from_sandbox=False):\n        self.major = major\n        self.minor = minor\n        self.from_sandbox = from_sandbox",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "PL_WIN",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.mk_wheel",
        "description": "catboost.catboost.python-package.mk_wheel",
        "peekOfCode": "PL_WIN = ['win_amd64']\nclass BUILD_SYSTEM(Enum):\n    CMAKE = 1\n    YA = 2\nclass PythonVersion(object):\n    def __init__(self, major, minor, from_sandbox=False):\n        self.major = major\n        self.minor = minor\n        self.from_sandbox = from_sandbox\nclass PythonTrait(object):",
        "detail": "catboost.catboost.python-package.mk_wheel",
        "documentation": {}
    },
    {
        "label": "ExtensionWithSrcAndDstSubPath",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class ExtensionWithSrcAndDstSubPath(Extension):\n    def __init__(self, name, cmake_build_sub_path, dst_sub_path):\n        super().__init__(name, sources=[])\n        self.cmake_build_sub_path = cmake_build_sub_path\n        self.dst_sub_path = dst_sub_path\ndef setup_hnsw_submodule(argv, extensions):\n    \"\"\"\n    Does not respect --dry-run because main setup.py commands won't work correctly without this submodule setup\n    \"\"\"\n    cmake_build_sub_path = os.path.join('library', 'python', 'hnsw', 'hnsw')",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "OptionsHelper",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class OptionsHelper(object):\n    @staticmethod\n    def get_user_options(extra_options_classes):\n        return list(itertools.chain.from_iterable([cls.options for cls in extra_options_classes]))\n    @staticmethod\n    def initialize_options(command):\n        for extra_options_class in command.__class__.extra_options_classes:\n            extra_options_class.initialize_options(command)\n    @staticmethod\n    def finalize_options(command):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "HNSWOptions",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class HNSWOptions(object):\n    options = [\n        ('with-hnsw', None, emph('Build with hnsw as catboost submodule')),\n    ]\n    @staticmethod\n    def initialize_options(command):\n        command.with_hnsw = False\n    @staticmethod\n    def finalize_options(command):\n        pass",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "WidgetOptions",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class WidgetOptions(object):\n    options = [\n        ('no-widget', None, emph('Disable Jupyter visualization widget support that is enabled by default')),\n        ('prebuilt-widget', None, emph('Do not rebuild already built widget in \"build-generated\" directory'))\n    ]\n    @staticmethod\n    def initialize_options(command):\n        command.no_widget = False\n        command.prebuilt_widget = False\n    @staticmethod",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "BuildExtOptions",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class BuildExtOptions(object):\n    options = [\n        ('with-cuda=',\n         None,\n         emph(\n            'Path to CUDA root dir '\n            + '(useful if CUDA_ROOT or CUDA_PATH is not specified or a particular CUDA version is needed)'\n         )\n        ),\n        ('no-cuda', None, emph('Build without CUDA support even if CUDA is available')),",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class build(_build):\n    extra_options_classes = [HNSWOptions, WidgetOptions, BuildExtOptions]\n    user_options = _build.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _build.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _build.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n    def run(self):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "bdist",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class bdist(_bdist):\n    extra_options_classes = [HNSWOptions, WidgetOptions, BuildExtOptions]\n    user_options = _bdist.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _bdist.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _bdist.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n    def run(self):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "bdist_wheel",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class bdist_wheel(_bdist_wheel):\n    extra_options_classes = [HNSWOptions, WidgetOptions, BuildExtOptions]\n    user_options = _bdist_wheel.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _bdist_wheel.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _bdist_wheel.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n    def run(self):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class build_ext(_build_ext):\n    extra_options_classes = [HNSWOptions, BuildExtOptions]\n    user_options = _build_ext.user_options +  OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _build_ext.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _build_ext.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n    @staticmethod",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "build_widget",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class build_widget(setuptools.Command, setuptools.command.build.SubCommand):\n    description = \"build CatBoost Jupyter visualization widget (requires yarn (https://yarnpkg.com/))\"\n    user_options = [\n        ('build-generated=', 'b', \"directory for built modules\"),\n        ('prebuilt-widget', None, emph('Do not rebuild already built widget in \"build-generated\" directory'))\n    ]\n    boolean_options = ['inplace']\n    inplace: bool = False\n    def initialize_options(self):\n        self.editable_mode = False",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "develop",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class develop(_develop):\n    extra_options_classes = [HNSWOptions, WidgetOptions, BuildExtOptions]\n    user_options = _develop.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _develop.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _develop.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n        if not self.no_widget:",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "install_data",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class install_data(_install_data):\n    extra_options_classes = [WidgetOptions]\n    user_options = _install.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _install_data.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _install_data.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n        if not self.no_widget:",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class install(_install):\n    extra_options_classes = [HNSWOptions, WidgetOptions, BuildExtOptions]\n    user_options = _install.user_options + OptionsHelper.get_user_options(extra_options_classes)\n    def initialize_options(self):\n        _install.initialize_options(self)\n        OptionsHelper.initialize_options(self)\n    def finalize_options(self):\n        _install.finalize_options(self)\n        OptionsHelper.finalize_options(self)\n    def has_data(self):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "sdist",
        "kind": 6,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "class sdist(_sdist):\n    def make_release_tree(self, base_dir, files):\n        _sdist.make_release_tree(self, base_dir, files)\n        copy_catboost_sources(\n            os.path.join(SETUP_DIR, '..', '..'),\n            os.path.join(base_dir, EXT_SRC),\n            verbose=self.distribution.verbose,\n            dry_run=self.distribution.dry_run,\n        )\nif __name__ == '__main__':",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_topsrc_dir",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def get_topsrc_dir():\n    if os.path.exists(os.path.join(SETUP_DIR, PKG_INFO)):\n        return os.path.join(SETUP_DIR, EXT_SRC)\n    else:\n        return os.path.abspath(os.path.join(SETUP_DIR, '..', '..'))\nclass ExtensionWithSrcAndDstSubPath(Extension):\n    def __init__(self, name, cmake_build_sub_path, dst_sub_path):\n        super().__init__(name, sources=[])\n        self.cmake_build_sub_path = cmake_build_sub_path\n        self.dst_sub_path = dst_sub_path",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "setup_hnsw_submodule",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def setup_hnsw_submodule(argv, extensions):\n    \"\"\"\n    Does not respect --dry-run because main setup.py commands won't work correctly without this submodule setup\n    \"\"\"\n    cmake_build_sub_path = os.path.join('library', 'python', 'hnsw', 'hnsw')\n    dst_sub_path = os.path.join('catboost', 'hnsw')\n    hnsw_submodule_dir = os.path.join(SETUP_DIR, dst_sub_path)\n    verbose = '--verbose' in argv\n    if '--with-hnsw' in argv:\n        extensions.append(ExtensionWithSrcAndDstSubPath('_hnsw', cmake_build_sub_path, dst_sub_path))",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_setup_requires",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def get_setup_requires(argv):\n    setup_requires = ['wheel']\n    if ('build_widget' in argv) or (not ('--no-widget' in argv)):\n        setup_requires += ['jupyterlab (>=3.0.6, == 3.*)']\n    return setup_requires\ndef get_all_cmake_lists(topdir, sub_path):\n    return [\n        os.path.join(sub_path, f) for f in os.listdir(os.path.join(topdir, sub_path))\n        if f.startswith('CMakeLists')\n    ]",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_all_cmake_lists",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def get_all_cmake_lists(topdir, sub_path):\n    return [\n        os.path.join(sub_path, f) for f in os.listdir(os.path.join(topdir, sub_path))\n        if f.startswith('CMakeLists')\n    ]\ndef get_all_files_wo_built_artifacts(topdir, sub_path, exclude_regexp_str, verbose):\n    exclude_regexp = re.compile(exclude_regexp_str)\n    result = []\n    os.chdir(topdir)\n    try:",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_all_files_wo_built_artifacts",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def get_all_files_wo_built_artifacts(topdir, sub_path, exclude_regexp_str, verbose):\n    exclude_regexp = re.compile(exclude_regexp_str)\n    result = []\n    os.chdir(topdir)\n    try:\n        for dirpath, dirnames, filenames in os.walk(sub_path, followlinks=True, topdown=True):\n            i = 0\n            while i < len(dirnames):\n                sub_path = os.path.join(dirpath, dirnames[i])\n                if exclude_regexp.match(sub_path):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "copy_catboost_sources",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def copy_catboost_sources(topdir, pkgdir, verbose, dry_run):\n    topnames = [\n        'AUTHORS', 'LICENSE', 'CONTRIBUTING.md', 'README.md', 'RELEASE.md',\n        'conanfile.py',\n        'build',\n        os.path.join('catboost', 'base_defs.pxd'),\n        os.path.join('catboost', 'cuda'),\n        os.path.join('catboost', 'idl'),\n        os.path.join('catboost', 'libs'),\n        os.path.join('catboost', 'private'),",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "emph",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def emph(s):\n    return '\\x1b[32m{}\\x1b[0m'.format(s)\ndef get_catboost_version():\n    version_py = os.path.join('catboost', 'version.py')\n    exec(compile(open(version_py).read(), version_py, 'exec'))\n    return locals()['VERSION']\nclass OptionsHelper(object):\n    @staticmethod\n    def get_user_options(extra_options_classes):\n        return list(itertools.chain.from_iterable([cls.options for cls in extra_options_classes]))",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_catboost_version",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def get_catboost_version():\n    version_py = os.path.join('catboost', 'version.py')\n    exec(compile(open(version_py).read(), version_py, 'exec'))\n    return locals()['VERSION']\nclass OptionsHelper(object):\n    @staticmethod\n    def get_user_options(extra_options_classes):\n        return list(itertools.chain.from_iterable([cls.options for cls in extra_options_classes]))\n    @staticmethod\n    def initialize_options(command):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "spawn_wo_exe",
        "kind": 2,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "def spawn_wo_exe(cmd_str, dry_run):\n    log.info(cmd_str)\n    if dry_run:\n        return\n    subprocess.check_call(cmd_str, shell=True)\nclass build_widget(setuptools.Command, setuptools.command.build.SubCommand):\n    description = \"build CatBoost Jupyter visualization widget (requires yarn (https://yarnpkg.com/))\"\n    user_options = [\n        ('build-generated=', 'b', \"directory for built modules\"),\n        ('prebuilt-widget', None, emph('Do not rebuild already built widget in \"build-generated\" directory'))",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "SETUP_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "SETUP_DIR = os.path.abspath(os.path.dirname(__file__))\nPKG_INFO = 'PKG-INFO'\nEXT_SRC = 'catboost_all_src'\ndef get_topsrc_dir():\n    if os.path.exists(os.path.join(SETUP_DIR, PKG_INFO)):\n        return os.path.join(SETUP_DIR, EXT_SRC)\n    else:\n        return os.path.abspath(os.path.join(SETUP_DIR, '..', '..'))\nclass ExtensionWithSrcAndDstSubPath(Extension):\n    def __init__(self, name, cmake_build_sub_path, dst_sub_path):",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "PKG_INFO",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "PKG_INFO = 'PKG-INFO'\nEXT_SRC = 'catboost_all_src'\ndef get_topsrc_dir():\n    if os.path.exists(os.path.join(SETUP_DIR, PKG_INFO)):\n        return os.path.join(SETUP_DIR, EXT_SRC)\n    else:\n        return os.path.abspath(os.path.join(SETUP_DIR, '..', '..'))\nclass ExtensionWithSrcAndDstSubPath(Extension):\n    def __init__(self, name, cmake_build_sub_path, dst_sub_path):\n        super().__init__(name, sources=[])",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "EXT_SRC",
        "kind": 5,
        "importPath": "catboost.catboost.python-package.setup",
        "description": "catboost.catboost.python-package.setup",
        "peekOfCode": "EXT_SRC = 'catboost_all_src'\ndef get_topsrc_dir():\n    if os.path.exists(os.path.join(SETUP_DIR, PKG_INFO)):\n        return os.path.join(SETUP_DIR, EXT_SRC)\n    else:\n        return os.path.abspath(os.path.join(SETUP_DIR, '..', '..'))\nclass ExtensionWithSrcAndDstSubPath(Extension):\n    def __init__(self, name, cmake_build_sub_path, dst_sub_path):\n        super().__init__(name, sources=[])\n        self.cmake_build_sub_path = cmake_build_sub_path",
        "detail": "catboost.catboost.python-package.setup",
        "documentation": {}
    },
    {
        "label": "get_logo_path",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "def get_logo_path():\n    possible_locations = ['../../../../../../../', '../../../../../../github_toplevel']\n    for location in possible_locations:\n        full_path = os.path.join(location, 'logo', 'catboost.png')\n        if os.path.exists(full_path):\n            return full_path\n    raise Exeception('CatBoost logo path is not found')\nhtml_logo = get_logo_path()\nhtml_theme_options = {\n    \"navbar_start\": [\"navbar-logo\"],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "project = 'Catboost for PySpark'\ncopyright = '2021, CatBoost developers'\nauthor = 'CatBoost developers'\n# The full version, including alpha/beta/rc tags\nrelease = '1.0.0'\n# -- General configuration ---------------------------------------------------\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "copyright = '2021, CatBoost developers'\nauthor = 'CatBoost developers'\n# The full version, including alpha/beta/rc tags\nrelease = '1.0.0'\n# -- General configuration ---------------------------------------------------\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.viewcode',",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "author = 'CatBoost developers'\n# The full version, including alpha/beta/rc tags\nrelease = '1.0.0'\n# -- General configuration ---------------------------------------------------\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.viewcode',\n    'sphinx_automodapi.automodapi',",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "release = '1.0.0'\n# -- General configuration ---------------------------------------------------\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.viewcode',\n    'sphinx_automodapi.automodapi',\n    'numpydoc'\n]",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "extensions = [\n    'sphinx.ext.viewcode',\n    'sphinx_automodapi.automodapi',\n    'numpydoc'\n]\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "templates_path = ['_templates']\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'pydata_sphinx_theme'\n# Add any paths that contain custom static files (such as style sheets) here,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "exclude_patterns = []\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'pydata_sphinx_theme'\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "html_theme = 'pydata_sphinx_theme'\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\ndef get_logo_path():",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "html_static_path = ['_static']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\ndef get_logo_path():\n    possible_locations = ['../../../../../../../', '../../../../../../github_toplevel']\n    for location in possible_locations:\n        full_path = os.path.join(location, 'logo', 'catboost.png')\n        if os.path.exists(full_path):",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\ndef get_logo_path():\n    possible_locations = ['../../../../../../../', '../../../../../../github_toplevel']\n    for location in possible_locations:\n        full_path = os.path.join(location, 'logo', 'catboost.png')\n        if os.path.exists(full_path):\n            return full_path\n    raise Exeception('CatBoost logo path is not found')",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "html_logo",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "html_logo = get_logo_path()\nhtml_theme_options = {\n    \"navbar_start\": [\"navbar-logo\"],\n    \"navbar_center\": [],\n    \"navbar_end\": [\"navbar-icon-links\"]\n}\n# -- Options for automodapi ----------------------------------------------\nnumpydoc_show_class_members = False",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "html_theme_options",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "html_theme_options = {\n    \"navbar_start\": [\"navbar-logo\"],\n    \"navbar_center\": [],\n    \"navbar_end\": [\"navbar-icon-links\"]\n}\n# -- Options for automodapi ----------------------------------------------\nnumpydoc_show_class_members = False",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "numpydoc_show_class_members",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "description": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "peekOfCode": "numpydoc_show_class_members = False",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.docs.python.source.conf",
        "documentation": {}
    },
    {
        "label": "binary_classification_simple_on_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def binary_classification_simple_on_dataframe():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, 1),\n                (0.97, 0.82, 0.33, 2),\n                (0.13, 0.22, 0.23, 2),\n                (0.14, 0.18, 0.1, 1),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "simple_binary_classification",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def simple_binary_classification():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, \"0\", \"query0\", 1.0, \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0\", \"query0\", 1.0, \"site22\", 0.18),\n                (0.13, 0.22, 0.23, \"1\", \"query1\", 0.0, \"Site9\", 1.0),\n                (0.14, 0.18, 0.1, \"1\", \"Query 2\", 0.5, \"site12\", 0.45),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "binary_classification_with_target_border",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def binary_classification_with_target_border():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, 0.12),\n                (0.97, 0.82, 0.33, 0.1),\n                (0.13, 0.22, 0.23, 0.7),\n                (0.14, 0.18, 0.1, 0.33),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "binary_classification_with_class_weights_map",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def binary_classification_with_class_weights_map():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, 0),\n                (0.97, 0.82, 0.33, 1),\n                (0.13, 0.22, 0.23, 1),\n                (0.14, 0.18, 0.1, 0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "binary_classification_with_weights",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def binary_classification_with_weights():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, 0, 1.0),\n                (0.97, 0.82, 0.33, 1, 2.0),\n                (0.13, 0.22, 0.23, 1, 2.0),\n                (0.14, 0.18, 0.1, 0, 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "binary_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def binary_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_sets_paths = [tempfile.mkstemp(prefix='catboost_eval_set_')[1] for i in range(2)]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, 0.72, 0, 0, 0, \"0\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, -0.7,   1, 1, 0, \"1\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, 0.18, 0, 2, 1, \"1\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "simple_multi_classification",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def simple_multi_classification():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, \"1\", \"query1\", 0.0, \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, \"2\", \"query0\", 1.0, \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0\", \"query0\", 1.0, \"site22\", 0.18),\n                (0.9, 0.67, 0.17, \"0\", \"Query 2\", 0.5, \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "multi_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def multi_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_sets_paths = [tempfile.mkstemp(prefix='catboost_eval_set_')[1] for i in range(2)]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, 0.72, 0, 0, 0, \"0\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, -0.7,   1, 1, 0, \"1\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, 0.18, 0, 2, 1, \"2\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "peekOfCode": "def main():\n    binary_classification_simple_on_dataframe()\n    simple_binary_classification()\n    binary_classification_with_target_border()\n    binary_classification_with_class_weights_map()\n    binary_classification_with_weights()\n    binary_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets()\n    simple_multi_classification()\n    multi_classification_with_num_and_one_hot_and_ctr_cat_features_with_eval_sets()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "simple1",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def simple1():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0.22\", \"query0\", \"site22\", 0.18),\n                (0.9, 0.67, 0.17, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "simple_on_dataframe",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def simple_on_dataframe():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.1, 0.2, 0.11, 0.12),\n                (0.97, 0.82, 0.33, 1.1),\n                (0.13, 0.22, 0.23, 2.1),\n                (0.14, 0.18, 0.1, 0.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "with_eval_set",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def with_eval_set():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_set_path = tempfile.mkstemp(prefix='catboost_eval_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0.22\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "with_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def with_eval_sets():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_sets_paths = [tempfile.mkstemp(prefix='catboost_eval_set_')[1] for i in range(2)]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0.22\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "overfitting_detector",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def overfitting_detector():\n    data_path = os.path.join(CATBOOST_TEST_DATA_DIR, \"querywise\")\n    learn_set_path = os.path.join(data_path, \"train.with_groups_sorted_by_group_id_hash\")\n    eval_set_path = os.path.join(data_path, \"test\")\n    cd_path = os.path.join(data_path, \"train.cd\")\n    eval_pool = cb.Pool(eval_set_path, column_description=cd_path)\n    result = {}\n    for od_type in ['IncToDec', 'Iter']:\n        if od_type == 'Iter':\n            od_params = ['--od-wait', '20']",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def params():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, \"0.22\", \"query0\", \"site22\", 0.18),\n                (0.9, 0.67, 0.17, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "one_hot_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def one_hot_cat_features():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (1, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),\n                (1, 2, 2, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "num_and_one_hot_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def num_and_one_hot_cat_features():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, 0.72, 0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, -0.7, 1, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, 0.18, 0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),\n                (0.9, 0.67, 0.17, 0.0, 1, 2, 2, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "num_and_one_hot_cat_features_with_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def num_and_one_hot_cat_features_with_eval_sets():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_sets_paths = [tempfile.mkstemp(prefix='catboost_eval_set_')[1] for i in range(2)]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, 0.72, 0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, -0.7, 1, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, 0.18, 0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "one_hot_and_ctr_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def one_hot_and_ctr_cat_features():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (1, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),\n                (1, 2, 2, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "num_and_one_hot_and_ctr_cat_features_with_eval_sets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def num_and_one_hot_and_ctr_cat_features_with_eval_sets():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    eval_sets_paths = [tempfile.mkstemp(prefix='catboost_eval_set_')[1] for i in range(2)]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0.13, 0.22, 0.23, 0.72, 0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0.1, 0.2, 0.11, -0.7,   1, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0.97, 0.82, 0.33, 0.18, 0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "constant_and_ctr_cat_features",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def constant_and_ctr_cat_features():\n    learn_set_path = tempfile.mkstemp(prefix='catboost_learn_set_')[1]\n    cd_path = tempfile.mkstemp(prefix='catboost_cd_')[1]\n    try:\n        utils.object_list_to_tsv(\n            [\n                (0, 0, 0, \"0.34\", \"query1\", \"Site9\", 1.0),\n                (0, 1, 0, \"0.12\", \"query0\", \"site1\", 0.12),\n                (0, 2, 1, \"0.22\", \"query0\", \"site22\", 0.18),\n                (0, 2, 2, \"0.01\", \"Query 2\", \"site22\", 1.0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "with_pairs",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def with_pairs():\n    top_k_in_MAP = 3\n    eval_metric = f'MAP:top={top_k_in_MAP}'\n    data_path = os.path.join(CATBOOST_TEST_DATA_DIR, \"querywise\")\n    learn_set_path = os.path.join(data_path, \"train\")\n    learn_set_pairs_path_with_scheme = 'dsv-grouped://' + os.path.join(data_path, \"train.grouped_pairs\")\n    cd_path = os.path.join(data_path, \"train.cd\")\n    model = utils.run_dist_train(\n        ['--iterations', '25',\n         '--loss-function', 'PairLogit',",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "with_pairs_with_eval_set",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def with_pairs_with_eval_set():\n    top_k_in_MAP = 2\n    eval_metric = f'MAP:top={top_k_in_MAP}'\n    data_path = os.path.join(CATBOOST_TEST_DATA_DIR, \"querywise\")\n    learn_set_path = os.path.join(data_path, \"train\")\n    learn_set_pairs_path_with_scheme = 'dsv-grouped://' + os.path.join(data_path, \"train.grouped_pairs\")\n    eval_set_path = os.path.join(data_path, \"test\")\n    eval_set_pairs_path_with_scheme = 'dsv-grouped://' + os.path.join(data_path, \"test.grouped_pairs\")\n    cd_path = os.path.join(data_path, \"train.cd\")\n    model = utils.run_dist_train(",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "peekOfCode": "def main():\n    simple1()\n    simple_on_dataframe()\n    with_eval_set()\n    with_eval_sets()\n    overfitting_detector()\n    params()\n    one_hot_cat_features()\n    num_and_one_hot_cat_features()\n    num_and_one_hot_cat_features_with_eval_sets()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "CATBOOST_APP_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "peekOfCode": "CATBOOST_APP_PATH = '../../../../../../app/catboost'\nCATBOOST_TEST_DATA_DIR = '../../../../../../pytest/data'\nOUTPUT_DIR = '../../test/resources/canondata'",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "documentation": {}
    },
    {
        "label": "CATBOOST_TEST_DATA_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "peekOfCode": "CATBOOST_TEST_DATA_DIR = '../../../../../../pytest/data'\nOUTPUT_DIR = '../../test/resources/canondata'",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "peekOfCode": "OUTPUT_DIR = '../../test/resources/canondata'",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.config",
        "documentation": {}
    },
    {
        "label": "prediction_values_change",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def prediction_values_change():\n    dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'higgs')\n    learn_set_path = os.path.join(dataset_dir, \"train_small\")\n    cd_path = os.path.join(dataset_dir, \"train.cd\")\n    model = utils.run_dist_train(\n        ['--iterations', '20',\n         '--loss-function', 'RMSE',\n         '--learn-set', learn_set_path,\n         '--cd', cd_path\n        ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "loss_function_change",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def loss_function_change():\n    dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'querywise')\n    learn_set_path = os.path.join(dataset_dir, \"train.with_groups_sorted_by_group_id_hash\")\n    cd_path = os.path.join(dataset_dir, \"train.cd\")\n    model = utils.run_dist_train(\n        ['--iterations', '20',\n         '--loss-function', 'QueryRMSE',\n         '--learn-set', learn_set_path,\n         '--cd', cd_path\n        ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "interaction",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def interaction():\n    dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'querywise')\n    learn_set_path = os.path.join(dataset_dir, \"train.with_groups_sorted_by_group_id_hash\")\n    cd_path = os.path.join(dataset_dir, \"train.cd\")\n    model = utils.run_dist_train(\n        ['--iterations', '20',\n         '--loss-function', 'QueryRMSE',\n         '--learn-set', learn_set_path,\n         '--cd', cd_path\n        ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "shap_values",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def shap_values():\n    result = {}\n    for problem_type in ['Regression', 'BinClass', 'MultiClass']:\n        if problem_type == 'Regression':\n            dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'querywise')\n            learn_set_path = os.path.join(dataset_dir, \"train.with_groups_sorted_by_group_id_hash\")\n            cd_path = os.path.join(dataset_dir, \"train.cd\")\n            loss_function = 'QueryRMSE'\n            additional_train_params = []\n            model_class = cb.CatBoostRegressor",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "prediction_diff",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def prediction_diff():\n    dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'higgs')\n    learn_set_path = os.path.join(dataset_dir, \"train_small\")\n    cd_path = os.path.join(dataset_dir, \"train.cd\")\n    model = utils.run_dist_train(\n        ['--iterations', '20',\n         '--loss-function', 'RMSE',\n         '--learn-set', learn_set_path,\n         '--cd', cd_path\n        ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "shap_interaction_values",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def shap_interaction_values():\n    result = {}\n    for problem_type in ['Regression', 'BinClass', 'MultiClass']:\n        if problem_type == 'Regression':\n            dataset_dir = os.path.join(CATBOOST_TEST_DATA_DIR, 'higgs')\n            learn_set_path = os.path.join(dataset_dir, \"train_small\")\n            cd_path = os.path.join(dataset_dir, \"train.cd\")\n            loss_function = 'RMSE'\n            additional_train_params = []\n            model_class = cb.CatBoostRegressor",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "peekOfCode": "def main():\n    prediction_values_change()\n    loss_function_change()\n    interaction()\n    shap_values()\n    prediction_diff()\n    shap_interaction_values()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "object_list_to_tsv",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "peekOfCode": "def object_list_to_tsv(object_list, file_path):\n    with open(file_path, 'w') as f:\n        for object_data in object_list:\n            f.write('\\t'.join(map(str, object_data)) + '\\n')\ndef get_free_port():\n    with socketserver.TCPServer((\"localhost\", 0), None) as s:\n        return s.server_address[1]\ndef is_port_free(port, sock_type=socket.SOCK_STREAM):\n    sock = socket.socket(socket.AF_INET6, sock_type)\n    try:",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "documentation": {}
    },
    {
        "label": "get_free_port",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "peekOfCode": "def get_free_port():\n    with socketserver.TCPServer((\"localhost\", 0), None) as s:\n        return s.server_address[1]\ndef is_port_free(port, sock_type=socket.SOCK_STREAM):\n    sock = socket.socket(socket.AF_INET6, sock_type)\n    try:\n        sock.bind(('::', port))\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    except socket.error as e:\n        if e.errno == errno.EADDRINUSE:",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "documentation": {}
    },
    {
        "label": "is_port_free",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "peekOfCode": "def is_port_free(port, sock_type=socket.SOCK_STREAM):\n    sock = socket.socket(socket.AF_INET6, sock_type)\n    try:\n        sock.bind(('::', port))\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    except socket.error as e:\n        if e.errno == errno.EADDRINUSE:\n            return False\n        raise\n    finally:",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "documentation": {}
    },
    {
        "label": "run_dist_train",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "peekOfCode": "def run_dist_train(cmd_line_params_list, model_class=cb.CatBoost, worker_count=1):\n    hosts_path = tempfile.mkstemp(prefix='catboost_dist_train_hosts_')[1]\n    model_path = tempfile.mkstemp(prefix='catboost_model_')[1]\n    train_dir = tempfile.mkdtemp(prefix='catboost_train_dir_')\n    try:\n        ports = []\n        workers = []\n        for i in range(worker_count):\n            ports.append(get_free_port())\n        with open(hosts_path, 'w') as hosts:",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "documentation": {}
    },
    {
        "label": "run_local_train",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "peekOfCode": "def run_local_train(cmd_line_params_list, model_class=cb.CatBoost):\n    model_path = tempfile.mkstemp(prefix='catboost_model_')[1]\n    train_dir = tempfile.mkdtemp(prefix='catboost_train_dir_')\n    try:\n        cmd = (\n            [CATBOOST_APP_PATH, 'fit']\n             + cmd_line_params_list\n             + ['--train-dir', train_dir,\n                '--model-file', model_path\n            ]",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.generate_canonical_results.utils",
        "documentation": {}
    },
    {
        "label": "testBinaryClassificationSimpleOnDataFrame",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testBinaryClassificationSimpleOnDataFrame():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcDataSchema = pool_test_helpers.createSchema(\n        [\n            (\"features\", VectorUDT()),\n            (\"label\", DoubleType())\n        ],\n        featureNames,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testSimpleBinaryClassification",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testSimpleBinaryClassification():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"groupWeight\", FloatType()),\n        (\"subgroupId\", IntegerType()),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testSimpleBinaryClassificationWithBooleanTarget",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testSimpleBinaryClassificationWithBooleanTarget():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", BooleanType())\n    ]\n    srcData = [\n        Row(Vectors.dense(0.1, 0.2, 0.11), False),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testBinaryClassificationWithClassNamesAsIntSet",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testBinaryClassificationWithClassNamesAsIntSet():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType())\n    ]\n    srcData = [\n        Row(Vectors.dense(0.1, 0.2, 0.11), \"1\"),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testBinaryClassificationWithTargetBorder",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testBinaryClassificationWithTargetBorder():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", DoubleType())\n    ]\n    srcData = [\n        Row(Vectors.dense(0.1, 0.2, 0.11), 0.12),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testBinaryClassificationWithClassWeightsMap",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testBinaryClassificationWithClassWeightsMap():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", IntegerType())\n    ]\n    srcData = [\n          Row(Vectors.dense(0.1, 0.2, 0.11), 0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testBinaryClassificationWithScalePosWeight",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testBinaryClassificationWithScalePosWeight():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", IntegerType())\n    ]\n    srcData = [\n          Row(Vectors.dense(0.1, 0.2, 0.11), 0),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testClassifierSerialization",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testClassifierSerialization():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    serializationDir = tempfile.mkdtemp(prefix=\"catboost_models_\")\n    path = os.path.join(serializationDir, \"serialized_classifier_0\")\n    classifier = catboost_spark.CatBoostClassifier()\n    classifier.write().overwrite().save(path)\n    loadedClassifier = catboost_spark.CatBoostClassifier.load(path)\n    path = os.path.join(serializationDir, \"serialized_classifier_1\")\n    classifier = (catboost_spark.CatBoostClassifier().setLossFunction(\"MultiClass\").setIterations(2))",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testModelSerialization",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testModelSerialization():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcDataSchema = pool_test_helpers.createSchema(\n        [\n            (\"features\", VectorUDT()),\n            (\"label\", DoubleType())\n        ],\n        featureNames,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testModelSerializationInPipeline",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testModelSerializationInPipeline():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    srcData = [\n        Row(0, \"query0\", 0.1, \"Male\", 0.2, \"Germany\", 0.11),\n        Row(1, \"query0\", 0.97, \"Female\", 0.82, \"Russia\", 0.33),\n        Row(1, \"query1\", 0.13, \"Male\", 0.22, \"USA\", 0.23),\n        Row(0, \"Query 2\", 0.14, \"Male\", 0.18, \"Finland\", 0.1),\n        Row(1, \"Query 2\", 0.9, \"Female\", 0.67, \"USA\", 0.17),\n        Row(0, \"Query 2\", 0.66, \"Female\", 0.1, \"UK\", 0.31)",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testWithCrossValidator",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "peekOfCode": "def testWithCrossValidator():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcDataSchema = pool_test_helpers.createSchema(\n        [\n            (\"features\", VectorUDT()),\n            (\"label\", DoubleType())\n        ],\n        featureNames,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_classifier_test",
        "documentation": {}
    },
    {
        "label": "testSimple",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testSimple():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testSimpleOnDataFrame",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testSimpleOnDataFrame():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcDataSchema = pool_test_helpers.createSchema(\n        [\n            (\"features\", VectorUDT()),\n            (\"label\", DoubleType())\n        ],\n        featureNames,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testFeaturesRenamed",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testFeaturesRenamed():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"f1\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testWithEvalSet",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testWithEvalSet():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testWithEvalSets",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testWithEvalSets():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testDurationParam",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testDurationParam():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testParams",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testParams():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testWithPairs",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testWithPairs():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"sampleId\", LongType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testModelSerialization",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testModelSerialization():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"subgroupId\", IntegerType()),\n        (\"weight\", FloatType())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "testModelSerializationInPipeline",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "peekOfCode": "def testModelSerializationInPipeline():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    srcData = [\n        Row(0.12, \"query0\", 0.1, \"Male\", 0.2, \"Germany\", 0.11),\n        Row(0.22, \"query0\", 0.97, \"Female\", 0.82, \"Russia\", 0.33),\n        Row(0.34, \"query1\", 0.13, \"Male\", 0.22, \"USA\", 0.23),\n        Row(0.42, \"Query 2\", 0.14, \"Male\", 0.18, \"Finland\", 0.1),\n        Row(0.01, \"Query 2\", 0.9, \"Female\", 0.67, \"USA\", 0.17),\n        Row(0.0, \"Query 2\", 0.66, \"Female\", 0.1, \"UK\", 0.31)",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.catboost_regressor_test",
        "documentation": {}
    },
    {
        "label": "CATBOOST_TEST_DATA_DIR",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.config",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.config",
        "peekOfCode": "CATBOOST_TEST_DATA_DIR = '../../../../../../pytest/data'",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.config",
        "documentation": {}
    },
    {
        "label": "testPredictionValuesChange",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testPredictionValuesChange():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'higgs')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    regressor = (catboost_spark.CatBoostRegressor()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testLossFunctionChange",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testLossFunctionChange():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'querywise')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    regressor = (catboost_spark.CatBoostRegressor()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testInteraction",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testInteraction():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'querywise')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    regressor = (catboost_spark.CatBoostRegressor()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "shapValuesTestCase",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def shapValuesTestCase(problemType, model, data):\n    import catboost_spark\n    shapModes = [\n        catboost_spark.EPreCalcShapValues.Auto,\n        catboost_spark.EPreCalcShapValues.UsePreCalc,\n        catboost_spark.EPreCalcShapValues.NoPreCalc\n    ]\n    calcTypes = [\n        catboost_spark.ECalcTypeShapValues.Regular,\n        catboost_spark.ECalcTypeShapValues.Approximate,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapValuesForBinClass",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapValuesForBinClass():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'higgs')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    classifier = (catboost_spark.CatBoostClassifier()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapValuesForMultiClass",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapValuesForMultiClass():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'cloudness_small')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train_float.cd\")\n    )\n    classifier = (catboost_spark.CatBoostClassifier()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapValuesForRegression",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapValuesForRegression():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'querywise')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    regressor = (catboost_spark.CatBoostRegressor()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testPredictionDiff",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testPredictionDiff():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'higgs')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    dataForPredictionDiff = catboost_spark.Pool(trainPool.data.limit(2))",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "shapInteractionValuesTestCase",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def shapInteractionValuesTestCase(problemType, model, data):\n    import catboost_spark\n    dataForFeatureImportance = catboost_spark.Pool(data.data.limit(5))\n    shapModes = [\n        catboost_spark.EPreCalcShapValues.Auto,\n        catboost_spark.EPreCalcShapValues.UsePreCalc,\n        catboost_spark.EPreCalcShapValues.NoPreCalc\n    ]\n    calcTypes = [\n        catboost_spark.ECalcTypeShapValues.Regular",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapInteractionValuesForBinClass",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapInteractionValuesForBinClass():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'higgs')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    classifier = (catboost_spark.CatBoostClassifier()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapInteractionValuesForMultiClass",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapInteractionValuesForMultiClass():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'cloudness_small')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train_float.cd\")\n    )\n    classifier = (catboost_spark.CatBoostClassifier()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testShapInteractionValuesForRegression",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "peekOfCode": "def testShapInteractionValuesForRegression():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    dataDir = os.path.join(config.CATBOOST_TEST_DATA_DIR, 'higgs')\n    trainPool = catboost_spark.Pool.load(\n      spark,\n      dataPathWithScheme = os.path.join(dataDir, \"train_small\"),\n      columnDescription = os.path.join(dataDir, \"train.cd\")\n    )\n    regressor = (catboost_spark.CatBoostRegressor()",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.feature_importance_test",
        "documentation": {}
    },
    {
        "label": "testLoadDSVSimple",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "peekOfCode": "def testLoadDSVSimple():\n    dataFile = pool_test_helpers.writeToTempFile(\n        \"0\\t0.1\\t0.2\\n\" +\n        \"1\\t0.97\\t0.82\\n\" +\n        \"0\\t0.13\\t0.22\\n\"\n    )\n    cdFile = pool_test_helpers.writeToTempFile(\n        \"0\\tTarget\"\n    )\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "documentation": {}
    },
    {
        "label": "testLoadDSVWithHeader",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "peekOfCode": "def testLoadDSVWithHeader():\n    dataFile = pool_test_helpers.writeToTempFile(\n        \"Target\\tFeat0\\tFeat1\\n\" +\n        \"0\\t0.1\\t0.2\\n\" +\n        \"1\\t0.97\\t0.82\\n\" +\n        \"0\\t0.13\\t0.22\\n\"\n    )\n    cdFile = pool_test_helpers.writeToTempFile(\n        \"0\\tTarget\"\n    )",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "documentation": {}
    },
    {
        "label": "testLoadDSVWithDelimiter",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "peekOfCode": "def testLoadDSVWithDelimiter():\n    dataFile = pool_test_helpers.writeToTempFile(\n        \"Target,Feat0,Feat1\\n\" +\n        \"0,0.1,0.2\\n\" +\n        \"1,0.97,0.82\\n\" +\n        \"0,0.13,0.22\\n\"\n    )\n    cdFile = pool_test_helpers.writeToTempFile(\n        \"0\\tTarget\"\n    )",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "documentation": {}
    },
    {
        "label": "testLoadLibSVMSimple",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "peekOfCode": "def testLoadLibSVMSimple():\n    dataFile = pool_test_helpers.writeToTempFile(\n        \"0 1:0.1 3:0.2\\n\" +\n        \"1 2:0.97 5:0.82 6:0.11 8:1.2\\n\" +\n        \"0 3:0.13 7:0.22 8:0.17\\n\"\n    )\n    cdFile = pool_test_helpers.writeToTempFile(\n        \"0\\tTarget\"\n    )\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "documentation": {}
    },
    {
        "label": "testLoadDSVWithPairs",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "peekOfCode": "def testLoadDSVWithPairs():\n    dataFile = pool_test_helpers.writeToTempFile(\n        \"0.12\\tquery0\\tsite1\\t0.12\\t1.0\\t0.1\\t0.2\\t0.11\\n\" +\n        \"0.22\\tquery0\\tsite22\\t0.18\\t1.0\\t0.97\\t0.82\\t0.33\\n\" +\n        \"0.34\\tquery1\\tSite9\\t1.0\\t0.0\\t0.13\\t0.22\\t0.23\\n\" +\n        \"0.42\\tQuery 2\\tsite12\\t0.45\\t0.5\\t0.14\\t0.18\\t0.1\\n\" +\n        \"0.01\\tQuery 2\\tsite22\\t1.0\\t0.5\\t0.9\\t0.67\\t0.17\\n\" +\n        \"0.0\\tQuery 2\\tSite45\\t2.0\\t0.5\\t0.66\\t0.1\\t0.31\\n\"\n    )\n    cdFile = pool_test_helpers.writeToTempFile(",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_loading_test",
        "documentation": {}
    },
    {
        "label": "implTestQuantizeCase",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "peekOfCode": "def implTestQuantizeCase(\n    srcDataSchema,\n    srcData,\n    quantizationParams\n):\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    print (\"srcDataSchema=\", srcDataSchema)\n    df = spark.createDataFrame(spark.sparkContext.parallelize(srcData), StructType(srcDataSchema))\n    pool = catboost_spark.Pool(df)",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "documentation": {}
    },
    {
        "label": "testQuantize",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "peekOfCode": "def testQuantize():\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    implTestQuantizeCase(\n        pool_test_helpers.createSchema(\n            [\n                (\"features\", VectorUDT()),\n                (\"label\", DoubleType())\n            ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "documentation": {}
    },
    {
        "label": "testQuantizeWithNaNsAndBorderCount",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "peekOfCode": "def testQuantizeWithNaNsAndBorderCount():\n    featureNames = [\"F1\", \"F2\", \"F3\", \"F4\"]\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    implTestQuantizeCase(\n        pool_test_helpers.createSchema(\n            [\n                (\"features\", VectorUDT()),\n                (\"label\", DoubleType())\n            ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "documentation": {}
    },
    {
        "label": "testQuantizeWithNaNsAndIgnoredFeatures",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "peekOfCode": "def testQuantizeWithNaNsAndIgnoredFeatures():\n    featureNames = [\"F1\", \"F2\", \"F3\", \"F4\"]\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    implTestQuantizeCase(\n        pool_test_helpers.createSchema(\n            [\n                (\"features\", VectorUDT()),\n                (\"label\", DoubleType())\n            ],",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_quantization_test",
        "documentation": {}
    },
    {
        "label": "getSimpleTestPool",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def getSimpleTestPool(method_name):\n    featureNames = [\"f1\", \"f2\", \"f3\"]\n    srcSchemaData = [\n        (\"features\", VectorUDT()),\n        (\"label\", StringType()),\n        (\"groupId\", LongType()),\n        (\"sampleId\", IntegerType())\n    ]\n    srcData = [\n        Row(Vectors.dense(0.13, 0.22, 0.23), \"0.34\", 0x86F1B93B695F9E6, 0x23D794E),",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "implTestCase",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def implTestCase(\n    tmpFolderPath,\n    pool,\n    dataFramesOptions = None,  # Option[Map[String, String]] = None,\n    dataFramesFormat = None,  # Option[String] = None,\n    saveMode = None,  # Option[SaveMode] = None,\n    retryCreation = False  # : Boolean = false\n):\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testSupportedFormats",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testSupportedFormats():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    for format in (\"parquet\", \"default\"):\n        tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName() + \".\" + format)\n        implTestCase(\n            tmpFolderPath,\n            pool,\n            dataFramesFormat = format if format != \"default\" else None",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testUnsupportedFormats",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testUnsupportedFormats():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    for format in (\"csv\", \"text\", \"json\", \"orc\"):\n        tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName() + \".\" + format)\n        with pytest.raises(Exception):\n            implTestCase(\n                tmpFolderPath,\n                pool,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testWithPairs",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testWithPairs():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName())\n    implTestCase(tmpFolderPath, pool)\ndef testSuccessfulRetryCreation():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testSuccessfulRetryCreation",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testSuccessfulRetryCreation():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    for saveMode in (\"ignore\", \"overwrite\"):\n        tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName() + \".\" + saveMode)\n        implTestCase(tmpFolderPath, pool, saveMode=saveMode, retryCreation=True)\ndef testFailedRetryCreation():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testFailedRetryCreation",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testFailedRetryCreation():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName())\n    with pytest.raises(Exception):\n        implTestCase(tmpFolderPath, pool, retryCreation=True)\ndef testQuantized():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "testQuantized",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "peekOfCode": "def testQuantized():\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    pool = getSimpleTestPool(test_helpers.getCurrentMethodName())\n    quantizedPool = pool.quantize()\n    for format in (\"orc\", \"parquet\", \"default\"):\n        tmpFolderPath = tempfile.mkdtemp(prefix=test_helpers.getCurrentMethodName() + \".\" + format)\n        implTestCase(\n            tmpFolderPath,\n            quantizedPool,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_serialization_test",
        "documentation": {}
    },
    {
        "label": "createSchema",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "peekOfCode": "def createSchema(\n    schemaDesc, #Seq[(String,DataType)],\n    featureNames, #Seq[String],\n    addFeatureNamesMetadata = True, # Boolean = true,\n    nullableFields = [], # Seq[String] = Seq(),\n    catFeaturesNumValues = {}, # Map[String,Int] = Map[String,Int](),\n    catFeaturesValues = {} #: Map[String,Seq[String]] = Map[String,Seq[String]]()\n): #: Seq[StructField] = {\n    result = []\n    for name, dataType in schemaDesc:",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "writeToTempFile",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "peekOfCode": "def writeToTempFile(str):\n    path = tempfile.mkstemp(prefix='PoolTest_')[1]\n    with open(path, 'w') as f:\n        f.write(str)\n    return path\ndef comparePoolWithExpectedData(\n    sparkSession,\n    pool,\n    expectedDataSchema,\n    expectedData,",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "comparePoolWithExpectedData",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "peekOfCode": "def comparePoolWithExpectedData(\n    sparkSession,\n    pool,\n    expectedDataSchema,\n    expectedData,\n    expectedFeatureNames,\n    expectedPairsData = None,\n    expectedPairsDataSchema = None,\n    # set to true if order of rows might change. Requires sampleId or (groupId, sampleId) in data\n    compareByIds=False",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "printPool",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "peekOfCode": "def printPool(pool, name=\"pool\"):\n    print ('----------------------------')\n    print (\"Pool '%s'\" % name)\n    attrs = [\n        \"isQuantized\",\n        \"getFeatureCount\",\n        \"getFeatureNames\",\n        \"count\",\n        \"pairsCount\",\n        \"getBaselineCount\"",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "createRawPool",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "peekOfCode": "def createRawPool(\n    appName, #:  String,\n    srcDataSchema, #: Seq[StructField],\n    srcData, #: Seq[Row],\n    columnNames,#: Map[String, String] // standard column name to name of column in the dataset\n    srcPairsData = None # Seq[Row]\n):\n    spark = test_helpers.getOrCreateSparkSession(test_helpers.getCurrentMethodName())\n    import catboost_spark\n    df = spark.createDataFrame(spark.sparkContext.parallelize(srcData), StructType(srcDataSchema))",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.pool_test_helpers",
        "documentation": {}
    },
    {
        "label": "getCurrentMethodName",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "peekOfCode": "def getCurrentMethodName():\n    return inspect.currentframe().f_back.f_code.co_name\ndef getOrCreateSparkSession(appName):\n    return (SparkSession.builder\n        .master(\"local[2]\")\n        .config(\"spark.jars.packages\", \"ai.catboost:catboost-spark_2.4_2.11:1.2.5\")\n        .appName(appName)\n        .getOrCreate()\n    )\ndef getDataForComparison(data, sortByFields):",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "documentation": {}
    },
    {
        "label": "getOrCreateSparkSession",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "peekOfCode": "def getOrCreateSparkSession(appName):\n    return (SparkSession.builder\n        .master(\"local[2]\")\n        .config(\"spark.jars.packages\", \"ai.catboost:catboost-spark_2.4_2.11:1.2.5\")\n        .appName(appName)\n        .getOrCreate()\n    )\ndef getDataForComparison(data, sortByFields):\n    if not sortByFields:\n        return data",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "documentation": {}
    },
    {
        "label": "getDataForComparison",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "peekOfCode": "def getDataForComparison(data, sortByFields):\n    if not sortByFields:\n        return data\n    else:\n        return data.sort(sortByFields).collect()\ndef assertEqualsWithPrecision(expected, actual, sortByFields=[]):\n    assert expected.count() == actual.count()\n    print(\"expected.schema\")\n    expected.schema().printTreeString()\n    print(\"actual.schema\")",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "documentation": {}
    },
    {
        "label": "assertEqualsWithPrecision",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "description": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "peekOfCode": "def assertEqualsWithPrecision(expected, actual, sortByFields=[]):\n    assert expected.count() == actual.count()\n    print(\"expected.schema\")\n    expected.schema().printTreeString()\n    print(\"actual.schema\")\n    actual.schema().printTreeString()\n    assert expected.schema().size() == actual.schema().size()\n    for i in range(expected.schema().size()):\n        expectedField = expected.schema()[i]\n        actualField = actual.schema()[i]",
        "detail": "catboost.catboost.spark.catboost4j-spark.core.src.test.python.test_helpers",
        "documentation": {}
    },
    {
        "label": "generate_project",
        "kind": 2,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "def generate_project(src_dir, substitution_dict, dst_dir):\n    for path in ('pom.xml', 'macros/pom.xml', 'core/pom.xml'):\n        with open(os.path.join(src_dir, path)) as src_file:\n            src = src_file.read()\n        dst = string.Template(src).safe_substitute(substitution_dict)\n        dst_path = os.path.join(dst_dir, path)\n        dst_path_dir = os.path.dirname(dst_path)\n        if not os.path.exists(dst_path_dir):\n            os.makedirs(dst_path_dir)\n        with open(dst_path, 'w') as dst_file:",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "global_substitition_dict",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "global_substitition_dict = {\n    'catboost_version_placeholder': '1.2.5',\n    'relative_global_project_root_placeholder': '../..'\n}\nscala_maven_plugin_configuration_scala_pre_2_13 = \"\"\"\n<compilerPlugins>\n    <compilerPlugin>\n        <groupId>org.scalamacros</groupId>\n        <artifactId>paradise_${scala.version}</artifactId>\n        <version>2.1.1</version>",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "scala_maven_plugin_configuration_scala_pre_2_13",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "scala_maven_plugin_configuration_scala_pre_2_13 = \"\"\"\n<compilerPlugins>\n    <compilerPlugin>\n        <groupId>org.scalamacros</groupId>\n        <artifactId>paradise_${scala.version}</artifactId>\n        <version>2.1.1</version>\n    </compilerPlugin>\n</compilerPlugins>\n\"\"\"\nscala_maven_plugin_configuration_scala_2_13 = \"\"\"",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "scala_maven_plugin_configuration_scala_2_13",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "scala_maven_plugin_configuration_scala_2_13 = \"\"\"\n<args>\n    <arg>-Ymacro-annotations</arg>\n</args>\n\"\"\"\nconfigs = [\n    {\n        'dst_dir' : '../projects/spark_2.3_2.11',\n        'substitution_dict' : {\n            'version_specific_src_dir': 'spark_2_x/scala',",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "configs",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "configs = [\n    {\n        'dst_dir' : '../projects/spark_2.3_2.11',\n        'substitution_dict' : {\n            'version_specific_src_dir': 'spark_2_x/scala',\n            'scala_compat_version_placeholder': '2.11',\n            'scala_version_placeholder': '2.11.12',\n            'spark_compat_version_placeholder': '2.3',\n            'spark_version_placeholder': '2.3.0',\n            'hadoop_version_placeholder': '2.7.3',",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "description": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "peekOfCode": "current_dir = os.path.dirname(os.path.realpath(__file__))\nfor config in configs:\n    substitution_dict = global_substitition_dict.copy()\n    substitution_dict.update(config['substitution_dict'])\n    generate_project(\n        src_dir=current_dir,\n        substitution_dict=substitution_dict,\n        dst_dir=os.path.join(current_dir, config['dst_dir'])\n    )",
        "detail": "catboost.catboost.spark.catboost4j-spark.generate_projects.generate",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "peekOfCode": "current_dir = os.path.dirname(os.path.realpath(__file__))\nmvn_deploy_args = ' '.join(sys.argv[1:])\nprojects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\ncommands += [\n    'cd ' + os.path.join(projects_dir, mvn_project_subdir) + ' && mvn deploy ' + mvn_deploy_args\n    for mvn_project_subdir in [\n        'spark_2.3_2.11',",
        "detail": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "documentation": {}
    },
    {
        "label": "mvn_deploy_args",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "peekOfCode": "mvn_deploy_args = ' '.join(sys.argv[1:])\nprojects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\ncommands += [\n    'cd ' + os.path.join(projects_dir, mvn_project_subdir) + ' && mvn deploy ' + mvn_deploy_args\n    for mvn_project_subdir in [\n        'spark_2.3_2.11',\n        os.path.join('spark_2.4_2.11', 'core'),",
        "detail": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "documentation": {}
    },
    {
        "label": "projects_dir",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "peekOfCode": "projects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\ncommands += [\n    'cd ' + os.path.join(projects_dir, mvn_project_subdir) + ' && mvn deploy ' + mvn_deploy_args\n    for mvn_project_subdir in [\n        'spark_2.3_2.11',\n        os.path.join('spark_2.4_2.11', 'core'),\n        'spark_2.4_2.12',",
        "detail": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "documentation": {}
    },
    {
        "label": "commands",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "peekOfCode": "commands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\ncommands += [\n    'cd ' + os.path.join(projects_dir, mvn_project_subdir) + ' && mvn deploy ' + mvn_deploy_args\n    for mvn_project_subdir in [\n        'spark_2.3_2.11',\n        os.path.join('spark_2.4_2.11', 'core'),\n        'spark_2.4_2.12',\n        os.path.join('spark_3.0_2.12', 'core'),",
        "detail": "catboost.catboost.spark.catboost4j-spark.mvn_deploy_all_projects",
        "documentation": {}
    },
    {
        "label": "current_dir",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "peekOfCode": "current_dir = os.path.dirname(os.path.realpath(__file__))\nmvn_args = ' '.join(sys.argv[1:])\nsys.path = [os.path.join(current_dir, 'generate_projects')] + sys.path\nimport generate\nprojects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\nfor config in generate.configs:\n    project_dir=os.path.realpath(os.path.join(current_dir, 'generate_projects', config['dst_dir']))",
        "detail": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "documentation": {}
    },
    {
        "label": "mvn_args",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "peekOfCode": "mvn_args = ' '.join(sys.argv[1:])\nsys.path = [os.path.join(current_dir, 'generate_projects')] + sys.path\nimport generate\nprojects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\nfor config in generate.configs:\n    project_dir=os.path.realpath(os.path.join(current_dir, 'generate_projects', config['dst_dir']))\n    commands.append('cd ' + project_dir + ' && mvn ' + mvn_args)",
        "detail": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "documentation": {}
    },
    {
        "label": "sys.path",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "peekOfCode": "sys.path = [os.path.join(current_dir, 'generate_projects')] + sys.path\nimport generate\nprojects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\nfor config in generate.configs:\n    project_dir=os.path.realpath(os.path.join(current_dir, 'generate_projects', config['dst_dir']))\n    commands.append('cd ' + project_dir + ' && mvn ' + mvn_args)\nfor command in commands:",
        "detail": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "documentation": {}
    },
    {
        "label": "projects_dir",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "peekOfCode": "projects_dir = os.path.join(current_dir, 'projects')\ncommands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\nfor config in generate.configs:\n    project_dir=os.path.realpath(os.path.join(current_dir, 'generate_projects', config['dst_dir']))\n    commands.append('cd ' + project_dir + ' && mvn ' + mvn_args)\nfor command in commands:\n    print ('Executing ', command)\n    subprocess.check_call(command, shell=True)",
        "detail": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "documentation": {}
    },
    {
        "label": "commands",
        "kind": 5,
        "importPath": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "description": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "peekOfCode": "commands = [\n    'cd ' + current_dir + ' && ./generate_projects/generate.py'\n]\nfor config in generate.configs:\n    project_dir=os.path.realpath(os.path.join(current_dir, 'generate_projects', config['dst_dir']))\n    commands.append('cd ' + project_dir + ' && mvn ' + mvn_args)\nfor command in commands:\n    print ('Executing ', command)\n    subprocess.check_call(command, shell=True)",
        "detail": "catboost.catboost.spark.catboost4j-spark.run_mvn_for_all_projects",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef make_data_file(contents):\n    filename = yatest.common.output_path(hex(hash(contents))[-8:])\n    with open(filename, 'w') as f:\n        f.write(contents)\n    return filename\ndef local_canonical_file(*args, **kwargs):",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "make_data_file",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def make_data_file(contents):\n    filename = yatest.common.output_path(hex(hash(contents))[-8:])\n    with open(filename, 'w') as f:\n        f.write(contents)\n    return filename\ndef local_canonical_file(*args, **kwargs):\n    return yatest.common.canonical_file(*args, local=True, **kwargs)\ndef exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def local_canonical_file(*args, **kwargs):\n    return yatest.common.canonical_file(*args, local=True, **kwargs)\ndef exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')\n    with pytest.raises(yatest.common.ExecutionError):\n        with open(stdout_file, 'w') as f:\n            yatest.common.execute(cmd, stdout=f)\n    return [local_canonical_file(stdout_file)]\ndef test_equal():",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "exec_test_diff_with_stdout",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')\n    with pytest.raises(yatest.common.ExecutionError):\n        with open(stdout_file, 'w') as f:\n            yatest.common.execute(cmd, stdout=f)\n    return [local_canonical_file(stdout_file)]\ndef test_equal():\n    cmd = (PROGRAM_BINARY_PATH, data_file('f1.tsv'), data_file('f1.tsv'), '--have-header')\n    yatest.common.execute(cmd)",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_equal",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_equal():\n    cmd = (PROGRAM_BINARY_PATH, data_file('f1.tsv'), data_file('f1.tsv'), '--have-header')\n    yatest.common.execute(cmd)\ndef test_totally_different():\n    return exec_test_diff_with_stdout(data_file('f1.tsv'), data_file('f2.tsv'))\ndef test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.tsv'), data_file('f1_cut.tsv'), '--have-header')\ndef test_with_vs_without_header():\n    return exec_test_diff_with_stdout(data_file('f2.tsv'), data_file('f2_without_header.tsv'))\ndef test_with_small_noise():",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_totally_different",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_totally_different():\n    return exec_test_diff_with_stdout(data_file('f1.tsv'), data_file('f2.tsv'))\ndef test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.tsv'), data_file('f1_cut.tsv'), '--have-header')\ndef test_with_vs_without_header():\n    return exec_test_diff_with_stdout(data_file('f2.tsv'), data_file('f2_without_header.tsv'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(\n        data_file('f1.tsv'),\n        data_file('f1_with_small_noise.tsv'),",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cut",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.tsv'), data_file('f1_cut.tsv'), '--have-header')\ndef test_with_vs_without_header():\n    return exec_test_diff_with_stdout(data_file('f2.tsv'), data_file('f2_without_header.tsv'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(\n        data_file('f1.tsv'),\n        data_file('f1_with_small_noise.tsv'),\n        '--have-header'\n    )",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_vs_without_header",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_with_vs_without_header():\n    return exec_test_diff_with_stdout(data_file('f2.tsv'), data_file('f2_without_header.tsv'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(\n        data_file('f1.tsv'),\n        data_file('f1_with_small_noise.tsv'),\n        '--have-header'\n    )\ndef test_with_small_noise_within_precision():\n    cmd = (",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise():\n    return exec_test_diff_with_stdout(\n        data_file('f1.tsv'),\n        data_file('f1_with_small_noise.tsv'),\n        '--have-header'\n    )\ndef test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.tsv'),",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise_within_precision",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.tsv'),\n        data_file('f1_with_small_noise.tsv'),\n        '--have-header',\n        '--diff-limit', '1e-5'\n    )\n    yatest.common.execute(cmd)\ndef test_with_small_noise_outside_precision():",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise_outside_precision",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise_outside_precision():\n    return exec_test_diff_with_stdout(\n        data_file('f2.tsv'),\n        data_file('f2_with_small_noise.tsv'),\n        '--have-header',\n        '--diff-limit', '1e-10'\n    )\ndef test_finite_vs_finite():\n    return exec_test_diff_with_stdout(\n        make_data_file('1\\n'),",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_finite_vs_finite",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_finite_vs_finite():\n    return exec_test_diff_with_stdout(\n        make_data_file('1\\n'),\n        make_data_file('1.0\\n')\n    )\ndef test_tiny_vs_tiny():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e-400\\n'),\n        make_data_file('1e-500\\n')\n    )",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_tiny_vs_tiny",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_tiny_vs_tiny():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e-400\\n'),\n        make_data_file('1e-500\\n')\n    )\ndef test_finite_vs_inf():\n    return exec_test_diff_with_stdout(\n        make_data_file('1\\n'),\n        make_data_file('1e400\\n')\n    )",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_finite_vs_inf",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_finite_vs_inf():\n    return exec_test_diff_with_stdout(\n        make_data_file('1\\n'),\n        make_data_file('1e400\\n')\n    )\ndef test_inf_vs_inf():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e400\\n'),\n        make_data_file('1e500\\n')\n    )",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_inf_vs_inf",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_inf_vs_inf():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e400\\n'),\n        make_data_file('1e500\\n')\n    )\ndef test_no_diff_limit_1():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e400\\n'),\n        make_data_file('1e500\\n'),\n        '--diff-limit', '1e500'",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_no_diff_limit_1",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_no_diff_limit_1():\n    return exec_test_diff_with_stdout(\n        make_data_file('1e400\\n'),\n        make_data_file('1e500\\n'),\n        '--diff-limit', '1e500'\n    )\ndef test_no_diff_limit_2():\n    return exec_test_diff_with_stdout(\n        make_data_file('-1e400\\n'),\n        make_data_file('1e500\\n'),",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_no_diff_limit_2",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "def test_no_diff_limit_2():\n    return exec_test_diff_with_stdout(\n        make_data_file('-1e400\\n'),\n        make_data_file('1e500\\n'),\n        '--diff-limit', '1e500'\n    )",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "PROJECT_REPOSITORY_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "PROJECT_REPOSITORY_PATH = os.path.join(\n    \"catboost\", \"tools\", \"limited_precision_dsv_diff\")\nPROGRAM_BINARY_PATH = yatest.common.binary_path(\n    os.path.join(PROJECT_REPOSITORY_PATH, \"limited_precision_dsv_diff\")\n)\ndef data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef make_data_file(contents):",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_BINARY_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "peekOfCode": "PROGRAM_BINARY_PATH = yatest.common.binary_path(\n    os.path.join(PROJECT_REPOSITORY_PATH, \"limited_precision_dsv_diff\")\n)\ndef data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef make_data_file(contents):\n    filename = yatest.common.output_path(hex(hash(contents))[-8:])\n    with open(filename, 'w') as f:",
        "detail": "catboost.catboost.tools.limited_precision_dsv_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "data_file",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef local_canonical_file(*args, **kwargs):\n    return yatest.common.canonical_file(*args, local=True, **kwargs)\ndef exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')\n    with pytest.raises(yatest.common.ExecutionError):",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "local_canonical_file",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def local_canonical_file(*args, **kwargs):\n    return yatest.common.canonical_file(*args, local=True, **kwargs)\ndef exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')\n    with pytest.raises(yatest.common.ExecutionError):\n        yatest.common.execute(cmd, stdout=open(stdout_file, 'w'))\n    return [local_canonical_file(stdout_file)]\ndef test_equal():\n    cmd = (PROGRAM_BINARY_PATH, data_file('f1.json'), data_file('f1.json'))",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "exec_test_diff_with_stdout",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def exec_test_diff_with_stdout(*args):\n    cmd = (PROGRAM_BINARY_PATH,) + args\n    stdout_file = yatest.common.test_output_path('stdout')\n    with pytest.raises(yatest.common.ExecutionError):\n        yatest.common.execute(cmd, stdout=open(stdout_file, 'w'))\n    return [local_canonical_file(stdout_file)]\ndef test_equal():\n    cmd = (PROGRAM_BINARY_PATH, data_file('f1.json'), data_file('f1.json'))\n    yatest.common.execute(cmd)\ndef test_totally_different():",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_equal",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_equal():\n    cmd = (PROGRAM_BINARY_PATH, data_file('f1.json'), data_file('f1.json'))\n    yatest.common.execute(cmd)\ndef test_totally_different():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f2.json'))\ndef test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_cut.json'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_with_small_noise.json'))\ndef test_with_small_noise_within_precision():",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_totally_different",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_totally_different():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f2.json'))\ndef test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_cut.json'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_with_small_noise.json'))\ndef test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.json'),",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_cut",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_cut():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_cut.json'))\ndef test_with_small_noise():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_with_small_noise.json'))\ndef test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.json'),\n        data_file('f1_with_small_noise.json'),\n        '--diff-limit', '1e-5'",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise():\n    return exec_test_diff_with_stdout(data_file('f1.json'), data_file('f1_with_small_noise.json'))\ndef test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.json'),\n        data_file('f1_with_small_noise.json'),\n        '--diff-limit', '1e-5'\n    )\n    yatest.common.execute(cmd)",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise_within_precision",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise_within_precision():\n    cmd = (\n        PROGRAM_BINARY_PATH,\n        data_file('f1.json'),\n        data_file('f1_with_small_noise.json'),\n        '--diff-limit', '1e-5'\n    )\n    yatest.common.execute(cmd)\ndef test_with_small_noise_outside_precision():\n    return exec_test_diff_with_stdout(",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "test_with_small_noise_outside_precision",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "def test_with_small_noise_outside_precision():\n    return exec_test_diff_with_stdout(\n        data_file('f2.json'),\n        data_file('f2_with_small_noise.json'),\n        '--diff-limit', '1e-10'\n    )",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "PROJECT_REPOSITORY_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "PROJECT_REPOSITORY_PATH = os.path.join(\n    \"catboost\", \"tools\", \"limited_precision_json_diff\")\nPROGRAM_BINARY_PATH = yatest.common.binary_path(\n    os.path.join(PROJECT_REPOSITORY_PATH, \"limited_precision_json_diff\")\n)\ndef data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef local_canonical_file(*args, **kwargs):",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_BINARY_PATH",
        "kind": 5,
        "importPath": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "description": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "peekOfCode": "PROGRAM_BINARY_PATH = yatest.common.binary_path(\n    os.path.join(PROJECT_REPOSITORY_PATH, \"limited_precision_json_diff\")\n)\ndef data_file(*path):\n    return yatest.common.source_path(\n        os.path.join(PROJECT_REPOSITORY_PATH, \"pytest\", \"data\", *path)\n    )\ndef local_canonical_file(*args, **kwargs):\n    return yatest.common.canonical_file(*args, local=True, **kwargs)\ndef exec_test_diff_with_stdout(*args):",
        "detail": "catboost.catboost.tools.limited_precision_json_diff.pytest.test",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "description": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "peekOfCode": "def parse_args():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--rtol', default=1.e-5)\n    parser.add_argument('--atol', default=1.e-8)\n    parser.add_argument('npyArrayPath1')\n    parser.add_argument('npyArrayPath2')\n    return parser.parse_args()\ndef main():\n    args = parse_args()\n    array1 = np.load(args.npyArrayPath1)",
        "detail": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "description": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "peekOfCode": "def main():\n    args = parse_args()\n    array1 = np.load(args.npyArrayPath1)\n    array2 = np.load(args.npyArrayPath2)\n    assert np.allclose(array1, array2, args.rtol, args.atol)\nif __name__ == \"__main__\":\n    main()",
        "detail": "catboost.catboost.tools.limited_precision_numpy_diff.main",
        "documentation": {}
    },
    {
        "label": "need_to_build_with_cuda_for_main_targets",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def need_to_build_with_cuda_for_main_targets(platform_name: str):\n    system, _ = platform_name.split('-')\n    return system in ['linux', 'windows']\ndef get_primary_platform_name():\n    if sys.platform == 'darwin':\n        return 'darwin-universal2'\n    else:\n        return {\n            'win32': 'windows',\n            'linux': 'linux'",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_primary_platform_name",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_primary_platform_name():\n    if sys.platform == 'darwin':\n        return 'darwin-universal2'\n    else:\n        return {\n            'win32': 'windows',\n            'linux': 'linux'\n        }[sys.platform] + '-x86_64'\ndef get_native_platform_name():\n    system_name = 'windows' if sys.platform == 'win32' else sys.platform",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_native_platform_name",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_native_platform_name():\n    system_name = 'windows' if sys.platform == 'win32' else sys.platform\n    arch = platform.machine()\n    if arch == 'AMD64':\n        arch = 'x86_64'\n    return system_name + '-' + arch\n# Unfortunately CMake's FindPython does not work reliably in all cases so we have to recreate similar logic here.\ndef get_python_root_dir(py_ver: Tuple[int, int])-> str:\n    # returns python_root_dir relative to CMAKE_FIND_ROOT_PATH\n    if sys.platform == 'win32':",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_python_root_dir",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_python_root_dir(py_ver: Tuple[int, int])-> str:\n    # returns python_root_dir relative to CMAKE_FIND_ROOT_PATH\n    if sys.platform == 'win32':\n        if IS_IN_GITHUB_ACTION:\n            # we've created x.y aliases for convinience\n            return os.path.join('Python', f'{py_ver[0]}.{py_ver[1]}')\n        else:\n            # pyenv installs x.y.z versions but we've created x.y aliases for convinience\n            return os.path.join('.pyenv', 'pyenv-win', 'versions', f'{py_ver[0]}.{py_ver[1]}')\n    if sys.platform == 'darwin':",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_python_version_include_and_library_paths",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_python_version_include_and_library_paths(py_ver: Tuple[int, int]) -> Tuple[str, str]:\n    # returns (python include path, python library path) relative to CMAKE_FIND_ROOT_PATH\n    base_path = get_python_root_dir(py_ver)\n    if sys.platform == 'win32':\n        return (os.path.join(base_path, 'include'), os.path.join(base_path, 'libs', f'python{py_ver[0]}{py_ver[1]}.lib'))\n    # for some reason python versions for python <=3.7 contain 'm' suffix\n    python_sub_name = f'python{py_ver[0]}.{py_ver[1]}' + ('m' if py_ver <= (3,7) else '')\n    if sys.platform == 'darwin':\n        lib_sub_path = os.path.join(\n            'lib',",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "run_in_python_package_dir",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def run_in_python_package_dir(\n    src_root_dir:str,\n    dry_run:bool,\n    verbose:bool,\n    commands: List[List[str]]):\n    os.chdir(os.path.join(src_root_dir, 'catboost', 'python-package'))\n    for cmd in commands:\n        if verbose:\n            logging.info(' '.join(cmd))\n        if not dry_run:",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "run_with_native_python_with_version_in_python_package_dir",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def run_with_native_python_with_version_in_python_package_dir(\n    src_root_dir:str,\n    dry_run:bool,\n    verbose:bool,\n    py_ver: Tuple[int, int],\n    python_cmds_args: List[List[str]]):\n    base_path = os.path.join(CMAKE_BUILD_ENV_ROOT, get_native_platform_name(), get_python_root_dir(py_ver))\n    if sys.platform == 'win32':\n        python_bin_path = os.path.join(base_path, 'python.exe')\n    else:",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "patch_sources",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def patch_sources(src_root_dir: str, build_test_tools:bool = False, dry_run:bool = False, verbose:bool = False):\n    # TODO(akhropov): Remove when system cuda.cmake is updated for Linux cross-build\n    distutils.file_util.copy_file(\n        src=os.path.join(src_root_dir, 'ci', 'cmake', 'cuda.cmake'),\n        dst=os.path.join(src_root_dir, 'cmake', 'cuda.cmake'),\n        verbose=verbose,\n        dry_run=dry_run\n    )\ndef get_python_plat_name(platform_name: str):\n    system, arch = platform_name.split('-')",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_python_plat_name",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_python_plat_name(platform_name: str):\n    system, arch = platform_name.split('-')\n    if system == 'windows':\n        return 'win_amd64'\n    elif system == 'darwin':\n        return 'macosx_11_0_universal2'\n    else: # linux\n        return 'manylinux2014_' + arch\ndef build_r_package(\n    src_root_dir: str,",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "build_r_package",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def build_r_package(\n    src_root_dir: str,\n    build_native_root_dir: str,\n    with_cuda: bool,\n    platform_name: str,\n    dry_run: bool,\n    verbose: bool\n):\n    system, _ = platform_name.split('-')\n    def get_catboostr_artifact_src_and_dst_name(system: str):",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "build_jvm_artifacts",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def build_jvm_artifacts(\n    src_root_dir: str,\n    build_native_root_dir: str,\n    platform_name: str,\n    macos_universal_binaries:bool,\n    build_with_cuda_for_main_targets: str,\n    dry_run: bool,\n    verbose: bool):\n    os.chdir(src_root_dir)\n    parts = [",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_exe_files",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_exe_files(system:str, name:str) -> List[str]:\n    return [name + '.exe' if system == 'windows' else name]\ndef get_static_lib_files(system:str, name:str) -> List[str]:\n    prefix = '' if system == 'windows' else 'lib'\n    suffix = '.lib' if system == 'windows' else '.a'\n    return [prefix + name + sub_suffix + suffix for sub_suffix in ['', '.global']]\ndef get_shared_lib_files(system:str, name:str) -> List[str]:\n    if system == 'windows':\n        return [name + '.lib', name + '.dll']\n    else:",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_static_lib_files",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_static_lib_files(system:str, name:str) -> List[str]:\n    prefix = '' if system == 'windows' else 'lib'\n    suffix = '.lib' if system == 'windows' else '.a'\n    return [prefix + name + sub_suffix + suffix for sub_suffix in ['', '.global']]\ndef get_shared_lib_files(system:str, name:str) -> List[str]:\n    if system == 'windows':\n        return [name + '.lib', name + '.dll']\n    else:\n        suffix = '.so' if system == 'linux' else '.dylib'\n        return ['lib' + name + suffix]",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_shared_lib_files",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_shared_lib_files(system:str, name:str) -> List[str]:\n    if system == 'windows':\n        return [name + '.lib', name + '.dll']\n    else:\n        suffix = '.so' if system == 'linux' else '.dylib'\n        return ['lib' + name + suffix]\ndef copy_built_artifacts_to_canonical_place(\n    platform_name: str,\n    with_cuda:bool,\n    build_native_root_dir:str,",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "copy_built_artifacts_to_canonical_place",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def copy_built_artifacts_to_canonical_place(\n    platform_name: str,\n    with_cuda:bool,\n    build_native_root_dir:str,\n    built_output_root_dir:str,\n    build_test_tools:bool,\n    dry_run:bool,\n    verbose: bool\n):\n    \"\"\"",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "get_real_build_root_dir",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def get_real_build_root_dir(src_root_dir:str, built_output_root_dir:str):\n    if os.environ.get('CMAKE_BUILD_CACHE_DIR'):\n        build_native_root_dir = os.path.join(\n            os.environ['CMAKE_BUILD_CACHE_DIR'],\n            hashlib.md5(os.path.abspath(src_root_dir).encode('utf-8')).hexdigest()[:10]\n        )\n        os.makedirs(build_native_root_dir, exist_ok=True)\n        return build_native_root_dir\n    else:\n        return built_output_root_dir",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "build_all_for_one_platform",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def build_all_for_one_platform(\n    src_root_dir:str,\n    built_output_root_dir:str,  # will contain 'no_cuda/{platform_name}' and 'have_cuda/{platform_name}' subdirs\n    platform_name:str,  # either \"{system}-{arch}' of 'darwin-universal2'\n    native_built_tools_root_dir:str=None,\n    cmake_target_toolchain:str=None,\n    conan_host_profile:str=None,\n    cmake_extra_args:List[str]=None,\n    build_test_tools:bool=False,\n    dry_run:bool=False,",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "build_all",
        "kind": 2,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "def build_all(src_root_dir: str, build_test_tools:bool = False, dry_run:bool = False, verbose:bool = False):\n    run_in_python_package_dir(\n        src_root_dir,\n        dry_run,\n        verbose,\n        [\n            ['python3', 'setup.py', 'build_widget'],\n            ['python3', '-m', 'build', '--sdist']\n        ]\n    )",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "IS_IN_GITHUB_ACTION",
        "kind": 5,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "IS_IN_GITHUB_ACTION = 'GITHUB_ACTION' in os.environ\nPYTHON_VERSIONS = [\n    (3,7),\n    (3,8),\n    (3,9),\n    (3,10),\n    (3,11),\n    (3,12)\n]\nMSVS_VERSION = '2022'",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "PYTHON_VERSIONS",
        "kind": 5,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "PYTHON_VERSIONS = [\n    (3,7),\n    (3,8),\n    (3,9),\n    (3,10),\n    (3,11),\n    (3,12)\n]\nMSVS_VERSION = '2022'\nMSVC_TOOLSET = '14.29.30133'",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "MSVS_VERSION",
        "kind": 5,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "MSVS_VERSION = '2022'\nMSVC_TOOLSET = '14.29.30133'\nif sys.platform == 'win32':\n    CMAKE_BUILD_ENV_ROOT = os.environ.get(\n        'CMAKE_BUILD_ENV_ROOT',\n        os.path.join(os.environ['USERPROFILE'], 'cmake_build_env_root')\n    )\n    # without C: because we use CMAKE_FIND_ROOT_PATH for speeding up build for many pythons\n    if IS_IN_GITHUB_ACTION:\n        CUDA_ROOT = '/CUDA/v11.8'",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "MSVC_TOOLSET",
        "kind": 5,
        "importPath": "catboost.ci.build_all",
        "description": "catboost.ci.build_all",
        "peekOfCode": "MSVC_TOOLSET = '14.29.30133'\nif sys.platform == 'win32':\n    CMAKE_BUILD_ENV_ROOT = os.environ.get(\n        'CMAKE_BUILD_ENV_ROOT',\n        os.path.join(os.environ['USERPROFILE'], 'cmake_build_env_root')\n    )\n    # without C: because we use CMAKE_FIND_ROOT_PATH for speeding up build for many pythons\n    if IS_IN_GITHUB_ACTION:\n        CUDA_ROOT = '/CUDA/v11.8'\n        JAVA_HOME = '/jdk-8'",
        "detail": "catboost.ci.build_all",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "catboost.ci.fixup_python_version",
        "description": "catboost.ci.fixup_python_version",
        "peekOfCode": "version = os.environ.get('CATBOOST_PACKAGE_VERSION')\ncounter = os.environ.get('GO_PIPELINE_COUNTER', '0')\nif version:\n    with open('catboost/python-package/catboost/version.py', 'w') as version_file:\n        version_file.write('VERSION = \\'{}.dev{}\\'\\n'.format(version, counter))",
        "detail": "catboost.ci.fixup_python_version",
        "documentation": {}
    },
    {
        "label": "counter",
        "kind": 5,
        "importPath": "catboost.ci.fixup_python_version",
        "description": "catboost.ci.fixup_python_version",
        "peekOfCode": "counter = os.environ.get('GO_PIPELINE_COUNTER', '0')\nif version:\n    with open('catboost/python-package/catboost/version.py', 'w') as version_file:\n        version_file.write('VERSION = \\'{}.dev{}\\'\\n'.format(version, counter))",
        "detail": "catboost.ci.fixup_python_version",
        "documentation": {}
    },
    {
        "label": "get_sys_arch_list",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def get_sys_arch_list():\n    return [\n        ('darwin', ['universal2']),\n        ('linux', ['aarch64', 'x86_64']),\n        ('windows', ['x86_64']),\n    ]\ndef prepare_app(src_dir: str, dst_dir: str, release_version: str):\n    for system, archs in get_sys_arch_list():\n        bin_suff = '.exe' if system == 'windows' else ''\n        for arch in archs:",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "prepare_app",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def prepare_app(src_dir: str, dst_dir: str, release_version: str):\n    for system, archs in get_sys_arch_list():\n        bin_suff = '.exe' if system == 'windows' else ''\n        for arch in archs:\n            os.rename(\n                os.path.join(src_dir, f'bin_{system}-{arch}', 'catboost' + bin_suff),\n                os.path.join(dst_dir, f'catboost-{system}-{arch}-{release_version}{bin_suff}')\n            )\n    # legacy names for compatibility\n    shutil.copy2(",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "extract_file_from_tgz",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def extract_file_from_tgz(src_tgz_path: str, tar_member: str, dst_path: str, tmp_dir: str):\n    with tarfile.open(src_tgz_path, \"r:gz\") as tar:\n        needed_members = [m for m in tar.getmembers() if m.name == tar_member]\n        tar.extractall(members=needed_members, path=tmp_dir)\n        os.rename(os.path.join(tmp_dir, tar_member), dst_path)\ndef prepare_R_package(src_dir: str, dst_dir: str, release_version: str, tmp_dir: str):\n    for system, archs in get_sys_arch_list():\n        for arch in archs:\n            dst_tgz = os.path.join(dst_dir, f'catboost-R-{system}-{arch}-{release_version}.tgz')\n            os.rename(os.path.join(src_dir, 'R', f'catboost-R-{system}-{arch}.tgz'), dst_tgz)",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "prepare_R_package",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def prepare_R_package(src_dir: str, dst_dir: str, release_version: str, tmp_dir: str):\n    for system, archs in get_sys_arch_list():\n        for arch in archs:\n            dst_tgz = os.path.join(dst_dir, f'catboost-R-{system}-{arch}-{release_version}.tgz')\n            os.rename(os.path.join(src_dir, 'R', f'catboost-R-{system}-{arch}.tgz'), dst_tgz)\n            # extract so only\n            if system == 'windows':\n                so_path_in_tgz = 'catboost/inst/libs/x64/libcatboostr.dll'\n                dst_suffix = '.dll'\n            else:",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "prepare_catboostmodel_lib",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def prepare_catboostmodel_lib(src_dir: str, dst_dir: str, release_version: str):\n    for system, archs in get_sys_arch_list():\n        lib_prefix = '' if system == 'windows' else 'lib'\n        lib_suffixes = {\n            'darwin': ['.dylib'],\n            'linux': ['.so'],\n            'windows': ['.lib', '.dll']\n        }[system]\n        for arch in archs:\n            for lib_suffix in lib_suffixes:",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "prepare_artifacts",
        "kind": 2,
        "importPath": "catboost.ci.prepare_release_artifacts",
        "description": "catboost.ci.prepare_release_artifacts",
        "peekOfCode": "def prepare_artifacts(src_dir: str, dst_dir: str, release_version: str):\n    os.mkdir(dst_dir)\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        prepare_app(src_dir, dst_dir, release_version)\n        prepare_R_package(src_dir, dst_dir, release_version, tmp_dir)\n        prepare_catboostmodel_lib(src_dir, dst_dir, release_version)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--src-dir', help='directory with fetched artifacts', default='./')\n    parser.add_argument('--dst-dir', help='directory with artifacts ready for upload', default='./upload')",
        "detail": "catboost.ci.prepare_release_artifacts",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "catboost.ci.webdav_upload",
        "description": "catboost.ci.webdav_upload",
        "peekOfCode": "client = webdav.client.Client({\n    \"webdav_hostname\": \"https://webdav.yandex.ru\",\n    \"webdav_login\":    os.environ[\"WEBDAV_LOGIN\"],\n    \"webdav_password\": os.environ[\"WEBDAV_PASSWORD\"]\n})\nif os.name == \"nt\":\n    client.default_options[\"SSL_VERIFYPEER\"] = 0\nbase_dir = \"webdav_test\"\nif \"APPVEYOR_BUILD_NUMBER\" in os.environ:\n    work_dir = base_dir + \"/\" + \"appveyor_\" + os.environ[\"APPVEYOR_BUILD_NUMBER\"]",
        "detail": "catboost.ci.webdav_upload",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "catboost.ci.webdav_upload",
        "description": "catboost.ci.webdav_upload",
        "peekOfCode": "base_dir = \"webdav_test\"\nif \"APPVEYOR_BUILD_NUMBER\" in os.environ:\n    work_dir = base_dir + \"/\" + \"appveyor_\" + os.environ[\"APPVEYOR_BUILD_NUMBER\"]\nelif \"TRAVIS_BUILD_NUMBER\" in os.environ:\n    work_dir = base_dir + \"/\" + \"travis_\" + os.environ[\"TRAVIS_BUILD_NUMBER\"]\nelse:\n    work_dir = base_dir + \"/\" + \"unknown\"\nif not client.check(work_dir):\n    client.mkdir(work_dir)\nfor path in sys.argv[1:]:",
        "detail": "catboost.ci.webdav_upload",
        "documentation": {}
    },
    {
        "label": "get_mro",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def get_mro(cls):\n    try:\n        return cls.__mro__\n    except AttributeError:\n        return old_style_mro(cls)\ndef old_style_mro(cls):\n    yield cls\n    for base in cls.__bases__:\n        for c in old_style_mro(base):\n            yield c",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "old_style_mro",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def old_style_mro(cls):\n    yield cls\n    for base in cls.__bases__:\n        for c in old_style_mro(base):\n            yield c\ndef mk_gen():\n    from abc import abstractmethod\n    required_methods = (\n        '__iter__', '__next__' if hasattr(iter(()), '__next__') else 'next',\n         'send', 'throw', 'close')",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "mk_gen",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def mk_gen():\n    from abc import abstractmethod\n    required_methods = (\n        '__iter__', '__next__' if hasattr(iter(()), '__next__') else 'next',\n         'send', 'throw', 'close')\n    class Generator(_collections_abc.Iterator):\n        __slots__ = ()\n        if '__next__' in required_methods:\n            def __next__(self):\n                return self.send(None)",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "mk_awaitable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def mk_awaitable():\n    from abc import abstractmethod, ABCMeta\n    @abstractmethod\n    def __await__(self):\n        yield\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Awaitable:\n            for B in get_mro(C):\n                if '__await__' in B.__dict__:",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "mk_coroutine",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def mk_coroutine():\n    from abc import abstractmethod\n    class Coroutine(Awaitable):\n        __slots__ = ()\n        @abstractmethod\n        def send(self, value):\n            \"\"\"Send a value into the coroutine.\n            Return next yielded value or raise StopIteration.\n            \"\"\"\n            raise StopIteration",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "patch",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "def patch(patch_inspect=True):\n    \"\"\"\n    Main entry point for patching the ``collections.abc`` and ``inspect``\n    standard library modules.\n    \"\"\"\n    PATCHED['collections.abc.Generator'] = _collections_abc.Generator = Generator\n    PATCHED['collections.abc.Coroutine'] = _collections_abc.Coroutine = Coroutine\n    PATCHED['collections.abc.Awaitable'] = _collections_abc.Awaitable = Awaitable\n    if patch_inspect:\n        import inspect",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "PATCHED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "description": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "peekOfCode": "PATCHED = {}\ndef patch(patch_inspect=True):\n    \"\"\"\n    Main entry point for patching the ``collections.abc`` and ``inspect``\n    standard library modules.\n    \"\"\"\n    PATCHED['collections.abc.Generator'] = _collections_abc.Generator = Generator\n    PATCHED['collections.abc.Coroutine'] = _collections_abc.Coroutine = Coroutine\n    PATCHED['collections.abc.Awaitable'] = _collections_abc.Awaitable = Awaitable\n    if patch_inspect:",
        "detail": "catboost.contrib.deprecated.python.backports-abc.backports_abc",
        "documentation": {}
    },
    {
        "label": "_HashedSeq",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "description": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "peekOfCode": "class _HashedSeq(list):\n    __slots__ = 'hashvalue'\n    def __init__(self, tup, hash=hash):\n        self[:] = tup\n        self.hashvalue = hash(tup)\n    def __hash__(self):\n        return self.hashvalue\ndef _make_key(\n    args,\n    kwds,",
        "detail": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "description": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "peekOfCode": "def update_wrapper(\n    wrapper,\n    wrapped,\n    assigned=functools.WRAPPER_ASSIGNMENTS,\n    updated=functools.WRAPPER_UPDATES,\n):\n    \"\"\"\n    Patch two bugs in functools.update_wrapper.\n    \"\"\"\n    # workaround for http://bugs.python.org/issue3445",
        "detail": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "description": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "peekOfCode": "def lru_cache(maxsize=100, typed=False):  # noqa: C901\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(3.0) and f(3) will be treated as distinct calls with\n    distinct results.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize) with\n    f.cache_info().  Clear the cache and statistics with f.cache_clear().",
        "detail": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "documentation": {}
    },
    {
        "label": "_CacheInfo",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "description": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "peekOfCode": "_CacheInfo = namedtuple(\"_CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\n@functools.wraps(functools.update_wrapper)\ndef update_wrapper(\n    wrapper,\n    wrapped,\n    assigned=functools.WRAPPER_ASSIGNMENTS,\n    updated=functools.WRAPPER_UPDATES,\n):\n    \"\"\"\n    Patch two bugs in functools.update_wrapper.",
        "detail": "catboost.contrib.deprecated.python.backports.functools-lru-cache.backports.functools_lru_cache",
        "documentation": {}
    },
    {
        "label": "get_terminal_size",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "description": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "peekOfCode": "def get_terminal_size(fallback=(80, 24)):\n    \"\"\"Get the size of the terminal window.\n    For each of the two dimensions, the environment variable, COLUMNS\n    and LINES respectively, is checked. If the variable is defined and\n    the value is a positive integer, it is used.\n    When COLUMNS or LINES is not defined, which is the common case,\n    the terminal connected to sys.__stdout__ is queried\n    by invoking os.get_terminal_size.\n    If the terminal size cannot be successfully queried, either because\n    the system doesn't support querying, or because we are not",
        "detail": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "description": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "peekOfCode": "__all__ = [\"get_terminal_size\"]\nterminal_size = namedtuple(\"terminal_size\", \"columns lines\")\ntry:\n    from ctypes import windll, create_string_buffer\n    _handles = {\n        0: windll.kernel32.GetStdHandle(-10),\n        1: windll.kernel32.GetStdHandle(-11),\n        2: windll.kernel32.GetStdHandle(-12),\n    }\n    def _get_terminal_size(fd):",
        "detail": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "documentation": {}
    },
    {
        "label": "terminal_size",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "description": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "peekOfCode": "terminal_size = namedtuple(\"terminal_size\", \"columns lines\")\ntry:\n    from ctypes import windll, create_string_buffer\n    _handles = {\n        0: windll.kernel32.GetStdHandle(-10),\n        1: windll.kernel32.GetStdHandle(-11),\n        2: windll.kernel32.GetStdHandle(-12),\n    }\n    def _get_terminal_size(fd):\n        columns = lines = 0",
        "detail": "catboost.contrib.deprecated.python.backports.shutil-get-terminal-size.backports.shutil_get_terminal_size.get_terminal_size",
        "documentation": {}
    },
    {
        "label": "_ChainMap",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "class _ChainMap(MutableMapping):\n    ''' A ChainMap groups multiple dicts (or other mappings) together\n    to create a single, updateable view.\n    The underlying mappings are stored in a list.  That list is public and can\n    accessed or updated using the *maps* attribute.  There is no other state.\n    Lookups search the underlying mappings successively until a key is found.\n    In contrast, writes, updates, and deletions only operate on the first\n    mapping.\n    '''\n    def __init__(self, *maps):",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "_PathLike",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "class _PathLike(_ABC):\n    \"\"\"Abstract base class for implementing the file system path protocol.\"\"\"\n    @abc.abstractmethod\n    def __fspath__(self):\n        \"\"\"Return the file system path representation of the object.\"\"\"\n        raise NotImplementedError\n    @classmethod\n    def __subclasshook__(cls, subclass):\n        return bool(\n            hasattr(subclass, '__fspath__')",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "from_none",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "def from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc\n# from reprlib 3.2.1\ndef recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "recursive_repr",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "def recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "__all__ = ['UserDict', 'OrderedDict', 'open']\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\nnative_str = str\nstr = type('str')\ndef from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\nnative_str = str\nstr = type('str')\ndef from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc\n# from reprlib 3.2.1",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "PY3",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "PY3 = sys.version_info[0] == 3\nnative_str = str\nstr = type('str')\ndef from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc\n# from reprlib 3.2.1\ndef recursive_repr(fillvalue='...'):",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "native_str",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "native_str = str\nstr = type('str')\ndef from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc\n# from reprlib 3.2.1\ndef recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "str = type('str')\ndef from_none(exc):\n    \"\"\"raise from_none(ValueError('a')) == raise ValueError('a') from None\"\"\"\n    exc.__cause__ = None\n    exc.__suppress_context__ = True\n    return exc\n# from reprlib 3.2.1\ndef recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "_ABC",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "_ABC = getattr(\n    abc,\n    'ABC',\n    # Python 3.3 compatibility\n    abc.ABCMeta(native_str('__ABC'), (object,), dict(__metaclass__=abc.ABCMeta)),\n)\nclass _PathLike(_ABC):\n    \"\"\"Abstract base class for implementing the file system path protocol.\"\"\"\n    @abc.abstractmethod\n    def __fspath__(self):",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "PathLike",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "PathLike = getattr(os, 'PathLike', _PathLike)\ndef _fspath(path):\n    \"\"\"Return the path representation of a path-like object.\n    If str or bytes is passed in, it is returned unchanged. Otherwise the\n    os.PathLike interface is used to get the path representation. If the\n    path representation is not str or bytes, TypeError is raised. If the\n    provided path is not str, bytes, or os.PathLike, TypeError is raised.\n    \"\"\"\n    if isinstance(path, (str, bytes)):\n        return path",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "fspath",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "description": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "peekOfCode": "fspath = getattr(os, 'fspath', _fspath)",
        "detail": "catboost.contrib.deprecated.python.configparser.backports.configparser.helpers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.configparser.configparser",
        "description": "catboost.contrib.deprecated.python.configparser.configparser",
        "peekOfCode": "__all__ = [\n    \"NoSectionError\",\n    \"DuplicateOptionError\",\n    \"DuplicateSectionError\",\n    \"NoOptionError\",\n    \"InterpolationError\",\n    \"InterpolationDepthError\",\n    \"InterpolationMissingOptionError\",\n    \"InterpolationSyntaxError\",\n    \"ParsingError\",",
        "detail": "catboost.contrib.deprecated.python.configparser.configparser",
        "documentation": {}
    },
    {
        "label": "TestHelpers",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "class TestHelpers(unittest.TestCase):\n    # _is_descriptor, _is_sunder, _is_dunder\n    def test_is_descriptor(self):\n        class foo:\n            pass\n        for attr in ('__get__','__set__','__delete__'):\n            obj = foo()\n            self.assertFalse(enum._is_descriptor(obj))\n            setattr(obj, attr, 1)\n            self.assertTrue(enum._is_descriptor(obj))",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "TestEnum",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "class TestEnum(unittest.TestCase):\n    def setUp(self):\n        class Season(Enum):\n            SPRING = 1\n            SUMMER = 2\n            AUTUMN = 3\n            WINTER = 4\n        self.Season = Season\n        class Konstants(float, Enum):\n            E = 2.7182818",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "TestUnique",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "class TestUnique(unittest.TestCase):\n    \"\"\"2.4 doesn't allow class decorators, use function syntax.\"\"\"\n    def test_unique_clean(self):\n        class Clean(Enum):\n            one = 1\n            two = 'dos'\n            tres = 4.0\n        unique(Clean)\n        class Cleaner(IntEnum):\n            single = 1",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "TestMe",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "class TestMe(unittest.TestCase):\n    pass\nif __name__ == '__main__':\n    unittest.main()",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "check_pickle_dump_load",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "def check_pickle_dump_load(assertion, source, target=None,\n        protocol=(0, HIGHEST_PROTOCOL)):\n    start, stop = protocol\n    failures = []\n    for protocol in range(start, stop+1):\n        try:\n            if target is None:\n                assertion(loads(dumps(source, protocol=protocol)) is source)\n            else:\n                assertion(loads(dumps(source, protocol=protocol)), target)",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "check_pickle_exception",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "def check_pickle_exception(assertion, exception, obj,\n        protocol=(0, HIGHEST_PROTOCOL)):\n    start, stop = protocol\n    failures = []\n    for protocol in range(start, stop+1):\n        try:\n            assertion(exception, dumps, obj, protocol=protocol)\n        except Exception:\n            exc = sys.exc_info()[1]\n            failures.append('%d: %s %s' % (protocol, exc.__class__.__name__, exc))",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "pyver",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.enum34.enum.test",
        "description": "catboost.contrib.deprecated.python.enum34.enum.test",
        "peekOfCode": "pyver = float('%s.%s' % sys.version_info[:2])\nif pyver < 2.5:\n    sys.path.insert(0, '.')\nimport enum\nfrom enum import Enum, IntEnum, unique, EnumMeta\nif pyver < 2.6:\n    from __builtin__ import enumerate as bltin_enumerate\n    def enumerate(thing, start=0):\n        result = []\n        for i, item in bltin_enumerate(thing):",
        "detail": "catboost.contrib.deprecated.python.enum34.enum.test",
        "documentation": {}
    },
    {
        "label": "error",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "class error(Exception):\n    \"\"\"Dummy implementation of _thread.error.\"\"\"\n    def __init__(self, *args):\n        self.args = args\ndef start_new_thread(function, args, kwargs={}):\n    \"\"\"Dummy implementation of _thread.start_new_thread().\n    Compatibility is maintained by making sure that ``args`` is a\n    tuple and ``kwargs`` is a dictionary.  If an exception is raised\n    and it is SystemExit (which can be done by _thread.exit()) it is\n    caught and nothing is done; all other exceptions are printed out",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "LockType",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "class LockType(object):\n    \"\"\"Class implementing dummy implementation of _thread.LockType.\n    Compatibility is maintained by maintaining self.locked_status\n    which is a boolean that stores the state of the lock.  Pickling of\n    the lock, though, should not be done since if the _thread module is\n    then used with an unpickled ``lock()`` from here problems could\n    occur from this class not having atomic methods.\n    \"\"\"\n    def __init__(self):\n        self.locked_status = False",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "start_new_thread",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def start_new_thread(function, args, kwargs={}):\n    \"\"\"Dummy implementation of _thread.start_new_thread().\n    Compatibility is maintained by making sure that ``args`` is a\n    tuple and ``kwargs`` is a dictionary.  If an exception is raised\n    and it is SystemExit (which can be done by _thread.exit()) it is\n    caught and nothing is done; all other exceptions are printed out\n    by using traceback.print_exc().\n    If the executed function calls interrupt_main the KeyboardInterrupt will be\n    raised when the function returns.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "exit",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def exit():\n    \"\"\"Dummy implementation of _thread.exit().\"\"\"\n    raise SystemExit\ndef get_ident():\n    \"\"\"Dummy implementation of _thread.get_ident().\n    Since this module should only be used when _threadmodule is not\n    available, it is safe to assume that the current process is the\n    only thread.  Thus a constant can be safely returned.\n    \"\"\"\n    return -1",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "get_ident",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def get_ident():\n    \"\"\"Dummy implementation of _thread.get_ident().\n    Since this module should only be used when _threadmodule is not\n    available, it is safe to assume that the current process is the\n    only thread.  Thus a constant can be safely returned.\n    \"\"\"\n    return -1\ndef allocate_lock():\n    \"\"\"Dummy implementation of _thread.allocate_lock().\"\"\"\n    return LockType()",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "allocate_lock",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def allocate_lock():\n    \"\"\"Dummy implementation of _thread.allocate_lock().\"\"\"\n    return LockType()\ndef stack_size(size=None):\n    \"\"\"Dummy implementation of _thread.stack_size().\"\"\"\n    if size is not None:\n        raise error(\"setting thread stack size not supported\")\n    return 0\nclass LockType(object):\n    \"\"\"Class implementing dummy implementation of _thread.LockType.",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "stack_size",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def stack_size(size=None):\n    \"\"\"Dummy implementation of _thread.stack_size().\"\"\"\n    if size is not None:\n        raise error(\"setting thread stack size not supported\")\n    return 0\nclass LockType(object):\n    \"\"\"Class implementing dummy implementation of _thread.LockType.\n    Compatibility is maintained by maintaining self.locked_status\n    which is a boolean that stores the state of the lock.  Pickling of\n    the lock, though, should not be done since if the _thread module is",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "interrupt_main",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "def interrupt_main():\n    \"\"\"Set _interrupt flag to True to have start_new_thread raise\n    KeyboardInterrupt upon exiting.\"\"\"\n    if _main:\n        raise KeyboardInterrupt\n    else:\n        global _interrupt\n        _interrupt = True",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "__all__ = ['error', 'start_new_thread', 'exit', 'get_ident', 'allocate_lock',\n           'interrupt_main', 'LockType']\n# A dummy value\nTIMEOUT_MAX = 2**31\n# NOTE: this module can be imported early in the extension building process,\n# and so top level imports of other modules should be avoided.  Instead, all\n# imports are done when needed on a function-by-function basis.  Since threads\n# are disabled, the import lock should not be an issue anyway (??).\nclass error(Exception):\n    \"\"\"Dummy implementation of _thread.error.\"\"\"",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "TIMEOUT_MAX",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "TIMEOUT_MAX = 2**31\n# NOTE: this module can be imported early in the extension building process,\n# and so top level imports of other modules should be avoided.  Instead, all\n# imports are done when needed on a function-by-function basis.  Since threads\n# are disabled, the import lock should not be an issue anyway (??).\nclass error(Exception):\n    \"\"\"Dummy implementation of _thread.error.\"\"\"\n    def __init__(self, *args):\n        self.args = args\ndef start_new_thread(function, args, kwargs={}):",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "_interrupt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "_interrupt = False\n# True when not executing in a \"thread\"\n_main = True\ndef interrupt_main():\n    \"\"\"Set _interrupt flag to True to have start_new_thread raise\n    KeyboardInterrupt upon exiting.\"\"\"\n    if _main:\n        raise KeyboardInterrupt\n    else:\n        global _interrupt",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "_main",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "peekOfCode": "_main = True\ndef interrupt_main():\n    \"\"\"Set _interrupt flag to True to have start_new_thread raise\n    KeyboardInterrupt upon exiting.\"\"\"\n    if _main:\n        raise KeyboardInterrupt\n    else:\n        global _interrupt\n        _interrupt = True",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32._dummy_thread32",
        "documentation": {}
    },
    {
        "label": "_Link",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "class _Link(object):\n    __slots__ = 'prev', 'next', 'key', '__weakref__'\nclass OrderedDict(dict):\n    'Dictionary that remembers insertion order'\n    # An inherited dict maps keys to values.\n    # The inherited dict provides __getitem__, __len__, __contains__, and get.\n    # The remaining methods are order-aware.\n    # Big-O running times for all methods are the same as regular dictionaries.\n    # The internal self.__map dict maps keys to links in a doubly linked list.\n    # The circular doubly linked list starts and ends with a sentinel element.",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "class OrderedDict(dict):\n    'Dictionary that remembers insertion order'\n    # An inherited dict maps keys to values.\n    # The inherited dict provides __getitem__, __len__, __contains__, and get.\n    # The remaining methods are order-aware.\n    # Big-O running times for all methods are the same as regular dictionaries.\n    # The internal self.__map dict maps keys to links in a doubly linked list.\n    # The circular doubly linked list starts and ends with a sentinel element.\n    # The sentinel element never gets deleted (this simplifies the algorithm).\n    # The sentinel is in self.__hardroot with a weakref proxy in self.__root.",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "def update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "wraps",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "def wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "def total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    convert = {\n        '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),\n                   ('__le__', lambda self, other: self < other or self == other),\n                   ('__ge__', lambda self, other: not self < other)],\n        '__le__': [('__ge__', lambda self, other: not self <= other or self == other),\n                   ('__lt__', lambda self, other: self <= other and not self == other),\n                   ('__gt__', lambda self, other: not self <= other)],\n        '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "cmp_to_key",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "def cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "def lru_cache(maxsize=100):\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize) with\n    f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n    See:  http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',\n           'total_ordering', 'cmp_to_key', 'lru_cache', 'reduce', 'partial']\nfrom _functools import partial, reduce\nfrom collections import MutableMapping, namedtuple\nfrom .reprlib32 import recursive_repr as _recursive_repr\nfrom weakref import proxy as _proxy\nimport sys as _sys\ntry:\n    from thread import allocate_lock as Lock\nexcept ImportError:",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "WRAPPER_ASSIGNMENTS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "WRAPPER_UPDATES",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "WRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "_CacheInfo",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "peekOfCode": "_CacheInfo = namedtuple(\"CacheInfo\", \"hits misses maxsize currsize\")\ndef lru_cache(maxsize=100):\n    \"\"\"Least-recently-used cache decorator.\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n    Arguments to the cached function must be hashable.\n    View the cache statistics named tuple (hits, misses, maxsize, currsize) with\n    f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n    See:  http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.functools32",
        "documentation": {}
    },
    {
        "label": "Repr",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "peekOfCode": "class Repr:\n    def __init__(self):\n        self.maxlevel = 6\n        self.maxtuple = 6\n        self.maxlist = 6\n        self.maxarray = 5\n        self.maxdict = 4\n        self.maxset = 6\n        self.maxfrozenset = 6\n        self.maxdeque = 6",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "documentation": {}
    },
    {
        "label": "recursive_repr",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "peekOfCode": "def recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "peekOfCode": "__all__ = [\"Repr\", \"repr\", \"recursive_repr\"]\nimport __builtin__ as builtins\nfrom itertools import islice\ntry:\n    from thread import get_ident\nexcept ImportError:\n    from _dummy_thread32 import get_ident\ndef recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "documentation": {}
    },
    {
        "label": "aRepr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "peekOfCode": "aRepr = Repr()\nrepr = aRepr.repr",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "documentation": {}
    },
    {
        "label": "repr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "description": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "peekOfCode": "repr = aRepr.repr",
        "detail": "catboost.contrib.deprecated.python.functools32.functools32.reprlib32",
        "documentation": {}
    },
    {
        "label": "Error",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass _Waiter(object):",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CancelledError",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "TimeoutError",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n    def add_result(self, future):\n        self.finished_futures.append(future)",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_Waiter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n    def add_result(self, future):\n        self.finished_futures.append(future)\n    def add_exception(self, future):\n        self.finished_futures.append(future)\n    def add_cancelled(self, future):",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AsCompletedWaiter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class _AsCompletedWaiter(_Waiter):\n    \"\"\"Used by as_completed().\"\"\"\n    def __init__(self):\n        super(_AsCompletedWaiter, self).__init__()\n        self.lock = threading.Lock()\n    def add_result(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_result(future)\n            self.event.set()\n    def add_exception(self, future):",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_FirstCompletedWaiter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class _FirstCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_COMPLETED).\"\"\"\n    def add_result(self, future):\n        super(_FirstCompletedWaiter, self).add_result(future)\n        self.event.set()\n    def add_exception(self, future):\n        super(_FirstCompletedWaiter, self).add_exception(future)\n        self.event.set()\n    def add_cancelled(self, future):\n        super(_FirstCompletedWaiter, self).add_cancelled(future)",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AllCompletedWaiter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class _AllCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).\"\"\"\n    def __init__(self, num_pending_calls, stop_on_exception):\n        self.num_pending_calls = num_pending_calls\n        self.stop_on_exception = stop_on_exception\n        self.lock = threading.Lock()\n        super(_AllCompletedWaiter, self).__init__()\n    def _decrement_pending_calls(self):\n        with self.lock:\n            self.num_pending_calls -= 1",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AcquireFutures",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class _AcquireFutures(object):\n    \"\"\"A context manager that does an ordered acquire of Future conditions.\"\"\"\n    def __init__(self, futures):\n        self.futures = sorted(futures, key=id)\n    def __enter__(self):\n        for future in self.futures:\n            future._condition.acquire()\n    def __exit__(self, *args):\n        for future in self.futures:\n            future._condition.release()",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "Future",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class Future(object):\n    \"\"\"Represents the result of an asynchronous computation.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes the future. Should not be called by clients.\"\"\"\n        self._condition = threading.Condition()\n        self._state = PENDING\n        self._result = None\n        self._exception = None\n        self._traceback = None\n        self._waiters = []",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "Executor",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class Executor(object):\n    \"\"\"This is an abstract base class for concrete asynchronous executors.\"\"\"\n    def submit(self, fn, *args, **kwargs):\n        \"\"\"Submits a callable to be executed with the given arguments.\n        Schedules the callable to be executed as fn(*args, **kwargs) and returns\n        a Future instance representing the execution of the callable.\n        Returns:\n            A Future representing the given call.\n        \"\"\"\n        raise NotImplementedError()",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "BrokenExecutor",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "class BrokenExecutor(RuntimeError):\n    \"\"\"\n    Raised when a executor has become non-functional after a severe failure.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "def as_completed(fs, timeout=None):\n    \"\"\"An iterator over the given futures that yields each as it completes.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            iterate over.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n    Returns:\n        An iterator that yields the given Futures as they complete (finished or\n        cancelled). If any given Futures are duplicated, they will be returned",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "wait",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "def wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options\n            are:\n            FIRST_COMPLETED - Return when any future finishes or is",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\nFIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FIRST_COMPLETED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "FIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FIRST_EXCEPTION",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "FIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "ALL_COMPLETED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "ALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_AS_COMPLETED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "_AS_COMPLETED = '_AS_COMPLETED'\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "PENDING",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "PENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "RUNNING",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "RUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CANCELLED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "CANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "CANCELLED_AND_NOTIFIED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "CANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "FINISHED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "FINISHED = 'FINISHED'\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_FUTURE_STATES",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_STATE_TO_DESCRIPTION_MAP",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",\n    CANCELLED: \"cancelled\",\n    CANCELLED_AND_NOTIFIED: \"cancelled\",\n    FINISHED: \"finished\"\n}\n# Logger for internal use by the futures package.\nLOGGER = logging.getLogger(\"concurrent.futures\")\nclass Error(Exception):",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "LOGGER",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "LOGGER = logging.getLogger(\"concurrent.futures\")\nclass Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\nclass TimeoutError(Error):\n    \"\"\"The operation exceeded the given deadline.\"\"\"\n    pass",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "DoneAndNotDoneFutures",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "peekOfCode": "DoneAndNotDoneFutures = collections.namedtuple(\n        'DoneAndNotDoneFutures', 'done not_done')\ndef wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures._base",
        "documentation": {}
    },
    {
        "label": "_WorkItem",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "class _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\nclass _ResultItem(object):\n    def __init__(self, work_id, exception=None, result=None):\n        self.work_id = work_id\n        self.exception = exception",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_ResultItem",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "class _ResultItem(object):\n    def __init__(self, work_id, exception=None, result=None):\n        self.work_id = work_id\n        self.exception = exception\n        self.result = result\nclass _CallItem(object):\n    def __init__(self, work_id, fn, args, kwargs):\n        self.work_id = work_id\n        self.fn = fn\n        self.args = args",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_CallItem",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "class _CallItem(object):\n    def __init__(self, work_id, fn, args, kwargs):\n        self.work_id = work_id\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\ndef _process_worker(call_queue, result_queue):\n    \"\"\"Evaluates calls from call_queue and places the results in result_queue.\n    This worker is run in a separate process.\n    Args:",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "ProcessPoolExecutor",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "class ProcessPoolExecutor(_base.Executor):\n    def __init__(self, max_workers=None):\n        \"\"\"Initializes a new ProcessPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of processes that can be used to\n                execute the given calls. If None or not given then as many\n                worker processes will be created as the machine has processors.\n        \"\"\"\n        _check_system_limits()\n        if max_workers is None:",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n# Workers are created as daemon threads and processes. This is done to allow the\n# interpreter to exit when there are still idle processes in a\n# ProcessPoolExecutor's process pool (i.e. shutdown() was not called). However,\n# allowing workers to die with the interpreter has two undesirable properties:\n#   - The workers would still be running during interpreter shutdown,\n#     meaning that they would fail in unpredictable ways.\n#   - The workers could be killed while evaluating a work item, which could\n#     be bad if the callable being evaluated has external side-effects e.g.\n#     writing to a file.",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_threads_queues",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False\ndef _python_exit():\n    global _shutdown\n    _shutdown = True\n    items = list(_threads_queues.items()) if _threads_queues else ()\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join(sys.maxint)",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_shutdown",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "_shutdown = False\ndef _python_exit():\n    global _shutdown\n    _shutdown = True\n    items = list(_threads_queues.items()) if _threads_queues else ()\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join(sys.maxint)\n# Controls how many more calls than processes will be queued in the call queue.",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "EXTRA_QUEUED_CALLS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "EXTRA_QUEUED_CALLS = 1\nclass _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\nclass _ResultItem(object):\n    def __init__(self, work_id, exception=None, result=None):\n        self.work_id = work_id",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_system_limits_checked",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "_system_limits_checked = False\n_system_limited = None\ndef _check_system_limits():\n    global _system_limits_checked, _system_limited\n    if _system_limits_checked:\n        if _system_limited:\n            raise NotImplementedError(_system_limited)\n    _system_limits_checked = True\n    try:\n        import os",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_system_limited",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "peekOfCode": "_system_limited = None\ndef _check_system_limits():\n    global _system_limits_checked, _system_limited\n    if _system_limits_checked:\n        if _system_limited:\n            raise NotImplementedError(_system_limited)\n    _system_limits_checked = True\n    try:\n        import os\n        nsems_max = os.sysconf(\"SC_SEM_NSEMS_MAX\")",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.process",
        "documentation": {}
    },
    {
        "label": "_WorkItem",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "class _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n    def run(self):\n        if not self.future.set_running_or_notify_cancel():\n            return\n        try:",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "BrokenThreadPool",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "class BrokenThreadPool(_base.BrokenExecutor):\n    \"\"\"\n    Raised when a worker thread in a ThreadPoolExecutor failed initializing.\n    \"\"\"\nclass ThreadPoolExecutor(_base.Executor):\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().next\n    def __init__(self, max_workers=None, thread_name_prefix='', initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n        Args:",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "class ThreadPoolExecutor(_base.Executor):\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().next\n    def __init__(self, max_workers=None, thread_name_prefix='', initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.\n        \"\"\"",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n# Workers are created as daemon threads. This is done to allow the interpreter\n# to exit when there are still idle threads in a ThreadPoolExecutor's thread\n# pool (i.e. shutdown() was not called). However, allowing workers to die with\n# the interpreter has two undesirable properties:\n#   - The workers would still be running during interpreter shutdown,\n#     meaning that they would fail in unpredictable ways.\n#   - The workers could be killed while evaluating a work item, which could\n#     be bad if the callable being evaluated has external side-effects e.g.\n#     writing to a file.",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "_threads_queues",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False\ndef _python_exit():\n    global _shutdown\n    _shutdown = True\n    items = list(_threads_queues.items()) if _threads_queues else ()\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join(sys.maxint)",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "_shutdown",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "description": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "peekOfCode": "_shutdown = False\ndef _python_exit():\n    global _shutdown\n    _shutdown = True\n    items = list(_threads_queues.items()) if _threads_queues else ()\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join(sys.maxint)\natexit.register(_python_exit)",
        "detail": "catboost.contrib.deprecated.python.futures.concurrent.futures.thread",
        "documentation": {}
    },
    {
        "label": "TestMixin",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "class TestMixin(unittest.TestCase):\n    def setUp(self):\n        global TEST_PATH\n        TEST_PATH = yatest.common.test_output_path('../test')\n        if not os.path.exists(TEST_PATH):\n            setup_main()\n        if symlinks_supported and not os.path.exists(\n                os.path.join(TEST_PATH, 'linkdir', 'linksubdir')):\n            setup_symlinks()\n    if not hasattr(unittest.TestCase, 'skipTest'):",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "create_file",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "def create_file(path, contents='1234'):\n    with open(path, 'w') as f:\n        f.write(contents)\ndef setup_main():\n    join = os.path.join\n    os.mkdir(TEST_PATH)\n    os.mkdir(join(TEST_PATH, 'subdir'))\n    create_file(join(TEST_PATH, 'file1.txt'))\n    create_file(join(TEST_PATH, 'file2.txt'), contents='12345678')\n    os.mkdir(join(TEST_PATH, 'subdir', 'unidir\\u018F'))",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "setup_main",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "def setup_main():\n    join = os.path.join\n    os.mkdir(TEST_PATH)\n    os.mkdir(join(TEST_PATH, 'subdir'))\n    create_file(join(TEST_PATH, 'file1.txt'))\n    create_file(join(TEST_PATH, 'file2.txt'), contents='12345678')\n    os.mkdir(join(TEST_PATH, 'subdir', 'unidir\\u018F'))\n    create_file(join(TEST_PATH, 'subdir', 'file1.txt'))\n    create_file(join(TEST_PATH, 'subdir', 'unicod\\u018F.txt'))\n    create_file(join(TEST_PATH, 'subdir', 'unidir\\u018F', 'file1.txt'))",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "setup_symlinks",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "def setup_symlinks():\n    join = os.path.join\n    os.mkdir(join(TEST_PATH, 'linkdir', 'linksubdir'))\n    create_file(join(TEST_PATH, 'linkdir', 'file1.txt'))\n    os.symlink(os.path.abspath(join(TEST_PATH, 'linkdir', 'file1.txt')),\n               join(TEST_PATH, 'linkdir', 'link_to_file'))\n    dir_name = os.path.abspath(join(TEST_PATH, 'linkdir', 'linksubdir'))\n    dir_link = join(TEST_PATH, 'linkdir', 'link_to_dir')\n    if IS_PY3:\n        os.symlink(dir_name, dir_link, target_is_directory=True)",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "teardown",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "def teardown():\n    try:\n        shutil.rmtree(TEST_PATH)\n    except OSError:\n        # why does the above fail sometimes?\n        time.sleep(0.1)\n        shutil.rmtree(TEST_PATH)\nclass TestMixin(unittest.TestCase):\n    def setUp(self):\n        global TEST_PATH",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_DIRECTORY",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "FILE_ATTRIBUTE_DIRECTORY = 16\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    int_types = int\nelse:\n    int_types = (int, long)\n    str = unicode\nif hasattr(os, 'symlink'):\n    try:\n        #link_name = os.path.join(os.path.dirname(__file__), '_testlink')",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "IS_PY3",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "peekOfCode": "IS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    int_types = int\nelse:\n    int_types = (int, long)\n    str = unicode\nif hasattr(os, 'symlink'):\n    try:\n        #link_name = os.path.join(os.path.dirname(__file__), '_testlink')\n        #os.symlink(__file__, link_name)",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_scandir",
        "documentation": {}
    },
    {
        "label": "TestWalk",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "peekOfCode": "class TestWalk(unittest.TestCase):\n    testfn = os.path.join(os.path.dirname(__file__), 'temp')\n    def test_traversal(self):\n        self.testfn = yatest.common.test_output_path('temp')\n        # Build:\n        #     TESTFN/\n        #       TEST1/              a file kid and two directory kids\n        #         tmp1\n        #         SUB1/             a file kid and a directory kid\n        #           tmp2",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "documentation": {}
    },
    {
        "label": "TestWalkSymlink",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "peekOfCode": "class TestWalkSymlink(unittest.TestCase):\n    temp_dir = os.path.join(os.path.dirname(__file__), 'temp')\n    def setUp(self):\n        self.temp_dir = yatest.common.test_output_path('temp')\n        os.mkdir(self.temp_dir)\n        self.dir_name = os.path.join(self.temp_dir, 'dir')\n        os.mkdir(self.dir_name)\n        open(os.path.join(self.dir_name, 'subfile'), 'w').close()\n        self.file_name = os.path.join(self.temp_dir, 'file')\n        open(self.file_name, 'w').close()",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "documentation": {}
    },
    {
        "label": "walk_func",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "peekOfCode": "walk_func = scandir.walk\nIS_PY3 = sys.version_info >= (3, 0)\nclass TestWalk(unittest.TestCase):\n    testfn = os.path.join(os.path.dirname(__file__), 'temp')\n    def test_traversal(self):\n        self.testfn = yatest.common.test_output_path('temp')\n        # Build:\n        #     TESTFN/\n        #       TEST1/              a file kid and two directory kids\n        #         tmp1",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "documentation": {}
    },
    {
        "label": "IS_PY3",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "description": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "peekOfCode": "IS_PY3 = sys.version_info >= (3, 0)\nclass TestWalk(unittest.TestCase):\n    testfn = os.path.join(os.path.dirname(__file__), 'temp')\n    def test_traversal(self):\n        self.testfn = yatest.common.test_output_path('temp')\n        # Build:\n        #     TESTFN/\n        #       TEST1/              a file kid and two directory kids\n        #         tmp1\n        #         SUB1/             a file kid and a directory kid",
        "detail": "catboost.contrib.deprecated.python.scandir.tests.test_walk",
        "documentation": {}
    },
    {
        "label": "GenericDirEntry",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "class GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):\n        self._scandir_path = scandir_path\n        self.name = name\n        self._stat = None\n        self._lstat = None\n        self._path = None\n    @property\n    def path(self):",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "__version__ = '1.10.0'\n__all__ = ['scandir', 'walk']\n# Windows FILE_ATTRIBUTE constants for interpreting the\n# FIND_DATA.dwFileAttributes member\nFILE_ATTRIBUTE_ARCHIVE = 32\nFILE_ATTRIBUTE_COMPRESSED = 2048\nFILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "__all__ = ['scandir', 'walk']\n# Windows FILE_ATTRIBUTE constants for interpreting the\n# FIND_DATA.dwFileAttributes member\nFILE_ATTRIBUTE_ARCHIVE = 32\nFILE_ATTRIBUTE_COMPRESSED = 2048\nFILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_ARCHIVE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_ARCHIVE = 32\nFILE_ATTRIBUTE_COMPRESSED = 2048\nFILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_COMPRESSED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_COMPRESSED = 2048\nFILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_DEVICE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_DIRECTORY",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_ENCRYPTED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_HIDDEN",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_INTEGRITY_STREAM",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_NORMAL",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_NO_SCRUB_DATA",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_OFFLINE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_READONLY",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_REPARSE_POINT",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_SPARSE_FILE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_SYSTEM",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):\n        self._scandir_path = scandir_path",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_TEMPORARY",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):\n        self._scandir_path = scandir_path\n        self.name = name",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "FILE_ATTRIBUTE_VIRTUAL",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "FILE_ATTRIBUTE_VIRTUAL = 65536\nIS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):\n        self._scandir_path = scandir_path\n        self.name = name\n        self._stat = None",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "IS_PY3",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "IS_PY3 = sys.version_info >= (3, 0)\nif IS_PY3:\n    unicode = str  # Because Python <= 3.2 doesn't have u'unicode' syntax\nclass GenericDirEntry(object):\n    __slots__ = ('name', '_stat', '_lstat', '_scandir_path', '_path')\n    def __init__(self, scandir_path, name):\n        self._scandir_path = scandir_path\n        self.name = name\n        self._stat = None\n        self._lstat = None",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "scandir_c",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "scandir_c = None\nscandir_python = None\nif sys.platform == 'win32':\n    if ctypes is not None:\n        from ctypes import wintypes\n        # Various constants from windows.h\n        INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value\n        ERROR_FILE_NOT_FOUND = 2\n        ERROR_NO_MORE_FILES = 18\n        IO_REPARSE_TAG_SYMLINK = 0xA000000C",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "scandir_python",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.scandir.scandir",
        "description": "catboost.contrib.deprecated.python.scandir.scandir",
        "peekOfCode": "scandir_python = None\nif sys.platform == 'win32':\n    if ctypes is not None:\n        from ctypes import wintypes\n        # Various constants from windows.h\n        INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value\n        ERROR_FILE_NOT_FOUND = 2\n        ERROR_NO_MORE_FILES = 18\n        IO_REPARSE_TAG_SYMLINK = 0xA000000C\n        # Numer of seconds between 1601-01-01 and 1970-01-01",
        "detail": "catboost.contrib.deprecated.python.scandir.scandir",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "class ChainMap(MutableMapping):\n    ''' A ChainMap groups multiple dicts (or other mappings) together\n    to create a single, updateable view.\n    The underlying mappings are stored in a list.  That list is public and can\n    accessed or updated using the *maps* attribute.  There is no other state.\n    Lookups search the underlying mappings successively until a key is found.\n    In contrast, writes, updates, and deletions only operate on the first\n    mapping.\n    '''\n    def __init__(self, *maps):",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "MappingProxyType",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "class MappingProxyType(UserDict):\n    def __init__(self, data):\n        UserDict.__init__(self)\n        self.data = data\ntry:\n    from abc import get_cache_token\nexcept ImportError:\n    def get_cache_token():\n        return ABCMeta._abc_invalidation_counter\nclass Support(object):",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "Support",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "class Support(object):\n    def dummy(self):\n        pass\n    def cpython_only(self, func):\n        if 'PyPy' in sys.version:\n            return self.dummy\n        return func\ndef get_type_hints(func):\n    # only import typing if annotation parsing is necessary\n    from typing import get_type_hints",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "recursive_repr",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "def recursive_repr(fillvalue='...'):\n    'Decorator to make a repr function return fillvalue for a recursive call'\n    def decorating_function(user_function):\n        repr_running = set()\n        def wrapper(self):\n            key = id(self), get_ident()\n            if key in repr_running:\n                return fillvalue\n            repr_running.add(key)\n            try:",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "get_type_hints",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "def get_type_hints(func):\n    # only import typing if annotation parsing is necessary\n    from typing import get_type_hints\n    return get_type_hints(func) or getattr(func, '__annotations__', {})\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "def update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "WRAPPER_ASSIGNMENTS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "WRAPPER_UPDATES",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "description": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "peekOfCode": "WRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to",
        "detail": "catboost.contrib.deprecated.python.singledispatch.singledispatch.helpers",
        "documentation": {}
    },
    {
        "label": "sig_child",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "description": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "peekOfCode": "sig_child = getattr(signal, 'SIGCLD', None)\nif sig_child is None:\n    sig_child = getattr(signal, 'SIGCHLD')\nsignal.signal(sig_child, signal.SIG_IGN)\nsubprocess32.Popen([sys.executable, '-c', 'print(\"albatross\")']).wait()\n# Also ensure poll() handles an errno.ECHILD appropriately.\np = subprocess32.Popen([sys.executable, '-c', 'print(\"albatross\")'])\nnum_polls = 0\nwhile p.poll() is None:\n    # Waiting for the process to finish.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "description": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "peekOfCode": "p = subprocess32.Popen([sys.executable, '-c', 'print(\"albatross\")'])\nnum_polls = 0\nwhile p.poll() is None:\n    # Waiting for the process to finish.\n    time.sleep(0.01)  # Avoid being a CPU busy loop.\n    num_polls += 1\n    if num_polls > 3000:\n        raise RuntimeError('poll should have returned 0 within 30 seconds')",
        "detail": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "documentation": {}
    },
    {
        "label": "num_polls",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "description": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "peekOfCode": "num_polls = 0\nwhile p.poll() is None:\n    # Waiting for the process to finish.\n    time.sleep(0.01)  # Avoid being a CPU busy loop.\n    num_polls += 1\n    if num_polls > 3000:\n        raise RuntimeError('poll should have returned 0 within 30 seconds')",
        "detail": "catboost.contrib.deprecated.python.subprocess32.testdata.sigchild_ignore",
        "documentation": {}
    },
    {
        "label": "SubprocessError",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "class SubprocessError(Exception): pass\nclass CalledProcessError(SubprocessError):\n    \"\"\"Raised when run() is called with check=True and the process\n    returns a non-zero exit status.\n    Attributes:\n      cmd, returncode, stdout, stderr, output\n    \"\"\"\n    def __init__(self, returncode, cmd, output=None, stderr=None):\n        self.returncode = returncode\n        self.cmd = cmd",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "class CalledProcessError(SubprocessError):\n    \"\"\"Raised when run() is called with check=True and the process\n    returns a non-zero exit status.\n    Attributes:\n      cmd, returncode, stdout, stderr, output\n    \"\"\"\n    def __init__(self, returncode, cmd, output=None, stderr=None):\n        self.returncode = returncode\n        self.cmd = cmd\n        self.output = output",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "TimeoutExpired",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "class TimeoutExpired(SubprocessError):\n    \"\"\"This exception is raised when the timeout expires while waiting for a\n    child process.\n    Attributes:\n        cmd, output, stdout, stderr, timeout\n    \"\"\"\n    def __init__(self, cmd, timeout, output=None, stderr=None):\n        self.cmd = cmd\n        self.timeout = timeout\n        self.output = output",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "CompletedProcess",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "class CompletedProcess(object):\n    \"\"\"A process that has finished running.\n    This is returned by run().\n    Attributes:\n      args: The list or str args passed to run().\n      returncode: The exit code of the process, negative for signals.\n      stdout: The standard output (None if not captured).\n      stderr: The standard error (None if not captured).\n    \"\"\"\n    def __init__(self, args, returncode, stdout=None, stderr=None):",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "Popen",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "class Popen(object):\n    def __init__(self, args, bufsize=0, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,\n                 shell=False, cwd=None, env=None, universal_newlines=False,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=()):\n        \"\"\"Create new Popen instance.\"\"\"\n        _cleanup()",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "call",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "def call(*popenargs, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete or\n    timeout, then return the returncode attribute.\n    The arguments are the same as for the Popen constructor.  Example:\n    retcode = call([\"ls\", \"-l\"])\n    \"\"\"\n    timeout = kwargs.pop('timeout', None)\n    p = Popen(*popenargs, **kwargs)\n    try:\n        return p.wait(timeout=timeout)",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "check_call",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "def check_call(*popenargs, **kwargs):\n    \"\"\"Run command with arguments.  Wait for command to complete.  If\n    the exit code was zero then return, otherwise raise\n    CalledProcessError.  The CalledProcessError object will have the\n    return code in the returncode attribute.\n    The arguments are the same as for the call function.  Example:\n    check_call([\"ls\", \"-l\"])\n    \"\"\"\n    retcode = call(*popenargs, **kwargs)\n    if retcode:",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "check_output",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "def check_output(*popenargs, **kwargs):\n    r\"\"\"Run command with arguments and return its output as a byte string.\n    If the exit code was non-zero it raises a CalledProcessError.  The\n    CalledProcessError object will have the return code in the returncode\n    attribute and output in the output attribute.\n    The arguments are the same as for the Popen constructor.  Example:\n    >>> check_output([\"ls\", \"-l\", \"/dev/null\"])\n    'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n    The stdout argument is not allowed as it is used internally.\n    To capture standard error in the result, use stderr=STDOUT.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "def run(*popenargs, **kwargs):\n    \"\"\"Run command with arguments and return a CompletedProcess instance.\n    The returned instance will have attributes args, returncode, stdout and\n    stderr. By default, stdout and stderr are not captured, and those attributes\n    will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n    If check is True and the exit code was non-zero, it raises a\n    CalledProcessError. The CalledProcessError object will have the return code\n    in the returncode attribute, and output & stderr attributes if those streams\n    were captured.\n    If timeout is given, and the process takes too long, a TimeoutExpired",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "list2cmdline",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "def list2cmdline(seq):\n    \"\"\"\n    Translate a sequence of arguments into a command line\n    string, using the same rules as the MS C runtime:\n    1) Arguments are delimited by white space, which is either a\n       space or a tab.\n    2) A string surrounded by double quotation marks is\n       interpreted as a single argument, regardless of white space\n       contained within.  A quoted string can be embedded in an\n       argument.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "mswindows",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "mswindows = (sys.platform == \"win32\")\nimport os\nimport errno\nimport exceptions\nimport types\nimport time\nimport traceback\nimport gc\nimport signal\n# Exception classes used by this module.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "__all__ = [\"Popen\", \"PIPE\", \"STDOUT\", \"call\", \"check_call\",\n           \"check_output\", \"CalledProcessError\"]\nif mswindows:\n    from _subprocess import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,\n                             STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,\n                             STD_ERROR_HANDLE, SW_HIDE,\n                             STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW)\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx\n    # Note: In Python 3.3 this constant is found in the _winapi module.\n    _WAIT_TIMEOUT = 0x102",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "_active",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "_active = []\ndef _cleanup():\n    for inst in _active[:]:\n        res = inst._internal_poll(_deadstate=sys.maxint)\n        if res is not None:\n            try:\n                _active.remove(inst)\n            except ValueError:\n                # This can happen if two threads create a new Popen instance.\n                # It's harmless that it was already removed, so ignore.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "PIPE = -1\nSTDOUT = -2\nDEVNULL = -3\n# This function is only used by multiprocessing, it is here so that people\n# can drop subprocess32 in as a replacement for the stdlib subprocess module.\ndef _args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    settings in sys.flags and sys.warnoptions.\"\"\"\n    flag_opt_map = {\n        'debug': 'd',",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "STDOUT = -2\nDEVNULL = -3\n# This function is only used by multiprocessing, it is here so that people\n# can drop subprocess32 in as a replacement for the stdlib subprocess module.\ndef _args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    settings in sys.flags and sys.warnoptions.\"\"\"\n    flag_opt_map = {\n        'debug': 'd',\n        # 'inspect': 'i',",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "DEVNULL",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "DEVNULL = -3\n# This function is only used by multiprocessing, it is here so that people\n# can drop subprocess32 in as a replacement for the stdlib subprocess module.\ndef _args_from_interpreter_flags():\n    \"\"\"Return a list of command-line arguments reproducing the current\n    settings in sys.flags and sys.warnoptions.\"\"\"\n    flag_opt_map = {\n        'debug': 'd',\n        # 'inspect': 'i',\n        # 'interactive': 'i',",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "_PLATFORM_DEFAULT_CLOSE_FDS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "peekOfCode": "_PLATFORM_DEFAULT_CLOSE_FDS = object()\nclass Popen(object):\n    def __init__(self, args, bufsize=0, executable=None,\n                 stdin=None, stdout=None, stderr=None,\n                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,\n                 shell=False, cwd=None, env=None, universal_newlines=False,\n                 startupinfo=None, creationflags=0,\n                 restore_signals=True, start_new_session=False,\n                 pass_fds=()):\n        \"\"\"Create new Popen instance.\"\"\"",
        "detail": "catboost.contrib.deprecated.python.subprocess32.subprocess32",
        "documentation": {}
    },
    {
        "label": "BaseTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class BaseTestCase(unittest.TestCase):\n    def setUp(self):\n        os.environ['Y_PYTHON_ENTRY_POINT'] = ':main'\n        # Try to minimize the number of children we have so this test\n        # doesn't crash on some buildbots (Alphas in particular).\n        reap_children()\n        if not hasattr(unittest.TestCase, 'addCleanup'):\n            self._cleanups = []\n    def tearDown(self):\n        try:",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "PopenTestException",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class PopenTestException(Exception):\n    pass\nclass PopenExecuteChildRaises(subprocess32.Popen):\n    \"\"\"Popen subclass for testing cleanup of subprocess.PIPE filehandles when\n    _execute_child fails.\n    \"\"\"\n    def _execute_child(self, *args, **kwargs):\n        raise PopenTestException(\"Forced Exception for Test\")\nclass ProcessTestCase(BaseTestCase):\n    def test_call_seq(self):",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "PopenExecuteChildRaises",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class PopenExecuteChildRaises(subprocess32.Popen):\n    \"\"\"Popen subclass for testing cleanup of subprocess.PIPE filehandles when\n    _execute_child fails.\n    \"\"\"\n    def _execute_child(self, *args, **kwargs):\n        raise PopenTestException(\"Forced Exception for Test\")\nclass ProcessTestCase(BaseTestCase):\n    def test_call_seq(self):\n        # call() function with sequence argument\n        rc = subprocess.call([sys.executable, \"-c\", yenv +",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "ProcessTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class ProcessTestCase(BaseTestCase):\n    def test_call_seq(self):\n        # call() function with sequence argument\n        rc = subprocess.call([sys.executable, \"-c\", yenv +\n                              \"import sys; sys.exit(47)\"])\n        self.assertEqual(rc, 47)\n    def test_call_timeout(self):\n        # call() function with timeout argument; we want to test that the child\n        # process gets killed when the timeout expires.  If the child isn't\n        # killed, this call will deadlock since subprocess.call waits for the",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "RunFuncTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class RunFuncTestCase(BaseTestCase):\n    def run_python(self, code, **kwargs):\n        \"\"\"Run Python code in a subprocess using subprocess.run\"\"\"\n        argv = [sys.executable, \"-c\", yenv + code]\n        return subprocess.run(argv, **kwargs)\n    def test_returncode(self):\n        # call() function with sequence argument\n        cp = self.run_python(\"import sys; sys.exit(47)\")\n        self.assertEqual(cp.returncode, 47)\n        try:",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "_SuppressCoreFiles",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class _SuppressCoreFiles(object):\n    \"\"\"Try to prevent core files from being created.\"\"\"\n    old_limit = None\n    def __enter__(self):\n        \"\"\"Try to save previous ulimit, then set it to (0, 0).\"\"\"\n        try:\n            import resource\n            self.old_limit = resource.getrlimit(resource.RLIMIT_CORE)\n            resource.setrlimit(resource.RLIMIT_CORE, (0, 0))\n        except (ImportError, ValueError, resource.error):",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "POSIXProcessTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class POSIXProcessTestCase(BaseTestCase):\n    def setUp(self):\n        BaseTestCase.setUp(self)\n        self._nonexistent_dir = \"/_this/pa.th/does/not/exist\"\n    def _get_chdir_exception(self):\n        try:\n            os.chdir(self._nonexistent_dir)\n        except OSError, e:\n            # This avoids hard coding the errno value or the OS perror()\n            # string and instead capture the exception that we want to see",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "Win32ProcessTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class Win32ProcessTestCase(BaseTestCase):\n    def test_startupinfo(self):\n        # startupinfo argument\n        # We uses hardcoded constants, because we do not want to\n        # depend on win32all.\n        STARTF_USESHOWWINDOW = 1\n        SW_MAXIMIZE = 3\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags = STARTF_USESHOWWINDOW\n        startupinfo.wShowWindow = SW_MAXIMIZE",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "ProcessTestCaseNoPoll",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class ProcessTestCaseNoPoll(ProcessTestCase):\n    def setUp(self):\n        subprocess._has_poll = False\n        ProcessTestCase.setUp(self)\n    def tearDown(self):\n        subprocess._has_poll = True\n        ProcessTestCase.tearDown(self)\nif not getattr(subprocess, '_has_poll', False):\n    class ProcessTestCaseNoPoll(unittest.TestCase): pass\n#@unittest.skipUnless(getattr(subprocess, '_posixsubprocess', False),",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "ProcessTestCasePOSIXPurePython",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class ProcessTestCasePOSIXPurePython(ProcessTestCase, POSIXProcessTestCase):\n    def setUp(self):\n        subprocess._posixsubprocess = None\n        ProcessTestCase.setUp(self)\n        POSIXProcessTestCase.setUp(self)\n    def tearDown(self):\n        subprocess._posixsubprocess = sys.modules['_posixsubprocess32']\n        POSIXProcessTestCase.tearDown(self)\n        ProcessTestCase.tearDown(self)\nclass POSIXSubprocessModuleTestCase(unittest.TestCase):",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "POSIXSubprocessModuleTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class POSIXSubprocessModuleTestCase(unittest.TestCase):\n    def test_fork_exec_sorted_fd_sanity_check(self):\n        # Issue #23564: sanity check the fork_exec() fds_to_keep sanity check.\n        _posixsubprocess = subprocess._posixsubprocess\n        gc_enabled = gc.isenabled()\n        try:\n            gc.enable()\n            for fds_to_keep in (\n                (-1, 2, 3, 4, 5),  # Negative number.\n                ('str', 4),  # Not an int.",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "HelperFunctionTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class HelperFunctionTests(unittest.TestCase):\n    #@unittest.skipIf(mswindows, \"errno and EINTR make no sense on windows\")\n    def test_eintr_retry_call(self):\n        record_calls = []\n        def fake_os_func(*args):\n            record_calls.append(args)\n            if len(record_calls) == 2:\n                raise OSError(errno.EINTR, \"fake interrupted system call\")\n            return tuple(reversed(args))\n        self.assertEqual((999, 256),",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "ContextManagerTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "class ContextManagerTests(BaseTestCase):\n    def test_pipe(self):\n        proc = subprocess.Popen([sys.executable, \"-c\", yenv +\n                               \"import sys;\"\n                               \"sys.stdout.write('stdout');\"\n                               \"sys.stderr.write('stderr');\"],\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n        try:\n            self.assertEqual(proc.stdout.read(), \"stdout\")",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "reap_children",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "def reap_children():\n    \"\"\"Use this function at the end of test_main() whenever sub-processes\n    are started.  This will help ensure that no extra children (zombies)\n    stick around to hog resources and create problems when looking\n    for refleaks.\n    \"\"\"\n    # Reap all our dead child processes so we don't leave zombies around.\n    # These hog resources and might be causing some of the buildbots to die.\n    if hasattr(os, 'waitpid'):\n        any_process = -1",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "def main():\n    unit_tests = (ProcessTestCase,\n                  POSIXProcessTestCase,\n                  POSIXSubprocessModuleTestCase,\n                  Win32ProcessTestCase,\n                  ProcessTestCasePOSIXPurePython,\n                  ProcessTestCaseNoPoll,\n                  HelperFunctionTests,\n                  ContextManagerTests,\n                  RunFuncTestCase,",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "subprocess = subprocess32\nimport sys\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\nelse:\n    import ctypes.util\nimport signal\nimport os",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "mswindows",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "mswindows = (sys.platform == \"win32\")\nyenv = '''\nimport os\nos.environ['Y_PYTHON_ENTRY_POINT'] = ':main'\n'''\n#\n# Depends on the following external programs: Python\n#\nif mswindows:\n    SETBINARY = ('import msvcrt; msvcrt.setmode(sys.stdout.fileno(), '",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "yenv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "yenv = '''\nimport os\nos.environ['Y_PYTHON_ENTRY_POINT'] = ':main'\n'''\n#\n# Depends on the following external programs: Python\n#\nif mswindows:\n    SETBINARY = ('import msvcrt; msvcrt.setmode(sys.stdout.fileno(), '\n                                                'os.O_BINARY);')",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "os.environ['Y_PYTHON_ENTRY_POINT']",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "description": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "peekOfCode": "os.environ['Y_PYTHON_ENTRY_POINT'] = ':main'\n'''\n#\n# Depends on the following external programs: Python\n#\nif mswindows:\n    SETBINARY = ('import msvcrt; msvcrt.setmode(sys.stdout.fileno(), '\n                                                'os.O_BINARY);')\nelse:\n    SETBINARY = ''",
        "detail": "catboost.contrib.deprecated.python.subprocess32.test_subprocess32",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "description": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "peekOfCode": "class A(Generic[T]):\n    pass\nclass B(Generic[T]):\n    class A(Generic[T]):\n        pass",
        "detail": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "description": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "peekOfCode": "class B(Generic[T]):\n    class A(Generic[T]):\n        pass",
        "detail": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "description": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "peekOfCode": "T = TypeVar('T')\nclass A(Generic[T]):\n    pass\nclass B(Generic[T]):\n    class A(Generic[T]):\n        pass",
        "detail": "catboost.contrib.deprecated.python.typing.test.mod_generics_cache",
        "documentation": {}
    },
    {
        "label": "BaseTestCase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class BaseTestCase(TestCase):\n    def assertIsSubclass(self, cls, class_or_tuple, msg=None):\n        if not issubclass(cls, class_or_tuple):\n            message = '%r is not a subclass of %r' % (cls, class_or_tuple)\n            if msg is not None:\n                message += ' : %s' % msg\n            raise self.failureException(message)\n    def assertNotIsSubclass(self, cls, class_or_tuple, msg=None):\n        if issubclass(cls, class_or_tuple):\n            message = '%r is a subclass of %r' % (cls, class_or_tuple)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "Employee",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class Employee(object):\n    pass\nclass Manager(Employee):\n    pass\nclass Founder(Employee):\n    pass\nclass ManagingFounder(Manager, Founder):\n    pass\nclass AnyTests(BaseTestCase):\n    def test_any_instance_type_error(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "Manager",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class Manager(Employee):\n    pass\nclass Founder(Employee):\n    pass\nclass ManagingFounder(Manager, Founder):\n    pass\nclass AnyTests(BaseTestCase):\n    def test_any_instance_type_error(self):\n        with self.assertRaises(TypeError):\n            isinstance(42, Any)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "Founder",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class Founder(Employee):\n    pass\nclass ManagingFounder(Manager, Founder):\n    pass\nclass AnyTests(BaseTestCase):\n    def test_any_instance_type_error(self):\n        with self.assertRaises(TypeError):\n            isinstance(42, Any)\n    def test_any_subclass_type_error(self):\n        with self.assertRaises(TypeError):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "ManagingFounder",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class ManagingFounder(Manager, Founder):\n    pass\nclass AnyTests(BaseTestCase):\n    def test_any_instance_type_error(self):\n        with self.assertRaises(TypeError):\n            isinstance(42, Any)\n    def test_any_subclass_type_error(self):\n        with self.assertRaises(TypeError):\n            issubclass(Employee, Any)\n        with self.assertRaises(TypeError):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "AnyTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class AnyTests(BaseTestCase):\n    def test_any_instance_type_error(self):\n        with self.assertRaises(TypeError):\n            isinstance(42, Any)\n    def test_any_subclass_type_error(self):\n        with self.assertRaises(TypeError):\n            issubclass(Employee, Any)\n        with self.assertRaises(TypeError):\n            issubclass(Any, Employee)\n    def test_repr(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "NoReturnTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class NoReturnTests(BaseTestCase):\n    def test_noreturn_instance_type_error(self):\n        with self.assertRaises(TypeError):\n            isinstance(42, NoReturn)\n    def test_noreturn_subclass_type_error(self):\n        with self.assertRaises(TypeError):\n            issubclass(Employee, NoReturn)\n        with self.assertRaises(TypeError):\n            issubclass(NoReturn, Employee)\n    def test_repr(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "TypeVarTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class TypeVarTests(BaseTestCase):\n    def test_basic_plain(self):\n        T = TypeVar('T')\n        # T equals itself.\n        self.assertEqual(T, T)\n        # T is an instance of TypeVar\n        self.assertIsInstance(T, TypeVar)\n    def test_typevar_instance_type_error(self):\n        T = TypeVar('T')\n        with self.assertRaises(TypeError):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "UnionTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class UnionTests(BaseTestCase):\n    def test_basics(self):\n        u = Union[int, float]\n        self.assertNotEqual(u, Union)\n    def test_subclass_error(self):\n        with self.assertRaises(TypeError):\n            issubclass(int, Union)\n        with self.assertRaises(TypeError):\n            issubclass(Union, int)\n        with self.assertRaises(TypeError):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "TupleTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class TupleTests(BaseTestCase):\n    def test_basics(self):\n        with self.assertRaises(TypeError):\n            issubclass(Tuple, Tuple[int, str])\n        with self.assertRaises(TypeError):\n            issubclass(tuple, Tuple[int, str])\n        class TP(tuple): pass\n        self.assertTrue(issubclass(tuple, Tuple))\n        self.assertTrue(issubclass(TP, Tuple))\n    def test_equality(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "CallableTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class CallableTests(BaseTestCase):\n    def test_self_subclass(self):\n        with self.assertRaises(TypeError):\n            self.assertTrue(issubclass(type(lambda x: x), Callable[[int], int]))\n        self.assertTrue(issubclass(type(lambda x: x), Callable))\n    def test_eq_hash(self):\n        self.assertEqual(Callable[[int], int], Callable[[int], int])\n        self.assertEqual(len({Callable[[int], int], Callable[[int], int]}), 1)\n        self.assertNotEqual(Callable[[int], int], Callable[[int], str])\n        self.assertNotEqual(Callable[[int], int], Callable[[str], int])",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "SimpleMapping",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class SimpleMapping(Generic[XK, XV]):\n    def __getitem__(self, key):\n        pass\n    def __setitem__(self, key, value):\n        pass\n    def get(self, key, default=None):\n        pass\nclass MySimpleMapping(SimpleMapping[XK, XV]):\n    def __init__(self):\n        self.store = {}",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "MySimpleMapping",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class MySimpleMapping(SimpleMapping[XK, XV]):\n    def __init__(self):\n        self.store = {}\n    def __getitem__(self, key):\n        return self.store[key]\n    def __setitem__(self, key, value):\n        self.store[key] = value\n    def get(self, key, default=None):\n        try:\n            return self.store[key]",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "ProtocolTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class ProtocolTests(BaseTestCase):\n    def test_basic_protocol(self):\n        @runtime_checkable\n        class P(Protocol):\n            def meth(self):\n                pass\n        class C(object): pass\n        class D(object):\n            def meth(self):\n                pass",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "GenericTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class GenericTests(BaseTestCase):\n    def test_basics(self):\n        X = SimpleMapping[str, Any]\n        self.assertEqual(X.__parameters__, ())\n        with self.assertRaises(TypeError):\n            X[unicode]\n        with self.assertRaises(TypeError):\n            X[unicode, unicode]\n        Y = SimpleMapping[XK, unicode]\n        self.assertEqual(Y.__parameters__, (XK,))",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "ClassVarTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class ClassVarTests(BaseTestCase):\n    def test_basics(self):\n        with self.assertRaises(TypeError):\n            ClassVar[1]\n        with self.assertRaises(TypeError):\n            ClassVar[int, str]\n        with self.assertRaises(TypeError):\n            ClassVar[int][str]\n    def test_repr(self):\n        self.assertEqual(repr(ClassVar), 'typing.ClassVar')",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "FinalTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class FinalTests(BaseTestCase):\n    def test_basics(self):\n        with self.assertRaises(TypeError):\n            Final[1]\n        with self.assertRaises(TypeError):\n            Final[int, str]\n        with self.assertRaises(TypeError):\n            Final[int][str]\n    def test_repr(self):\n        self.assertEqual(repr(Final), 'typing.Final')",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "LiteralTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class LiteralTests(BaseTestCase):\n    def test_basics(self):\n        Literal[1]\n        Literal[1, 2, 3]\n        Literal[\"x\", \"y\", \"z\"]\n        Literal[None]\n    def test_illegal_parameters_do_not_raise_runtime_errors(self):\n        # Type checkers should reject these types, but we do not\n        # raise errors at runtime to maintain maximium flexibility\n        Literal[int]",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "CastTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class CastTests(BaseTestCase):\n    def test_basics(self):\n        self.assertEqual(cast(int, 42), 42)\n        self.assertEqual(cast(float, 42), 42)\n        self.assertIs(type(cast(float, 42)), int)\n        self.assertEqual(cast(Any, 42), 42)\n        self.assertEqual(cast(list, 42), 42)\n        self.assertEqual(cast(Union[str, float], 42), 42)\n        self.assertEqual(cast(AnyStr, 42), 42)\n        self.assertEqual(cast(None, 42), 42)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "ForwardRefTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class ForwardRefTests(BaseTestCase):\n    def test_forwardref_instance_type_error(self):\n        fr = typing._ForwardRef('int')\n        with self.assertRaises(TypeError):\n            isinstance(42, fr)\n    def test_syntax_error(self):\n        with self.assertRaises(SyntaxError):\n            Generic['/T']\n    def test_forwardref_subclass_type_error(self):\n        fr = typing._ForwardRef('int')",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "OverloadTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class OverloadTests(BaseTestCase):\n    def test_overload_fails(self):\n        from typing import overload\n        with self.assertRaises(RuntimeError):\n            @overload\n            def blah():\n                pass\n            blah()\n    def test_overload_succeeds(self):\n        from typing import overload",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "CollectionsAbcTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class CollectionsAbcTests(BaseTestCase):\n    def test_hashable(self):\n        self.assertIsInstance(42, typing.Hashable)\n        self.assertNotIsInstance([], typing.Hashable)\n    def test_iterable(self):\n        self.assertIsInstance([], typing.Iterable)\n        # Due to ABC caching, the second time takes a separate code\n        # path and could fail.  So call this a few times.\n        self.assertIsInstance([], typing.Iterable)\n        self.assertIsInstance([], typing.Iterable)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "OtherABCTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class OtherABCTests(BaseTestCase):\n    def test_contextmanager(self):\n        @contextlib.contextmanager\n        def manager():\n            yield 42\n        cm = manager()\n        self.assertIsInstance(cm, typing.ContextManager)\n        self.assertNotIsInstance(42, typing.ContextManager)\nclass TypeTests(BaseTestCase):\n    def test_type_basic(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "TypeTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class TypeTests(BaseTestCase):\n    def test_type_basic(self):\n        class User(object): pass\n        class BasicUser(User): pass\n        class ProUser(User): pass\n        def new_user(user_class):\n            # type: (Type[User]) -> User\n            return user_class()\n        new_user(BasicUser)\n    def test_type_typevar(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "NewTypeTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class NewTypeTests(BaseTestCase):\n    def test_basic(self):\n        UserId = NewType('UserId', int)\n        UserName = NewType('UserName', str)\n        self.assertIsInstance(UserId(5), int)\n        self.assertIsInstance(UserName('Joe'), type('Joe'))\n        self.assertEqual(UserId(5) + 1, 6)\n    def test_errors(self):\n        UserId = NewType('UserId', int)\n        UserName = NewType('UserName', str)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "NamedTupleTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class NamedTupleTests(BaseTestCase):\n    def test_basics(self):\n        Emp = NamedTuple('Emp', [('name', str), ('id', int)])\n        self.assertIsSubclass(Emp, tuple)\n        joe = Emp('Joe', 42)\n        jim = Emp(name='Jim', id=1)\n        self.assertIsInstance(joe, Emp)\n        self.assertIsInstance(joe, tuple)\n        self.assertEqual(joe.name, 'Joe')\n        self.assertEqual(joe.id, 42)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "TypedDictTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class TypedDictTests(BaseTestCase):\n    def test_basics_iterable_syntax(self):\n        Emp = TypedDict(b'Emp', {'name': str, 'id': int})\n        self.assertIsSubclass(Emp, dict)\n        self.assertIsSubclass(Emp, typing.MutableMapping)\n        if sys.version_info[0] >= 3:\n            import collections.abc\n            self.assertNotIsSubclass(Emp, collections.abc.Sequence)\n        jim = Emp(name='Jim', id=1)\n        self.assertIs(type(jim), dict)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "IOTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class IOTests(BaseTestCase):\n    def test_io_submodule(self):\n        from typing.io import IO, TextIO, BinaryIO, __all__, __name__\n        self.assertIs(IO, typing.IO)\n        self.assertIs(TextIO, typing.TextIO)\n        self.assertIs(BinaryIO, typing.BinaryIO)\n        self.assertEqual(set(__all__), set(['IO', 'TextIO', 'BinaryIO']))\n        self.assertEqual(__name__, 'typing.io')\nclass RETests(BaseTestCase):\n    # Much of this is really testing _TypeAlias.",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "RETests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class RETests(BaseTestCase):\n    # Much of this is really testing _TypeAlias.\n    def test_basics(self):\n        pat = re.compile('[a-z]+', re.I)\n        self.assertIsSubclass(pat.__class__, Pattern)\n        self.assertIsSubclass(type(pat), Pattern)\n        self.assertIsInstance(pat, Pattern)\n        mat = pat.search('12345abcde.....')\n        self.assertIsSubclass(mat.__class__, Match)\n        self.assertIsSubclass(type(mat), Match)",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "AllTests",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "class AllTests(BaseTestCase):\n    \"\"\"Tests for __all__.\"\"\"\n    def test_all(self):\n        from typing import __all__ as a\n        # Just spot-check the first and last of every category.\n        self.assertIn('AbstractSet', a)\n        self.assertIn('ValuesView', a)\n        self.assertIn('cast', a)\n        self.assertIn('overload', a)\n        # Check that io and re are not exported.",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "XK",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "XK = TypeVar('XK', unicode, bytes)\nXV = TypeVar('XV')\nclass SimpleMapping(Generic[XK, XV]):\n    def __getitem__(self, key):\n        pass\n    def __setitem__(self, key, value):\n        pass\n    def get(self, key, default=None):\n        pass\nclass MySimpleMapping(SimpleMapping[XK, XV]):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "XV",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "description": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "peekOfCode": "XV = TypeVar('XV')\nclass SimpleMapping(Generic[XK, XV]):\n    def __getitem__(self, key):\n        pass\n    def __setitem__(self, key, value):\n        pass\n    def get(self, key, default=None):\n        pass\nclass MySimpleMapping(SimpleMapping[XK, XV]):\n    def __init__(self):",
        "detail": "catboost.contrib.deprecated.python.typing.test.test_typing",
        "documentation": {}
    },
    {
        "label": "TypingMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class TypingMeta(type):\n    \"\"\"Metaclass for most types defined in typing module\n    (not a part of public API).\n    This also defines a dummy constructor (all the work for most typing\n    constructs is done in __new__) and a nicer repr().\n    \"\"\"\n    _is_protocol = False\n    def __new__(cls, name, bases, namespace):\n        return super(TypingMeta, cls).__new__(cls, str(name), bases, namespace)\n    @classmethod",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_TypingBase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _TypingBase(object):\n    \"\"\"Internal indicator of special typing constructs.\"\"\"\n    __metaclass__ = TypingMeta\n    __slots__ = ('__weakref__',)\n    def __init__(self, *args, **kwds):\n        pass\n    def __new__(cls, *args, **kwds):\n        \"\"\"Constructor.\n        This only exists to give a better error message in case\n        someone tries to subclass a special typing object (not a good idea).",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_FinalTypingBase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _FinalTypingBase(_TypingBase):\n    \"\"\"Internal mix-in class to prevent instantiation.\n    Prevents instantiation unless _root=True is given in class call.\n    It is used to create pseudo-singleton instances Any, Union, Optional, etc.\n    \"\"\"\n    __slots__ = ()\n    def __new__(cls, *args, **kwds):\n        self = super(_FinalTypingBase, cls).__new__(cls, *args, **kwds)\n        if '_root' in kwds and kwds['_root'] is True:\n            return self",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_ForwardRef",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _ForwardRef(_TypingBase):\n    \"\"\"Internal wrapper to hold a forward reference.\"\"\"\n    __slots__ = ('__forward_arg__', '__forward_code__',\n                 '__forward_evaluated__', '__forward_value__')\n    def __init__(self, arg):\n        super(_ForwardRef, self).__init__(arg)\n        if not isinstance(arg, basestring):\n            raise TypeError('Forward reference must be a string -- got %r' % (arg,))\n        try:\n            code = compile(arg, '<string>', 'eval')",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_TypeAlias",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _TypeAlias(_TypingBase):\n    \"\"\"Internal helper class for defining generic variants of concrete types.\n    Note that this is not a type; let's call it a pseudo-type.  It cannot\n    be used in instance and subclass checks in parameterized form, i.e.\n    ``isinstance(42, Match[str])`` raises ``TypeError`` instead of returning\n    ``False``.\n    \"\"\"\n    __slots__ = ('name', 'type_var', 'impl_type', 'type_checker')\n    def __init__(self, name, type_var, impl_type, type_checker):\n        \"\"\"Initializer.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ClassVarMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class ClassVarMeta(TypingMeta):\n    \"\"\"Metaclass for _ClassVar\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(ClassVarMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _ClassVar(_FinalTypingBase):\n    \"\"\"Special type construct to mark class variables.\n    An annotation wrapped in ClassVar indicates that a given\n    attribute is intended to be used as a class variable and",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_ClassVar",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _ClassVar(_FinalTypingBase):\n    \"\"\"Special type construct to mark class variables.\n    An annotation wrapped in ClassVar indicates that a given\n    attribute is intended to be used as a class variable and\n    should not be set on instances of that class. Usage::\n      class Starship:\n          stats = {}  # type: ClassVar[Dict[str, int]] # class variable\n          damage = 10 # type: int                      # instance variable\n    ClassVar accepts only types and cannot be further subscribed.\n    Note that ClassVar is not a class itself, and should not",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_FinalMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _FinalMeta(TypingMeta):\n    \"\"\"Metaclass for _Final\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(_FinalMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _Final(_FinalTypingBase):\n    \"\"\"A special typing construct to indicate that a name\n    cannot be re-assigned or overridden in a subclass.\n    For example:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_Final",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _Final(_FinalTypingBase):\n    \"\"\"A special typing construct to indicate that a name\n    cannot be re-assigned or overridden in a subclass.\n    For example:\n        MAX_SIZE: Final = 9000\n        MAX_SIZE += 1  # Error reported by type checker\n        class Connection:\n            TIMEOUT: Final[int] = 10\n        class FastConnector(Connection):\n            TIMEOUT = 1  # Error reported by type checker",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_LiteralMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _LiteralMeta(TypingMeta):\n    \"\"\"Metaclass for _Literal\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(_LiteralMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _Literal(_FinalTypingBase):\n    \"\"\"A type that can be used to indicate to type checkers that the\n    corresponding value has a value literally equivalent to the\n    provided parameter. For example:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_Literal",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _Literal(_FinalTypingBase):\n    \"\"\"A type that can be used to indicate to type checkers that the\n    corresponding value has a value literally equivalent to the\n    provided parameter. For example:\n        var: Literal[4] = 4\n    The type checker understands that 'var' is literally equal to the\n    value 4 and no other value.\n    Literal[...] cannot be subclassed. There is no runtime checking\n    verifying that the parameter is actually a value instead of a type.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "AnyMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class AnyMeta(TypingMeta):\n    \"\"\"Metaclass for Any.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(AnyMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _Any(_FinalTypingBase):\n    \"\"\"Special type indicating an unconstrained type.\n    - Any is compatible with every type.\n    - Any assumed to have all methods.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_Any",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _Any(_FinalTypingBase):\n    \"\"\"Special type indicating an unconstrained type.\n    - Any is compatible with every type.\n    - Any assumed to have all methods.\n    - All values assumed to be instances of Any.\n    Note that all the above statements are true from the point of view of\n    static type checkers. At runtime, Any should not be used with instance\n    or class checks.\n    \"\"\"\n    __metaclass__ = AnyMeta",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "NoReturnMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class NoReturnMeta(TypingMeta):\n    \"\"\"Metaclass for NoReturn.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(NoReturnMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _NoReturn(_FinalTypingBase):\n    \"\"\"Special type indicating functions that never return.\n    Example::\n      from typing import NoReturn",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_NoReturn",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _NoReturn(_FinalTypingBase):\n    \"\"\"Special type indicating functions that never return.\n    Example::\n      from typing import NoReturn\n      def stop() -> NoReturn:\n          raise Exception('no way')\n    This type is invalid in other positions, e.g., ``List[NoReturn]``\n    will fail in static type checkers.\n    \"\"\"\n    __metaclass__ = NoReturnMeta",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TypeVarMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class TypeVarMeta(TypingMeta):\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        return super(TypeVarMeta, cls).__new__(cls, name, bases, namespace)\nclass TypeVar(_TypingBase):\n    \"\"\"Type variable.\n    Usage::\n      T = TypeVar('T')  # Can be anything\n      A = TypeVar('A', str, bytes)  # Must be str or bytes\n    Type variables exist primarily for the benefit of static type",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class TypeVar(_TypingBase):\n    \"\"\"Type variable.\n    Usage::\n      T = TypeVar('T')  # Can be anything\n      A = TypeVar('A', str, bytes)  # Must be str or bytes\n    Type variables exist primarily for the benefit of static type\n    checkers.  They serve as the parameters for generic types as well\n    as for generic function definitions.  See class Generic for more\n    information on generic types.  Generic functions work as follows:\n      def repeat(x: T, n: int) -> List[T]:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "UnionMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class UnionMeta(TypingMeta):\n    \"\"\"Metaclass for Union.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        return super(UnionMeta, cls).__new__(cls, name, bases, namespace)\nclass _Union(_FinalTypingBase):\n    \"\"\"Union type; Union[X, Y] means either X or Y.\n    To define a union, use e.g. Union[int, str].  Details:\n    - The arguments must be types and there must be at least one.\n    - None as an argument is a special case and is replaced by",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_Union",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _Union(_FinalTypingBase):\n    \"\"\"Union type; Union[X, Y] means either X or Y.\n    To define a union, use e.g. Union[int, str].  Details:\n    - The arguments must be types and there must be at least one.\n    - None as an argument is a special case and is replaced by\n      type(None).\n    - Unions of unions are flattened, e.g.::\n        Union[Union[int, str], float] == Union[int, str, float]\n    - Unions of a single argument vanish, e.g.::\n        Union[int] == int  # The constructor actually returns int",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "OptionalMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class OptionalMeta(TypingMeta):\n    \"\"\"Metaclass for Optional.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        return super(OptionalMeta, cls).__new__(cls, name, bases, namespace)\nclass _Optional(_FinalTypingBase):\n    \"\"\"Optional type.\n    Optional[X] is equivalent to Union[X, None].\n    \"\"\"\n    __metaclass__ = OptionalMeta",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_Optional",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _Optional(_FinalTypingBase):\n    \"\"\"Optional type.\n    Optional[X] is equivalent to Union[X, None].\n    \"\"\"\n    __metaclass__ = OptionalMeta\n    __slots__ = ()\n    @_tp_cache\n    def __getitem__(self, arg):\n        arg = _type_check(arg, \"Optional[t] requires a single type.\")\n        return Union[arg, type(None)]",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "GenericMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class GenericMeta(TypingMeta, abc.ABCMeta):\n    \"\"\"Metaclass for generic types.\n    This is a metaclass for typing.Generic and generic ABCs defined in\n    typing module. User defined subclasses of GenericMeta can override\n    __new__ and invoke super().__new__. Note that GenericMeta.__new__\n    has strict rules on what is allowed in its bases argument:\n    * plain Generic is disallowed in bases;\n    * Generic[...] should appear in bases at most once;\n    * if Generic[...] is present, then it should list all type variables\n      that appear in other bases.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Generic(object):\n    \"\"\"Abstract base class for generic types.\n    A generic type is typically declared by inheriting from\n    this class parameterized with one or more type variables.\n    For example, a generic mapping type might be defined as::\n      class Mapping(Generic[KT, VT]):\n          def __getitem__(self, key: KT) -> VT:\n              ...\n          # Etc.\n    This class can then be used as follows::",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_TypingEmpty",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _TypingEmpty(object):\n    \"\"\"Internal placeholder for () or []. Used by TupleMeta and CallableMeta\n    to allow empty list/tuple in specific places, without allowing them\n    to sneak in where prohibited.\n    \"\"\"\nclass _TypingEllipsis(object):\n    \"\"\"Internal placeholder for ... (ellipsis).\"\"\"\nclass TupleMeta(GenericMeta):\n    \"\"\"Metaclass for Tuple (internal).\"\"\"\n    @_tp_cache",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_TypingEllipsis",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _TypingEllipsis(object):\n    \"\"\"Internal placeholder for ... (ellipsis).\"\"\"\nclass TupleMeta(GenericMeta):\n    \"\"\"Metaclass for Tuple (internal).\"\"\"\n    @_tp_cache\n    def __getitem__(self, parameters):\n        if self.__origin__ is not None or self._gorg is not Tuple:\n            # Normal generic rules apply if this is not the first subscription\n            # or a subscription of a subclass.\n            return super(TupleMeta, self).__getitem__(parameters)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TupleMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class TupleMeta(GenericMeta):\n    \"\"\"Metaclass for Tuple (internal).\"\"\"\n    @_tp_cache\n    def __getitem__(self, parameters):\n        if self.__origin__ is not None or self._gorg is not Tuple:\n            # Normal generic rules apply if this is not the first subscription\n            # or a subscription of a subclass.\n            return super(TupleMeta, self).__getitem__(parameters)\n        if parameters == ():\n            return super(TupleMeta, self).__getitem__((_TypingEmpty,))",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Tuple(tuple):\n    \"\"\"Tuple type; Tuple[X, Y] is the cross-product type of X and Y.\n    Example: Tuple[T1, T2] is a tuple of two elements corresponding\n    to type variables T1 and T2.  Tuple[int, float, str] is a tuple\n    of an int, a float and a string.\n    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].\n    \"\"\"\n    __metaclass__ = TupleMeta\n    __extra__ = tuple\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "CallableMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class CallableMeta(GenericMeta):\n    \"\"\" Metaclass for Callable.\"\"\"\n    def __repr__(self):\n        if self.__origin__ is None:\n            return super(CallableMeta, self).__repr__()\n        return self._tree_repr(self._subs_tree())\n    def _tree_repr(self, tree):\n        if self._gorg is not Callable:\n            return super(CallableMeta, self)._tree_repr(tree)\n        # For actual Callable (not its subclass) we override",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Callable(object):\n    \"\"\"Callable type; Callable[[int], str] is a function of (int) -> str.\n    The subscription syntax must always be used with exactly two\n    values: the argument list and the return type.  The argument list\n    must be a list of types or ellipsis; the return type must be a single type.\n    There is no syntax to indicate optional or keyword arguments,\n    such function types are rarely used as callback types.\n    \"\"\"\n    __metaclass__ = CallableMeta\n    __extra__ = collections_abc.Callable",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_ProtocolMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _ProtocolMeta(GenericMeta):\n    \"\"\"Internal metaclass for Protocol.\n    This exists so Protocol classes can be generic without deriving\n    from Generic.\n    \"\"\"\n    def __init__(cls, *args, **kwargs):\n        super(_ProtocolMeta, cls).__init__(*args, **kwargs)\n        if not cls.__dict__.get('_is_protocol', None):\n            cls._is_protocol = any(b is Protocol or\n                                   isinstance(b, _ProtocolMeta) and",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Protocol(object):\n    \"\"\"Base class for protocol classes. Protocol classes are defined as::\n      class Proto(Protocol):\n          def meth(self):\n              # type: () -> int\n              pass\n    Such classes are primarily used with static type checkers that recognize\n    structural subtyping (static duck-typing), for example::\n      class C:\n          def meth(self):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Iterable(Generic[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Iterable\nclass Iterator(Iterable[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Iterator\n@runtime_checkable\nclass SupportsInt(Protocol):\n    __slots__ = ()\n    @abstractmethod",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Iterator(Iterable[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Iterator\n@runtime_checkable\nclass SupportsInt(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __int__(self):\n        pass\n@runtime_checkable",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "SupportsInt",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class SupportsInt(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __int__(self):\n        pass\n@runtime_checkable\nclass SupportsFloat(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __float__(self):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class SupportsFloat(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __float__(self):\n        pass\n@runtime_checkable\nclass SupportsComplex(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __complex__(self):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "SupportsComplex",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class SupportsComplex(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __complex__(self):\n        pass\n@runtime_checkable\nclass SupportsIndex(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __index__(self):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "SupportsIndex",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class SupportsIndex(Protocol):\n    __slots__ = ()\n    @abstractmethod\n    def __index__(self):\n        pass\n@runtime_checkable\nclass SupportsAbs(Protocol[T_co]):\n    __slots__ = ()\n    @abstractmethod\n    def __abs__(self):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "SupportsAbs",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class SupportsAbs(Protocol[T_co]):\n    __slots__ = ()\n    @abstractmethod\n    def __abs__(self):\n        pass\nif hasattr(collections_abc, 'Reversible'):\n    class Reversible(Iterable[T_co]):\n        __slots__ = ()\n        __extra__ = collections_abc.Reversible\nelse:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Container",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Container(Generic[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Container\n# Callable was defined earlier.\nclass AbstractSet(Sized, Iterable[T_co], Container[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Set\nclass MutableSet(AbstractSet[T]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableSet",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class AbstractSet(Sized, Iterable[T_co], Container[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Set\nclass MutableSet(AbstractSet[T]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableSet\n# NOTE: It is only covariant in the value type.\nclass Mapping(Sized, Iterable[KT], Container[KT], Generic[KT, VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Mapping",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class MutableSet(AbstractSet[T]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableSet\n# NOTE: It is only covariant in the value type.\nclass Mapping(Sized, Iterable[KT], Container[KT], Generic[KT, VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Mapping\nclass MutableMapping(Mapping[KT, VT]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableMapping",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Mapping(Sized, Iterable[KT], Container[KT], Generic[KT, VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Mapping\nclass MutableMapping(Mapping[KT, VT]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableMapping\nif hasattr(collections_abc, 'Reversible'):\n    class Sequence(Sized, Reversible[T_co], Container[T_co]):\n        __slots__ = ()\n        __extra__ = collections_abc.Sequence",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class MutableMapping(Mapping[KT, VT]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableMapping\nif hasattr(collections_abc, 'Reversible'):\n    class Sequence(Sized, Reversible[T_co], Container[T_co]):\n        __slots__ = ()\n        __extra__ = collections_abc.Sequence\nelse:\n    class Sequence(Sized, Iterable[T_co], Container[T_co]):\n        __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class MutableSequence(Sequence[T]):\n    __slots__ = ()\n    __extra__ = collections_abc.MutableSequence\nclass ByteString(Sequence[int]):\n    pass\nByteString.register(str)\nByteString.register(bytearray)\nclass List(list, MutableSequence[T]):\n    __slots__ = ()\n    __extra__ = list",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ByteString",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class ByteString(Sequence[int]):\n    pass\nByteString.register(str)\nByteString.register(bytearray)\nclass List(list, MutableSequence[T]):\n    __slots__ = ()\n    __extra__ = list\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is List:\n            raise TypeError(\"Type List cannot be instantiated; \"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class List(list, MutableSequence[T]):\n    __slots__ = ()\n    __extra__ = list\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is List:\n            raise TypeError(\"Type List cannot be instantiated; \"\n                            \"use list() instead\")\n        return _generic_new(list, cls, *args, **kwds)\nclass Deque(collections.deque, MutableSequence[T]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Deque(collections.deque, MutableSequence[T]):\n    __slots__ = ()\n    __extra__ = collections.deque\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is Deque:\n            return collections.deque(*args, **kwds)\n        return _generic_new(collections.deque, cls, *args, **kwds)\nclass Set(set, MutableSet[T]):\n    __slots__ = ()\n    __extra__ = set",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Set(set, MutableSet[T]):\n    __slots__ = ()\n    __extra__ = set\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is Set:\n            raise TypeError(\"Type Set cannot be instantiated; \"\n                            \"use set() instead\")\n        return _generic_new(set, cls, *args, **kwds)\nclass FrozenSet(frozenset, AbstractSet[T_co]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class FrozenSet(frozenset, AbstractSet[T_co]):\n    __slots__ = ()\n    __extra__ = frozenset\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is FrozenSet:\n            raise TypeError(\"Type FrozenSet cannot be instantiated; \"\n                            \"use frozenset() instead\")\n        return _generic_new(frozenset, cls, *args, **kwds)\nclass MappingView(Sized, Iterable[T_co]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "MappingView",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class MappingView(Sized, Iterable[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.MappingView\nclass KeysView(MappingView[KT], AbstractSet[KT]):\n    __slots__ = ()\n    __extra__ = collections_abc.KeysView\nclass ItemsView(MappingView[Tuple[KT, VT_co]],\n                AbstractSet[Tuple[KT, VT_co]],\n                Generic[KT, VT_co]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "KeysView",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class KeysView(MappingView[KT], AbstractSet[KT]):\n    __slots__ = ()\n    __extra__ = collections_abc.KeysView\nclass ItemsView(MappingView[Tuple[KT, VT_co]],\n                AbstractSet[Tuple[KT, VT_co]],\n                Generic[KT, VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.ItemsView\nclass ValuesView(MappingView[VT_co]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ItemsView",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class ItemsView(MappingView[Tuple[KT, VT_co]],\n                AbstractSet[Tuple[KT, VT_co]],\n                Generic[KT, VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.ItemsView\nclass ValuesView(MappingView[VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.ValuesView\nclass ContextManager(Generic[T_co]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ValuesView",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class ValuesView(MappingView[VT_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.ValuesView\nclass ContextManager(Generic[T_co]):\n    __slots__ = ()\n    def __enter__(self):\n        return self\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_value, traceback):\n        return None",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class ContextManager(Generic[T_co]):\n    __slots__ = ()\n    def __enter__(self):\n        return self\n    @abc.abstractmethod\n    def __exit__(self, exc_type, exc_value, traceback):\n        return None\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is ContextManager:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Dict(dict, MutableMapping[KT, VT]):\n    __slots__ = ()\n    __extra__ = dict\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is Dict:\n            raise TypeError(\"Type Dict cannot be instantiated; \"\n                            \"use dict() instead\")\n        return _generic_new(dict, cls, *args, **kwds)\nclass DefaultDict(collections.defaultdict, MutableMapping[KT, VT]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class DefaultDict(collections.defaultdict, MutableMapping[KT, VT]):\n    __slots__ = ()\n    __extra__ = collections.defaultdict\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is DefaultDict:\n            return collections.defaultdict(*args, **kwds)\n        return _generic_new(collections.defaultdict, cls, *args, **kwds)\nclass Counter(collections.Counter, Dict[T, int]):\n    __slots__ = ()\n    __extra__ = collections.Counter",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Counter(collections.Counter, Dict[T, int]):\n    __slots__ = ()\n    __extra__ = collections.Counter\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is Counter:\n            return collections.Counter(*args, **kwds)\n        return _generic_new(collections.Counter, cls, *args, **kwds)\n# Determine what base class to use for Generator.\nif hasattr(collections_abc, 'Generator'):\n    # Sufficiently recent versions of 3.5 have a Generator ABC.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Generator(Iterator[T_co], Generic[T_co, T_contra, V_co]):\n    __slots__ = ()\n    __extra__ = _G_base\n    def __new__(cls, *args, **kwds):\n        if cls._gorg is Generator:\n            raise TypeError(\"Type Generator cannot be instantiated; \"\n                            \"create a subclass instead\")\n        return _generic_new(_G_base, cls, *args, **kwds)\n# Internal type variable used for Type[].\nCT_co = TypeVar('CT_co', covariant=True, bound=type)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class Type(Generic[CT_co]):\n    \"\"\"A special construct usable to annotate class objects.\n    For example, suppose we have the following classes::\n      class User: ...  # Abstract base for User classes\n      class BasicUser(User): ...\n      class ProUser(User): ...\n      class TeamUser(User): ...\n    And a function that takes a class argument that's a subclass of\n    User and returns an instance of the corresponding class::\n      U = TypeVar('U', bound=User)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_TypedDictMeta",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class _TypedDictMeta(type):\n    def __new__(cls, name, bases, ns, total=True):\n        # Create new typed dict class object.\n        # This method is called directly when TypedDict is subclassed,\n        # or via _typeddict_new when TypedDict is instantiated. This way\n        # TypedDict supports all three syntaxes described in its docstring.\n        # Subclasses and instances of TypedDict return actual dictionaries\n        # via _dict_new.\n        ns['__new__'] = _typeddict_new if name == b'TypedDict' else _dict_new\n        tp_dict = super(_TypedDictMeta, cls).__new__(cls, name, (dict,), ns)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class IO(Generic[AnyStr]):\n    \"\"\"Generic base class for TextIO and BinaryIO.\n    This is an abstract, generic version of the return of open().\n    NOTE: This does not distinguish between the different possible\n    classes (text vs. binary, read vs. write vs. read/write,\n    append-only, unbuffered).  The TextIO and BinaryIO subclasses\n    below capture the distinctions between text vs. binary, which is\n    pervasive in the interface; however we currently do not offer a\n    way to track the other distinctions in the type system.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class BinaryIO(IO[bytes]):\n    \"\"\"Typed version of the return of open() in binary mode.\"\"\"\n    __slots__ = ()\n    @abstractmethod\n    def write(self, s):\n        pass\n    @abstractmethod\n    def __enter__(self):\n        pass\nclass TextIO(IO[unicode]):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class TextIO(IO[unicode]):\n    \"\"\"Typed version of the return of open() in text mode.\"\"\"\n    __slots__ = ()\n    @abstractproperty\n    def buffer(self):\n        pass\n    @abstractproperty\n    def encoding(self):\n        pass\n    @abstractproperty",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class io(object):\n    \"\"\"Wrapper namespace for IO generic classes.\"\"\"\n    __all__ = ['IO', 'TextIO', 'BinaryIO']\n    IO = IO\n    TextIO = TextIO\n    BinaryIO = BinaryIO\nio.__name__ = __name__ + b'.io'\nsys.modules[io.__name__] = io\nPattern = _TypeAlias('Pattern', AnyStr, type(stdlib_re.compile('')),\n                     lambda p: p.pattern)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "class re(object):\n    \"\"\"Wrapper namespace for re type aliases.\"\"\"\n    __all__ = ['Pattern', 'Match']\n    Pattern = Pattern\n    Match = Match\nre.__name__ = __name__ + b'.re'\nsys.modules[re.__name__] = re",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "final",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def final(f):\n    \"\"\"This decorator can be used to indicate to type checkers that\n    the decorated method cannot be overridden, and decorated class\n    cannot be subclassed. For example:\n        class Base:\n            @final\n            def done(self) -> None:\n                ...\n        class Sub(Base):\n            def done(self) -> None:  # Error reported by type checker",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def cast(typ, val):\n    \"\"\"Cast a value to a type.\n    This returns the value unchanged.  To the type checker this\n    signals that the return value has the designated type, but at\n    runtime we intentionally don't check anything (we want this\n    to be as fast as possible).\n    \"\"\"\n    return val\ndef _get_defaults(func):\n    \"\"\"Internal helper to extract the default arguments, by name.\"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "get_type_hints",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def get_type_hints(obj, globalns=None, localns=None):\n    \"\"\"In Python 2 this is not supported and always returns None.\"\"\"\n    return None\ndef no_type_check(arg):\n    \"\"\"Decorator to indicate that annotations are not type hints.\n    The argument must be a class or function; if it is a class, it\n    applies recursively to all methods and classes defined in that class\n    (but not to methods defined in its superclasses or subclasses).\n    This mutates the function(s) or class(es) in place.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "no_type_check",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def no_type_check(arg):\n    \"\"\"Decorator to indicate that annotations are not type hints.\n    The argument must be a class or function; if it is a class, it\n    applies recursively to all methods and classes defined in that class\n    (but not to methods defined in its superclasses or subclasses).\n    This mutates the function(s) or class(es) in place.\n    \"\"\"\n    if isinstance(arg, type):\n        arg_attrs = arg.__dict__.copy()\n        for attr, val in arg.__dict__.items():",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "no_type_check_decorator",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def no_type_check_decorator(decorator):\n    \"\"\"Decorator to give another decorator the @no_type_check effect.\n    This wraps the decorator with something that wraps the decorated\n    function in @no_type_check.\n    \"\"\"\n    @functools.wraps(decorator)\n    def wrapped_decorator(*args, **kwds):\n        func = decorator(*args, **kwds)\n        func = no_type_check(func)\n        return func",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def overload(func):\n    \"\"\"Decorator for overloaded functions/methods.\n    In a stub file, place two or more stub definitions for the same\n    function in a row, each decorated with @overload.  For example:\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "runtime_checkable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def runtime_checkable(cls):\n    \"\"\"Mark a protocol class as a runtime protocol, so that it\n    can be used with isinstance() and issubclass(). Raise TypeError\n    if applied to a non-protocol class.\n    This allows a simple-minded structural check very similar to the\n    one-offs in collections.abc such as Hashable.\n    \"\"\"\n    if not isinstance(cls, _ProtocolMeta) or not cls._is_protocol:\n        raise TypeError('@runtime_checkable can be only applied to protocol classes,'\n                        ' got %r' % cls)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def NamedTuple(typename, fields):\n    \"\"\"Typed version of namedtuple.\n    Usage::\n        Employee = typing.NamedTuple('Employee', [('name', str), ('id', int)])\n    This is equivalent to::\n        Employee = collections.namedtuple('Employee', ['name', 'id'])\n    The resulting class has one extra attribute: _field_types,\n    giving a dict mapping field names to types.  (The field names\n    are in the _fields attribute, which is part of the namedtuple\n    API.)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "def NewType(name, tp):\n    \"\"\"NewType creates simple unique types with almost zero\n    runtime overhead. NewType(name, tp) is considered a subtype of tp\n    by static type checkers. At runtime, NewType(name, tp) returns\n    a dummy function that simply returns its argument. Usage::\n        UserId = NewType('UserId', int)\n        def name_by_id(user_id):\n            # type: (UserId) -> str\n            ...\n        UserId('user')          # Fails type check",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "__all__ = [\n    # Super-special typing primitives.\n    'Any',\n    'Callable',\n    'ClassVar',\n    'Final',\n    'Generic',\n    'Literal',\n    'Optional',\n    'Protocol',",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "ClassVar = _ClassVar(_root=True)\nclass _FinalMeta(TypingMeta):\n    \"\"\"Metaclass for _Final\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(_FinalMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _Final(_FinalTypingBase):\n    \"\"\"A special typing construct to indicate that a name\n    cannot be re-assigned or overridden in a subclass.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Final = _Final(_root=True)\ndef final(f):\n    \"\"\"This decorator can be used to indicate to type checkers that\n    the decorated method cannot be overridden, and decorated class\n    cannot be subclassed. For example:\n        class Base:\n            @final\n            def done(self) -> None:\n                ...\n        class Sub(Base):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Literal = _Literal(_root=True)\nclass AnyMeta(TypingMeta):\n    \"\"\"Metaclass for Any.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(AnyMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _Any(_FinalTypingBase):\n    \"\"\"Special type indicating an unconstrained type.\n    - Any is compatible with every type.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Any = _Any(_root=True)\nclass NoReturnMeta(TypingMeta):\n    \"\"\"Metaclass for NoReturn.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        self = super(NoReturnMeta, cls).__new__(cls, name, bases, namespace)\n        return self\nclass _NoReturn(_FinalTypingBase):\n    \"\"\"Special type indicating functions that never return.\n    Example::",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "NoReturn = _NoReturn(_root=True)\nclass TypeVarMeta(TypingMeta):\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        return super(TypeVarMeta, cls).__new__(cls, name, bases, namespace)\nclass TypeVar(_TypingBase):\n    \"\"\"Type variable.\n    Usage::\n      T = TypeVar('T')  # Can be anything\n      A = TypeVar('A', str, bytes)  # Must be str or bytes",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "T = TypeVar('T')  # Any type.\nKT = TypeVar('KT')  # Key type.\nVT = TypeVar('VT')  # Value type.\nT_co = TypeVar('T_co', covariant=True)  # Any type covariant containers.\nV_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.\nVT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "KT",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "KT = TypeVar('KT')  # Key type.\nVT = TypeVar('VT')  # Value type.\nT_co = TypeVar('T_co', covariant=True)  # Any type covariant containers.\nV_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.\nVT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "VT",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "VT = TypeVar('VT')  # Value type.\nT_co = TypeVar('T_co', covariant=True)  # Any type covariant containers.\nV_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.\nVT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "T_co = TypeVar('T_co', covariant=True)  # Any type covariant containers.\nV_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.\nVT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable\n    found in tvars with corresponding substitution from args or",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "V_co",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "V_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.\nVT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable\n    found in tvars with corresponding substitution from args or\n    with corresponding substitution sub-tree if arg is a generic type.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "VT_co",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "VT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.\nT_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable\n    found in tvars with corresponding substitution from args or\n    with corresponding substitution sub-tree if arg is a generic type.\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "T_contra",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "T_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.\n# A useful type variable with constraints.  This represents string types.\n# (This one *is* for export!)\nAnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable\n    found in tvars with corresponding substitution from args or\n    with corresponding substitution sub-tree if arg is a generic type.\n    \"\"\"\n    if tvars is None:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "AnyStr = TypeVar('AnyStr', bytes, unicode)\ndef _replace_arg(arg, tvars, args):\n    \"\"\"An internal helper function: replace arg if it is a type variable\n    found in tvars with corresponding substitution from args or\n    with corresponding substitution sub-tree if arg is a generic type.\n    \"\"\"\n    if tvars is None:\n        tvars = []\n    if hasattr(arg, '_subs_tree') and isinstance(arg, (GenericMeta, _TypingBase)):\n        return arg._subs_tree(tvars, args)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_cleanups",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "_cleanups = []\ndef _tp_cache(func):\n    maxsize = 128\n    cache = {}\n    _cleanups.append(cache.clear)\n    @functools.wraps(func)\n    def inner(*args):\n        key = args\n        try:\n            return cache[key]",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Union = _Union(_root=True)\nclass OptionalMeta(TypingMeta):\n    \"\"\"Metaclass for Optional.\"\"\"\n    def __new__(cls, name, bases, namespace):\n        cls.assert_no_subclassing(bases)\n        return super(OptionalMeta, cls).__new__(cls, name, bases, namespace)\nclass _Optional(_FinalTypingBase):\n    \"\"\"Optional type.\n    Optional[X] is equivalent to Union[X, None].\n    \"\"\"",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Optional = _Optional(_root=True)\ndef _next_in_mro(cls):\n    \"\"\"Helper for Generic.__new__.\n    Returns the class after the last occurrence of Generic or\n    Generic[...] in cls.__mro__.\n    \"\"\"\n    next_in_mro = object\n    # Look for the last occurrence of Generic or Generic[...].\n    for i, c in enumerate(cls.__mro__[:-1]):\n        if isinstance(c, GenericMeta) and c._gorg is Generic:",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "copy._copy_dispatch[GenericMeta]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "copy._copy_dispatch[GenericMeta] = _copy_generic\n# Prevent checks for Generic to crash when defining Generic.\nGeneric = None\ndef _generic_new(base_cls, cls, *args, **kwds):\n    # Assure type is erased on instantiation,\n    # but attempt to store it in __orig_class__\n    if cls.__origin__ is None:\n        if (base_cls.__new__ is object.__new__ and\n                cls.__init__ is not object.__init__):\n            return base_cls.__new__(cls)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Generic = None\ndef _generic_new(base_cls, cls, *args, **kwds):\n    # Assure type is erased on instantiation,\n    # but attempt to store it in __orig_class__\n    if cls.__origin__ is None:\n        if (base_cls.__new__ is object.__new__ and\n                cls.__init__ is not object.__init__):\n            return base_cls.__new__(cls)\n        else:\n            return base_cls.__new__(cls, *args, **kwds)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "copy._copy_dispatch[TupleMeta]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "copy._copy_dispatch[TupleMeta] = _copy_generic\nclass Tuple(tuple):\n    \"\"\"Tuple type; Tuple[X, Y] is the cross-product type of X and Y.\n    Example: Tuple[T1, T2] is a tuple of two elements corresponding\n    to type variables T1 and T2.  Tuple[int, float, str] is a tuple\n    of an int, a float and a string.\n    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].\n    \"\"\"\n    __metaclass__ = TupleMeta\n    __extra__ = tuple",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "copy._copy_dispatch[CallableMeta]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "copy._copy_dispatch[CallableMeta] = _copy_generic\nclass Callable(object):\n    \"\"\"Callable type; Callable[[int], str] is a function of (int) -> str.\n    The subscription syntax must always be used with exactly two\n    values: the argument list and the return type.  The argument list\n    must be a list of types or ellipsis; the return type must be a single type.\n    There is no syntax to indicate optional or keyword arguments,\n    such function types are rarely used as callback types.\n    \"\"\"\n    __metaclass__ = CallableMeta",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "_PROTO_WHITELIST",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "_PROTO_WHITELIST = ['Callable', 'Iterable', 'Iterator',\n                    'Hashable', 'Sized', 'Container', 'Collection',\n                    'Reversible', 'ContextManager']\nclass _ProtocolMeta(GenericMeta):\n    \"\"\"Internal metaclass for Protocol.\n    This exists so Protocol classes can be generic without deriving\n    from Generic.\n    \"\"\"\n    def __init__(cls, *args, **kwargs):\n        super(_ProtocolMeta, cls).__init__(*args, **kwargs)",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Hashable",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Hashable = collections_abc.Hashable  # Not generic.\nclass Iterable(Generic[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Iterable\nclass Iterator(Iterable[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Iterator\n@runtime_checkable\nclass SupportsInt(Protocol):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Sized",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Sized = collections_abc.Sized  # Not generic.\nclass Container(Generic[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Container\n# Callable was defined earlier.\nclass AbstractSet(Sized, Iterable[T_co], Container[T_co]):\n    __slots__ = ()\n    __extra__ = collections_abc.Set\nclass MutableSet(AbstractSet[T]):\n    __slots__ = ()",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "CT_co",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "CT_co = TypeVar('CT_co', covariant=True, bound=type)\n# This is not a real generic class.  Don't use outside annotations.\nclass Type(Generic[CT_co]):\n    \"\"\"A special construct usable to annotate class objects.\n    For example, suppose we have the following classes::\n      class User: ...  # Abstract base for User classes\n      class BasicUser(User): ...\n      class ProUser(User): ...\n      class TeamUser(User): ...\n    And a function that takes a class argument that's a subclass of",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TypedDict",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "TypedDict = _TypedDictMeta(b'TypedDict', (dict,), {})\nTypedDict.__module__ = __name__\nTypedDict.__doc__ = \\\n    \"\"\"A simple typed name space. At runtime it is equivalent to a plain dict.\n    TypedDict creates a dictionary type that expects all of its\n    instances to have a certain set of keys, with each key\n    associated with a value of a consistent type. This expectation\n    is not checked at runtime but is only enforced by type checkers.\n    Usage::\n        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TypedDict.__module__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "TypedDict.__module__ = __name__\nTypedDict.__doc__ = \\\n    \"\"\"A simple typed name space. At runtime it is equivalent to a plain dict.\n    TypedDict creates a dictionary type that expects all of its\n    instances to have a certain set of keys, with each key\n    associated with a value of a consistent type. This expectation\n    is not checked at runtime but is only enforced by type checkers.\n    Usage::\n        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n        a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TypedDict.__doc__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "TypedDict.__doc__ = \\\n    \"\"\"A simple typed name space. At runtime it is equivalent to a plain dict.\n    TypedDict creates a dictionary type that expects all of its\n    instances to have a certain set of keys, with each key\n    associated with a value of a consistent type. This expectation\n    is not checked at runtime but is only enforced by type checkers.\n    Usage::\n        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n        a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n        b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Text",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Text = unicode\n# Constant that's True when type checking, but False here.\nTYPE_CHECKING = False\nclass IO(Generic[AnyStr]):\n    \"\"\"Generic base class for TextIO and BinaryIO.\n    This is an abstract, generic version of the return of open().\n    NOTE: This does not distinguish between the different possible\n    classes (text vs. binary, read vs. write vs. read/write,\n    append-only, unbuffered).  The TextIO and BinaryIO subclasses\n    below capture the distinctions between text vs. binary, which is",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "TYPE_CHECKING = False\nclass IO(Generic[AnyStr]):\n    \"\"\"Generic base class for TextIO and BinaryIO.\n    This is an abstract, generic version of the return of open().\n    NOTE: This does not distinguish between the different possible\n    classes (text vs. binary, read vs. write vs. read/write,\n    append-only, unbuffered).  The TextIO and BinaryIO subclasses\n    below capture the distinctions between text vs. binary, which is\n    pervasive in the interface; however we currently do not offer a\n    way to track the other distinctions in the type system.",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "io.__name__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "io.__name__ = __name__ + b'.io'\nsys.modules[io.__name__] = io\nPattern = _TypeAlias('Pattern', AnyStr, type(stdlib_re.compile('')),\n                     lambda p: p.pattern)\nMatch = _TypeAlias('Match', AnyStr, type(stdlib_re.match('', '')),\n                   lambda m: m.re.pattern)\nclass re(object):\n    \"\"\"Wrapper namespace for re type aliases.\"\"\"\n    __all__ = ['Pattern', 'Match']\n    Pattern = Pattern",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "sys.modules[io.__name__]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "sys.modules[io.__name__] = io\nPattern = _TypeAlias('Pattern', AnyStr, type(stdlib_re.compile('')),\n                     lambda p: p.pattern)\nMatch = _TypeAlias('Match', AnyStr, type(stdlib_re.match('', '')),\n                   lambda m: m.re.pattern)\nclass re(object):\n    \"\"\"Wrapper namespace for re type aliases.\"\"\"\n    __all__ = ['Pattern', 'Match']\n    Pattern = Pattern\n    Match = Match",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Pattern = _TypeAlias('Pattern', AnyStr, type(stdlib_re.compile('')),\n                     lambda p: p.pattern)\nMatch = _TypeAlias('Match', AnyStr, type(stdlib_re.match('', '')),\n                   lambda m: m.re.pattern)\nclass re(object):\n    \"\"\"Wrapper namespace for re type aliases.\"\"\"\n    __all__ = ['Pattern', 'Match']\n    Pattern = Pattern\n    Match = Match\nre.__name__ = __name__ + b'.re'",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Match",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "Match = _TypeAlias('Match', AnyStr, type(stdlib_re.match('', '')),\n                   lambda m: m.re.pattern)\nclass re(object):\n    \"\"\"Wrapper namespace for re type aliases.\"\"\"\n    __all__ = ['Pattern', 'Match']\n    Pattern = Pattern\n    Match = Match\nre.__name__ = __name__ + b'.re'\nsys.modules[re.__name__] = re",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "re.__name__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "re.__name__ = __name__ + b'.re'\nsys.modules[re.__name__] = re",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "sys.modules[re.__name__]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.typing.typing",
        "description": "catboost.contrib.deprecated.python.typing.typing",
        "peekOfCode": "sys.modules[re.__name__] = re",
        "detail": "catboost.contrib.deprecated.python.typing.typing",
        "documentation": {}
    },
    {
        "label": "Py_buffer",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "class Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),\n\t\t(\"readonly\", c_int),\n\t\t(\"ndim\", c_int),\n\t\t(\"format\", c_char_p),\n\t\t(\"shape\", c_ssize_p),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "get_buffer",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "def get_buffer(obj, writable=False):\n\tbuf = Py_buffer.get_from(obj, PyBUF_WRITABLE if writable else PyBUF_SIMPLE)\n\ttry:\n\t\tbuffer_type = c_char * buf.len\n\t\treturn buffer_type.from_address(buf.buf)\n\tfinally:\n\t\tbuf.release()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "c_ssize_p",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "c_ssize_p = POINTER(c_ssize_t)\nPyObject_GetBuffer = pythonapi.PyObject_GetBuffer\nPyBuffer_Release = pythonapi.PyBuffer_Release\nPyBUF_SIMPLE = 0\nPyBUF_WRITABLE = 1\nclass Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "PyObject_GetBuffer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "PyObject_GetBuffer = pythonapi.PyObject_GetBuffer\nPyBuffer_Release = pythonapi.PyBuffer_Release\nPyBUF_SIMPLE = 0\nPyBUF_WRITABLE = 1\nclass Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "PyBuffer_Release",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "PyBuffer_Release = pythonapi.PyBuffer_Release\nPyBUF_SIMPLE = 0\nPyBUF_WRITABLE = 1\nclass Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),\n\t\t(\"readonly\", c_int),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "PyBUF_SIMPLE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "PyBUF_SIMPLE = 0\nPyBUF_WRITABLE = 1\nclass Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),\n\t\t(\"readonly\", c_int),\n\t\t(\"ndim\", c_int),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "PyBUF_WRITABLE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "PyBUF_WRITABLE = 1\nclass Py_buffer(ctypes.Structure):\n\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),\n\t\t(\"readonly\", c_int),\n\t\t(\"ndim\", c_int),\n\t\t(\"format\", c_char_p),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "\t_fields_ = [\n\t\t(\"buf\", c_void_p),\n\t\t(\"obj\", py_object),\n\t\t(\"len\", c_ssize_t),\n\t\t(\"itemsize\", c_ssize_t),\n\t\t(\"readonly\", c_int),\n\t\t(\"ndim\", c_int),\n\t\t(\"format\", c_char_p),\n\t\t(\"shape\", c_ssize_p),\n\t\t(\"strides\", c_ssize_p),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "\t\tbuf",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "\t\tbuf = cls()\n\t\tPyObject_GetBuffer(py_object(obj), byref(buf), flags)\n\t\treturn buf\n\tdef release(self):\n\t\tPyBuffer_Release(byref(self))\ndef get_buffer(obj, writable=False):\n\tbuf = Py_buffer.get_from(obj, PyBUF_WRITABLE if writable else PyBUF_SIMPLE)\n\ttry:\n\t\tbuffer_type = c_char * buf.len\n\t\treturn buffer_type.from_address(buf.buf)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "\tbuf",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "\tbuf = Py_buffer.get_from(obj, PyBUF_WRITABLE if writable else PyBUF_SIMPLE)\n\ttry:\n\t\tbuffer_type = c_char * buf.len\n\t\treturn buffer_type.from_address(buf.buf)\n\tfinally:\n\t\tbuf.release()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "\t\tbuffer_type",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "peekOfCode": "\t\tbuffer_type = c_char * buf.len\n\t\treturn buffer_type.from_address(buf.buf)\n\tfinally:\n\t\tbuf.release()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.buffer",
        "documentation": {}
    },
    {
        "label": "InteractiveConsole",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "class InteractiveConsole(code.InteractiveConsole, object):\n\t# code.InteractiveConsole without banner\n\t# exits on EOF\n\t# also more robust treating of sys.ps1, sys.ps2\n\t# prints prompt into stderr rather than stdout\n\t# flushes sys.stderr and sys.stdout\n\tdef __init__(self, locals=None, filename=\"<stdin>\"):\n\t\tself.done = False\n\t\t# PY3 # super().__init__(locals, filename)\n\t\tsuper(InteractiveConsole, self).__init__(locals, filename)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "def print_banner(file=sys.stderr):\n\tprint(\"Python {} on {}\".format(sys.version, sys.platform), file=file)\n\tprint('Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.', file=file)\n# PY3 # class InteractiveConsole(code.InteractiveConsole):\nclass InteractiveConsole(code.InteractiveConsole, object):\n\t# code.InteractiveConsole without banner\n\t# exits on EOF\n\t# also more robust treating of sys.ps1, sys.ps2\n\t# prints prompt into stderr rather than stdout\n\t# flushes sys.stderr and sys.stdout",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "def enable():\n\tglobal running_console\n\tif running_console is not None:\n\t\traise RuntimeError(\"interactive console already running\")\n\telse:\n\t\trunning_console = InteractiveConsole(__main__.__dict__) \n\t\trunning_console.interact() \ndef disable():\n\tglobal running_console\n\tif running_console is None:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "disable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "def disable():\n\tglobal running_console\n\tif running_console is None:\n\t\traise RuntimeError(\"interactive console is not running\")\n\telse:\n\t\trunning_console.done = True\n\t\trunning_console = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\tself.done",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\tself.done = False\n\t\t# PY3 # super().__init__(locals, filename)\n\t\tsuper(InteractiveConsole, self).__init__(locals, filename)\n\tdef raw_input(self, prompt=\"\"):\n\t\tsys.stderr.write(prompt)\n\t\tif PY2:\n\t\t\treturn raw_input()\n\t\telse:\n\t\t\treturn input()\n\tdef runcode(self, code):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t#sys.ps1",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t#sys.ps1 = \"~>> \"\n\t\t#sys.ps2 = \"~.. \"\n\t\ttry:\n\t\t\tsys.ps1\n\t\texcept AttributeError:\n\t\t\tsys.ps1 = \">>> \"\n\t\ttry:\n\t\t\tsys.ps2\n\t\texcept AttributeError:\n\t\t\tsys.ps2 = \"... \"",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t#sys.ps2",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t#sys.ps2 = \"~.. \"\n\t\ttry:\n\t\t\tsys.ps1\n\t\texcept AttributeError:\n\t\t\tsys.ps1 = \">>> \"\n\t\ttry:\n\t\t\tsys.ps2\n\t\texcept AttributeError:\n\t\t\tsys.ps2 = \"... \"\n\t\tmore = 0",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\tsys.ps1",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\tsys.ps1 = \">>> \"\n\t\ttry:\n\t\t\tsys.ps2\n\t\texcept AttributeError:\n\t\t\tsys.ps2 = \"... \"\n\t\tmore = 0\n\t\twhile not self.done:\n\t\t\ttry:\n\t\t\t\tif more:\n\t\t\t\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\tsys.ps2",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\tsys.ps2 = \"... \"\n\t\tmore = 0\n\t\twhile not self.done:\n\t\t\ttry:\n\t\t\t\tif more:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tprompt = sys.ps2\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\tmore",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\tmore = 0\n\t\twhile not self.done:\n\t\t\ttry:\n\t\t\t\tif more:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tprompt = sys.ps2\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\telse:\n\t\t\t\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\t\tprompt = sys.ps2\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\telse:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tprompt = sys.ps1\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\ttry:\n\t\t\t\t\tline = self.raw_input(prompt)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\t\tprompt = \"\"\n\t\t\t\telse:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tprompt = sys.ps1\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\ttry:\n\t\t\t\t\tline = self.raw_input(prompt)\n\t\t\t\texcept EOFError:\n\t\t\t\t\tself.on_EOF()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\t\tprompt = sys.ps1\n\t\t\t\t\texcept AttributeError:\n\t\t\t\t\t\tprompt = \"\"\n\t\t\t\ttry:\n\t\t\t\t\tline = self.raw_input(prompt)\n\t\t\t\texcept EOFError:\n\t\t\t\t\tself.on_EOF()\n\t\t\t\telse:\n\t\t\t\t\tmore = self.push(line)\n\t\t\texcept KeyboardInterrupt:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\t\tprompt = \"\"\n\t\t\t\ttry:\n\t\t\t\t\tline = self.raw_input(prompt)\n\t\t\t\texcept EOFError:\n\t\t\t\t\tself.on_EOF()\n\t\t\t\telse:\n\t\t\t\t\tmore = self.push(line)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\tself.write(\"\\nKeyboardInterrupt\\n\")\n\t\t\t\tself.resetbuffer()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\tline = self.raw_input(prompt)\n\t\t\t\texcept EOFError:\n\t\t\t\t\tself.on_EOF()\n\t\t\t\telse:\n\t\t\t\t\tmore = self.push(line)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\tself.write(\"\\nKeyboardInterrupt\\n\")\n\t\t\t\tself.resetbuffer()\n\t\t\t\tmore = 0\n\tdef on_EOF(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmore",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\t\tmore = self.push(line)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\tself.write(\"\\nKeyboardInterrupt\\n\")\n\t\t\t\tself.resetbuffer()\n\t\t\t\tmore = 0\n\tdef on_EOF(self):\n\t\tself.write(\"\\n\")\n\t\t# PY3 # raise SystemExit from None\n\t\traise SystemExit\nrunning_console = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmore",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\t\t\tmore = 0\n\tdef on_EOF(self):\n\t\tself.write(\"\\n\")\n\t\t# PY3 # raise SystemExit from None\n\t\traise SystemExit\nrunning_console = None\ndef enable():\n\tglobal running_console\n\tif running_console is not None:\n\t\traise RuntimeError(\"interactive console already running\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "running_console",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "running_console = None\ndef enable():\n\tglobal running_console\n\tif running_console is not None:\n\t\traise RuntimeError(\"interactive console already running\")\n\telse:\n\t\trunning_console = InteractiveConsole(__main__.__dict__) \n\t\trunning_console.interact() \ndef disable():\n\tglobal running_console",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\trunning_console",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\trunning_console = InteractiveConsole(__main__.__dict__) \n\t\trunning_console.interact() \ndef disable():\n\tglobal running_console\n\tif running_console is None:\n\t\traise RuntimeError(\"interactive console is not running\")\n\telse:\n\t\trunning_console.done = True\n\t\trunning_console = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\trunning_console.done",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\trunning_console.done = True\n\t\trunning_console = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "\t\trunning_console",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "peekOfCode": "\t\trunning_console = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.console",
        "documentation": {}
    },
    {
        "label": "FileObject",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "peekOfCode": "class FileObject(ctypes.Structure):\n\t_fields_ = [\n\t\t#(\"_ob_next\", c_void_p),\n\t\t#(\"_ob_prev\", c_void_p),\n\t\t(\"ob_refcnt\", c_ssize_t),\n\t\t(\"ob_type\", c_void_p),\n\t\t(\"fp\", c_void_p),\n\t\t(\"name\", py_object),\n\t\t(\"mode\", py_object),\n\t\t(\"close\", c_void_p),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "documentation": {}
    },
    {
        "label": "\t_fields_",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "peekOfCode": "\t_fields_ = [\n\t\t#(\"_ob_next\", c_void_p),\n\t\t#(\"_ob_prev\", c_void_p),\n\t\t(\"ob_refcnt\", c_ssize_t),\n\t\t(\"ob_type\", c_void_p),\n\t\t(\"fp\", c_void_p),\n\t\t(\"name\", py_object),\n\t\t(\"mode\", py_object),\n\t\t(\"close\", c_void_p),\n\t\t(\"softspace\", c_int),",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "documentation": {}
    },
    {
        "label": "\t\tself.fp",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "peekOfCode": "\t\tself.fp = pythonapi.PyFile_AsFile(py_object(f))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.file_object",
        "documentation": {}
    },
    {
        "label": "check_Windows",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "peekOfCode": "def check_Windows():\n\tcurrent_platform = platform.system()\n\tif not WINDOWS:\n\t\traise RuntimeError(\"available only for Windows, not {}.\".format(current_platform))\ndef check_PY2():\n\tif not PY2:\n\t\traise RuntimeError(\"needed only in Python 2\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "documentation": {}
    },
    {
        "label": "check_PY2",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "peekOfCode": "def check_PY2():\n\tif not PY2:\n\t\traise RuntimeError(\"needed only in Python 2\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "documentation": {}
    },
    {
        "label": "WINDOWS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "peekOfCode": "WINDOWS = platform.system().lower() == \"windows\"\nPY2 = sys.version_info.major < 3\ndef check_Windows():\n\tcurrent_platform = platform.system()\n\tif not WINDOWS:\n\t\traise RuntimeError(\"available only for Windows, not {}.\".format(current_platform))\ndef check_PY2():\n\tif not PY2:\n\t\traise RuntimeError(\"needed only in Python 2\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "peekOfCode": "PY2 = sys.version_info.major < 3\ndef check_Windows():\n\tcurrent_platform = platform.system()\n\tif not WINDOWS:\n\t\traise RuntimeError(\"available only for Windows, not {}.\".format(current_platform))\ndef check_PY2():\n\tif not PY2:\n\t\traise RuntimeError(\"needed only in Python 2\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "documentation": {}
    },
    {
        "label": "\tcurrent_platform",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "peekOfCode": "\tcurrent_platform = platform.system()\n\tif not WINDOWS:\n\t\traise RuntimeError(\"available only for Windows, not {}.\".format(current_platform))\ndef check_PY2():\n\tif not PY2:\n\t\traise RuntimeError(\"needed only in Python 2\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.info",
        "documentation": {}
    },
    {
        "label": "stdout_encode",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_encode(s):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "stdin_encode",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def stdin_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_decode(b):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "stdin_decode",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def stdin_decode(b):\n\tif isinstance(b, unicode):\n\t\treturn b\n\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn b.decode(encoding, errors)\n\telse:\n\t\treturn b.decode(encoding)\ndef readline(prompt=\"\"):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "readline",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def readline(prompt=\"\"):\n\tcheck_encodings()\n\tprompt_bytes = stdout_encode(prompt)\n\tline_bytes = PyOS_Readline(STDIN_FILE_POINTER, STDOUT_FILE_POINTER, prompt_bytes)\n\tif line_bytes is None:\n\t\traise KeyboardInterrupt\n\telse:\n\t\treturn line_bytes\ndef raw_input(prompt=\"\"):\n\t\"\"\"raw_input([prompt]) -> string",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "raw_input",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def raw_input(prompt=\"\"):\n\t\"\"\"raw_input([prompt]) -> string\nRead a string from standard input.  The trailing newline is stripped.\nIf the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.\nOn Unix, GNU readline is used if enabled.  The prompt string, if given,\nis printed without a trailing newline before reading.\"\"\"\n\tsys.stderr.flush()\n\ttty = STDIN.is_a_TTY() and STDOUT.is_a_TTY()\n\tif RETURN_UNICODE:\n\t\tif tty:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def input(prompt=\"\"):\n\t\"\"\"input([prompt]) -> value\nEquivalent to eval(raw_input(prompt)).\"\"\"\n\tstring = stdin_decode(raw_input(prompt))\n\tcaller_frame = sys._getframe(1)\n\tglobals = caller_frame.f_globals\n\tlocals = caller_frame.f_locals\n\treturn eval(string, globals, locals)\ndef enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE\n\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "disable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "def disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "original_raw_input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "original_raw_input = builtins.raw_input\noriginal_input = builtins.input\nRETURN_UNICODE = True\nPyOS_Readline = pythonapi.PyOS_Readline\nPyOS_Readline.restype = c_char_p\nPyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "original_input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "original_input = builtins.input\nRETURN_UNICODE = True\nPyOS_Readline = pythonapi.PyOS_Readline\nPyOS_Readline.restype = c_char_p\nPyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "RETURN_UNICODE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "RETURN_UNICODE = True\nPyOS_Readline = pythonapi.PyOS_Readline\nPyOS_Readline.restype = c_char_p\nPyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyOS_Readline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyOS_Readline = pythonapi.PyOS_Readline\nPyOS_Readline.restype = c_char_p\nPyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyOS_Readline.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyOS_Readline.restype = c_char_p\nPyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyOS_Readline.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyOS_Readline.argtypes = [c_void_p, c_void_p, c_char_p]\nPyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyFile_AsFile",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyFile_AsFile = pythonapi.PyFile_AsFile\nPyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyFile_AsFile.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyFile_AsFile.restype = c_void_p\nPyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "PyFile_AsFile.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "PyFile_AsFile.argtypes = [py_object]\nSTDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "STDIN_FILE_POINTER",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "STDIN_FILE_POINTER = PyFile_AsFile(sys.stdin)\nSTDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "STDOUT_FILE_POINTER",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "STDOUT_FILE_POINTER = PyFile_AsFile(sys.stdout)\ndef stdout_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tencoding = sys.stdout.encoding\n\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdin.encoding",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\terrors",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\terrors = sys.stdout.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_encode(s):\n\tif isinstance(s, bytes):\n\t\treturn s\n\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_decode(b):\n\tif isinstance(b, unicode):\n\t\treturn b\n\tencoding = sys.stdin.encoding",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\terrors",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn s.encode(encoding, errors)\n\telse:\n\t\treturn s.encode(encoding)\ndef stdin_decode(b):\n\tif isinstance(b, unicode):\n\t\treturn b\n\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tencoding = sys.stdin.encoding\n\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn b.decode(encoding, errors)\n\telse:\n\t\treturn b.decode(encoding)\ndef readline(prompt=\"\"):\n\tcheck_encodings()\n\tprompt_bytes = stdout_encode(prompt)\n\tline_bytes = PyOS_Readline(STDIN_FILE_POINTER, STDOUT_FILE_POINTER, prompt_bytes)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\terrors",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\terrors = sys.stdin.errors\n\tif errors is not None:\n\t\treturn b.decode(encoding, errors)\n\telse:\n\t\treturn b.decode(encoding)\ndef readline(prompt=\"\"):\n\tcheck_encodings()\n\tprompt_bytes = stdout_encode(prompt)\n\tline_bytes = PyOS_Readline(STDIN_FILE_POINTER, STDOUT_FILE_POINTER, prompt_bytes)\n\tif line_bytes is None:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tprompt_bytes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tprompt_bytes = stdout_encode(prompt)\n\tline_bytes = PyOS_Readline(STDIN_FILE_POINTER, STDOUT_FILE_POINTER, prompt_bytes)\n\tif line_bytes is None:\n\t\traise KeyboardInterrupt\n\telse:\n\t\treturn line_bytes\ndef raw_input(prompt=\"\"):\n\t\"\"\"raw_input([prompt]) -> string\nRead a string from standard input.  The trailing newline is stripped.\nIf the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tline_bytes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tline_bytes = PyOS_Readline(STDIN_FILE_POINTER, STDOUT_FILE_POINTER, prompt_bytes)\n\tif line_bytes is None:\n\t\traise KeyboardInterrupt\n\telse:\n\t\treturn line_bytes\ndef raw_input(prompt=\"\"):\n\t\"\"\"raw_input([prompt]) -> string\nRead a string from standard input.  The trailing newline is stripped.\nIf the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.\nOn Unix, GNU readline is used if enabled.  The prompt string, if given,",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\ttty",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\ttty = STDIN.is_a_TTY() and STDOUT.is_a_TTY()\n\tif RETURN_UNICODE:\n\t\tif tty:\n\t\t\tline_bytes = readline(prompt)\n\t\t\tline = stdin_decode(line_bytes)\n\t\telse:\n\t\t\tline = stdio_readline(prompt)\n\telse:\n\t\tif tty:\n\t\t\tline = readline(prompt)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline_bytes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline_bytes = readline(prompt)\n\t\t\tline = stdin_decode(line_bytes)\n\t\telse:\n\t\t\tline = stdio_readline(prompt)\n\telse:\n\t\tif tty:\n\t\t\tline = readline(prompt)\n\t\telse:\n\t\t\tline_unicode = stdio_readline(prompt)\n\t\t\tline = stdin_encode(line_unicode)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline = stdin_decode(line_bytes)\n\t\telse:\n\t\t\tline = stdio_readline(prompt)\n\telse:\n\t\tif tty:\n\t\t\tline = readline(prompt)\n\t\telse:\n\t\t\tline_unicode = stdio_readline(prompt)\n\t\t\tline = stdin_encode(line_unicode)\n\tif line:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline = stdio_readline(prompt)\n\telse:\n\t\tif tty:\n\t\t\tline = readline(prompt)\n\t\telse:\n\t\t\tline_unicode = stdio_readline(prompt)\n\t\t\tline = stdin_encode(line_unicode)\n\tif line:\n\t\treturn line[:-1] # strip strailing \"\\n\"\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline = readline(prompt)\n\t\telse:\n\t\t\tline_unicode = stdio_readline(prompt)\n\t\t\tline = stdin_encode(line_unicode)\n\tif line:\n\t\treturn line[:-1] # strip strailing \"\\n\"\n\telse:\n\t\traise EOFError\ndef input(prompt=\"\"):\n\t\"\"\"input([prompt]) -> value",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline_unicode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline_unicode = stdio_readline(prompt)\n\t\t\tline = stdin_encode(line_unicode)\n\tif line:\n\t\treturn line[:-1] # strip strailing \"\\n\"\n\telse:\n\t\traise EOFError\ndef input(prompt=\"\"):\n\t\"\"\"input([prompt]) -> value\nEquivalent to eval(raw_input(prompt)).\"\"\"\n\tstring = stdin_decode(raw_input(prompt))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\t\t\tline = stdin_encode(line_unicode)\n\tif line:\n\t\treturn line[:-1] # strip strailing \"\\n\"\n\telse:\n\t\traise EOFError\ndef input(prompt=\"\"):\n\t\"\"\"input([prompt]) -> value\nEquivalent to eval(raw_input(prompt)).\"\"\"\n\tstring = stdin_decode(raw_input(prompt))\n\tcaller_frame = sys._getframe(1)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tstring",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tstring = stdin_decode(raw_input(prompt))\n\tcaller_frame = sys._getframe(1)\n\tglobals = caller_frame.f_globals\n\tlocals = caller_frame.f_locals\n\treturn eval(string, globals, locals)\ndef enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE\n\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tcaller_frame",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tcaller_frame = sys._getframe(1)\n\tglobals = caller_frame.f_globals\n\tlocals = caller_frame.f_locals\n\treturn eval(string, globals, locals)\ndef enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE\n\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tglobals",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tglobals = caller_frame.f_globals\n\tlocals = caller_frame.f_locals\n\treturn eval(string, globals, locals)\ndef enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE\n\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tlocals",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tlocals = caller_frame.f_locals\n\treturn eval(string, globals, locals)\ndef enable(return_unicode=RETURN_UNICODE):\n\tglobal RETURN_UNICODE\n\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tRETURN_UNICODE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tRETURN_UNICODE = return_unicode\n\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tbuiltins.raw_input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tbuiltins.raw_input = raw_input\n\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tbuiltins.input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tbuiltins.input = input\ndef disable():\n\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tbuiltins.raw_input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tbuiltins.raw_input = original_raw_input\n\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "\tbuiltins.input",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "peekOfCode": "\tbuiltins.input = original_input",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.raw_input",
        "documentation": {}
    },
    {
        "label": "ReadlineHookManager",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "class ReadlineHookManager:\n\tdef __init__(self):\n\t\tself.readline_wrapper_ref = HOOKFUNC(self.readline_wrapper)\n\t\tself.address = cast(self.readline_wrapper_ref, c_void_p).value\n\t\t#self.original_address = PyOS_ReadlineFunctionPointer.value\n\t\tself.readline_hook = None\n\tdef readline_wrapper(self, stdin, stdout, prompt):\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tcheck_encodings()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "PyReadlineManager",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "class PyReadlineManager:\n\tdef __init__(self):\n\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):\n\t\tself.set_codepage(self.original_codepage)\ndef pyreadline_is_active():\n\tif not pyreadline:\n\t\treturn False",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "get_libc",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def get_libc():\n\tif WINDOWS:\n\t\tpath = \"msvcrt\"\n\telse:\n\t\tpath = ctypes.util.find_library(\"c\")\n\t\tif path is None:\n\t\t\traise RuntimeError(\"cannot locate libc\")\n\treturn cdll[path]\nLIBC = get_libc()\nPyMem_Malloc = pythonapi.PyMem_Malloc",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "new_zero_terminated_string",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")\n\t\twarnings.warn(\"sys.stdin.encoding == {!r}, whereas sys.stdout.encoding == {!r}, readline hook consumer may assume they are the same\".format(sys.stdin.encoding, sys.stdout.encoding), \n\t\t\tRuntimeWarning, stacklevel=3)\ndef stdio_readline(prompt=\"\"):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "check_encodings",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")\n\t\twarnings.warn(\"sys.stdin.encoding == {!r}, whereas sys.stdout.encoding == {!r}, readline hook consumer may assume they are the same\".format(sys.stdin.encoding, sys.stdout.encoding), \n\t\t\tRuntimeWarning, stacklevel=3)\ndef stdio_readline(prompt=\"\"):\n\tsys.stdout.write(prompt)\n\tsys.stdout.flush()\n\treturn sys.stdin.readline()\nclass ReadlineHookManager:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "stdio_readline",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def stdio_readline(prompt=\"\"):\n\tsys.stdout.write(prompt)\n\tsys.stdout.flush()\n\treturn sys.stdin.readline()\nclass ReadlineHookManager:\n\tdef __init__(self):\n\t\tself.readline_wrapper_ref = HOOKFUNC(self.readline_wrapper)\n\t\tself.address = cast(self.readline_wrapper_ref, c_void_p).value\n\t\t#self.original_address = PyOS_ReadlineFunctionPointer.value\n\t\tself.readline_hook = None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "pyreadline_is_active",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def pyreadline_is_active():\n\tif not pyreadline:\n\t\treturn False\n\tref = pyreadline.console.console.readline_ref\n\tif ref is None:\n\t\treturn False\n\treturn cast(ref, c_void_p).value == PyOS_ReadlineFunctionPointer.value\nmanager = ReadlineHookManager()\nif pyreadline:\n\tpyreadline_manager = PyReadlineManager()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def enable(use_pyreadline=True):\n\tcheck_encodings()\n\tif use_pyreadline and pyreadline:\n\t\tpyreadline_manager.set_codepage(sys.stdin.encoding)\n\t\t\t# pyreadline assumes that encoding of all sys.stdio objects is the same\n\t\tif not pyreadline_is_active():\n\t\t\tmanager.install_hook(stdio_readline)\n\telse:\n\t\tmanager.install_hook(stdio_readline)\ndef disable():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "disable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "def disable():\n\tif pyreadline:\n\t\tpyreadline_manager.restore_original()\n\telse:\n\t\tmanager.restore_original()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\tpyreadline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\tpyreadline = None\ndef get_libc():\n\tif WINDOWS:\n\t\tpath = \"msvcrt\"\n\telse:\n\t\tpath = ctypes.util.find_library(\"c\")\n\t\tif path is None:\n\t\t\traise RuntimeError(\"cannot locate libc\")\n\treturn cdll[path]\nLIBC = get_libc()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tpath",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tpath = \"msvcrt\"\n\telse:\n\t\tpath = ctypes.util.find_library(\"c\")\n\t\tif path is None:\n\t\t\traise RuntimeError(\"cannot locate libc\")\n\treturn cdll[path]\nLIBC = get_libc()\nPyMem_Malloc = pythonapi.PyMem_Malloc\nPyMem_Malloc.restype = c_size_t\nPyMem_Malloc.argtypes = [c_size_t]",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tpath",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tpath = ctypes.util.find_library(\"c\")\n\t\tif path is None:\n\t\t\traise RuntimeError(\"cannot locate libc\")\n\treturn cdll[path]\nLIBC = get_libc()\nPyMem_Malloc = pythonapi.PyMem_Malloc\nPyMem_Malloc.restype = c_size_t\nPyMem_Malloc.argtypes = [c_size_t]\nstrncpy = LIBC.strncpy\nstrncpy.restype = c_char_p",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "LIBC",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "LIBC = get_libc()\nPyMem_Malloc = pythonapi.PyMem_Malloc\nPyMem_Malloc.restype = c_size_t\nPyMem_Malloc.argtypes = [c_size_t]\nstrncpy = LIBC.strncpy\nstrncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "PyMem_Malloc",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "PyMem_Malloc = pythonapi.PyMem_Malloc\nPyMem_Malloc.restype = c_size_t\nPyMem_Malloc.argtypes = [c_size_t]\nstrncpy = LIBC.strncpy\nstrncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "PyMem_Malloc.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "PyMem_Malloc.restype = c_size_t\nPyMem_Malloc.argtypes = [c_size_t]\nstrncpy = LIBC.strncpy\nstrncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "PyMem_Malloc.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "PyMem_Malloc.argtypes = [c_size_t]\nstrncpy = LIBC.strncpy\nstrncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "strncpy",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "strncpy = LIBC.strncpy\nstrncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "strncpy.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "strncpy.restype = c_char_p\nstrncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "strncpy.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "strncpy.argtypes = [c_char_p, c_char_p, c_size_t]\nHOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "HOOKFUNC",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "HOOKFUNC = CFUNCTYPE(c_char_p, c_void_p, c_void_p, c_char_p)\n#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")\n\t\twarnings.warn(\"sys.stdin.encoding == {!r}, whereas sys.stdout.encoding == {!r}, readline hook consumer may assume they are the same\".format(sys.stdin.encoding, sys.stdout.encoding), ",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "#PyOS_ReadlineFunctionPointer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "#PyOS_ReadlineFunctionPointer = c_void_p.in_dll(pythonapi, \"PyOS_ReadlineFunctionPointer\")\ndef new_zero_terminated_string(b):\n\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")\n\t\twarnings.warn(\"sys.stdin.encoding == {!r}, whereas sys.stdout.encoding == {!r}, readline hook consumer may assume they are the same\".format(sys.stdin.encoding, sys.stdout.encoding), \n\t\t\tRuntimeWarning, stacklevel=3)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\tp",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\tp = PyMem_Malloc(len(b) + 1)\n\tstrncpy(cast(p, c_char_p), b, len(b) + 1)\n\treturn p\ndef check_encodings():\n\tif sys.stdin.encoding != sys.stdout.encoding:\n\t\t# raise RuntimeError(\"sys.stdin.encoding != sys.stdout.encoding, readline hook doesn't know, which one to use to decode prompt\")\n\t\twarnings.warn(\"sys.stdin.encoding == {!r}, whereas sys.stdout.encoding == {!r}, readline hook consumer may assume they are the same\".format(sys.stdin.encoding, sys.stdout.encoding), \n\t\t\tRuntimeWarning, stacklevel=3)\ndef stdio_readline(prompt=\"\"):\n\tsys.stdout.write(prompt)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.readline_wrapper_ref",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.readline_wrapper_ref = HOOKFUNC(self.readline_wrapper)\n\t\tself.address = cast(self.readline_wrapper_ref, c_void_p).value\n\t\t#self.original_address = PyOS_ReadlineFunctionPointer.value\n\t\tself.readline_hook = None\n\tdef readline_wrapper(self, stdin, stdout, prompt):\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tcheck_encodings()\n\t\t\texcept RuntimeError:\n\t\t\t\ttraceback.print_exc(file=sys.stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.address",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.address = cast(self.readline_wrapper_ref, c_void_p).value\n\t\t#self.original_address = PyOS_ReadlineFunctionPointer.value\n\t\tself.readline_hook = None\n\tdef readline_wrapper(self, stdin, stdout, prompt):\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tcheck_encodings()\n\t\t\texcept RuntimeError:\n\t\t\t\ttraceback.print_exc(file=sys.stderr)\n\t\t\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\t#self.original_address",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\t#self.original_address = PyOS_ReadlineFunctionPointer.value\n\t\tself.readline_hook = None\n\tdef readline_wrapper(self, stdin, stdout, prompt):\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tcheck_encodings()\n\t\t\texcept RuntimeError:\n\t\t\t\ttraceback.print_exc(file=sys.stderr)\n\t\t\t\ttry:\n\t\t\t\t\tprompt = prompt.decode(\"utf-8\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.readline_hook",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.readline_hook = None\n\tdef readline_wrapper(self, stdin, stdout, prompt):\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tcheck_encodings()\n\t\t\texcept RuntimeError:\n\t\t\t\ttraceback.print_exc(file=sys.stderr)\n\t\t\t\ttry:\n\t\t\t\t\tprompt = prompt.decode(\"utf-8\")\n\t\t\t\texcept UnicodeDecodeError:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\t\t\t\tprompt = prompt.decode(\"utf-8\")\n\t\t\t\texcept UnicodeDecodeError:\n\t\t\t\t\tprompt = \"\"\n\t\t\telse:\n\t\t\t\tprompt = prompt.decode(sys.stdout.encoding)\n\t\t\ttry:\n\t\t\t\tline = self.readline_hook(prompt)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\treturn 0\n\t\t\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\t\t\t\tprompt = \"\"\n\t\t\telse:\n\t\t\t\tprompt = prompt.decode(sys.stdout.encoding)\n\t\t\ttry:\n\t\t\t\tline = self.readline_hook(prompt)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\treturn 0\n\t\t\telse:\n\t\t\t\treturn new_zero_terminated_string(line.encode(sys.stdin.encoding))\n\t\texcept:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprompt",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\t\t\tprompt = prompt.decode(sys.stdout.encoding)\n\t\t\ttry:\n\t\t\t\tline = self.readline_hook(prompt)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\treturn 0\n\t\t\telse:\n\t\t\t\treturn new_zero_terminated_string(line.encode(sys.stdin.encoding))\n\t\texcept:\n\t\t\tself.restore_original()\n\t\t\tprint(\"Internal win_unicode_console error, disabling custom readline hook...\", file=sys.stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\t\t\tline = self.readline_hook(prompt)\n\t\t\texcept KeyboardInterrupt:\n\t\t\t\treturn 0\n\t\t\telse:\n\t\t\t\treturn new_zero_terminated_string(line.encode(sys.stdin.encoding))\n\t\texcept:\n\t\t\tself.restore_original()\n\t\t\tprint(\"Internal win_unicode_console error, disabling custom readline hook...\", file=sys.stderr)\n\t\t\ttraceback.print_exc(file=sys.stderr)\n\t\t\treturn new_zero_terminated_string(b\"\\n\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.readline_hook",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.readline_hook = hook\n\t\tPyOS_ReadlineFunctionPointer.value = self.address\n\tdef restore_original(self):\n\t\tself.readline_hook = None\n\t\tPyOS_ReadlineFunctionPointer.value = self.original_address\nclass PyReadlineManager:\n\tdef __init__(self):\n\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tPyOS_ReadlineFunctionPointer.value",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tPyOS_ReadlineFunctionPointer.value = self.address\n\tdef restore_original(self):\n\t\tself.readline_hook = None\n\t\tPyOS_ReadlineFunctionPointer.value = self.original_address\nclass PyReadlineManager:\n\tdef __init__(self):\n\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.readline_hook",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.readline_hook = None\n\t\tPyOS_ReadlineFunctionPointer.value = self.original_address\nclass PyReadlineManager:\n\tdef __init__(self):\n\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):\n\t\tself.set_codepage(self.original_codepage)\ndef pyreadline_is_active():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tPyOS_ReadlineFunctionPointer.value",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tPyOS_ReadlineFunctionPointer.value = self.original_address\nclass PyReadlineManager:\n\tdef __init__(self):\n\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):\n\t\tself.set_codepage(self.original_codepage)\ndef pyreadline_is_active():\n\tif not pyreadline:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tself.original_codepage",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tself.original_codepage = pyreadline.unicode_helper.pyreadline_codepage\n\tdef set_codepage(self, codepage):\n\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):\n\t\tself.set_codepage(self.original_codepage)\ndef pyreadline_is_active():\n\tif not pyreadline:\n\t\treturn False\n\tref = pyreadline.console.console.readline_ref\n\tif ref is None:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\t\tpyreadline.unicode_helper.pyreadline_codepage",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\t\tpyreadline.unicode_helper.pyreadline_codepage = codepage\n\tdef restore_original(self):\n\t\tself.set_codepage(self.original_codepage)\ndef pyreadline_is_active():\n\tif not pyreadline:\n\t\treturn False\n\tref = pyreadline.console.console.readline_ref\n\tif ref is None:\n\t\treturn False\n\treturn cast(ref, c_void_p).value == PyOS_ReadlineFunctionPointer.value",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\tref",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\tref = pyreadline.console.console.readline_ref\n\tif ref is None:\n\t\treturn False\n\treturn cast(ref, c_void_p).value == PyOS_ReadlineFunctionPointer.value\nmanager = ReadlineHookManager()\nif pyreadline:\n\tpyreadline_manager = PyReadlineManager()\n# PY3 # def enable(*, use_pyreadline=True):\ndef enable(use_pyreadline=True):\n\tcheck_encodings()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "manager",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "manager = ReadlineHookManager()\nif pyreadline:\n\tpyreadline_manager = PyReadlineManager()\n# PY3 # def enable(*, use_pyreadline=True):\ndef enable(use_pyreadline=True):\n\tcheck_encodings()\n\tif use_pyreadline and pyreadline:\n\t\tpyreadline_manager.set_codepage(sys.stdin.encoding)\n\t\t\t# pyreadline assumes that encoding of all sys.stdio objects is the same\n\t\tif not pyreadline_is_active():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "\tpyreadline_manager",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "peekOfCode": "\tpyreadline_manager = PyReadlineManager()\n# PY3 # def enable(*, use_pyreadline=True):\ndef enable(use_pyreadline=True):\n\tcheck_encodings()\n\tif use_pyreadline and pyreadline:\n\t\tpyreadline_manager.set_codepage(sys.stdin.encoding)\n\t\t\t# pyreadline assumes that encoding of all sys.stdio objects is the same\n\t\tif not pyreadline_is_active():\n\t\t\tmanager.install_hook(stdio_readline)\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.readline_hook",
        "documentation": {}
    },
    {
        "label": "set_inspect_flag",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def set_inspect_flag(value):\n\tinspect_flag.value = int(value)\nCODE_FIELDS = [\"argcount\", \"kwonlyargcount\", \"nlocals\", \"stacksize\", \n\t\t\"flags\", \"code\", \"consts\", \"names\", \"varnames\", \"filename\", \n\t\t\"name\", \t\"firstlineno\", \"lnotab\", \"freevars\", \"cellvars\"]\nif PY2:\n\tCODE_FIELDS.remove(\"kwonlyargcount\")\ndef update_code(codeobj, **kwargs):\n\tdef field_values():\n\t\tfor field in CODE_FIELDS:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "update_code",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def update_code(codeobj, **kwargs):\n\tdef field_values():\n\t\tfor field in CODE_FIELDS:\n\t\t\toriginal_value = getattr(codeobj, \"co_{}\".format(field))\n\t\t\tvalue = kwargs.get(field, original_value)\n\t\t\tyield value\n\treturn Code(*field_values())\ndef update_code_recursively(codeobj, **kwargs):\n\tupdated = {}\n\tdef update(codeobj, **kwargs):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "update_code_recursively",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def update_code_recursively(codeobj, **kwargs):\n\tupdated = {}\n\tdef update(codeobj, **kwargs):\n\t\tresult = updated.get(codeobj, None)\n\t\tif result is not None:\n\t\t\treturn result\n\t\tif any(isinstance(c, Code) for c in codeobj.co_consts):\n\t\t\tconsts = tuple(update(c, **kwargs) if isinstance(c, Code) else c\n\t\t\t\tfor c in codeobj.co_consts)\n\t\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "get_code",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def get_code(path):\n\tif PY2:\n\t\tfrom .tokenize_open import read_source_lines\n\t\tsource = u\"\".join(read_source_lines(path))\n\telse:\n\t\twith tokenize.open(path) as f: # opens with detected source encoding\n\t\t\tsource = f.read()\n\ttry:\n\t\tcode = compile(source, path, \"exec\", dont_inherit=True)\n\texcept UnicodeEncodeError:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "print_exception_without_first_line",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def print_exception_without_first_line(etype, value, tb, limit=None, file=None, chain=True):\n\tif file is None:\n\t\tfile = sys.stderr\n\tlines = iter(traceback.TracebackException(\n\t\ttype(value), value, tb, limit=limit).format(chain=chain))\n\tnext(lines)\n\tfor line in lines:\n\t\tprint(line, file=file, end=\"\")\ndef run_script(args):\n\tsys.argv = [args.script] + args.script_arguments",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "run_script",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def run_script(args):\n\tsys.argv = [args.script] + args.script_arguments\n\tpath = args.script\n\t__main__.__file__ = path\n\ttry:\n\t\tcode = get_code(path)\n\texcept Exception as e:\n\t\ttraceback.print_exception(e.__class__, e, None, file=sys.stderr)\n\telse:\n\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "run_init",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def run_init(args):\n\tif args.init == \"enable\":\n\t\tenable()\n\telif args.init == \"disable\":\n\t\tdisable()\n\telif args.init == \"module\":\n\t\t__import__(args.module)\n\telif args.init == \"none\":\n\t\tpass\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "run_with_custom_repl",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def run_with_custom_repl(args):\n\trun_init(args)\n\tif args.script:\n\t\trun_script(args)\n\tif sys.flags.interactive or not args.script:\n\t\tif sys.flags.interactive and not args.script:\n\t\t\tconsole.print_banner()\n\t\ttry:\n\t\t\tconsole.enable()\n\t\tfinally:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "run_with_standard_repl",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def run_with_standard_repl(args):\n\trun_init(args)\n\tif args.script:\n\t\trun_script(args)\n\tif sys.flags.interactive and not args.script:\n\t\tconsole.print_banner()\ndef run_arguments():\n\tparser = argparse.ArgumentParser(description=\"Runs a script after customizable initialization. By default, win_unicode_console is enabled.\")\n\tinit_group = parser.add_mutually_exclusive_group()\n\tinit_group.add_argument(",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "run_arguments",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "def run_arguments():\n\tparser = argparse.ArgumentParser(description=\"Runs a script after customizable initialization. By default, win_unicode_console is enabled.\")\n\tinit_group = parser.add_mutually_exclusive_group()\n\tinit_group.add_argument(\n\t\t\"-e\", \"--init-enable\", dest=\"init\", action=\"store_const\", const=\"enable\", \n\t\thelp=\"enable win_unicode_console on init (default)\")\n\tinit_group.add_argument(\n\t\t\"-d\", \"--init-disable\", dest=\"init\", action=\"store_const\", const=\"disable\", \n\t\thelp=\"disable win_unicode_console on init\")\n\tinit_group.add_argument(",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "inspect_flag",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "inspect_flag = cast(pythonapi.Py_InspectFlag, POINTER(c_long)).contents\ndef set_inspect_flag(value):\n\tinspect_flag.value = int(value)\nCODE_FIELDS = [\"argcount\", \"kwonlyargcount\", \"nlocals\", \"stacksize\", \n\t\t\"flags\", \"code\", \"consts\", \"names\", \"varnames\", \"filename\", \n\t\t\"name\", \t\"firstlineno\", \"lnotab\", \"freevars\", \"cellvars\"]\nif PY2:\n\tCODE_FIELDS.remove(\"kwonlyargcount\")\ndef update_code(codeobj, **kwargs):\n\tdef field_values():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tinspect_flag.value",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tinspect_flag.value = int(value)\nCODE_FIELDS = [\"argcount\", \"kwonlyargcount\", \"nlocals\", \"stacksize\", \n\t\t\"flags\", \"code\", \"consts\", \"names\", \"varnames\", \"filename\", \n\t\t\"name\", \t\"firstlineno\", \"lnotab\", \"freevars\", \"cellvars\"]\nif PY2:\n\tCODE_FIELDS.remove(\"kwonlyargcount\")\ndef update_code(codeobj, **kwargs):\n\tdef field_values():\n\t\tfor field in CODE_FIELDS:\n\t\t\toriginal_value = getattr(codeobj, \"co_{}\".format(field))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "CODE_FIELDS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "CODE_FIELDS = [\"argcount\", \"kwonlyargcount\", \"nlocals\", \"stacksize\", \n\t\t\"flags\", \"code\", \"consts\", \"names\", \"varnames\", \"filename\", \n\t\t\"name\", \t\"firstlineno\", \"lnotab\", \"freevars\", \"cellvars\"]\nif PY2:\n\tCODE_FIELDS.remove(\"kwonlyargcount\")\ndef update_code(codeobj, **kwargs):\n\tdef field_values():\n\t\tfor field in CODE_FIELDS:\n\t\t\toriginal_value = getattr(codeobj, \"co_{}\".format(field))\n\t\t\tvalue = kwargs.get(field, original_value)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\toriginal_value",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\toriginal_value = getattr(codeobj, \"co_{}\".format(field))\n\t\t\tvalue = kwargs.get(field, original_value)\n\t\t\tyield value\n\treturn Code(*field_values())\ndef update_code_recursively(codeobj, **kwargs):\n\tupdated = {}\n\tdef update(codeobj, **kwargs):\n\t\tresult = updated.get(codeobj, None)\n\t\tif result is not None:\n\t\t\treturn result",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\tvalue",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\tvalue = kwargs.get(field, original_value)\n\t\t\tyield value\n\treturn Code(*field_values())\ndef update_code_recursively(codeobj, **kwargs):\n\tupdated = {}\n\tdef update(codeobj, **kwargs):\n\t\tresult = updated.get(codeobj, None)\n\t\tif result is not None:\n\t\t\treturn result\n\t\tif any(isinstance(c, Code) for c in codeobj.co_consts):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tupdated",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tupdated = {}\n\tdef update(codeobj, **kwargs):\n\t\tresult = updated.get(codeobj, None)\n\t\tif result is not None:\n\t\t\treturn result\n\t\tif any(isinstance(c, Code) for c in codeobj.co_consts):\n\t\t\tconsts = tuple(update(c, **kwargs) if isinstance(c, Code) else c\n\t\t\t\tfor c in codeobj.co_consts)\n\t\telse:\n\t\t\tconsts = codeobj.co_consts",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tresult = updated.get(codeobj, None)\n\t\tif result is not None:\n\t\t\treturn result\n\t\tif any(isinstance(c, Code) for c in codeobj.co_consts):\n\t\t\tconsts = tuple(update(c, **kwargs) if isinstance(c, Code) else c\n\t\t\t\tfor c in codeobj.co_consts)\n\t\telse:\n\t\t\tconsts = codeobj.co_consts\n\t\tresult = update_code(codeobj, consts=consts, **kwargs)\n\t\tupdated[codeobj] = result",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\tconsts",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\tconsts = tuple(update(c, **kwargs) if isinstance(c, Code) else c\n\t\t\t\tfor c in codeobj.co_consts)\n\t\telse:\n\t\t\tconsts = codeobj.co_consts\n\t\tresult = update_code(codeobj, consts=consts, **kwargs)\n\t\tupdated[codeobj] = result\n\t\treturn result\n\treturn update(codeobj, **kwargs)\ndef get_code(path):\n\tif PY2:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\tconsts",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\tconsts = codeobj.co_consts\n\t\tresult = update_code(codeobj, consts=consts, **kwargs)\n\t\tupdated[codeobj] = result\n\t\treturn result\n\treturn update(codeobj, **kwargs)\ndef get_code(path):\n\tif PY2:\n\t\tfrom .tokenize_open import read_source_lines\n\t\tsource = u\"\".join(read_source_lines(path))\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tresult = update_code(codeobj, consts=consts, **kwargs)\n\t\tupdated[codeobj] = result\n\t\treturn result\n\treturn update(codeobj, **kwargs)\ndef get_code(path):\n\tif PY2:\n\t\tfrom .tokenize_open import read_source_lines\n\t\tsource = u\"\".join(read_source_lines(path))\n\telse:\n\t\twith tokenize.open(path) as f: # opens with detected source encoding",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tupdated[codeobj]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tupdated[codeobj] = result\n\t\treturn result\n\treturn update(codeobj, **kwargs)\ndef get_code(path):\n\tif PY2:\n\t\tfrom .tokenize_open import read_source_lines\n\t\tsource = u\"\".join(read_source_lines(path))\n\telse:\n\t\twith tokenize.open(path) as f: # opens with detected source encoding\n\t\t\tsource = f.read()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tsource",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tsource = u\"\".join(read_source_lines(path))\n\telse:\n\t\twith tokenize.open(path) as f: # opens with detected source encoding\n\t\t\tsource = f.read()\n\ttry:\n\t\tcode = compile(source, path, \"exec\", dont_inherit=True)\n\texcept UnicodeEncodeError:\n\t\tcode = compile(source, \"<encoding error>\", \"exec\", dont_inherit=True)\n\t\tif PY2:\n\t\t\tpath = path.encode(\"utf-8\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\tsource",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\tsource = f.read()\n\ttry:\n\t\tcode = compile(source, path, \"exec\", dont_inherit=True)\n\texcept UnicodeEncodeError:\n\t\tcode = compile(source, \"<encoding error>\", \"exec\", dont_inherit=True)\n\t\tif PY2:\n\t\t\tpath = path.encode(\"utf-8\")\n\t\tcode = update_code_recursively(code, filename=path)\n\t\t\t# so code constains correct filename (even if it contains Unicode)\n\t\t\t# and tracebacks show contents of code lines",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tcode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tcode = compile(source, path, \"exec\", dont_inherit=True)\n\texcept UnicodeEncodeError:\n\t\tcode = compile(source, \"<encoding error>\", \"exec\", dont_inherit=True)\n\t\tif PY2:\n\t\t\tpath = path.encode(\"utf-8\")\n\t\tcode = update_code_recursively(code, filename=path)\n\t\t\t# so code constains correct filename (even if it contains Unicode)\n\t\t\t# and tracebacks show contents of code lines\n\treturn code\ndef print_exception_without_first_line(etype, value, tb, limit=None, file=None, chain=True):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tcode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tcode = compile(source, \"<encoding error>\", \"exec\", dont_inherit=True)\n\t\tif PY2:\n\t\t\tpath = path.encode(\"utf-8\")\n\t\tcode = update_code_recursively(code, filename=path)\n\t\t\t# so code constains correct filename (even if it contains Unicode)\n\t\t\t# and tracebacks show contents of code lines\n\treturn code\ndef print_exception_without_first_line(etype, value, tb, limit=None, file=None, chain=True):\n\tif file is None:\n\t\tfile = sys.stderr",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\tpath",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\tpath = path.encode(\"utf-8\")\n\t\tcode = update_code_recursively(code, filename=path)\n\t\t\t# so code constains correct filename (even if it contains Unicode)\n\t\t\t# and tracebacks show contents of code lines\n\treturn code\ndef print_exception_without_first_line(etype, value, tb, limit=None, file=None, chain=True):\n\tif file is None:\n\t\tfile = sys.stderr\n\tlines = iter(traceback.TracebackException(\n\t\ttype(value), value, tb, limit=limit).format(chain=chain))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tcode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tcode = update_code_recursively(code, filename=path)\n\t\t\t# so code constains correct filename (even if it contains Unicode)\n\t\t\t# and tracebacks show contents of code lines\n\treturn code\ndef print_exception_without_first_line(etype, value, tb, limit=None, file=None, chain=True):\n\tif file is None:\n\t\tfile = sys.stderr\n\tlines = iter(traceback.TracebackException(\n\t\ttype(value), value, tb, limit=limit).format(chain=chain))\n\tnext(lines)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tfile",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tfile = sys.stderr\n\tlines = iter(traceback.TracebackException(\n\t\ttype(value), value, tb, limit=limit).format(chain=chain))\n\tnext(lines)\n\tfor line in lines:\n\t\tprint(line, file=file, end=\"\")\ndef run_script(args):\n\tsys.argv = [args.script] + args.script_arguments\n\tpath = args.script\n\t__main__.__file__ = path",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tlines",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tlines = iter(traceback.TracebackException(\n\t\ttype(value), value, tb, limit=limit).format(chain=chain))\n\tnext(lines)\n\tfor line in lines:\n\t\tprint(line, file=file, end=\"\")\ndef run_script(args):\n\tsys.argv = [args.script] + args.script_arguments\n\tpath = args.script\n\t__main__.__file__ = path\n\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tsys.argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tsys.argv = [args.script] + args.script_arguments\n\tpath = args.script\n\t__main__.__file__ = path\n\ttry:\n\t\tcode = get_code(path)\n\texcept Exception as e:\n\t\ttraceback.print_exception(e.__class__, e, None, file=sys.stderr)\n\telse:\n\t\ttry:\n\t\t\texec(code, __main__.__dict__)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tpath = args.script\n\t__main__.__file__ = path\n\ttry:\n\t\tcode = get_code(path)\n\texcept Exception as e:\n\t\ttraceback.print_exception(e.__class__, e, None, file=sys.stderr)\n\telse:\n\t\ttry:\n\t\t\texec(code, __main__.__dict__)\n\t\texcept BaseException as e:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t__main__.__file__",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t__main__.__file__ = path\n\ttry:\n\t\tcode = get_code(path)\n\texcept Exception as e:\n\t\ttraceback.print_exception(e.__class__, e, None, file=sys.stderr)\n\telse:\n\t\ttry:\n\t\t\texec(code, __main__.__dict__)\n\t\texcept BaseException as e:\n\t\t\tif not sys.flags.inspect and isinstance(e, SystemExit):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\tcode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\tcode = get_code(path)\n\texcept Exception as e:\n\t\ttraceback.print_exception(e.__class__, e, None, file=sys.stderr)\n\telse:\n\t\ttry:\n\t\t\texec(code, __main__.__dict__)\n\t\texcept BaseException as e:\n\t\t\tif not sys.flags.inspect and isinstance(e, SystemExit):\n\t\t\t\traise\n\t\t\telif PY2: # Python 2 produces tracebacks in mixed encoding (!)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\t\t\tline = line.decode(\"utf-8\", \"replace\")\n\t\t\t\t\ttry:\n\t\t\t\t\t\tsys.stderr.write(line)\n\t\t\t\t\texcept UnicodeEncodeError:\n\t\t\t\t\t\tline = line.encode(sys.stderr.encoding, \"backslashreplace\")\n\t\t\t\t\t\tsys.stderr.write(line)\n\t\t\t\t\tsys.stderr.flush() # is this needed?\n\t\t\telse: # PY3\n\t\t\t\ttraceback.print_exception(e.__class__, e, e.__traceback__.tb_next, file=sys.stderr)\ndef run_init(args):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tline",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\t\t\t\t\tline = line.encode(sys.stderr.encoding, \"backslashreplace\")\n\t\t\t\t\t\tsys.stderr.write(line)\n\t\t\t\t\tsys.stderr.flush() # is this needed?\n\t\t\telse: # PY3\n\t\t\t\ttraceback.print_exception(e.__class__, e, e.__traceback__.tb_next, file=sys.stderr)\ndef run_init(args):\n\tif args.init == \"enable\":\n\t\tenable()\n\telif args.init == \"disable\":\n\t\tdisable()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tparser",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tparser = argparse.ArgumentParser(description=\"Runs a script after customizable initialization. By default, win_unicode_console is enabled.\")\n\tinit_group = parser.add_mutually_exclusive_group()\n\tinit_group.add_argument(\n\t\t\"-e\", \"--init-enable\", dest=\"init\", action=\"store_const\", const=\"enable\", \n\t\thelp=\"enable win_unicode_console on init (default)\")\n\tinit_group.add_argument(\n\t\t\"-d\", \"--init-disable\", dest=\"init\", action=\"store_const\", const=\"disable\", \n\t\thelp=\"disable win_unicode_console on init\")\n\tinit_group.add_argument(\n\t\t\"-m\", \"--init-module\", dest=\"module\", ",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\tinit_group",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\tinit_group = parser.add_mutually_exclusive_group()\n\tinit_group.add_argument(\n\t\t\"-e\", \"--init-enable\", dest=\"init\", action=\"store_const\", const=\"enable\", \n\t\thelp=\"enable win_unicode_console on init (default)\")\n\tinit_group.add_argument(\n\t\t\"-d\", \"--init-disable\", dest=\"init\", action=\"store_const\", const=\"disable\", \n\t\thelp=\"disable win_unicode_console on init\")\n\tinit_group.add_argument(\n\t\t\"-m\", \"--init-module\", dest=\"module\", \n\t\thelp=\"import the given module on init\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\trepl_group",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\trepl_group = parser.add_mutually_exclusive_group()\n\trepl_group.add_argument(\n\t\t\"-s\", \"--standard-repl\", dest=\"use_repl\", action=\"store_false\", \n\t\thelp=\"use the standard Python REPL (default)\")\n\trepl_group.add_argument(\n\t\t\"-c\", \"--custom-repl\", dest=\"use_repl\", action=\"store_true\", \n\t\thelp=\"use win_unicode_console.console REPL\")\n\tparser.set_defaults(use_repl=False)\n\tparser.add_argument(\"script\", nargs=\"?\")\n\tparser.add_argument(\"script_arguments\", nargs=argparse.REMAINDER, metavar=\"script-arguments\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\targs",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\targs = parser.parse_args(sys.argv[1:])\n\texcept SystemExit:\n\t\tset_inspect_flag(0)\t# don't go interactive after printing help\n\t\traise\n\tif args.module:\n\t\targs.init = \"module\"\n\tif args.use_repl:\n\t\trun_with_custom_repl(args)\n\telse:\n\t\trun_with_standard_repl(args)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "\t\targs.init",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "peekOfCode": "\t\targs.init = \"module\"\n\tif args.use_repl:\n\t\trun_with_custom_repl(args)\n\telse:\n\t\trun_with_standard_repl(args)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.runner",
        "documentation": {}
    },
    {
        "label": "StandardStreamInfo",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property\n\tdef stream(self):\n\t\treturn getattr(sys, self.name)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "_ReprMixin",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class _ReprMixin:\n\tdef __repr__(self):\n\t\tmodname = self.__class__.__module__\n\t\tif PY2:\n\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:\n\t\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleRawIOBase",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class WindowsConsoleRawIOBase(_ReprMixin, io.RawIOBase):\n\tdef __init__(self, name, handle, fileno):\n\t\tself.name = name\n\t\tself.handle = handle\n\t\tself.file_no = fileno\n\tdef fileno(self):\n\t\treturn self.file_no\n\tdef isatty(self):\n\t\t# PY3 # super().isatty()\t# for close check in default implementation\n\t\tsuper(WindowsConsoleRawIOBase, self).isatty()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleRawReader",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class WindowsConsoleRawReader(WindowsConsoleRawIOBase):\n\tdef readable(self):\n\t\treturn True\n\tdef readinto(self, b):\n\t\tbytes_to_be_read = len(b)\n\t\tif not bytes_to_be_read:\n\t\t\treturn 0\n\t\telif bytes_to_be_read % 2:\n\t\t\traise ValueError(\"cannot read odd number of bytes from UTF-16-LE encoded console\")\n\t\tbuffer = get_buffer(b, writable=True)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "WindowsConsoleRawWriter",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class WindowsConsoleRawWriter(WindowsConsoleRawIOBase):\n\tdef writable(self):\n\t\treturn True\n\tdef write(self, b):\n\t\tbytes_to_be_written = len(b)\n\t\tbuffer = get_buffer(b)\n\t\tcode_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n\t\tcode_units_written = c_ulong()\n\t\tif code_units_to_be_written == 0 != bytes_to_be_written:\n\t\t\traise ValueError(\"two-byte code units expected, just one byte given\")",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "_TextStreamWrapperMixin",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class _TextStreamWrapperMixin(_ReprMixin):\n\tdef __init__(self, base):\n\t\tself.base = base\n\t@property\n\tdef encoding(self):\n\t\treturn self.base.encoding\n\t@property\n\tdef errors(self):\n\t\treturn self.base.errors\n\t@property",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "TextStreamWrapper",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class TextStreamWrapper(_TextStreamWrapperMixin, io.TextIOBase):\n\tpass\nclass TextTranscodingWrapper(TextStreamWrapper):\n\tencoding = None # disable the descriptor\n\tdef __init__(self, base, encoding):\n\t\t# PY3 # super().__init__(base)\n\t\tsuper(TextTranscodingWrapper, self).__init__(base)\n\t\tself.encoding = encoding\nclass StrStreamWrapper(TextStreamWrapper):\n\tdef write(self, s):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "TextTranscodingWrapper",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class TextTranscodingWrapper(TextStreamWrapper):\n\tencoding = None # disable the descriptor\n\tdef __init__(self, base, encoding):\n\t\t# PY3 # super().__init__(base)\n\t\tsuper(TextTranscodingWrapper, self).__init__(base)\n\t\tself.encoding = encoding\nclass StrStreamWrapper(TextStreamWrapper):\n\tdef write(self, s):\n\t\tif isinstance(s, bytes):\n\t\t\ts = s.decode(self.encoding)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "StrStreamWrapper",
        "kind": 6,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "class StrStreamWrapper(TextStreamWrapper):\n\tdef write(self, s):\n\t\tif isinstance(s, bytes):\n\t\t\ts = s.decode(self.encoding)\n\t\tself.base.write(s)\nif PY2:\n\tclass FileobjWrapper(_TextStreamWrapperMixin, file):\n\t\tdef __init__(self, base, f):\n\t\t\tsuper(FileobjWrapper, self).__init__(base)\n\t\t\tfileobj = self._fileobj = FileObject.from_file(self)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "disable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "def disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()\n\tsys.stdin = sys.__stdin__\n\tsys.stdout = sys.__stdout__\n\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\ndef enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\n\tif not WINDOWS:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "def enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\n\tif not WINDOWS:\n\t\treturn\n\t# defaults\n\tif PY2:\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_fileobj\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_str\n\t\tif stderr is Ellipsis:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "enable_only",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "def enable_only(stdin=None, stdout=None, stderr=None):\n\tenable(stdin=stdin, stdout=stdout, stderr=stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tkernel32",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tkernel32 = WinDLL(\"kernel32\", use_last_error=True)\n\tReadConsoleW = kernel32.ReadConsoleW\n\tWriteConsoleW = kernel32.WriteConsoleW\n\tGetConsoleMode = kernel32.GetConsoleMode\nERROR_SUCCESS = 0\nERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tReadConsoleW",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tReadConsoleW = kernel32.ReadConsoleW\n\tWriteConsoleW = kernel32.WriteConsoleW\n\tGetConsoleMode = kernel32.GetConsoleMode\nERROR_SUCCESS = 0\nERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tWriteConsoleW",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tWriteConsoleW = kernel32.WriteConsoleW\n\tGetConsoleMode = kernel32.GetConsoleMode\nERROR_SUCCESS = 0\nERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tGetConsoleMode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tGetConsoleMode = kernel32.GetConsoleMode\nERROR_SUCCESS = 0\nERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "ERROR_SUCCESS",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "ERROR_SUCCESS = 0\nERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "ERROR_INVALID_HANDLE",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "ERROR_INVALID_HANDLE = 6\nERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "ERROR_NOT_ENOUGH_MEMORY",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "ERROR_NOT_ENOUGH_MEMORY = 8\nERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "ERROR_OPERATION_ABORTED",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "ERROR_OPERATION_ABORTED = 995\nEOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "EOF",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "EOF = b\"\\x1a\"\nMAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "MAX_BYTES_WRITTEN",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "MAX_BYTES_WRITTEN = 32767\t# arbitrary because WriteConsoleW ability to write big buffers depends on heap usage\nclass StandardStreamInfo:\n\tdef __init__(self, name, standard_fileno):\n\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property\n\tdef stream(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.name",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.name = name\n\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property\n\tdef stream(self):\n\t\treturn getattr(sys, self.name)\n\tdef is_a_TTY(self):\n\t\t# the test used in input()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.fileno",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.fileno = standard_fileno\n\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property\n\tdef stream(self):\n\t\treturn getattr(sys, self.name)\n\tdef is_a_TTY(self):\n\t\t# the test used in input()\n\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.handle",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.handle = get_osfhandle(standard_fileno) if WINDOWS else None\n\tdef __repr__(self):\n\t\treturn \"<{} '{}' fileno={} handle={}>\".format(self.__class__.__name__, self.name, self.fileno, self.handle)\n\t@property\n\tdef stream(self):\n\t\treturn getattr(sys, self.name)\n\tdef is_a_TTY(self):\n\t\t# the test used in input()\n\t\ttry:\n\t\t\tget_fileno = self.stream.fileno",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tget_fileno",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tget_fileno = self.stream.fileno\n\t\texcept AttributeError: # e.g. StringIO in Python 2\n\t\t\treturn False\n\t\ttry:\n\t\t\tfileno = get_fileno()\n\t\texcept io.UnsupportedOperation:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn fileno == self.fileno and self.stream.isatty()\n\tdef is_a_console(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tfileno",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tfileno = get_fileno()\n\t\texcept io.UnsupportedOperation:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn fileno == self.fileno and self.stream.isatty()\n\tdef is_a_console(self):\n\t\tif self.handle is None:\n\t\t\treturn False\n\t\tif GetConsoleMode(self.handle, byref(c_ulong())):\n\t\t\treturn True",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tlast_error",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tlast_error = get_last_error()\n\t\t\tif last_error == ERROR_INVALID_HANDLE:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\traise WinError(last_error)\n\tdef should_be_fixed(self):\n\t\tif self.stream is None:\t# e.g. with IDLE\n\t\t\treturn True\n\t\treturn self.is_a_TTY() and self.is_a_console()\nSTDIN = StandardStreamInfo(\"stdin\", standard_fileno=0)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "STDIN",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "STDIN = StandardStreamInfo(\"stdin\", standard_fileno=0)\nSTDOUT = StandardStreamInfo(\"stdout\", standard_fileno=1)\nSTDERR = StandardStreamInfo(\"stderr\", standard_fileno=2)\nclass _ReprMixin:\n\tdef __repr__(self):\n\t\tmodname = self.__class__.__module__\n\t\tif PY2:\n\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "STDOUT = StandardStreamInfo(\"stdout\", standard_fileno=1)\nSTDERR = StandardStreamInfo(\"stderr\", standard_fileno=2)\nclass _ReprMixin:\n\tdef __repr__(self):\n\t\tmodname = self.__class__.__module__\n\t\tif PY2:\n\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "STDERR",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "STDERR = StandardStreamInfo(\"stderr\", standard_fileno=2)\nclass _ReprMixin:\n\tdef __repr__(self):\n\t\tmodname = self.__class__.__module__\n\t\tif PY2:\n\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tmodname",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tmodname = self.__class__.__module__\n\t\tif PY2:\n\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:\n\t\t\ttry:\n\t\t\t\tvalue = getattr(self, name)\n\t\t\texcept AttributeError:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tclsname",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tclsname = self.__class__.__name__\n\t\telse:\n\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:\n\t\t\ttry:\n\t\t\t\tvalue = getattr(self, name)\n\t\t\texcept AttributeError:\n\t\t\t\tpass\n\t\t\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tclsname",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tclsname = self.__class__.__qualname__\n\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:\n\t\t\ttry:\n\t\t\t\tvalue = getattr(self, name)\n\t\t\texcept AttributeError:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tattributes.append(\"{}={}\".format(name, repr(value)))\n\t\treturn \"<{}.{} {}>\".format(modname, clsname, \" \".join(attributes))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tattributes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tattributes = []\n\t\tfor name in [\"name\", \"encoding\"]:\n\t\t\ttry:\n\t\t\t\tvalue = getattr(self, name)\n\t\t\texcept AttributeError:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tattributes.append(\"{}={}\".format(name, repr(value)))\n\t\treturn \"<{}.{} {}>\".format(modname, clsname, \" \".join(attributes))\nclass WindowsConsoleRawIOBase(_ReprMixin, io.RawIOBase):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tvalue",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\t\tvalue = getattr(self, name)\n\t\t\texcept AttributeError:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tattributes.append(\"{}={}\".format(name, repr(value)))\n\t\treturn \"<{}.{} {}>\".format(modname, clsname, \" \".join(attributes))\nclass WindowsConsoleRawIOBase(_ReprMixin, io.RawIOBase):\n\tdef __init__(self, name, handle, fileno):\n\t\tself.name = name\n\t\tself.handle = handle",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.name",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.name = name\n\t\tself.handle = handle\n\t\tself.file_no = fileno\n\tdef fileno(self):\n\t\treturn self.file_no\n\tdef isatty(self):\n\t\t# PY3 # super().isatty()\t# for close check in default implementation\n\t\tsuper(WindowsConsoleRawIOBase, self).isatty()\n\t\treturn True\nclass WindowsConsoleRawReader(WindowsConsoleRawIOBase):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.handle",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.handle = handle\n\t\tself.file_no = fileno\n\tdef fileno(self):\n\t\treturn self.file_no\n\tdef isatty(self):\n\t\t# PY3 # super().isatty()\t# for close check in default implementation\n\t\tsuper(WindowsConsoleRawIOBase, self).isatty()\n\t\treturn True\nclass WindowsConsoleRawReader(WindowsConsoleRawIOBase):\n\tdef readable(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.file_no",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.file_no = fileno\n\tdef fileno(self):\n\t\treturn self.file_no\n\tdef isatty(self):\n\t\t# PY3 # super().isatty()\t# for close check in default implementation\n\t\tsuper(WindowsConsoleRawIOBase, self).isatty()\n\t\treturn True\nclass WindowsConsoleRawReader(WindowsConsoleRawIOBase):\n\tdef readable(self):\n\t\treturn True",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tbytes_to_be_read",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tbytes_to_be_read = len(b)\n\t\tif not bytes_to_be_read:\n\t\t\treturn 0\n\t\telif bytes_to_be_read % 2:\n\t\t\traise ValueError(\"cannot read odd number of bytes from UTF-16-LE encoded console\")\n\t\tbuffer = get_buffer(b, writable=True)\n\t\tcode_units_to_be_read = bytes_to_be_read // 2\n\t\tcode_units_read = c_ulong()\n\t\tset_last_error(ERROR_SUCCESS)\n\t\tReadConsoleW(self.handle, buffer, code_units_to_be_read, byref(code_units_read), None)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tbuffer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tbuffer = get_buffer(b, writable=True)\n\t\tcode_units_to_be_read = bytes_to_be_read // 2\n\t\tcode_units_read = c_ulong()\n\t\tset_last_error(ERROR_SUCCESS)\n\t\tReadConsoleW(self.handle, buffer, code_units_to_be_read, byref(code_units_read), None)\n\t\tlast_error = get_last_error()\n\t\tif last_error == ERROR_OPERATION_ABORTED:\n\t\t\ttime.sleep(0.1)\t# wait for KeyboardInterrupt\n\t\tif last_error != ERROR_SUCCESS:\n\t\t\traise WinError(last_error)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tcode_units_to_be_read",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tcode_units_to_be_read = bytes_to_be_read // 2\n\t\tcode_units_read = c_ulong()\n\t\tset_last_error(ERROR_SUCCESS)\n\t\tReadConsoleW(self.handle, buffer, code_units_to_be_read, byref(code_units_read), None)\n\t\tlast_error = get_last_error()\n\t\tif last_error == ERROR_OPERATION_ABORTED:\n\t\t\ttime.sleep(0.1)\t# wait for KeyboardInterrupt\n\t\tif last_error != ERROR_SUCCESS:\n\t\t\traise WinError(last_error)\n\t\tif buffer[0] == EOF:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tcode_units_read",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tcode_units_read = c_ulong()\n\t\tset_last_error(ERROR_SUCCESS)\n\t\tReadConsoleW(self.handle, buffer, code_units_to_be_read, byref(code_units_read), None)\n\t\tlast_error = get_last_error()\n\t\tif last_error == ERROR_OPERATION_ABORTED:\n\t\t\ttime.sleep(0.1)\t# wait for KeyboardInterrupt\n\t\tif last_error != ERROR_SUCCESS:\n\t\t\traise WinError(last_error)\n\t\tif buffer[0] == EOF:\n\t\t\treturn 0",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tlast_error",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tlast_error = get_last_error()\n\t\tif last_error == ERROR_OPERATION_ABORTED:\n\t\t\ttime.sleep(0.1)\t# wait for KeyboardInterrupt\n\t\tif last_error != ERROR_SUCCESS:\n\t\t\traise WinError(last_error)\n\t\tif buffer[0] == EOF:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 2 * code_units_read.value # bytes read\nclass WindowsConsoleRawWriter(WindowsConsoleRawIOBase):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tbytes_to_be_written",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tbytes_to_be_written = len(b)\n\t\tbuffer = get_buffer(b)\n\t\tcode_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n\t\tcode_units_written = c_ulong()\n\t\tif code_units_to_be_written == 0 != bytes_to_be_written:\n\t\t\traise ValueError(\"two-byte code units expected, just one byte given\")\n\t\tif not WriteConsoleW(self.handle, buffer, code_units_to_be_written, byref(code_units_written), None):\n\t\t\texc = WinError(get_last_error())\n\t\t\tif exc.winerror == ERROR_NOT_ENOUGH_MEMORY:\n\t\t\t\texc.strerror += \" Try to lower `win_unicode_console.streams.MAX_BYTES_WRITTEN`.\"",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tbuffer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tbuffer = get_buffer(b)\n\t\tcode_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n\t\tcode_units_written = c_ulong()\n\t\tif code_units_to_be_written == 0 != bytes_to_be_written:\n\t\t\traise ValueError(\"two-byte code units expected, just one byte given\")\n\t\tif not WriteConsoleW(self.handle, buffer, code_units_to_be_written, byref(code_units_written), None):\n\t\t\texc = WinError(get_last_error())\n\t\t\tif exc.winerror == ERROR_NOT_ENOUGH_MEMORY:\n\t\t\t\texc.strerror += \" Try to lower `win_unicode_console.streams.MAX_BYTES_WRITTEN`.\"\n\t\t\traise exc",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tcode_units_to_be_written",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tcode_units_to_be_written = min(bytes_to_be_written, MAX_BYTES_WRITTEN) // 2\n\t\tcode_units_written = c_ulong()\n\t\tif code_units_to_be_written == 0 != bytes_to_be_written:\n\t\t\traise ValueError(\"two-byte code units expected, just one byte given\")\n\t\tif not WriteConsoleW(self.handle, buffer, code_units_to_be_written, byref(code_units_written), None):\n\t\t\texc = WinError(get_last_error())\n\t\t\tif exc.winerror == ERROR_NOT_ENOUGH_MEMORY:\n\t\t\t\texc.strerror += \" Try to lower `win_unicode_console.streams.MAX_BYTES_WRITTEN`.\"\n\t\t\traise exc\n\t\treturn 2 * code_units_written.value # bytes written",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tcode_units_written",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tcode_units_written = c_ulong()\n\t\tif code_units_to_be_written == 0 != bytes_to_be_written:\n\t\t\traise ValueError(\"two-byte code units expected, just one byte given\")\n\t\tif not WriteConsoleW(self.handle, buffer, code_units_to_be_written, byref(code_units_written), None):\n\t\t\texc = WinError(get_last_error())\n\t\t\tif exc.winerror == ERROR_NOT_ENOUGH_MEMORY:\n\t\t\t\texc.strerror += \" Try to lower `win_unicode_console.streams.MAX_BYTES_WRITTEN`.\"\n\t\t\traise exc\n\t\treturn 2 * code_units_written.value # bytes written\nclass _TextStreamWrapperMixin(_ReprMixin):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\texc",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\texc = WinError(get_last_error())\n\t\t\tif exc.winerror == ERROR_NOT_ENOUGH_MEMORY:\n\t\t\t\texc.strerror += \" Try to lower `win_unicode_console.streams.MAX_BYTES_WRITTEN`.\"\n\t\t\traise exc\n\t\treturn 2 * code_units_written.value # bytes written\nclass _TextStreamWrapperMixin(_ReprMixin):\n\tdef __init__(self, base):\n\t\tself.base = base\n\t@property\n\tdef encoding(self):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.base",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.base = base\n\t@property\n\tdef encoding(self):\n\t\treturn self.base.encoding\n\t@property\n\tdef errors(self):\n\t\treturn self.base.errors\n\t@property\n\tdef line_buffering(self):\n\t\treturn self.base.line_buffering",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tencoding = None # disable the descriptor\n\tdef __init__(self, base, encoding):\n\t\t# PY3 # super().__init__(base)\n\t\tsuper(TextTranscodingWrapper, self).__init__(base)\n\t\tself.encoding = encoding\nclass StrStreamWrapper(TextStreamWrapper):\n\tdef write(self, s):\n\t\tif isinstance(s, bytes):\n\t\t\ts = s.decode(self.encoding)\n\t\tself.base.write(s)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tself.encoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tself.encoding = encoding\nclass StrStreamWrapper(TextStreamWrapper):\n\tdef write(self, s):\n\t\tif isinstance(s, bytes):\n\t\t\ts = s.decode(self.encoding)\n\t\tself.base.write(s)\nif PY2:\n\tclass FileobjWrapper(_TextStreamWrapperMixin, file):\n\t\tdef __init__(self, base, f):\n\t\t\tsuper(FileobjWrapper, self).__init__(base)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\ts",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\ts = s.decode(self.encoding)\n\t\tself.base.write(s)\nif PY2:\n\tclass FileobjWrapper(_TextStreamWrapperMixin, file):\n\t\tdef __init__(self, base, f):\n\t\t\tsuper(FileobjWrapper, self).__init__(base)\n\t\t\tfileobj = self._fileobj = FileObject.from_file(self)\n\t\t\tfileobj.set_encoding(base.encoding)\n\t\t\tfileobj.copy_file_pointer(f)\n\t\t\tfileobj.readable = base.readable()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tfileobj",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tfileobj = self._fileobj = FileObject.from_file(self)\n\t\t\tfileobj.set_encoding(base.encoding)\n\t\t\tfileobj.copy_file_pointer(f)\n\t\t\tfileobj.readable = base.readable()\n\t\t\tfileobj.writable = base.writable()\n\t\t# needed for the right interpretation of unicode literals in interactive mode when win_unicode_console is enabled in sitecustomize since Py_Initialize changes encoding afterwards\n\t\tdef _reset_encoding(self):\n\t\t\tself._fileobj.set_encoding(self.base.encoding)\n\t\tdef readline(self, size=-1):\n\t\t\tself._reset_encoding()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tfileobj.readable",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tfileobj.readable = base.readable()\n\t\t\tfileobj.writable = base.writable()\n\t\t# needed for the right interpretation of unicode literals in interactive mode when win_unicode_console is enabled in sitecustomize since Py_Initialize changes encoding afterwards\n\t\tdef _reset_encoding(self):\n\t\t\tself._fileobj.set_encoding(self.base.encoding)\n\t\tdef readline(self, size=-1):\n\t\t\tself._reset_encoding()\n\t\t\treturn self.base.readline(size)\nif WINDOWS:\n\tstdin_raw = WindowsConsoleRawReader(\"<stdin>\", STDIN.handle, STDIN.fileno)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tfileobj.writable",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tfileobj.writable = base.writable()\n\t\t# needed for the right interpretation of unicode literals in interactive mode when win_unicode_console is enabled in sitecustomize since Py_Initialize changes encoding afterwards\n\t\tdef _reset_encoding(self):\n\t\t\tself._fileobj.set_encoding(self.base.encoding)\n\t\tdef readline(self, size=-1):\n\t\t\tself._reset_encoding()\n\t\t\treturn self.base.readline(size)\nif WINDOWS:\n\tstdin_raw = WindowsConsoleRawReader(\"<stdin>\", STDIN.handle, STDIN.fileno)\n\tstdout_raw = WindowsConsoleRawWriter(\"<stdout>\", STDOUT.handle, STDOUT.fileno)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdin_raw",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdin_raw = WindowsConsoleRawReader(\"<stdin>\", STDIN.handle, STDIN.fileno)\n\tstdout_raw = WindowsConsoleRawWriter(\"<stdout>\", STDOUT.handle, STDOUT.fileno)\n\tstderr_raw = WindowsConsoleRawWriter(\"<stderr>\", STDERR.handle, STDERR.fileno)\n\tstdin_text = io.TextIOWrapper(io.BufferedReader(stdin_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdout_text = io.TextIOWrapper(io.BufferedWriter(stdout_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdout_raw",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdout_raw = WindowsConsoleRawWriter(\"<stdout>\", STDOUT.handle, STDOUT.fileno)\n\tstderr_raw = WindowsConsoleRawWriter(\"<stderr>\", STDERR.handle, STDERR.fileno)\n\tstdin_text = io.TextIOWrapper(io.BufferedReader(stdin_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdout_text = io.TextIOWrapper(io.BufferedWriter(stdout_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstderr_raw",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstderr_raw = WindowsConsoleRawWriter(\"<stderr>\", STDERR.handle, STDERR.fileno)\n\tstdin_text = io.TextIOWrapper(io.BufferedReader(stdin_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdout_text = io.TextIOWrapper(io.BufferedWriter(stdout_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdin_text",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdin_text = io.TextIOWrapper(io.BufferedReader(stdin_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdout_text = io.TextIOWrapper(io.BufferedWriter(stdout_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdout_text",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdout_text = io.TextIOWrapper(io.BufferedWriter(stdout_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstderr_text",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstderr_text = io.TextIOWrapper(io.BufferedWriter(stderr_raw), encoding=\"utf-16-le\", line_buffering=True)\n\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdin_text_transcoded",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdin_text_transcoded = TextTranscodingWrapper(stdin_text, encoding=\"utf-8\")\n\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdout_text_transcoded",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdout_text_transcoded = TextTranscodingWrapper(stdout_text, encoding=\"utf-8\")\n\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstderr_text_transcoded",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstderr_text_transcoded = TextTranscodingWrapper(stderr_text, encoding=\"utf-8\")\n\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstdout_text_str",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstdout_text_str = StrStreamWrapper(stdout_text_transcoded)\n\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()\n\tsys.stdin = sys.__stdin__",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tstderr_text_str",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tstderr_text_str = StrStreamWrapper(stderr_text_transcoded)\n\tif PY2:\n\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()\n\tsys.stdin = sys.__stdin__\n\tsys.stdout = sys.__stdout__",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tstdin_text_fileobj",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tstdin_text_fileobj = FileobjWrapper(stdin_text_transcoded, sys.__stdin__)\n\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()\n\tsys.stdin = sys.__stdin__\n\tsys.stdout = sys.__stdout__\n\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tstdout_text_str_fileobj",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tstdout_text_str_fileobj = FileobjWrapper(stdout_text_str, sys.__stdout__)\ndef disable():\n\tsys.stdin.flush()\n\tsys.stdout.flush()\n\tsys.stderr.flush()\n\tsys.stdin = sys.__stdin__\n\tsys.stdout = sys.__stdout__\n\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\ndef enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tsys.stdin",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tsys.stdin = sys.__stdin__\n\tsys.stdout = sys.__stdout__\n\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\ndef enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\n\tif not WINDOWS:\n\t\treturn\n\t# defaults\n\tif PY2:\n\t\tif stdin is Ellipsis:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tsys.stdout",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tsys.stdout = sys.__stdout__\n\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\ndef enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\n\tif not WINDOWS:\n\t\treturn\n\t# defaults\n\tif PY2:\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_fileobj",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\tsys.stderr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\tsys.stderr = sys.__stderr__\n# PY3 # def enable(*, stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\ndef enable(stdin=Ellipsis, stdout=Ellipsis, stderr=Ellipsis):\n\tif not WINDOWS:\n\t\treturn\n\t# defaults\n\tif PY2:\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_fileobj\n\t\tif stdout is Ellipsis:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstdin",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstdin = stdin_text_fileobj\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_str\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_str\n\telse: # transcoding because Python tokenizer cannot handle UTF-16\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_transcoded\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_transcoded",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstdout",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstdout = stdout_text_str\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_str\n\telse: # transcoding because Python tokenizer cannot handle UTF-16\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_transcoded\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_transcoded\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_transcoded",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstderr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstderr = stderr_text_str\n\telse: # transcoding because Python tokenizer cannot handle UTF-16\n\t\tif stdin is Ellipsis:\n\t\t\tstdin = stdin_text_transcoded\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_transcoded\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_transcoded\n\tif stdin is not None and STDIN.should_be_fixed():\n\t\tsys.stdin = stdin",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstdin",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstdin = stdin_text_transcoded\n\t\tif stdout is Ellipsis:\n\t\t\tstdout = stdout_text_transcoded\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_transcoded\n\tif stdin is not None and STDIN.should_be_fixed():\n\t\tsys.stdin = stdin\n\tif stdout is not None and STDOUT.should_be_fixed():\n\t\tsys.stdout.flush()\n\t\tsys.stdout = stdout",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstdout",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstdout = stdout_text_transcoded\n\t\tif stderr is Ellipsis:\n\t\t\tstderr = stderr_text_transcoded\n\tif stdin is not None and STDIN.should_be_fixed():\n\t\tsys.stdin = stdin\n\tif stdout is not None and STDOUT.should_be_fixed():\n\t\tsys.stdout.flush()\n\t\tsys.stdout = stdout\n\tif stderr is not None and STDERR.should_be_fixed():\n\t\tsys.stderr.flush()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\t\tstderr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\t\tstderr = stderr_text_transcoded\n\tif stdin is not None and STDIN.should_be_fixed():\n\t\tsys.stdin = stdin\n\tif stdout is not None and STDOUT.should_be_fixed():\n\t\tsys.stdout.flush()\n\t\tsys.stdout = stdout\n\tif stderr is not None and STDERR.should_be_fixed():\n\t\tsys.stderr.flush()\n\t\tsys.stderr = stderr\n# PY3 # def enable_only(*, stdin=None, stdout=None, stderr=None):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tsys.stdin",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tsys.stdin = stdin\n\tif stdout is not None and STDOUT.should_be_fixed():\n\t\tsys.stdout.flush()\n\t\tsys.stdout = stdout\n\tif stderr is not None and STDERR.should_be_fixed():\n\t\tsys.stderr.flush()\n\t\tsys.stderr = stderr\n# PY3 # def enable_only(*, stdin=None, stdout=None, stderr=None):\ndef enable_only(stdin=None, stdout=None, stderr=None):\n\tenable(stdin=stdin, stdout=stdout, stderr=stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tsys.stdout",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tsys.stdout = stdout\n\tif stderr is not None and STDERR.should_be_fixed():\n\t\tsys.stderr.flush()\n\t\tsys.stderr = stderr\n# PY3 # def enable_only(*, stdin=None, stdout=None, stderr=None):\ndef enable_only(stdin=None, stdout=None, stderr=None):\n\tenable(stdin=stdin, stdout=stdout, stderr=stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "\t\tsys.stderr",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "peekOfCode": "\t\tsys.stderr = stderr\n# PY3 # def enable_only(*, stdin=None, stdout=None, stderr=None):\ndef enable_only(stdin=None, stdout=None, stderr=None):\n\tenable(stdin=stdin, stdout=stdout, stderr=stderr)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.streams",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "def detect_encoding(readline):\n\t\"\"\"\n\tThe detect_encoding() function is used to detect the encoding that should\n\tbe used to decode a Python source file.  It requires one argument, readline,\n\tin the same way as the tokenize() generator.\n\tIt will call readline a maximum of twice, and return the encoding used\n\t(as a string) and a list of any lines (left as bytes) it has read in.\n\tIt detects the encoding from the presence of a utf-8 bom or an encoding\n\tcookie as specified in pep-0263.  If both a bom and a cookie are present,\n\tbut disagree, a SyntaxError will be raised.  If the encoding cookie is an",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "detect_encoding_ex",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "def detect_encoding_ex(readline):\n\ttry:\n\t\tfilename = readline.__self__.name\n\texcept AttributeError:\n\t\tfilename = None\n\tbom_found = False\n\tencoding = None\n\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "def open(filename):\n\t\"\"\"Open a file in read only mode using the encoding detected by\n\tdetect_encoding().\n\t\"\"\"\n\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines = detect_encoding(buffer.readline)\n\t\tbuffer.seek(0)\n\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "read_source_lines",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "def read_source_lines(filename):\n\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines, cookie_present = detect_encoding_ex(buffer.readline)\n\t\tbuffer.seek(0)\n\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'\n\texcept:\n\t\tbuffer.close()\n\t\traise",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "re_ASCII",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "re_ASCII = 256 # not present in Python 2\ncookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re_ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re_ASCII)\ndef _get_normal_name(orig_enc):\n\t\"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n\t# Only care about the first 12 characters.\n\tenc = orig_enc[:12].lower().replace(\"_\", \"-\")\n\tif enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n\t\treturn \"utf-8\"\n\tif enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "cookie_re",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "cookie_re = re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)', re_ASCII)\nblank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re_ASCII)\ndef _get_normal_name(orig_enc):\n\t\"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n\t# Only care about the first 12 characters.\n\tenc = orig_enc[:12].lower().replace(\"_\", \"-\")\n\tif enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n\t\treturn \"utf-8\"\n\tif enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n\t\t\tenc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "blank_re",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "blank_re = re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)', re_ASCII)\ndef _get_normal_name(orig_enc):\n\t\"\"\"Imitates get_normal_name in tokenizer.c.\"\"\"\n\t# Only care about the first 12 characters.\n\tenc = orig_enc[:12].lower().replace(\"_\", \"-\")\n\tif enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n\t\treturn \"utf-8\"\n\tif enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n\t\t\tenc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n\t\treturn \"iso-8859-1\"",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tenc",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tenc = orig_enc[:12].lower().replace(\"_\", \"-\")\n\tif enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n\t\treturn \"utf-8\"\n\tif enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or \\\n\t\t\tenc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n\t\treturn \"iso-8859-1\"\n\treturn orig_enc\ndef detect_encoding(readline):\n\t\"\"\"\n\tThe detect_encoding() function is used to detect the encoding that should",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tfilename",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tfilename = readline.__self__.name\n\texcept AttributeError:\n\t\tfilename = None\n\tbom_found = False\n\tencoding = None\n\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:\n\t\t\treturn readline()\n\t\texcept StopIteration:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tfilename",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tfilename = None\n\tbom_found = False\n\tencoding = None\n\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:\n\t\t\treturn readline()\n\t\texcept StopIteration:\n\t\t\treturn b''\n\tdef find_cookie(line):",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tbom_found",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tbom_found = False\n\tencoding = None\n\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:\n\t\t\treturn readline()\n\t\texcept StopIteration:\n\t\t\treturn b''\n\tdef find_cookie(line):\n\t\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tencoding = None\n\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:\n\t\t\treturn readline()\n\t\texcept StopIteration:\n\t\t\treturn b''\n\tdef find_cookie(line):\n\t\ttry:\n\t\t\t# Decode as UTF-8. Either the line is an encoding declaration,",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tdefault",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tdefault = 'utf-8'\n\tdef read_or_stop():\n\t\ttry:\n\t\t\treturn readline()\n\t\texcept StopIteration:\n\t\t\treturn b''\n\tdef find_cookie(line):\n\t\ttry:\n\t\t\t# Decode as UTF-8. Either the line is an encoding declaration,\n\t\t\t# in which case it should be pure ASCII, or it must be UTF-8",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\tline_string",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\tline_string = line.decode('utf-8')\n\t\texcept UnicodeDecodeError:\n\t\t\tmsg = \"invalid or missing encoding declaration\"\n\t\t\tif filename is not None:\n\t\t\t\tmsg = '{} for {!r}'.format(msg, filename)\n\t\t\traise SyntaxError(msg)\n\t\tmatch = cookie_re.match(line_string)\n\t\tif not match:\n\t\t\treturn None\n\t\tencoding = _get_normal_name(match.group(1))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\tmsg = \"invalid or missing encoding declaration\"\n\t\t\tif filename is not None:\n\t\t\t\tmsg = '{} for {!r}'.format(msg, filename)\n\t\t\traise SyntaxError(msg)\n\t\tmatch = cookie_re.match(line_string)\n\t\tif not match:\n\t\t\treturn None\n\t\tencoding = _get_normal_name(match.group(1))\n\t\ttry:\n\t\t\tcodec = lookup(encoding)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\t\tmsg = '{} for {!r}'.format(msg, filename)\n\t\t\traise SyntaxError(msg)\n\t\tmatch = cookie_re.match(line_string)\n\t\tif not match:\n\t\t\treturn None\n\t\tencoding = _get_normal_name(match.group(1))\n\t\ttry:\n\t\t\tcodec = lookup(encoding)\n\t\texcept LookupError:\n\t\t\t# This behaviour mimics the Python interpreter",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tmatch",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tmatch = cookie_re.match(line_string)\n\t\tif not match:\n\t\t\treturn None\n\t\tencoding = _get_normal_name(match.group(1))\n\t\ttry:\n\t\t\tcodec = lookup(encoding)\n\t\texcept LookupError:\n\t\t\t# This behaviour mimics the Python interpreter\n\t\t\tif filename is None:\n\t\t\t\tmsg = \"unknown encoding: \" + encoding",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tencoding = _get_normal_name(match.group(1))\n\t\ttry:\n\t\t\tcodec = lookup(encoding)\n\t\texcept LookupError:\n\t\t\t# This behaviour mimics the Python interpreter\n\t\t\tif filename is None:\n\t\t\t\tmsg = \"unknown encoding: \" + encoding\n\t\t\telse:\n\t\t\t\tmsg = \"unknown encoding for {!r}: {}\".format(filename,\n\t\t\t\t\t\tencoding)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\tcodec",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\tcodec = lookup(encoding)\n\t\texcept LookupError:\n\t\t\t# This behaviour mimics the Python interpreter\n\t\t\tif filename is None:\n\t\t\t\tmsg = \"unknown encoding: \" + encoding\n\t\t\telse:\n\t\t\t\tmsg = \"unknown encoding for {!r}: {}\".format(filename,\n\t\t\t\t\t\tencoding)\n\t\t\traise SyntaxError(msg)\n\t\tif bom_found:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\t\tmsg = \"unknown encoding: \" + encoding\n\t\t\telse:\n\t\t\t\tmsg = \"unknown encoding for {!r}: {}\".format(filename,\n\t\t\t\t\t\tencoding)\n\t\t\traise SyntaxError(msg)\n\t\tif bom_found:\n\t\t\tif encoding != 'utf-8':\n\t\t\t\t# This behaviour mimics the Python interpreter\n\t\t\t\tif filename is None:\n\t\t\t\t\tmsg = 'encoding problem: utf-8'",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\t\tmsg = \"unknown encoding for {!r}: {}\".format(filename,\n\t\t\t\t\t\tencoding)\n\t\t\traise SyntaxError(msg)\n\t\tif bom_found:\n\t\t\tif encoding != 'utf-8':\n\t\t\t\t# This behaviour mimics the Python interpreter\n\t\t\t\tif filename is None:\n\t\t\t\t\tmsg = 'encoding problem: utf-8'\n\t\t\t\telse:\n\t\t\t\t\tmsg = 'encoding problem for {!r}: utf-8'.format(filename)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\t\t\tmsg = 'encoding problem: utf-8'\n\t\t\t\telse:\n\t\t\t\t\tmsg = 'encoding problem for {!r}: utf-8'.format(filename)\n\t\t\t\traise SyntaxError(msg)\n\t\t\tencoding += '-sig'\n\t\treturn encoding\n\tfirst = read_or_stop()\n\tif first.startswith(BOM_UTF8):\n\t\tbom_found = True\n\t\tfirst = first[3:]",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmsg",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\t\t\t\tmsg = 'encoding problem for {!r}: utf-8'.format(filename)\n\t\t\t\traise SyntaxError(msg)\n\t\t\tencoding += '-sig'\n\t\treturn encoding\n\tfirst = read_or_stop()\n\tif first.startswith(BOM_UTF8):\n\t\tbom_found = True\n\t\tfirst = first[3:]\n\t\tdefault = 'utf-8-sig'\n\tif not first:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tfirst",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tfirst = read_or_stop()\n\tif first.startswith(BOM_UTF8):\n\t\tbom_found = True\n\t\tfirst = first[3:]\n\t\tdefault = 'utf-8-sig'\n\tif not first:\n\t\treturn default, [], False\n\tencoding = find_cookie(first)\n\tif encoding:\n\t\treturn encoding, [first], True",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tbom_found",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tbom_found = True\n\t\tfirst = first[3:]\n\t\tdefault = 'utf-8-sig'\n\tif not first:\n\t\treturn default, [], False\n\tencoding = find_cookie(first)\n\tif encoding:\n\t\treturn encoding, [first], True\n\tif not blank_re.match(first):\n\t\treturn default, [first], False",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tfirst",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tfirst = first[3:]\n\t\tdefault = 'utf-8-sig'\n\tif not first:\n\t\treturn default, [], False\n\tencoding = find_cookie(first)\n\tif encoding:\n\t\treturn encoding, [first], True\n\tif not blank_re.match(first):\n\t\treturn default, [first], False\n\tsecond = read_or_stop()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\tdefault",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\tdefault = 'utf-8-sig'\n\tif not first:\n\t\treturn default, [], False\n\tencoding = find_cookie(first)\n\tif encoding:\n\t\treturn encoding, [first], True\n\tif not blank_re.match(first):\n\t\treturn default, [first], False\n\tsecond = read_or_stop()\n\tif not second:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tencoding = find_cookie(first)\n\tif encoding:\n\t\treturn encoding, [first], True\n\tif not blank_re.match(first):\n\t\treturn default, [first], False\n\tsecond = read_or_stop()\n\tif not second:\n\t\treturn default, [first], False\n\tencoding = find_cookie(second)\n\tif encoding:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tsecond",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tsecond = read_or_stop()\n\tif not second:\n\t\treturn default, [first], False\n\tencoding = find_cookie(second)\n\tif encoding:\n\t\treturn encoding, [first, second], True\n\treturn default, [first, second], False\ndef open(filename):\n\t\"\"\"Open a file in read only mode using the encoding detected by\n\tdetect_encoding().",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tencoding",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tencoding = find_cookie(second)\n\tif encoding:\n\t\treturn encoding, [first, second], True\n\treturn default, [first, second], False\ndef open(filename):\n\t\"\"\"Open a file in read only mode using the encoding detected by\n\tdetect_encoding().\n\t\"\"\"\n\tbuffer = _builtin_open(filename, 'rb')\n\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tbuffer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines = detect_encoding(buffer.readline)\n\t\tbuffer.seek(0)\n\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'\n\t\treturn text\n\texcept:\n\t\tbuffer.close()\n\t\traise",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'\n\t\treturn text\n\texcept:\n\t\tbuffer.close()\n\t\traise\ndef read_source_lines(filename):\n\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines, cookie_present = detect_encoding_ex(buffer.readline)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\ttext.mode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\ttext.mode = 'r'\n\t\treturn text\n\texcept:\n\t\tbuffer.close()\n\t\traise\ndef read_source_lines(filename):\n\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines, cookie_present = detect_encoding_ex(buffer.readline)\n\t\tbuffer.seek(0)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\tbuffer",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\tbuffer = _builtin_open(filename, 'rb')\n\ttry:\n\t\tencoding, lines, cookie_present = detect_encoding_ex(buffer.readline)\n\t\tbuffer.seek(0)\n\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'\n\texcept:\n\t\tbuffer.close()\n\t\traise\n\twith text:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\ttext = TextIOWrapper(buffer, encoding, line_buffering=True)\n\t\ttext.mode = 'r'\n\texcept:\n\t\tbuffer.close()\n\t\traise\n\twith text:\n\t\tif cookie_present:\n\t\t\tfor i in lines:\n\t\t\t\tyield text.readline().replace(\"coding\", \"Coding\")\n\t\t\t\t# so compile() won't complain about encoding declatation in a Unicode string",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "\t\ttext.mode",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "peekOfCode": "\t\ttext.mode = 'r'\n\texcept:\n\t\tbuffer.close()\n\t\traise\n\twith text:\n\t\tif cookie_present:\n\t\t\tfor i in lines:\n\t\t\t\tyield text.readline().replace(\"coding\", \"Coding\")\n\t\t\t\t# so compile() won't complain about encoding declatation in a Unicode string\n\t\t\t\t# see 2.7/Python/ast.c:228",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.tokenize_open",
        "documentation": {}
    },
    {
        "label": "get_full_unicode_argv",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "def get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "get_unicode_argv",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "def get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]\n\tnew_argv = get_full_unicode_argv()[-len(original_argv):]\n\tif original_argv[0] == \"-c\":\n\t\tnew_argv[0] = u\"-c\"\n\treturn new_argv\noriginal_argv = None\ndef argv_setter_hook(path):\n\tglobal original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "argv_setter_hook",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "def argv_setter_hook(path):\n\tglobal original_argv\n\tif original_argv is not None: # already got it\n\t\traise ImportError\n\ttry:\n\t\toriginal_argv = sys.argv\n\texcept AttributeError:\n\t\tpass\n\telse:\n\t\tenable()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "enable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "def enable():\n\tglobal original_argv\n\tif original_argv is None:\n\t\ttry:\n\t\t\toriginal_argv = sys.argv\n\t\texcept AttributeError: # in sitecustomize in Python 2\n\t\t\tsys.path_hooks[:0] = [argv_setter_hook]\n\t\t\treturn\n\tsys.argv = get_unicode_argv()\ndef disable():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "disable",
        "kind": 2,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "def disable():\n\tif original_argv is not None:\n\t\tsys.argv = original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "kernel32",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "kernel32 = WinDLL(\"kernel32\", use_last_error=True)\nshell32 = WinDLL(\"shell32\", use_last_error=True)\nGetCommandLineW = kernel32.GetCommandLineW\nGetCommandLineW.argtypes = ()\nGetCommandLineW.restype = LPCWSTR\nCommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "shell32",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "shell32 = WinDLL(\"shell32\", use_last_error=True)\nGetCommandLineW = kernel32.GetCommandLineW\nGetCommandLineW.argtypes = ()\nGetCommandLineW.restype = LPCWSTR\nCommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "GetCommandLineW",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "GetCommandLineW = kernel32.GetCommandLineW\nGetCommandLineW.argtypes = ()\nGetCommandLineW.restype = LPCWSTR\nCommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "GetCommandLineW.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "GetCommandLineW.argtypes = ()\nGetCommandLineW.restype = LPCWSTR\nCommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "GetCommandLineW.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "GetCommandLineW.restype = LPCWSTR\nCommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "CommandLineToArgvW",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "CommandLineToArgvW = shell32.CommandLineToArgvW\nCommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "CommandLineToArgvW.argtypes",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "CommandLineToArgvW.argtypes = (LPCWSTR, POINTER(c_int))\nCommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "CommandLineToArgvW.restype",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "CommandLineToArgvW.restype = POINTER(LPWSTR)\nLocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "LocalFree",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "LocalFree = kernel32.LocalFree\ndef get_full_unicode_argv():\n\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\tcmd",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\tcmd = GetCommandLineW()\n\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]\n\tnew_argv = get_full_unicode_argv()[-len(original_argv):]",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\targc",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\targc = c_int(0)\n\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]\n\tnew_argv = get_full_unicode_argv()[-len(original_argv):]\n\tif original_argv[0] == \"-c\":",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\targv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\targv = CommandLineToArgvW(cmd, byref(argc))\n\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]\n\tnew_argv = get_full_unicode_argv()[-len(original_argv):]\n\tif original_argv[0] == \"-c\":\n\t\tnew_argv[0] = u\"-c\"",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\tpy_argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\tpy_argv = [arg for i, arg in zip(range(argc.value), argv)]\n\tLocalFree(argv)\n\treturn py_argv\ndef get_unicode_argv():\n\tif original_argv == [\"\"]:\n\t\treturn [u\"\"]\n\tnew_argv = get_full_unicode_argv()[-len(original_argv):]\n\tif original_argv[0] == \"-c\":\n\t\tnew_argv[0] = u\"-c\"\n\treturn new_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\tnew_argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\tnew_argv = get_full_unicode_argv()[-len(original_argv):]\n\tif original_argv[0] == \"-c\":\n\t\tnew_argv[0] = u\"-c\"\n\treturn new_argv\noriginal_argv = None\ndef argv_setter_hook(path):\n\tglobal original_argv\n\tif original_argv is not None: # already got it\n\t\traise ImportError\n\ttry:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\t\tnew_argv[0]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\t\tnew_argv[0] = u\"-c\"\n\treturn new_argv\noriginal_argv = None\ndef argv_setter_hook(path):\n\tglobal original_argv\n\tif original_argv is not None: # already got it\n\t\traise ImportError\n\ttry:\n\t\toriginal_argv = sys.argv\n\texcept AttributeError:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "original_argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "original_argv = None\ndef argv_setter_hook(path):\n\tglobal original_argv\n\tif original_argv is not None: # already got it\n\t\traise ImportError\n\ttry:\n\t\toriginal_argv = sys.argv\n\texcept AttributeError:\n\t\tpass\n\telse:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\t\toriginal_argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\t\toriginal_argv = sys.argv\n\texcept AttributeError:\n\t\tpass\n\telse:\n\t\tenable()\n\tfinally:\n\t\traise ImportError\ndef enable():\n\tglobal original_argv\n\tif original_argv is None:",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\t\t\toriginal_argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\t\t\toriginal_argv = sys.argv\n\t\texcept AttributeError: # in sitecustomize in Python 2\n\t\t\tsys.path_hooks[:0] = [argv_setter_hook]\n\t\t\treturn\n\tsys.argv = get_unicode_argv()\ndef disable():\n\tif original_argv is not None:\n\t\tsys.argv = original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\t\t\tsys.path_hooks[:0]",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\t\t\tsys.path_hooks[:0] = [argv_setter_hook]\n\t\t\treturn\n\tsys.argv = get_unicode_argv()\ndef disable():\n\tif original_argv is not None:\n\t\tsys.argv = original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\tsys.argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\tsys.argv = get_unicode_argv()\ndef disable():\n\tif original_argv is not None:\n\t\tsys.argv = original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "\t\tsys.argv",
        "kind": 5,
        "importPath": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "description": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "peekOfCode": "\t\tsys.argv = original_argv",
        "detail": "catboost.contrib.deprecated.python.win-unicode-console.win_unicode_console.unicode_argv",
        "documentation": {}
    },
    {
        "label": "cp_testimage",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "def cp_testimage(name, newname):\n    shutil.copyfile(yatest.common.source_path(_TESTIMAGES_ROOT + name), newname)\ndef run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])\n    for i in range(1, len(command)):\n        m = _TESTIMAGES_RE.match(command[i])\n        if m:\n            name = m.group(1)",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "def run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])\n    for i in range(1, len(command)):\n        m = _TESTIMAGES_RE.match(command[i])\n        if m:\n            name = m.group(1)\n            if name == \"$(TESTORIG)\":\n                name = _TESTORIG",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "md5cmp",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "def md5cmp(hexdigest, filename):\n    with open(filename, 'rb') as f:\n        assert(hexdigest == hashlib.md5(f.read()).hexdigest())\ndef rm_f(patterns):\n    for pattern in patterns.split():\n        for fn in glob.glob(pattern):\n            if \"/\" in fn:\n                raise Exception(\"/ seems supsicious in a file name to remove\")\n            os.unlink(fn)\n# Makefile.am mimic",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "rm_f",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "def rm_f(patterns):\n    for pattern in patterns.split():\n        for fn in glob.glob(pattern):\n            if \"/\" in fn:\n                raise Exception(\"/ seems supsicious in a file name to remove\")\n            os.unlink(fn)\n# Makefile.am mimic\nMD5_JPEG_RGB_ISLOW = \"768e970dd57b340ff1b83c9d3d47c77b\"\nMD5_PPM_RGB_ISLOW = \"00a257f5393fef8821f2b88ac7421291\"\nMD5_BMP_RGB_ISLOW_565 = \"f07d2e75073e4bb10f6c6f4d36e2e3be\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "test_bittest",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "def test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    run(\"cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm\")\n    md5cmp(MD5_JPEG_RGB_ISLOW, \"testout_rgb_islow.jpg\")\n# CC: null  SAMP: fullsize  IDCT: islow  ENT: huff\n    run(\"djpeg -dct int -ppm -outfile testout_rgb_islow.ppm testout_rgb_islow.jpg\")\n    md5cmp(MD5_PPM_RGB_ISLOW, \"testout_rgb_islow.ppm\")",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "_TJ_ROOT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "_TJ_ROOT = \"contrib/libs/libjpeg-turbo/\"\n_TESTIMAGES_ROOT = \"contrib/libs/libjpeg-turbo/testimages/\"\n_TESTIMAGES_RE = re.compile(r'^\\$\\(srcdir\\)/testimages/(.*)$')\n_TESTORIG = \"testorig.jpg\"\ndef cp_testimage(name, newname):\n    shutil.copyfile(yatest.common.source_path(_TESTIMAGES_ROOT + name), newname)\ndef run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "_TESTIMAGES_ROOT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "_TESTIMAGES_ROOT = \"contrib/libs/libjpeg-turbo/testimages/\"\n_TESTIMAGES_RE = re.compile(r'^\\$\\(srcdir\\)/testimages/(.*)$')\n_TESTORIG = \"testorig.jpg\"\ndef cp_testimage(name, newname):\n    shutil.copyfile(yatest.common.source_path(_TESTIMAGES_ROOT + name), newname)\ndef run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])\n    for i in range(1, len(command)):",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "_TESTIMAGES_RE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "_TESTIMAGES_RE = re.compile(r'^\\$\\(srcdir\\)/testimages/(.*)$')\n_TESTORIG = \"testorig.jpg\"\ndef cp_testimage(name, newname):\n    shutil.copyfile(yatest.common.source_path(_TESTIMAGES_ROOT + name), newname)\ndef run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])\n    for i in range(1, len(command)):\n        m = _TESTIMAGES_RE.match(command[i])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "_TESTORIG",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "_TESTORIG = \"testorig.jpg\"\ndef cp_testimage(name, newname):\n    shutil.copyfile(yatest.common.source_path(_TESTIMAGES_ROOT + name), newname)\ndef run(command):\n    command = command.split()\n    ut = \"\"\n    command[0] = yatest.common.binary_path(_TJ_ROOT + ut + command[0] + \"/\" + command[0])\n    for i in range(1, len(command)):\n        m = _TESTIMAGES_RE.match(command[i])\n        if m:",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_RGB_ISLOW",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_RGB_ISLOW = \"768e970dd57b340ff1b83c9d3d47c77b\"\nMD5_PPM_RGB_ISLOW = \"00a257f5393fef8821f2b88ac7421291\"\nMD5_BMP_RGB_ISLOW_565 = \"f07d2e75073e4bb10f6c6f4d36e2e3be\"\nMD5_BMP_RGB_ISLOW_565D = \"4cfa0928ef3e6bb626d7728c924cfda4\"\nMD5_JPEG_422_IFAST_OPT = \"2540287b79d913f91665e660303ab2c8\"\nMD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_RGB_ISLOW",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_RGB_ISLOW = \"00a257f5393fef8821f2b88ac7421291\"\nMD5_BMP_RGB_ISLOW_565 = \"f07d2e75073e4bb10f6c6f4d36e2e3be\"\nMD5_BMP_RGB_ISLOW_565D = \"4cfa0928ef3e6bb626d7728c924cfda4\"\nMD5_JPEG_422_IFAST_OPT = \"2540287b79d913f91665e660303ab2c8\"\nMD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_RGB_ISLOW_565",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_RGB_ISLOW_565 = \"f07d2e75073e4bb10f6c6f4d36e2e3be\"\nMD5_BMP_RGB_ISLOW_565D = \"4cfa0928ef3e6bb626d7728c924cfda4\"\nMD5_JPEG_422_IFAST_OPT = \"2540287b79d913f91665e660303ab2c8\"\nMD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_RGB_ISLOW_565D",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_RGB_ISLOW_565D = \"4cfa0928ef3e6bb626d7728c924cfda4\"\nMD5_JPEG_422_IFAST_OPT = \"2540287b79d913f91665e660303ab2c8\"\nMD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_422_IFAST_OPT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_422_IFAST_OPT = \"2540287b79d913f91665e660303ab2c8\"\nMD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_422_IFAST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_422_IFAST = \"35bd6b3f833bad23de82acea847129fa\"\nMD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_422M_IFAST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_422M_IFAST = \"8dbc65323d62cca7c91ba02dd1cfa81d\"\nMD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_422M_IFAST_565",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_422M_IFAST_565 = \"3294bd4d9a1f2b3d08ea6020d0db7065\"\nMD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_422M_IFAST_565D",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_422M_IFAST_565D = \"da98c9c7b6039511be4a79a878a9abc1\"\nMD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_420_IFAST_Q100_PROG",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_420_IFAST_Q100_PROG = \"990cbe0329c882420a2094da7e5adade\"\nMD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420_Q100_IFAST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420_Q100_IFAST = \"5a732542015c278ff43635e473a8a294\"\nMD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_Q100_IFAST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_Q100_IFAST = \"ff692ee9323a3b424894862557c092f1\"\nMD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_GRAY_ISLOW",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_GRAY_ISLOW = \"72b51f894b8f4a10b3ee3066770aa38d\"\nMD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_GRAY_ISLOW",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_GRAY_ISLOW = \"8d3596c56eace32f205deccc229aa5ed\"\nMD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_GRAY_ISLOW_RGB",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_GRAY_ISLOW_RGB = \"116424ac07b79e5e801f00508eab48ec\"\nMD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_GRAY_ISLOW_565",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_GRAY_ISLOW_565 = \"12f78118e56a2f48b966f792fedf23cc\"\nMD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_GRAY_ISLOW_565D",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_GRAY_ISLOW_565D = \"bdbbd616441a24354c98553df5dc82db\"\nMD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_420S_IFAST_OPT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_420S_IFAST_OPT = \"388708217ac46273ca33086b22827ed8\"\n# See README.md for more details on why this next bit is necessary.\nMD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_3x2_FLOAT_PROG_SSE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_3x2_FLOAT_PROG_SSE = \"343e3f8caf8af5986ebaf0bdc13b5c71\"\nMD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_3x2_FLOAT_SSE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_3x2_FLOAT_SSE = \"1a75f36e5904d6fc3a85a43da9ad89bb\"\nMD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_3x2_FLOAT_PROG_32BIT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_3x2_FLOAT_PROG_32BIT = \"9bca803d2042bd1eb03819e2bf92b3e5\"\nMD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_3x2_FLOAT_32BIT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_3x2_FLOAT_32BIT = \"f6bfab038438ed8f5522fbd33595dcdc\"\nMD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_3x2_FLOAT_64BIT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_3x2_FLOAT_64BIT = \"0e917a34193ef976b679a6b069b1be26\"\nMD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_3x2_IFAST_PROG",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_3x2_IFAST_PROG = \"1ee5d2c1a77f2da495f993c8c7cceca5\"\nMD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_3x2_IFAST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_3x2_IFAST = \"fd283664b3b49127984af0a7f118fccd\"\nMD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_420_ISLOW_ARI",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_420_ISLOW_ARI = \"e986fb0a637a8d833d96e8a6d6d84ea1\"\nMD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_444_ISLOW_PROGARI",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_444_ISLOW_PROGARI = \"0a8f1c8f66e113c3cf635df0a475a617\"\nMD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_IFAST_ARI",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_IFAST_ARI = \"72b59a99bcf1de24c5b27d151bde2437\"\nMD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_420_ISLOW",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_420_ISLOW = \"9a68f56bc76e466aa7e52f415d0f4a5f\"\nMD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_2_1",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_2_1 = \"9f9de8c0612f8d06869b960b05abf9c9\"\nMD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_15_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_15_8 = \"b6875bc070720b899566cc06459b63b7\"\nMD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_13_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_13_8 = \"bc3452573c8152f6ae552939ee19f82f\"\nMD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_11_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_11_8 = \"d8cc73c0aaacd4556569b59437ba00a5\"\nMD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_9_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_9_8 = \"d25e61bc7eac0002f5b393aa223747b6\"\nMD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_7_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_7_8 = \"ddb564b7c74a09494016d6cd7502a946\"\nMD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_3_4",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_3_4 = \"8ed8e68808c3fbc4ea764fc9d2968646\"\nMD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_5_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_5_8 = \"a3363274999da2366a024efae6d16c9b\"\nMD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_1_2",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_1_2 = \"e692a315cea26b988c8e8b29a5dbcd81\"\nMD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_3_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_3_8 = \"79eca9175652ced755155c90e785a996\"\nMD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_1_4",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_1_4 = \"79cd778f8bf1a117690052cacdd54eca\"\nMD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420M_ISLOW_1_8",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420M_ISLOW_1_8 = \"391b3d4aca640c8567d6f8745eb2142f\"\nMD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_420_ISLOW_256",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_420_ISLOW_256 = \"4980185e3776e89bd931736e1cddeee6\"\nMD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_420_ISLOW_565",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_420_ISLOW_565 = \"bf9d13e16c4923b92e1faa604d7922cb\"\nMD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_420_ISLOW_565D",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_420_ISLOW_565D = \"6bde71526acc44bcff76f696df8638d2\"\nMD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_420M_ISLOW_565",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_420M_ISLOW_565 = \"8dc0185245353cfa32ad97027342216f\"\nMD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_BMP_420M_ISLOW_565D",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_BMP_420M_ISLOW_565D = \"ce034037d212bc403330df6f915c161b\"\nMD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420_ISLOW_SKIP15_31",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420_ISLOW_SKIP15_31 = \"c4c65c1e43d7275cd50328a61e6534f0\"\nMD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420_ISLOW_ARI_SKIP16_139",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420_ISLOW_ARI_SKIP16_139 = \"087c6b123db16ac00cb88c5b590bb74a\"\nMD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = \"26eb36ccc7d1f0cb80cdabb0ac8b5d99\"\nMD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = \"886c6775af22370257122f8b16207e6d\"\nMD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_444_ISLOW_SKIP1_6",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_444_ISLOW_SKIP1_6 = \"5606f86874cf26b8fcee1117a0a436a6\"\nMD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    run(\"cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm\")",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = \"db87dc7ce26bcdc7a6b56239ce2b9d6c\"\nMD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    run(\"cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm\")\n    md5cmp(MD5_JPEG_RGB_ISLOW, \"testout_rgb_islow.jpg\")",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = \"cb57b32bd6d03e35432362f7bf184b6d\"\nMD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    run(\"cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm\")\n    md5cmp(MD5_JPEG_RGB_ISLOW, \"testout_rgb_islow.jpg\")\n# CC: null  SAMP: fullsize  IDCT: islow  ENT: huff",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "MD5_JPEG_CROP",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "peekOfCode": "MD5_JPEG_CROP = \"b4197f377e621c4e9b1d20471432610d\"\ndef test_bittest():\n# These tests are carefully crafted to provide full coverage of as many of the\n# underlying algorithms as possible (including all of the SIMD-accelerated\n# ones.)\n# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    run(\"cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm\")\n    md5cmp(MD5_JPEG_RGB_ISLOW, \"testout_rgb_islow.jpg\")\n# CC: null  SAMP: fullsize  IDCT: islow  ENT: huff\n    run(\"djpeg -dct int -ppm -outfile testout_rgb_islow.ppm testout_rgb_islow.jpg\")",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.bittests",
        "documentation": {}
    },
    {
        "label": "run_unit",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def run_unit(args=None):\n    binary = yatest.common.binary_path(_TJUNITTEST)\n    return yatest.common.canonical_execute(binary, args)\ndef test_tjunittest():\n    return run_unit()\ndef test_tjunittest_alloc():\n    return run_unit([\"-alloc\"])\ndef test_tjunittest_yuv():\n    return run_unit([\"-yuv\"])\ndef test_tjunittest_yuv_alloc():",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "test_tjunittest",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def test_tjunittest():\n    return run_unit()\ndef test_tjunittest_alloc():\n    return run_unit([\"-alloc\"])\ndef test_tjunittest_yuv():\n    return run_unit([\"-yuv\"])\ndef test_tjunittest_yuv_alloc():\n    return run_unit([\"-yuv\", \"-alloc\"])\ndef test_tjunittest_yuv_noyuvpad():\n    return run_unit([\"-yuv\", \"-noyuvpad\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "test_tjunittest_alloc",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def test_tjunittest_alloc():\n    return run_unit([\"-alloc\"])\ndef test_tjunittest_yuv():\n    return run_unit([\"-yuv\"])\ndef test_tjunittest_yuv_alloc():\n    return run_unit([\"-yuv\", \"-alloc\"])\ndef test_tjunittest_yuv_noyuvpad():\n    return run_unit([\"-yuv\", \"-noyuvpad\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "test_tjunittest_yuv",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def test_tjunittest_yuv():\n    return run_unit([\"-yuv\"])\ndef test_tjunittest_yuv_alloc():\n    return run_unit([\"-yuv\", \"-alloc\"])\ndef test_tjunittest_yuv_noyuvpad():\n    return run_unit([\"-yuv\", \"-noyuvpad\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "test_tjunittest_yuv_alloc",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def test_tjunittest_yuv_alloc():\n    return run_unit([\"-yuv\", \"-alloc\"])\ndef test_tjunittest_yuv_noyuvpad():\n    return run_unit([\"-yuv\", \"-noyuvpad\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "test_tjunittest_yuv_noyuvpad",
        "kind": 2,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "def test_tjunittest_yuv_noyuvpad():\n    return run_unit([\"-yuv\", \"-noyuvpad\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "_TJUNITTEST",
        "kind": 5,
        "importPath": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "description": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "peekOfCode": "_TJUNITTEST = \"contrib/libs/libjpeg-turbo/tjunittest/tjunittest\"\ndef run_unit(args=None):\n    binary = yatest.common.binary_path(_TJUNITTEST)\n    return yatest.common.canonical_execute(binary, args)\ndef test_tjunittest():\n    return run_unit()\ndef test_tjunittest_alloc():\n    return run_unit([\"-alloc\"])\ndef test_tjunittest_yuv():\n    return run_unit([\"-yuv\"])",
        "detail": "catboost.contrib.libs.libjpeg-turbo.ut.tjunittest",
        "documentation": {}
    },
    {
        "label": "check_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_value_info(\n    value_info: ValueInfoProto, ctx: C.CheckerContext = DEFAULT_CONTEXT\n) -> None:\n    pass\n@_create_checker(TensorProto)\ndef check_tensor(tensor: TensorProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass\n@_create_checker(AttributeProto)\ndef check_attribute(\n    attr: AttributeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_tensor",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_tensor(tensor: TensorProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass\n@_create_checker(AttributeProto)\ndef check_attribute(\n    attr: AttributeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT\n) -> None:\n    pass\n@_create_checker(NodeProto)\ndef check_node(node: NodeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_attribute",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_attribute(\n    attr: AttributeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT\n) -> None:\n    pass\n@_create_checker(NodeProto)\ndef check_node(node: NodeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass\ndef check_function(\n    function: FunctionProto, ctx: Optional[C.CheckerContext] = None\n) -> None:",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_node",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_node(node: NodeProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass\ndef check_function(\n    function: FunctionProto, ctx: Optional[C.CheckerContext] = None\n) -> None:\n    if ctx is None:\n        ctx = C.CheckerContext()\n        ctx.ir_version = helper.find_min_ir_version_for(\n            list(function.opset_import), True\n        )",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_function",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_function(\n    function: FunctionProto, ctx: Optional[C.CheckerContext] = None\n) -> None:\n    if ctx is None:\n        ctx = C.CheckerContext()\n        ctx.ir_version = helper.find_min_ir_version_for(\n            list(function.opset_import), True\n        )\n        function_opset_dic = {}\n        for domain_version in function.opset_import:",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_graph(graph: GraphProto, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> None:\n    pass\ndef check_sparse_tensor(\n    sparse: SparseTensorProto, ctx: C.CheckerContext = DEFAULT_CONTEXT\n) -> None:\n    C.check_sparse_tensor(sparse.SerializeToString(), ctx)\ndef check_model(model: Union[ModelProto, str, bytes], full_check: bool = False) -> None:\n    \"\"\"Check the consistency of a model. An exception is raised if the test fails.\n    Arguments:\n        model (ModelProto): model to check",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_sparse_tensor",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_sparse_tensor(\n    sparse: SparseTensorProto, ctx: C.CheckerContext = DEFAULT_CONTEXT\n) -> None:\n    C.check_sparse_tensor(sparse.SerializeToString(), ctx)\ndef check_model(model: Union[ModelProto, str, bytes], full_check: bool = False) -> None:\n    \"\"\"Check the consistency of a model. An exception is raised if the test fails.\n    Arguments:\n        model (ModelProto): model to check\n        full_check (bool): if True, the function checks shapes can be inferred\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "def check_model(model: Union[ModelProto, str, bytes], full_check: bool = False) -> None:\n    \"\"\"Check the consistency of a model. An exception is raised if the test fails.\n    Arguments:\n        model (ModelProto): model to check\n        full_check (bool): if True, the function checks shapes can be inferred\n    \"\"\"\n    # If model is a path instead of ModelProto\n    if isinstance(model, str):\n        C.check_model_path(model, full_check)\n    else:",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "MAXIMUM_PROTOBUF",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "MAXIMUM_PROTOBUF = 2000000000\n# TODO: This thing where we reserialize the protobuf back into the\n# string, only to deserialize it at the call site, is really goofy.\n# Stop doing that.\n# NB: Please don't edit this context!\nDEFAULT_CONTEXT = C.CheckerContext()\nDEFAULT_CONTEXT.ir_version = IR_VERSION\n# TODO: Maybe ONNX-ML should also be defaulted?\nDEFAULT_CONTEXT.opset_imports = {\"\": onnx.defs.onnx_opset_version()}\nFuncType = TypeVar(\"FuncType\", bound=Callable[..., Any])",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONTEXT",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "DEFAULT_CONTEXT = C.CheckerContext()\nDEFAULT_CONTEXT.ir_version = IR_VERSION\n# TODO: Maybe ONNX-ML should also be defaulted?\nDEFAULT_CONTEXT.opset_imports = {\"\": onnx.defs.onnx_opset_version()}\nFuncType = TypeVar(\"FuncType\", bound=Callable[..., Any])\n# TODO: This really doesn't seem worth the metaprogramming...\ndef _create_checker(proto_type: Type[Message]) -> Callable[[FuncType], FuncType]:\n    def decorator(py_func: FuncType) -> FuncType:\n        @functools.wraps(py_func)\n        def checker(proto: Message, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> Any:",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONTEXT.ir_version",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "DEFAULT_CONTEXT.ir_version = IR_VERSION\n# TODO: Maybe ONNX-ML should also be defaulted?\nDEFAULT_CONTEXT.opset_imports = {\"\": onnx.defs.onnx_opset_version()}\nFuncType = TypeVar(\"FuncType\", bound=Callable[..., Any])\n# TODO: This really doesn't seem worth the metaprogramming...\ndef _create_checker(proto_type: Type[Message]) -> Callable[[FuncType], FuncType]:\n    def decorator(py_func: FuncType) -> FuncType:\n        @functools.wraps(py_func)\n        def checker(proto: Message, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> Any:\n            if not isinstance(proto, proto_type):",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONTEXT.opset_imports",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "DEFAULT_CONTEXT.opset_imports = {\"\": onnx.defs.onnx_opset_version()}\nFuncType = TypeVar(\"FuncType\", bound=Callable[..., Any])\n# TODO: This really doesn't seem worth the metaprogramming...\ndef _create_checker(proto_type: Type[Message]) -> Callable[[FuncType], FuncType]:\n    def decorator(py_func: FuncType) -> FuncType:\n        @functools.wraps(py_func)\n        def checker(proto: Message, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> Any:\n            if not isinstance(proto, proto_type):\n                raise RuntimeError(\n                    f\"You cannot pass an object that is not of type {proto_type.__name__}\"",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "FuncType",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "FuncType = TypeVar(\"FuncType\", bound=Callable[..., Any])\n# TODO: This really doesn't seem worth the metaprogramming...\ndef _create_checker(proto_type: Type[Message]) -> Callable[[FuncType], FuncType]:\n    def decorator(py_func: FuncType) -> FuncType:\n        @functools.wraps(py_func)\n        def checker(proto: Message, ctx: C.CheckerContext = DEFAULT_CONTEXT) -> Any:\n            if not isinstance(proto, proto_type):\n                raise RuntimeError(\n                    f\"You cannot pass an object that is not of type {proto_type.__name__}\"\n                )",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.checker",
        "description": "catboost.contrib.libs.onnx.onnx.checker",
        "peekOfCode": "ValidationError = C.ValidationError",
        "detail": "catboost.contrib.libs.onnx.onnx.checker",
        "documentation": {}
    },
    {
        "label": "check_overlapping_names",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def check_overlapping_names(\n    g1: GraphProto, g2: GraphProto, io_map: Optional[List[Tuple[str, str]]] = None\n) -> List[Tuple[str, List[str]]]:\n    \"\"\"Checks whether there are name collisions between two graphs\n    Returns a list of tuples where the first element represents the member containing overlapping names\n    (One of: \"node\", \"edge\", \"value_info\", \"initializer\", \"sparse_initializer\"), and the\n    second element contains a list of names that appear in both graphs on that category.\n    Optionally, it takes an io_map, representing the output/inputs to be connected. It provided, overlapping\n    present in the io_map argument will be ignored.\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "merge_graphs",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def merge_graphs(  # pylint: disable=too-many-branches,too-many-statements\n    g1: GraphProto,\n    g2: GraphProto,\n    io_map: List[Tuple[str, str]],\n    inputs: Optional[List[str]] = None,\n    outputs: Optional[List[str]] = None,\n    prefix1: Optional[str] = None,\n    prefix2: Optional[str] = None,\n    name: Optional[str] = None,\n    doc_string: Optional[str] = None,",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "merge_models",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def merge_models(  # pylint: disable=too-many-branches\n    m1: ModelProto,\n    m2: ModelProto,\n    io_map: List[Tuple[str, str]],\n    inputs: Optional[List[str]] = None,\n    outputs: Optional[List[str]] = None,\n    prefix1: Optional[str] = None,\n    prefix2: Optional[str] = None,\n    name: Optional[str] = None,\n    doc_string: Optional[str] = None,",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "add_prefix_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def add_prefix_graph(  # pylint: disable=too-many-branches\n    graph: GraphProto,\n    prefix: str,\n    rename_nodes: Optional[bool] = True,\n    rename_edges: Optional[bool] = True,\n    rename_inputs: Optional[bool] = True,\n    rename_outputs: Optional[bool] = True,\n    rename_initializers: Optional[bool] = True,\n    rename_value_infos: Optional[bool] = True,\n    inplace: Optional[bool] = False,",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def add_prefix(\n    model: ModelProto,\n    prefix: str,\n    rename_nodes: Optional[bool] = True,\n    rename_edges: Optional[bool] = True,\n    rename_inputs: Optional[bool] = True,\n    rename_outputs: Optional[bool] = True,\n    rename_initializers: Optional[bool] = True,\n    rename_value_infos: Optional[bool] = True,\n    rename_functions: Optional[bool] = True,",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "expand_out_dim_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def expand_out_dim_graph(\n    graph: GraphProto,\n    dim_idx: int,\n    inplace: Optional[bool] = False,\n) -> GraphProto:\n    \"\"\"Inserts an extra dimension with extent 1 to each output in the graph.\n    Inserts an Unsqueeze node for each output. It can be used as a utility before merging graphs,\n    for example when the second one expects a batch dimension.\n    Arguments:\n        graph (GraphProto): Graph",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "expand_out_dim",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.compose",
        "description": "catboost.contrib.libs.onnx.onnx.compose",
        "peekOfCode": "def expand_out_dim(\n    model: ModelProto,\n    dim_idx: int,\n    inplace: Optional[bool] = False,\n) -> ModelProto:\n    \"\"\"Inserts an extra dimension with extent 1 to each output in the graph.\n    Inserts an Unsqueeze node for each output. It can be used as a utility before merging graphs,\n    for example when the second one expects a batch dimension.\n    Arguments:\n        model (ModelProto): Model",
        "detail": "catboost.contrib.libs.onnx.onnx.compose",
        "documentation": {}
    },
    {
        "label": "ExternalDataInfo",
        "kind": 6,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "class ExternalDataInfo:\n    def __init__(self, tensor: TensorProto) -> None:\n        self.location = \"\"\n        self.offset = None\n        self.length = None\n        self.checksum = None\n        self.basepath = \"\"\n        for entry in tensor.external_data:\n            setattr(self, entry.key, entry.value)\n        if self.offset:",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "load_external_data_for_tensor",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def load_external_data_for_tensor(tensor: TensorProto, base_dir: str) -> None:\n    \"\"\"\n    Loads data from an external file for tensor.\n    Ideally TensorProto should not hold any raw data but if it does it will be ignored.\n    Arguments:\n        tensor: a TensorProto object.\n        base_dir: directory that contains the external data.\n    \"\"\"\n    info = ExternalDataInfo(tensor)\n    file_location = _sanitize_path(info.location)",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "load_external_data_for_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def load_external_data_for_model(model: ModelProto, base_dir: str) -> None:\n    \"\"\"\n    Loads external tensors into model\n    Arguments:\n        model: ModelProto to load external data to\n        base_dir: directory that contains external data\n    \"\"\"\n    for tensor in _get_all_tensors(model):\n        if uses_external_data(tensor):\n            load_external_data_for_tensor(tensor, base_dir)",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "set_external_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def set_external_data(\n    tensor: TensorProto,\n    location: str,\n    offset: Optional[int] = None,\n    length: Optional[int] = None,\n    checksum: Optional[str] = None,\n    basepath: Optional[str] = None,\n) -> None:\n    if not tensor.HasField(\"raw_data\"):\n        raise ValueError(",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "convert_model_to_external_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def convert_model_to_external_data(\n    model: ModelProto,\n    all_tensors_to_one_file: bool = True,\n    location: Optional[str] = None,\n    size_threshold: int = 1024,\n    convert_attribute: bool = False,\n) -> None:\n    \"\"\"\n    Call to set all tensors with raw data as external data. This call should preceed 'save_model'.\n    'save_model' saves all the tensors data as external data after calling this function.",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "convert_model_from_external_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def convert_model_from_external_data(model: ModelProto) -> None:\n    \"\"\"\n    Call to set all tensors which use external data as embedded data.\n    save_model saves all the tensors data as embedded data after\n    calling this function.\n    Arguments:\n        model (ModelProto): Model to be converted.\n    \"\"\"\n    for tensor in _get_all_tensors(model):\n        if uses_external_data(tensor):",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "save_external_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def save_external_data(tensor: TensorProto, base_path: str) -> None:\n    \"\"\"\n    Writes tensor data to an external file according to information in the `external_data` field.\n    Arguments:\n        tensor (TensorProto): Tensor object to be serialized\n        base_path: System path of a folder where tensor data is to be stored\n    \"\"\"\n    info = ExternalDataInfo(tensor)\n    external_data_file_path = os.path.join(base_path, info.location)\n    # Retrieve the tensor's data from raw_data or load external file",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "uses_external_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def uses_external_data(tensor: TensorProto) -> bool:\n    \"\"\"Returns true if the tensor stores data in an external location.\"\"\"\n    return (\n        tensor.HasField(\"data_location\")\n        and tensor.data_location == TensorProto.EXTERNAL\n    )\ndef remove_external_data_field(tensor: TensorProto, field_key: str) -> None:\n    \"\"\"\n    Removes a field from a Tensor's external_data key-value store.\n    Modifies tensor object in place.",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "remove_external_data_field",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def remove_external_data_field(tensor: TensorProto, field_key: str) -> None:\n    \"\"\"\n    Removes a field from a Tensor's external_data key-value store.\n    Modifies tensor object in place.\n    Arguments:\n        tensor (TensorProto): Tensor object from which value will be removed\n        field_key (string): The key of the field to be removed\n    \"\"\"\n    for i, field in enumerate(tensor.external_data):\n        if field.key == field_key:",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "write_external_data_tensors",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "description": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "peekOfCode": "def write_external_data_tensors(model: ModelProto, filepath: str) -> ModelProto:\n    \"\"\"\n    Serializes data for all the tensors which have data location set to TensorProto.External.\n    Note: This function also strips basepath information from all tensors' external_data fields.\n    Arguments:\n        model (ModelProto): Model object which is the source of tensors to serialize.\n        filepath: System path to the directory which should be treated as base path for external data.\n    Returns:\n        ModelProto: The modified model object.\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.external_data_helper",
        "documentation": {}
    },
    {
        "label": "process_ifs",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0\n    for line in lines:\n        if IF_ONNX_ML_REGEX.match(line):\n            assert in_if == 0\n            in_if = 1\n        elif ELSE_ONNX_ML_REGEX.match(line):\n            assert in_if == 1\n            in_if = 2\n        elif ENDIF_ONNX_ML_REGEX.match(line):",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "process_package_name",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def process_package_name(lines: Iterable[str], package_name: str) -> Iterable[str]:\n    need_rename = package_name != DEFAULT_PACKAGE_NAME\n    for line in lines:\n        m = IMPORT_REGEX.match(line) if need_rename else None\n        if m:\n            include_name = m.group(2)\n            ml = ML_REGEX.match(include_name)\n            if ml:\n                include_name = f\"{ml.group(1)}_{package_name}-ml\"\n            else:",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "convert_to_proto3",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def convert_to_proto3(lines: Iterable[str]) -> Iterable[str]:\n    for line in lines:\n        # Set the syntax specifier\n        m = PROTO_SYNTAX_REGEX.match(line)\n        if m:\n            yield m.group(1) + 'syntax = \"proto3\";'\n            continue\n        # Remove optional keywords\n        m = OPTIONAL_REGEX.match(line)\n        if m:",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "gen_proto3_code",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def gen_proto3_code(\n    protoc_path: str, proto3_path: str, include_path: str, cpp_out: str, python_out: str\n) -> None:\n    print(f\"Generate pb3 code using {protoc_path}\")\n    build_args = [protoc_path, proto3_path, \"-I\", include_path]\n    build_args.extend([\"--cpp_out\", cpp_out, \"--python_out\", python_out])\n    subprocess.check_call(build_args)\ndef translate(source: str, proto: int, onnx_ml: bool, package_name: str) -> str:\n    lines: Iterable[str] = source.splitlines()\n    lines = process_ifs(lines, onnx_ml=onnx_ml)",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "translate",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def translate(source: str, proto: int, onnx_ml: bool, package_name: str) -> str:\n    lines: Iterable[str] = source.splitlines()\n    lines = process_ifs(lines, onnx_ml=onnx_ml)\n    lines = process_package_name(lines, package_name=package_name)\n    if proto == 3:\n        lines = convert_to_proto3(lines)\n    else:\n        assert proto == 2\n    return \"\\n\".join(lines)  # TODO: not Windows friendly\ndef qualify(f: str, pardir: Optional[str] = None) -> str:",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "qualify",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def qualify(f: str, pardir: Optional[str] = None) -> str:\n    if pardir is None:\n        pardir = os.path.realpath(os.path.dirname(__file__))\n    return os.path.join(pardir, f)\ndef convert(  # pylint: disable=too-many-branches,too-many-statements\n    stem: str,\n    package_name: str,\n    output: str,\n    do_onnx_ml: bool = False,\n    lite: bool = False,",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def convert(  # pylint: disable=too-many-branches,too-many-statements\n    stem: str,\n    package_name: str,\n    output: str,\n    do_onnx_ml: bool = False,\n    lite: bool = False,\n    protoc_path: str = \"\",\n) -> None:\n    proto_in = qualify(f\"{stem}.in.proto\")\n    need_rename = package_name != DEFAULT_PACKAGE_NAME",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "def main() -> None:\n    parser = argparse.ArgumentParser(\n        description=\"Generates .proto file variations from .in.proto\"\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--package\",\n        default=\"onnx\",\n        help=\"package name in the generated proto files\" \" (default: %(default)s)\",\n    )",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "autogen_header",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "autogen_header = \"\"\"\\\n//\n// WARNING: This file is automatically generated!  Please edit onnx.in.proto.\n//\n\"\"\"\nLITE_OPTION = \"\"\"\n// For using protobuf-lite\noption optimize_for = LITE_RUNTIME;\n\"\"\"\nDEFAULT_PACKAGE_NAME = \"onnx\"",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "LITE_OPTION",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "LITE_OPTION = \"\"\"\n// For using protobuf-lite\noption optimize_for = LITE_RUNTIME;\n\"\"\"\nDEFAULT_PACKAGE_NAME = \"onnx\"\nIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#if\\s+ONNX-ML\\s*$\")\nENDIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#endif\\s*$\")\nELSE_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#else\\s*$\")\ndef process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PACKAGE_NAME",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "DEFAULT_PACKAGE_NAME = \"onnx\"\nIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#if\\s+ONNX-ML\\s*$\")\nENDIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#endif\\s*$\")\nELSE_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#else\\s*$\")\ndef process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0\n    for line in lines:\n        if IF_ONNX_ML_REGEX.match(line):\n            assert in_if == 0\n            in_if = 1",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "IF_ONNX_ML_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "IF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#if\\s+ONNX-ML\\s*$\")\nENDIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#endif\\s*$\")\nELSE_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#else\\s*$\")\ndef process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0\n    for line in lines:\n        if IF_ONNX_ML_REGEX.match(line):\n            assert in_if == 0\n            in_if = 1\n        elif ELSE_ONNX_ML_REGEX.match(line):",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "ENDIF_ONNX_ML_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "ENDIF_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#endif\\s*$\")\nELSE_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#else\\s*$\")\ndef process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0\n    for line in lines:\n        if IF_ONNX_ML_REGEX.match(line):\n            assert in_if == 0\n            in_if = 1\n        elif ELSE_ONNX_ML_REGEX.match(line):\n            assert in_if == 1",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "ELSE_ONNX_ML_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "ELSE_ONNX_ML_REGEX = re.compile(r\"\\s*//\\s*#else\\s*$\")\ndef process_ifs(lines: Iterable[str], onnx_ml: bool) -> Iterable[str]:\n    in_if = 0\n    for line in lines:\n        if IF_ONNX_ML_REGEX.match(line):\n            assert in_if == 0\n            in_if = 1\n        elif ELSE_ONNX_ML_REGEX.match(line):\n            assert in_if == 1\n            in_if = 2",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "IMPORT_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "IMPORT_REGEX = re.compile(r'(\\s*)import\\s*\"([^\"]*)\\.proto\";\\s*$')\nPACKAGE_NAME_REGEX = re.compile(r\"\\{PACKAGE_NAME\\}\")\nML_REGEX = re.compile(r\"(.*)\\-ml\")\ndef process_package_name(lines: Iterable[str], package_name: str) -> Iterable[str]:\n    need_rename = package_name != DEFAULT_PACKAGE_NAME\n    for line in lines:\n        m = IMPORT_REGEX.match(line) if need_rename else None\n        if m:\n            include_name = m.group(2)\n            ml = ML_REGEX.match(include_name)",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "PACKAGE_NAME_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "PACKAGE_NAME_REGEX = re.compile(r\"\\{PACKAGE_NAME\\}\")\nML_REGEX = re.compile(r\"(.*)\\-ml\")\ndef process_package_name(lines: Iterable[str], package_name: str) -> Iterable[str]:\n    need_rename = package_name != DEFAULT_PACKAGE_NAME\n    for line in lines:\n        m = IMPORT_REGEX.match(line) if need_rename else None\n        if m:\n            include_name = m.group(2)\n            ml = ML_REGEX.match(include_name)\n            if ml:",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "ML_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "ML_REGEX = re.compile(r\"(.*)\\-ml\")\ndef process_package_name(lines: Iterable[str], package_name: str) -> Iterable[str]:\n    need_rename = package_name != DEFAULT_PACKAGE_NAME\n    for line in lines:\n        m = IMPORT_REGEX.match(line) if need_rename else None\n        if m:\n            include_name = m.group(2)\n            ml = ML_REGEX.match(include_name)\n            if ml:\n                include_name = f\"{ml.group(1)}_{package_name}-ml\"",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "PROTO_SYNTAX_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "PROTO_SYNTAX_REGEX = re.compile(r'(\\s*)syntax\\s*=\\s*\"proto2\"\\s*;\\s*$')\nOPTIONAL_REGEX = re.compile(r\"(\\s*)optional\\s(.*)$\")\ndef convert_to_proto3(lines: Iterable[str]) -> Iterable[str]:\n    for line in lines:\n        # Set the syntax specifier\n        m = PROTO_SYNTAX_REGEX.match(line)\n        if m:\n            yield m.group(1) + 'syntax = \"proto3\";'\n            continue\n        # Remove optional keywords",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "OPTIONAL_REGEX",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "description": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "peekOfCode": "OPTIONAL_REGEX = re.compile(r\"(\\s*)optional\\s(.*)$\")\ndef convert_to_proto3(lines: Iterable[str]) -> Iterable[str]:\n    for line in lines:\n        # Set the syntax specifier\n        m = PROTO_SYNTAX_REGEX.match(line)\n        if m:\n            yield m.group(1) + 'syntax = \"proto3\";'\n            continue\n        # Remove optional keywords\n        m = OPTIONAL_REGEX.match(line)",
        "detail": "catboost.contrib.libs.onnx.onnx.gen_proto",
        "documentation": {}
    },
    {
        "label": "create_op_set_id_version_map",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def create_op_set_id_version_map(table: VersionTableType) -> VersionMapType:\n    \"\"\"create a map from (opset-domain, opset-version) to ir-version from above table\"\"\"\n    result: VersionMapType = {}\n    def process(release_version: str, ir_version: int, *args: Any) -> None:\n        del release_version  # Unused\n        for pair in zip([\"ai.onnx\", \"ai.onnx.ml\", \"ai.onnx.training\"], args):\n            if pair not in result:\n                result[pair] = ir_version\n                if pair[0] == \"ai.onnx.training\":\n                    result[\"ai.onnx.preview.training\", pair[1]] = ir_version",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "find_min_ir_version_for",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def find_min_ir_version_for(\n    opsetidlist: List[OperatorSetIdProto], ignore_unknown: bool = False\n) -> int:\n    \"\"\"Given list of opset ids, determine minimum IR version required.\n    Arguments:\n        opsetidlist (List[OperatorSetIdProto]): The list of OperatorSetIdProto\n        ignore_unknown (bool): If True, ignore unknown domain and return default min version for that domain.\n    Returns:\n        The minimum IR version required (integer)\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_node",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_node(\n    op_type: str,\n    inputs: Sequence[str],\n    outputs: Sequence[str],\n    name: Optional[str] = None,\n    doc_string: Optional[str] = None,\n    domain: Optional[str] = None,\n    **kwargs: Any,\n) -> NodeProto:\n    \"\"\"Construct a NodeProto.",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_operatorsetid",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_operatorsetid(\n    domain: str,\n    version: int,\n) -> OperatorSetIdProto:\n    \"\"\"Construct an OperatorSetIdProto.\n    Arguments:\n        domain (string): The domain of the operator set id\n        version (integer): Version of operator set id\n    Returns:\n        OperatorSetIdProto",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_graph(\n    nodes: Sequence[NodeProto],\n    name: str,\n    inputs: Sequence[ValueInfoProto],\n    outputs: Sequence[ValueInfoProto],\n    initializer: Optional[Sequence[TensorProto]] = None,\n    doc_string: Optional[str] = None,\n    value_info: Optional[Sequence[ValueInfoProto]] = None,\n    sparse_initializer: Optional[Sequence[SparseTensorProto]] = None,\n) -> GraphProto:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_opsetid",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_opsetid(domain: str, version: int) -> OperatorSetIdProto:\n    \"\"\"Construct an OperatorSetIdProto.\n    Arguments:\n        domain (string): The domain of the operator set id\n        version (integer): Version of operator set id\n    Returns:\n        OperatorSetIdProto\n    \"\"\"\n    opsetid = OperatorSetIdProto()\n    opsetid.domain = domain",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_function",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_function(\n    domain: str,\n    fname: str,\n    inputs: Sequence[str],\n    outputs: Sequence[str],\n    nodes: Sequence[NodeProto],\n    opset_imports: Sequence[OperatorSetIdProto],\n    attributes: Optional[Sequence[str]] = None,\n    attribute_protos: Optional[Sequence[AttributeProto]] = None,\n    doc_string: Optional[str] = None,",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_model(graph: GraphProto, **kwargs: Any) -> ModelProto:\n    \"\"\"Construct a ModelProto\n    Arguments:\n        graph (GraphProto): *make_graph* returns\n        **kwargs: any attribute to add to the returned instance\n    Returns:\n        ModelProto\n    \"\"\"\n    model = ModelProto()\n    # Touch model.ir_version so it is stored as the version from which it is",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_model_gen_version",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_model_gen_version(graph: GraphProto, **kwargs: Any) -> ModelProto:\n    ir_version_field = \"ir_version\"\n    if ir_version_field not in kwargs:\n        opset_imports_field = \"opset_imports\"\n        imports = kwargs[opset_imports_field] if opset_imports_field in kwargs else []\n        kwargs[ir_version_field] = find_min_ir_version_for(imports)\n    return make_model(graph, **kwargs)\ndef set_model_props(model: ModelProto, dict_value: Dict[str, str]) -> None:\n    del model.metadata_props[:]\n    for k, v in dict_value.items():",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "set_model_props",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def set_model_props(model: ModelProto, dict_value: Dict[str, str]) -> None:\n    del model.metadata_props[:]\n    for k, v in dict_value.items():\n        entry = model.metadata_props.add()\n        entry.key = k\n        entry.value = v\n        # model.metadata_properties.append(entry)\ndef split_complex_to_pairs(ca: Sequence[np.complex64]) -> Sequence[int]:\n    return [\n        (ca[i // 2].real if (i % 2 == 0) else ca[i // 2].imag)  # type: ignore[misc]",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "split_complex_to_pairs",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def split_complex_to_pairs(ca: Sequence[np.complex64]) -> Sequence[int]:\n    return [\n        (ca[i // 2].real if (i % 2 == 0) else ca[i // 2].imag)  # type: ignore[misc]\n        for i in range(len(ca) * 2)\n    ]\n# convert a float32 value to a bfloat16 (as int)\n# By default, this conversion rounds-to-nearest-even and supports NaN\n# Setting `truncate` to True enables a simpler conversion. In this mode the\n# conversion is performed by simply dropping the 2 least significant bytes of\n# the significand. In this mode an error of up to 1 bit may be introduced and",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "float32_to_bfloat16",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def float32_to_bfloat16(fval: float, truncate: bool = False) -> int:\n    ival = int.from_bytes(struct.pack(\"<f\", fval), \"little\")\n    if truncate:\n        return ival >> 16\n    # NaN requires at least 1 significand bit set\n    if isnan(fval):\n        return 0x7FC0  # sign=0, exp=all-ones, sig=0b1000000\n    # drop bottom 16-bits\n    # round remaining bits using round-to-nearest-even\n    rounded = ((ival >> 16) & 1) + 0x7FFF",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "float32_to_float8e4m3",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def float32_to_float8e4m3(  # pylint: disable=too-many-statements\n    fval: float,\n    scale: float = 1.0,\n    fn: bool = True,\n    uz: bool = False,\n    saturate: bool = True,\n) -> int:\n    \"\"\"\n    Convert a float32 value to a float8, e4m3 (as int).\n    :param fval: float to convert",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "float32_to_float8e5m2",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def float32_to_float8e5m2(  # pylint: disable=too-many-statements\n    fval: float,\n    scale: float = 1.0,\n    fn: bool = False,\n    uz: bool = False,\n    saturate: bool = True,\n) -> int:\n    \"\"\"\n    Convert a float32 value to a float8, e5m2 (as int).\n    :param fval: float to convert",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_tensor",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_tensor(\n    name: str, data_type: int, dims: Sequence[int], vals: Any, raw: bool = False\n) -> TensorProto:\n    \"\"\"\n    Make a TensorProto with specified arguments.  If raw is False, this\n    function will choose the corresponding proto field to store the\n    values based on data_type. If raw is True, use \"raw_data\" proto\n    field to store the values, and values should be of type bytes in\n    this case.\n    Arguments:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_sparse_tensor",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_sparse_tensor(\n    values: TensorProto, indices: TensorProto, dims: Sequence[int]\n) -> SparseTensorProto:\n    \"\"\"Construct a SparseTensorProto\n    Arguments:\n        values (TensorProto): the values\n        indices (TensorProto): the indices\n        dims: the shape\n    Returns:\n        SparseTensorProto",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_sequence",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_sequence(\n    name: str,\n    elem_type: SequenceProto.DataType,\n    values: Sequence[Any],\n) -> SequenceProto:\n    \"\"\"\n    Make a Sequence with specified value arguments.\n    \"\"\"\n    sequence = SequenceProto()\n    sequence.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_map",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_map(\n    name: str, key_type: int, keys: List[Any], values: SequenceProto\n) -> MapProto:\n    \"\"\"\n    Make a Map with specified key-value pair arguments.\n    Criteria for conversion:\n    - Keys and Values must have the same number of elements\n    - Every key in keys must be of the same type\n    - Every value in values must be of the same type\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_optional",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_optional(\n    name: str,\n    elem_type: OptionalProto.DataType,\n    value: Optional[Any],\n) -> OptionalProto:\n    \"\"\"\n    Make an Optional with specified value arguments.\n    \"\"\"\n    optional = OptionalProto()\n    optional.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_attribute",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_attribute(  # pylint: disable=too-many-statements\n    key: str, value: Any, doc_string: Optional[str] = None\n) -> AttributeProto:\n    \"\"\"Makes an AttributeProto based on the value type.\"\"\"\n    attr = AttributeProto()\n    attr.name = key\n    if doc_string:\n        attr.doc_string = doc_string\n    # Singular cases\n    if isinstance(value, numbers.Integral):",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_attribute_ref",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_attribute_ref(\n    name: str, attr_type: AttributeProto.AttributeType, doc_string: Optional[str] = None\n) -> AttributeProto:\n    \"\"\"Make an AttributeProto holding a reference to the parent function's attribute of given name and type.\"\"\"\n    attr = AttributeProto()\n    attr.name = name\n    attr.type = attr_type\n    if doc_string:\n        attr.doc_string = doc_string\n    return attr",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "get_attribute_value",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def get_attribute_value(attr: AttributeProto) -> Any:\n    if attr.ref_attr_name:\n        raise ValueError(f\"Cannot get value of reference attribute: {attr}\")\n    if attr.type == AttributeProto.FLOAT:\n        return attr.f\n    if attr.type == AttributeProto.INT:\n        return attr.i\n    if attr.type == AttributeProto.STRING:\n        return attr.s\n    if attr.type == AttributeProto.TENSOR:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "get_node_attr_value",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def get_node_attr_value(node: NodeProto, attr_name: str) -> Any:\n    matching = [x for x in node.attribute if x.name == attr_name]\n    if len(matching) > 1:\n        raise ValueError(f\"Node has multiple attributes with name {attr_name}\")\n    if len(matching) < 1:\n        raise ValueError(f\"Node has no attribute with name {attr_name}\")\n    return get_attribute_value(matching[0])\ndef make_empty_tensor_value_info(name: str) -> ValueInfoProto:\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_empty_tensor_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_empty_tensor_value_info(name: str) -> ValueInfoProto:\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name\n    return value_info_proto\ndef make_tensor_type_proto(\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    shape_denotation: Optional[List[str]] = None,\n) -> TypeProto:\n    \"\"\"Makes a Tensor TypeProto based on the data type and shape.\"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_tensor_type_proto",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_tensor_type_proto(\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    shape_denotation: Optional[List[str]] = None,\n) -> TypeProto:\n    \"\"\"Makes a Tensor TypeProto based on the data type and shape.\"\"\"\n    type_proto = TypeProto()\n    tensor_type_proto = type_proto.tensor_type\n    tensor_type_proto.elem_type = elem_type\n    tensor_shape_proto = tensor_type_proto.shape",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_tensor_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_tensor_value_info(\n    name: str,\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    doc_string: str = \"\",\n    shape_denotation: Optional[List[str]] = None,\n) -> ValueInfoProto:\n    \"\"\"Makes a ValueInfoProto based on the data type and shape.\"\"\"\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_sparse_tensor_type_proto",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_sparse_tensor_type_proto(\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    shape_denotation: Optional[List[str]] = None,\n) -> TypeProto:\n    \"\"\"Makes a SparseTensor TypeProto based on the data type and shape.\"\"\"\n    type_proto = TypeProto()\n    sparse_tensor_type_proto = type_proto.sparse_tensor_type\n    sparse_tensor_type_proto.elem_type = elem_type\n    sparse_tensor_shape_proto = sparse_tensor_type_proto.shape",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_sparse_tensor_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_sparse_tensor_value_info(\n    name: str,\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    doc_string: str = \"\",\n    shape_denotation: Optional[List[str]] = None,\n) -> ValueInfoProto:\n    \"\"\"Makes a SparseTensor ValueInfoProto based on the data type and shape.\"\"\"\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_sequence_type_proto",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_sequence_type_proto(\n    inner_type_proto: TypeProto,\n) -> TypeProto:\n    \"\"\"Makes a sequence TypeProto.\"\"\"\n    type_proto = TypeProto()\n    type_proto.sequence_type.elem_type.CopyFrom(inner_type_proto)\n    return type_proto\ndef make_optional_type_proto(\n    inner_type_proto: TypeProto,\n) -> TypeProto:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_optional_type_proto",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_optional_type_proto(\n    inner_type_proto: TypeProto,\n) -> TypeProto:\n    \"\"\"Makes an optional TypeProto.\"\"\"\n    type_proto = TypeProto()\n    type_proto.optional_type.elem_type.CopyFrom(inner_type_proto)\n    return type_proto\ndef make_value_info(\n    name: str,\n    type_proto: TypeProto,",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_value_info(\n    name: str,\n    type_proto: TypeProto,\n    doc_string: str = \"\",\n) -> ValueInfoProto:\n    \"\"\"Makes a ValueInfoProto with the given type_proto.\"\"\"\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name\n    if doc_string:\n        value_info_proto.doc_string = doc_string",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_tensor_sequence_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_tensor_sequence_value_info(\n    name: str,\n    elem_type: int,\n    shape: Optional[Sequence[Union[str, int, None]]],\n    doc_string: str = \"\",\n    elem_shape_denotation: Optional[List[str]] = None,\n) -> ValueInfoProto:\n    \"\"\"Makes a Sequence[Tensors] ValueInfoProto based on the data type and shape.\"\"\"\n    value_info_proto = ValueInfoProto()\n    value_info_proto.name = name",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_attribute",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_attribute(\n    attr: AttributeProto, subgraphs: bool = False\n) -> Union[str, Tuple[str, List[GraphProto]]]:\n    content = []\n    content.append(attr.name)\n    content.append(\"=\")\n    def str_float(f: float) -> str:\n        # NB: Different Python versions print different numbers of trailing\n        # decimals, specifying this explicitly keeps it consistent for all\n        # versions",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_dim",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_dim(dim: TensorShapeProto.Dimension) -> str:\n    which = dim.WhichOneof(\"value\")\n    if which is None:\n        raise TypeError(f\"which cannot be {None}.\")\n    return str(getattr(dim, which))\ndef printable_type(t: TypeProto) -> str:\n    if t.WhichOneof(\"value\") == \"tensor_type\":\n        s = TensorProto.DataType.Name(t.tensor_type.elem_type)\n        if t.tensor_type.HasField(\"shape\"):\n            if len(t.tensor_type.shape.dim):",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_type",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_type(t: TypeProto) -> str:\n    if t.WhichOneof(\"value\") == \"tensor_type\":\n        s = TensorProto.DataType.Name(t.tensor_type.elem_type)\n        if t.tensor_type.HasField(\"shape\"):\n            if len(t.tensor_type.shape.dim):\n                s += str(\", \" + \"x\".join(map(printable_dim, t.tensor_type.shape.dim)))\n            else:\n                s += \", scalar\"\n        return s\n    if t.WhichOneof(\"value\") is None:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_value_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_value_info(v: ValueInfoProto) -> str:\n    s = f\"%{v.name}\"\n    if v.type:\n        s = f\"{s}[{printable_type(v.type)}]\"\n    return s\ndef printable_tensor_proto(t: TensorProto) -> str:\n    s = f\"%{t.name}[\"\n    s += TensorProto.DataType.Name(t.data_type)\n    if t.dims is not None:\n        if len(t.dims):",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_tensor_proto",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_tensor_proto(t: TensorProto) -> str:\n    s = f\"%{t.name}[\"\n    s += TensorProto.DataType.Name(t.data_type)\n    if t.dims is not None:\n        if len(t.dims):\n            s += str(\", \" + \"x\".join(map(str, t.dims)))\n        else:\n            s += \", scalar\"\n    s += \"]\"\n    return s",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_node",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_node(\n    node: NodeProto, prefix: str = \"\", subgraphs: bool = False\n) -> Union[str, Tuple[str, List[GraphProto]]]:\n    content = []\n    if len(node.output):\n        content.append(\", \".join([f\"%{name}\" for name in node.output]))\n        content.append(\"=\")\n    # To deal with nested graphs\n    graphs: List[GraphProto] = []\n    printed_attrs = []",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "printable_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def printable_graph(graph: GraphProto, prefix: str = \"\") -> str:\n    \"\"\"\n    Display a GraphProto as a string.\n    Arguments:\n        graph (GraphProto): the graph to display\n        prefix (string): prefix of every line\n    Returns:\n        string\n    \"\"\"\n    content = []",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "strip_doc_string",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def strip_doc_string(proto: google.protobuf.message.Message) -> None:\n    \"\"\"\n    Empties `doc_string` field on any nested protobuf messages\n    \"\"\"\n    if not isinstance(proto, google.protobuf.message.Message):\n        raise TypeError(\n            f\"proto must be an instance of {google.protobuf.message.Message}.\"\n        )\n    for descriptor in proto.DESCRIPTOR.fields:\n        if descriptor.name == \"doc_string\":",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "make_training_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def make_training_info(\n    algorithm: GraphProto,\n    algorithm_bindings: AssignmentBindingType,\n    initialization: Optional[GraphProto],\n    initialization_bindings: Optional[AssignmentBindingType],\n) -> TrainingInfoProto:\n    training_info = TrainingInfoProto()\n    training_info.algorithm.CopyFrom(algorithm)\n    for k, v in algorithm_bindings:\n        binding = training_info.update_binding.add()",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "tensor_dtype_to_np_dtype",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def tensor_dtype_to_np_dtype(tensor_dtype: int) -> np.dtype:\n    \"\"\"\n    Convert a TensorProto's data_type to corresponding numpy dtype. It can be used while making tensor.\n    :param tensor_dtype: TensorProto's data_type\n    :return: numpy's data_type\n    \"\"\"\n    return mapping.TENSOR_TYPE_MAP[tensor_dtype].np_dtype\ndef tensor_dtype_to_storage_tensor_dtype(tensor_dtype: int) -> int:\n    \"\"\"\n    Convert a TensorProto's data_type to corresponding data_type for storage.",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "tensor_dtype_to_storage_tensor_dtype",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def tensor_dtype_to_storage_tensor_dtype(tensor_dtype: int) -> int:\n    \"\"\"\n    Convert a TensorProto's data_type to corresponding data_type for storage.\n    :param tensor_dtype: TensorProto's data_type\n    :return: data_type for storage\n    \"\"\"\n    return mapping.TENSOR_TYPE_MAP[tensor_dtype].storage_dtype\ndef tensor_dtype_to_string(tensor_dtype: int) -> str:\n    \"\"\"\n    Get the name of given TensorProto's data_type.",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "tensor_dtype_to_string",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def tensor_dtype_to_string(tensor_dtype: int) -> str:\n    \"\"\"\n    Get the name of given TensorProto's data_type.\n    :param tensor_dtype: TensorProto's data_type\n    :return: the name of data_type\n    \"\"\"\n    return mapping.TENSOR_TYPE_MAP[tensor_dtype].name\ndef tensor_dtype_to_field(tensor_dtype: int) -> str:\n    \"\"\"\n    Convert a TensorProto's data_type to corresponding field name for storage. It can be used while making tensors.",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "tensor_dtype_to_field",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def tensor_dtype_to_field(tensor_dtype: int) -> str:\n    \"\"\"\n    Convert a TensorProto's data_type to corresponding field name for storage. It can be used while making tensors.\n    :param tensor_dtype: TensorProto's data_type\n    :return: field name\n    \"\"\"\n    return mapping._STORAGE_TENSOR_TYPE_TO_FIELD[  # pylint: disable=protected-access\n        mapping.TENSOR_TYPE_MAP[tensor_dtype].storage_dtype\n    ]\ndef np_dtype_to_tensor_dtype(np_dtype: np.dtype) -> int:",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "np_dtype_to_tensor_dtype",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def np_dtype_to_tensor_dtype(np_dtype: np.dtype) -> int:\n    \"\"\"\n    Convert a numpy's dtype to corresponding tensor type. It can be used while converting numpy arrays to tensors.\n    :param np_dtype: numpy's data_type\n    :return: TensorsProto's data_type\n    \"\"\"\n    return cast(\n        int,\n        mapping._NP_TYPE_TO_TENSOR_TYPE[np_dtype],  # pylint: disable=protected-access\n    )",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "get_all_tensor_dtypes",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "def get_all_tensor_dtypes() -> KeysView[int]:\n    \"\"\"\n    Get all tensor types from TensorProto.\n    :return: all tensor types from TensorProto\n    \"\"\"\n    return mapping.TENSOR_TYPE_MAP.keys()",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "VersionRowType",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "VersionRowType = Union[Tuple[str, int, int, int], Tuple[str, int, int, int, int]]\nVersionTableType = List[VersionRowType]\nAssignmentBindingType = List[Tuple[str, str]]\n# This is a copy of the documented version in https://github.com/onnx/onnx/blob/main/docs/Versioning.md#released-versions\n# Both must be updated whenever a new version of ONNX is released.\nVERSION_TABLE: VersionTableType = [\n    # Release-version, IR version, ai.onnx version, ai.onnx.ml version, (optional) ai.onnx.training version\n    (\"1.0\", 3, 1, 1),\n    (\"1.1\", 3, 5, 1),\n    (\"1.1.2\", 3, 6, 1),",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "VersionTableType",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "VersionTableType = List[VersionRowType]\nAssignmentBindingType = List[Tuple[str, str]]\n# This is a copy of the documented version in https://github.com/onnx/onnx/blob/main/docs/Versioning.md#released-versions\n# Both must be updated whenever a new version of ONNX is released.\nVERSION_TABLE: VersionTableType = [\n    # Release-version, IR version, ai.onnx version, ai.onnx.ml version, (optional) ai.onnx.training version\n    (\"1.0\", 3, 1, 1),\n    (\"1.1\", 3, 5, 1),\n    (\"1.1.2\", 3, 6, 1),\n    (\"1.2\", 3, 7, 1),",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "AssignmentBindingType",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "AssignmentBindingType = List[Tuple[str, str]]\n# This is a copy of the documented version in https://github.com/onnx/onnx/blob/main/docs/Versioning.md#released-versions\n# Both must be updated whenever a new version of ONNX is released.\nVERSION_TABLE: VersionTableType = [\n    # Release-version, IR version, ai.onnx version, ai.onnx.ml version, (optional) ai.onnx.training version\n    (\"1.0\", 3, 1, 1),\n    (\"1.1\", 3, 5, 1),\n    (\"1.1.2\", 3, 6, 1),\n    (\"1.2\", 3, 7, 1),\n    (\"1.3\", 3, 8, 1),",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "VersionMapType",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "VersionMapType = Dict[Tuple[str, int], int]\ndef create_op_set_id_version_map(table: VersionTableType) -> VersionMapType:\n    \"\"\"create a map from (opset-domain, opset-version) to ir-version from above table\"\"\"\n    result: VersionMapType = {}\n    def process(release_version: str, ir_version: int, *args: Any) -> None:\n        del release_version  # Unused\n        for pair in zip([\"ai.onnx\", \"ai.onnx.ml\", \"ai.onnx.training\"], args):\n            if pair not in result:\n                result[pair] = ir_version\n                if pair[0] == \"ai.onnx.training\":",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "OP_SET_ID_VERSION_MAP",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.helper",
        "description": "catboost.contrib.libs.onnx.onnx.helper",
        "peekOfCode": "OP_SET_ID_VERSION_MAP = create_op_set_id_version_map(VERSION_TABLE)\ndef find_min_ir_version_for(\n    opsetidlist: List[OperatorSetIdProto], ignore_unknown: bool = False\n) -> int:\n    \"\"\"Given list of opset ids, determine minimum IR version required.\n    Arguments:\n        opsetidlist (List[OperatorSetIdProto]): The list of OperatorSetIdProto\n        ignore_unknown (bool): If True, ignore unknown domain and return default min version for that domain.\n    Returns:\n        The minimum IR version required (integer)",
        "detail": "catboost.contrib.libs.onnx.onnx.helper",
        "documentation": {}
    },
    {
        "label": "ModelInfo",
        "kind": 6,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "class ModelInfo:\n    \"\"\"\n    A class to represent a model's property and metadata in the ONNX Hub.\n    It extracts model name, path, sha, tags, etc. from the passed in raw_model_info dict.\n    Attributes:\n        model: The name of the model.\n        model_path: The path to the model, relative to the model zoo (https://github.com/onnx/models/) repo root.\n        metadata: Additional metadata of the model, such as the size of the model, IO ports, etc.\n        model_sha: The SHA256 digest of the model file.\n        tags: A set of tags associated with the model.",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "set_dir",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def set_dir(new_dir: str) -> None:\n    \"\"\"\n    Sets the current ONNX hub cache location\n    :param new_dir: location of new model hub cache\n    \"\"\"\n    global _ONNX_HUB_DIR  # pylint: disable=global-statement\n    _ONNX_HUB_DIR = new_dir\ndef get_dir() -> str:\n    \"\"\"\n    Gets the current ONNX hub cache location",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "get_dir",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def get_dir() -> str:\n    \"\"\"\n    Gets the current ONNX hub cache location\n    :return: The location of the ONNX hub model cache\n    \"\"\"\n    return _ONNX_HUB_DIR\ndef _parse_repo_info(repo: str) -> Tuple[str, str, str]:\n    \"\"\"\n    Gets the repo owner, name and ref from a repo specification string.\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "list_models",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def list_models(\n    repo: str = \"onnx/models:main\",\n    model: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n) -> List[ModelInfo]:\n    \"\"\"\n    Gets the list of model info consistent with a given name and tags\n    :param repo: The location of the model repo in format \"user/repo[:branch]\".\n        If no branch is found will default to \"main\"\n    :param model: The name of the model to search for. If `None`, will return all models with matching tags.",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "get_model_info",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def get_model_info(\n    model: str, repo: str = \"onnx/models:main\", opset: Optional[int] = None\n) -> ModelInfo:\n    \"\"\"\n    Gets the model info matching the given name and opset.\n    :param model: The name of the onnx model in the manifest. This field is case-sensitive\n    :param repo: The location of the model repo in format \"user/repo[:branch]\".\n        If no branch is found will default to \"main\"\n    :param opset: The opset of the model to get. The default of `None` will return the model with largest opset.\n    :return: ModelInfo",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def load(\n    model: str,\n    repo: str = \"onnx/models:main\",\n    opset: Optional[int] = None,\n    force_reload: bool = False,\n    silent: bool = False,\n) -> Optional[onnx.ModelProto]:\n    \"\"\"\n    Downloads a model by name from the onnx model hub\n    :param model: The name of the onnx model in the manifest. This field is case-sensitive",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "download_model_with_test_data",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def download_model_with_test_data(\n    model: str,\n    repo: str = \"onnx/models:main\",\n    opset: Optional[int] = None,\n    force_reload: bool = False,\n    silent: bool = False,\n) -> Optional[str]:\n    \"\"\"\n    Downloads a model along with test data by name from the onnx model hub and returns the directory to which the files have been extracted.\n    :param model: The name of the onnx model in the manifest. This field is case-sensitive",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "load_composite_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.hub",
        "description": "catboost.contrib.libs.onnx.onnx.hub",
        "peekOfCode": "def load_composite_model(\n    network_model: str,\n    preprocessing_model: str,\n    network_repo: str = \"onnx/models:main\",\n    preprocessing_repo: str = \"onnx/models:main\",\n    opset: Optional[int] = None,\n    force_reload: bool = False,\n    silent: bool = False,\n) -> Optional[onnx.ModelProto]:\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.hub",
        "documentation": {}
    },
    {
        "label": "DeprecatedWarningDict",
        "kind": 6,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "class DeprecatedWarningDict(dict):  # type: ignore\n    def __init__(\n        self,\n        dictionary: Dict[int, Union[int, str, np.dtype]],\n        original_function: str,\n        future_function: str = \"\",\n    ) -> None:\n        super().__init__(dictionary)\n        self._origin_function = original_function\n        self._future_function = future_function",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "TensorDtypeMap",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "TensorDtypeMap = NamedTuple(\n    \"TensorDtypeMap\", [(\"np_dtype\", np.dtype), (\"storage_dtype\", int), (\"name\", str)]\n)\n# tensor_dtype: (numpy type, storage type, string name)\nTENSOR_TYPE_MAP = {\n    int(TensorProto.FLOAT): TensorDtypeMap(\n        np.dtype(\"float32\"), int(TensorProto.FLOAT), \"TensorProto.FLOAT\"\n    ),\n    int(TensorProto.UINT8): TensorDtypeMap(\n        np.dtype(\"uint8\"), int(TensorProto.INT32), \"TensorProto.UINT8\"",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "TENSOR_TYPE_MAP",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "TENSOR_TYPE_MAP = {\n    int(TensorProto.FLOAT): TensorDtypeMap(\n        np.dtype(\"float32\"), int(TensorProto.FLOAT), \"TensorProto.FLOAT\"\n    ),\n    int(TensorProto.UINT8): TensorDtypeMap(\n        np.dtype(\"uint8\"), int(TensorProto.INT32), \"TensorProto.UINT8\"\n    ),\n    int(TensorProto.INT8): TensorDtypeMap(\n        np.dtype(\"int8\"), int(TensorProto.INT32), \"TensorProto.INT8\"\n    ),",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "TENSOR_TYPE_TO_NP_TYPE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "TENSOR_TYPE_TO_NP_TYPE = DeprecatedWarningDict(\n    {tensor_dtype: value.np_dtype for tensor_dtype, value in TENSOR_TYPE_MAP.items()},\n    \"TENSOR_TYPE_TO_NP_TYPE\",\n    \"tensor_dtype_to_np_dtype\",\n)\n# This is only used to get keys into STORAGE_TENSOR_TYPE_TO_FIELD.\n# TODO(https://github.com/onnx/onnx/issues/4554): Move these variables into _mapping.py\nTENSOR_TYPE_TO_STORAGE_TENSOR_TYPE = DeprecatedWarningDict(\n    {\n        tensor_dtype: value.storage_dtype",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "TENSOR_TYPE_TO_STORAGE_TENSOR_TYPE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "TENSOR_TYPE_TO_STORAGE_TENSOR_TYPE = DeprecatedWarningDict(\n    {\n        tensor_dtype: value.storage_dtype\n        for tensor_dtype, value in TENSOR_TYPE_MAP.items()\n    },\n    \"TENSOR_TYPE_TO_STORAGE_TENSOR_TYPE\",\n    \"tensor_dtype_to_storage_tensor_dtype\",\n)\n# NP_TYPE_TO_TENSOR_TYPE will be eventually removed in the future\n# and _NP_TYPE_TO_TENSOR_TYPE will only be used internally",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "_NP_TYPE_TO_TENSOR_TYPE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "_NP_TYPE_TO_TENSOR_TYPE = {\n    v: k\n    for k, v in TENSOR_TYPE_TO_NP_TYPE.items()\n    if k\n    not in (\n        TensorProto.BFLOAT16,\n        TensorProto.FLOAT8E4M3FN,\n        TensorProto.FLOAT8E4M3FNUZ,\n        TensorProto.FLOAT8E5M2,\n        TensorProto.FLOAT8E5M2FNUZ,",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "NP_TYPE_TO_TENSOR_TYPE",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "NP_TYPE_TO_TENSOR_TYPE = DeprecatedWarningDict(\n    cast(Dict[int, Union[int, str, Any]], _NP_TYPE_TO_TENSOR_TYPE),\n    \"NP_TYPE_TO_TENSOR_TYPE\",\n    \"np_dtype_to_tensor_dtype\",\n)\n# STORAGE_TENSOR_TYPE_TO_FIELD will be eventually removed in the future\n# and _STORAGE_TENSOR_TYPE_TO_FIELD will only be used internally\n_STORAGE_TENSOR_TYPE_TO_FIELD = {\n    int(TensorProto.FLOAT): \"float_data\",\n    int(TensorProto.INT32): \"int32_data\",",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "_STORAGE_TENSOR_TYPE_TO_FIELD",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "_STORAGE_TENSOR_TYPE_TO_FIELD = {\n    int(TensorProto.FLOAT): \"float_data\",\n    int(TensorProto.INT32): \"int32_data\",\n    int(TensorProto.INT64): \"int64_data\",\n    int(TensorProto.UINT8): \"int32_data\",\n    int(TensorProto.UINT16): \"int32_data\",\n    int(TensorProto.DOUBLE): \"double_data\",\n    int(TensorProto.COMPLEX64): \"float_data\",\n    int(TensorProto.COMPLEX128): \"double_data\",\n    int(TensorProto.UINT32): \"uint64_data\",",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "STORAGE_TENSOR_TYPE_TO_FIELD",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "STORAGE_TENSOR_TYPE_TO_FIELD = DeprecatedWarningDict(\n    cast(Dict[int, Union[int, str, Any]], _STORAGE_TENSOR_TYPE_TO_FIELD),\n    \"STORAGE_TENSOR_TYPE_TO_FIELD\",\n)\n# This map will be removed and there is no replacement for it\nSTORAGE_ELEMENT_TYPE_TO_FIELD = DeprecatedWarningDict(\n    {\n        int(SequenceProto.TENSOR): \"tensor_values\",\n        int(SequenceProto.SPARSE_TENSOR): \"sparse_tensor_values\",\n        int(SequenceProto.SEQUENCE): \"sequence_values\",",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "STORAGE_ELEMENT_TYPE_TO_FIELD",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "STORAGE_ELEMENT_TYPE_TO_FIELD = DeprecatedWarningDict(\n    {\n        int(SequenceProto.TENSOR): \"tensor_values\",\n        int(SequenceProto.SPARSE_TENSOR): \"sparse_tensor_values\",\n        int(SequenceProto.SEQUENCE): \"sequence_values\",\n        int(SequenceProto.MAP): \"map_values\",\n        int(OptionalProto.OPTIONAL): \"optional_value\",\n    },\n    \"STORAGE_ELEMENT_TYPE_TO_FIELD\",\n)",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "OPTIONAL_ELEMENT_TYPE_TO_FIELD",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.mapping",
        "description": "catboost.contrib.libs.onnx.onnx.mapping",
        "peekOfCode": "OPTIONAL_ELEMENT_TYPE_TO_FIELD = DeprecatedWarningDict(\n    {\n        int(OptionalProto.TENSOR): \"tensor_value\",\n        int(OptionalProto.SPARSE_TENSOR): \"sparse_tensor_value\",\n        int(OptionalProto.SEQUENCE): \"sequence_value\",\n        int(OptionalProto.MAP): \"map_value\",\n        int(OptionalProto.OPTIONAL): \"optional_value\",\n    },\n    \"OPTIONAL_ELEMENT_TYPE_TO_FIELD\",\n)",
        "detail": "catboost.contrib.libs.onnx.onnx.mapping",
        "documentation": {}
    },
    {
        "label": "combine_pairs_to_complex",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def combine_pairs_to_complex(fa: Sequence[int]) -> List[complex]:\n    return [complex(fa[i * 2], fa[i * 2 + 1]) for i in range(len(fa) // 2)]\ndef bfloat16_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of bf16 (as uint32) to f32 (as uint32).\n    :param data: a numpy array, empty dimensions are allowed if dims is None\n    :param dims: if specified, the function reshapes the results\n    :return: a numpy array of float32 with the same dimension if dims is None,",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "bfloat16_to_float32",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def bfloat16_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of bf16 (as uint32) to f32 (as uint32).\n    :param data: a numpy array, empty dimensions are allowed if dims is None\n    :param dims: if specified, the function reshapes the results\n    :return: a numpy array of float32 with the same dimension if dims is None,\n        or reshaped to dims if specified\"\"\"\n    shift = lambda x: x << 16  # noqa: E731",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "float8e4m3_to_float32",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def float8e4m3_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n    fn: bool = True,\n    uz: bool = False,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of float8, e4m3 (as uint32) to f32 (as uint32).\n    :param data: a numpy array, empty dimensions are allowed if dims is None\n    :param dims: if specified, the function reshapes the results\n    :param fn: no infinite values",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "float8e5m2_to_float32",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def float8e5m2_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n    fn: bool = False,\n    uz: bool = False,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of float8, e5m2 (as uint32) to f32 (as uint32).\n    :param data: a numpy array, empty dimensions are allowed if dims is None\n    :param dims: if specified, the function reshapes the results\n    :param fn: no infinite values",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "to_array",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def to_array(  # pylint: disable=too-many-branches\n    tensor: TensorProto, base_dir: str = \"\"\n) -> np.ndarray:\n    \"\"\"Converts a tensor def object to a numpy array.\n    Args:\n        tensor: a TensorProto object.\n        base_dir: if external tensor exists, base_dir can help to find the path to it\n    Returns:\n        arr: the converted array.\n    \"\"\"",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "from_array",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def from_array(arr: np.ndarray, name: Optional[str] = None) -> TensorProto:\n    \"\"\"Converts a numpy array to a tensor def.\n    Args:\n        arr: a numpy array.\n        name: (optional) the name of the tensor.\n    Returns:\n        TensorProto: the converted tensor def.\n    \"\"\"\n    tensor = TensorProto()\n    tensor.dims.extend(arr.shape)",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "to_list",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def to_list(sequence: SequenceProto) -> List[Any]:\n    \"\"\"Converts a sequence def to a Python list.\n    Args:\n        sequence: a SequenceProto object.\n    Returns:\n        list: the converted list.\n    \"\"\"\n    elem_type = sequence.elem_type\n    if elem_type == SequenceProto.TENSOR:\n        return [to_array(v) for v in sequence.tensor_values]  # type: ignore[arg-type]",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "from_list",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def from_list(  # pylint: disable=too-many-branches\n    lst: List[Any], name: Optional[str] = None, dtype: Optional[int] = None\n) -> SequenceProto:  # pylint: disable=too-many-branches\n    \"\"\"Converts a list into a sequence def.\n    Args:\n        lst: a Python list\n        name: (optional) the name of the sequence.\n        dtype: (optional) type of element in the input list, used for specifying\n                          sequence values when converting an empty list.\n    Returns:",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "to_dict",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def to_dict(map_proto: MapProto) -> Dict[Any, Any]:\n    \"\"\"Converts a map def to a Python dictionary.\n    Args:\n        map: a MapProto object.\n    Returns:\n        dict: the converted dictionary.\n    \"\"\"\n    key_list: List[Any] = []\n    if map_proto.key_type == TensorProto.STRING:\n        key_list = list(map_proto.string_keys)",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "from_dict",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def from_dict(dict_: Dict[Any, Any], name: Optional[str] = None) -> MapProto:\n    \"\"\"Converts a Python dictionary into a map def.\n    Args:\n        dict: Python dictionary\n        name: (optional) the name of the map.\n    Returns:\n        MapProto: the converted map def.\n    \"\"\"\n    map_proto = MapProto()\n    if name:",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "to_optional",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def to_optional(optional: OptionalProto) -> Optional[Any]:\n    \"\"\"Converts an optional def to a Python optional.\n    Args:\n        optional: an OptionalProto object.\n    Returns:\n        opt: the converted optional.\n    \"\"\"\n    elem_type = optional.elem_type\n    if elem_type == OptionalProto.UNDEFINED:\n        return None",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "from_optional",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def from_optional(\n    opt: Optional[Any], name: Optional[str] = None, dtype: Optional[int] = None\n) -> OptionalProto:\n    \"\"\"Converts an optional value into a Optional def.\n    Args:\n        opt: a Python optional\n        name: (optional) the name of the optional.\n        dtype: (optional) type of element in the input, used for specifying\n                          optional values when converting empty none. dtype must\n                          be a valid OptionalProto.DataType value",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "convert_endian",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def convert_endian(tensor: TensorProto) -> None:\n    \"\"\"\n    Call to convert endianess of raw data in tensor.\n    Arguments:\n        tensor (TensorProto): TensorProto to be converted.\n    \"\"\"\n    tensor_dtype = tensor.data_type\n    np_dtype = helper.tensor_dtype_to_np_dtype(tensor_dtype)\n    tensor.raw_data = (\n        np.frombuffer(tensor.raw_data, dtype=np_dtype).byteswap().tobytes()",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "create_random_int",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "def create_random_int(\n    input_shape: Tuple[int], dtype: np.dtype, seed: int = 1\n) -> np.ndarray:\n    \"\"\"\n    Create random integer array for backend/test/case/node.\n    Args:\n        input_shape: specify the shape for the returned integer array.\n        dtype: specify the NumPy data type for the returned integer array.\n        seed: (optional) the seed for np.random.\n    Returns:",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "_float8e4m3_to_float32",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "_float8e4m3_to_float32 = np.vectorize(\n    _float8e4m3_to_float32_scalar, excluded=[\"fn\", \"uz\"]\n)\ndef float8e4m3_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n    fn: bool = True,\n    uz: bool = False,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of float8, e4m3 (as uint32) to f32 (as uint32).",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "_float8e5m2_to_float32",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "description": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "peekOfCode": "_float8e5m2_to_float32 = np.vectorize(\n    _float8e5m2_to_float32_scalar, excluded=[\"fn\", \"uz\"]\n)\ndef float8e5m2_to_float32(\n    data: Union[np.int16, np.int32, np.ndarray],\n    dims: Optional[Union[int, Sequence[int]]] = None,\n    fn: bool = False,\n    uz: bool = False,\n) -> np.ndarray:\n    \"\"\"Converts ndarray of float8, e5m2 (as uint32) to f32 (as uint32).",
        "detail": "catboost.contrib.libs.onnx.onnx.numpy_helper",
        "documentation": {}
    },
    {
        "label": "ParseError",
        "kind": 6,
        "importPath": "catboost.contrib.libs.onnx.onnx.parser",
        "description": "catboost.contrib.libs.onnx.onnx.parser",
        "peekOfCode": "class ParseError(Exception):\n    pass\ndef parse_model(model_text: str) -> onnx.ModelProto:\n    \"\"\"Parse a string to build a ModelProto.\n    Arguments:\n        model_text (string): formatted string\n    Returns:\n        ModelProto\n    \"\"\"\n    (success, msg, model_proto_str) = C.parse_model(model_text)",
        "detail": "catboost.contrib.libs.onnx.onnx.parser",
        "documentation": {}
    },
    {
        "label": "parse_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.parser",
        "description": "catboost.contrib.libs.onnx.onnx.parser",
        "peekOfCode": "def parse_model(model_text: str) -> onnx.ModelProto:\n    \"\"\"Parse a string to build a ModelProto.\n    Arguments:\n        model_text (string): formatted string\n    Returns:\n        ModelProto\n    \"\"\"\n    (success, msg, model_proto_str) = C.parse_model(model_text)\n    if success:\n        return onnx.load_from_string(model_proto_str)",
        "detail": "catboost.contrib.libs.onnx.onnx.parser",
        "documentation": {}
    },
    {
        "label": "parse_graph",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.parser",
        "description": "catboost.contrib.libs.onnx.onnx.parser",
        "peekOfCode": "def parse_graph(graph_text: str) -> onnx.GraphProto:\n    \"\"\"Parse a string to build a GraphProto.\n    Arguments:\n        graph_text (string): formatted string\n    Returns:\n        GraphProto\n    \"\"\"\n    (success, msg, graph_proto_str) = C.parse_graph(graph_text)\n    if success:\n        graph_proto = onnx.GraphProto()",
        "detail": "catboost.contrib.libs.onnx.onnx.parser",
        "documentation": {}
    },
    {
        "label": "parse_function",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.parser",
        "description": "catboost.contrib.libs.onnx.onnx.parser",
        "peekOfCode": "def parse_function(function_text: str) -> onnx.FunctionProto:\n    \"\"\"Parse a string to build a FunctionProto.\n    Arguments:\n        function_text (string): formatted string\n    Returns:\n        FunctionProto\n    \"\"\"\n    (success, msg, function_proto_str) = C.parse_function(function_text)\n    if success:\n        function_proto = onnx.FunctionProto()",
        "detail": "catboost.contrib.libs.onnx.onnx.parser",
        "documentation": {}
    },
    {
        "label": "parse_node",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.parser",
        "description": "catboost.contrib.libs.onnx.onnx.parser",
        "peekOfCode": "def parse_node(node_text: str) -> onnx.NodeProto:\n    \"\"\"Parse a string to build a NodeProto.\n    Arguments:\n        node_text: formatted string\n    Returns:\n        NodeProto\n    \"\"\"\n    (success, msg, node_proto_str) = C.parse_node(node_text)\n    if success:\n        node_proto = onnx.NodeProto()",
        "detail": "catboost.contrib.libs.onnx.onnx.parser",
        "documentation": {}
    },
    {
        "label": "to_text",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.printer",
        "description": "catboost.contrib.libs.onnx.onnx.printer",
        "peekOfCode": "def to_text(proto: Union[onnx.ModelProto, onnx.FunctionProto, onnx.GraphProto]) -> str:\n    if isinstance(proto, onnx.ModelProto):\n        return C.model_to_text(proto.SerializeToString())\n    if isinstance(proto, onnx.FunctionProto):\n        return C.function_to_text(proto.SerializeToString())\n    if isinstance(proto, onnx.GraphProto):\n        return C.graph_to_text(proto.SerializeToString())\n    raise TypeError(\"Unsupported argument type.\")",
        "detail": "catboost.contrib.libs.onnx.onnx.printer",
        "documentation": {}
    },
    {
        "label": "infer_shapes",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "description": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "peekOfCode": "def infer_shapes(\n    model: Union[ModelProto, bytes],\n    check_type: bool = False,\n    strict_mode: bool = False,\n    data_prop: bool = False,\n) -> ModelProto:\n    \"\"\"Apply shape inference to the provided ModelProto.\n    Inferred shapes are added to the value_info field of the graph.\n    If the inferred values conflict with values already provided in the\n    graph, that means that the provided values are invalid (or there is a",
        "detail": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "infer_shapes_path",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "description": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "peekOfCode": "def infer_shapes_path(\n    model_path: str,\n    output_path: str = \"\",\n    check_type: bool = False,\n    strict_mode: bool = False,\n    data_prop: bool = False,\n) -> None:\n    \"\"\"\n    Take model path for shape_inference same as infer_shape; it support >2GB models\n    Directly output the inferred model to the output_path; Default is the original model path",
        "detail": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "infer_node_outputs",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "description": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "peekOfCode": "def infer_node_outputs(\n    schema: onnx.defs.OpSchema,\n    node: onnx.NodeProto,\n    input_types: Dict[str, onnx.TypeProto],\n    input_data: Optional[Dict[str, onnx.TensorProto]] = None,\n    input_sparse_data: Optional[Dict[str, onnx.SparseTensorProto]] = None,\n    opset_imports: Optional[List[onnx.OperatorSetIdProto]] = None,\n    ir_version: int = onnx.IR_VERSION,\n) -> Dict[str, onnx.TypeProto]:\n    if not schema.has_type_and_shape_inference_function:  # type: ignore",
        "detail": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "infer_function_output_types",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "description": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "peekOfCode": "def infer_function_output_types(\n    function: FunctionProto,\n    input_types: Sequence[TypeProto],\n    attributes: Sequence[AttributeProto],\n) -> List[TypeProto]:\n    \"\"\"\n    Apply type-and-shape-inference to given function body, with given input types\n    and given input attribute values.\n    \"\"\"\n    result = C.infer_function_output_types(",
        "detail": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "InferenceError",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "description": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "peekOfCode": "InferenceError = C.InferenceError",
        "detail": "catboost.contrib.libs.onnx.onnx.shape_inference",
        "documentation": {}
    },
    {
        "label": "Extractor",
        "kind": 6,
        "importPath": "catboost.contrib.libs.onnx.onnx.utils",
        "description": "catboost.contrib.libs.onnx.onnx.utils",
        "peekOfCode": "class Extractor:\n    def __init__(self, model: ModelProto) -> None:\n        self.model = onnx.shape_inference.infer_shapes(model)\n        self.graph = self.model.graph\n        self.wmap = self._build_name2obj_dict(self.graph.initializer)\n        self.vimap = self._build_name2obj_dict(self.graph.value_info)\n    @staticmethod\n    def _build_name2obj_dict(objs):  # type: ignore\n        return {obj.name: obj for obj in objs}\n    def _collect_new_io_core(self, original_io, io_names_to_extract):  # type: ignore",
        "detail": "catboost.contrib.libs.onnx.onnx.utils",
        "documentation": {}
    },
    {
        "label": "extract_model",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.utils",
        "description": "catboost.contrib.libs.onnx.onnx.utils",
        "peekOfCode": "def extract_model(\n    input_path: str,\n    output_path: str,\n    input_names: List[str],\n    output_names: List[str],\n    check_model: bool = True,\n) -> None:\n    \"\"\"Extracts sub-model from an ONNX model.\n    The sub-model is defined by the names of the input and output tensors *exactly*.\n    Note: For control-flow operators, e.g. If and Loop, the _boundary of sub-model_,",
        "detail": "catboost.contrib.libs.onnx.onnx.utils",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.version",
        "description": "catboost.contrib.libs.onnx.onnx.version",
        "peekOfCode": "version = \"1.14.1\"\ngit_version = \"None\"",
        "detail": "catboost.contrib.libs.onnx.onnx.version",
        "documentation": {}
    },
    {
        "label": "git_version",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.version",
        "description": "catboost.contrib.libs.onnx.onnx.version",
        "peekOfCode": "git_version = \"None\"",
        "detail": "catboost.contrib.libs.onnx.onnx.version",
        "documentation": {}
    },
    {
        "label": "convert_version",
        "kind": 2,
        "importPath": "catboost.contrib.libs.onnx.onnx.version_converter",
        "description": "catboost.contrib.libs.onnx.onnx.version_converter",
        "peekOfCode": "def convert_version(model: ModelProto, target_version: int) -> ModelProto:\n    \"\"\"Apply the version conversion on the serialized ModelProto.\n    Arguments:\n        input (ModelProto): model\n        target_version (int): target opset version\n    Returns:\n        return (ModelProto) converted model\n    Raises Exceptions:\n        RuntimeError when some necessary conversion is not supported\n    Supported adapters:",
        "detail": "catboost.contrib.libs.onnx.onnx.version_converter",
        "documentation": {}
    },
    {
        "label": "ConvertError",
        "kind": 5,
        "importPath": "catboost.contrib.libs.onnx.onnx.version_converter",
        "description": "catboost.contrib.libs.onnx.onnx.version_converter",
        "peekOfCode": "ConvertError = C.ConvertError",
        "detail": "catboost.contrib.libs.onnx.onnx.version_converter",
        "documentation": {}
    },
    {
        "label": "with_metaclass",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "peekOfCode": "def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a\n    # dummy metaclass for one level of class instantiation that replaces\n    # itself with the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            return meta(name, bases, d)\n    return type.__new__(metaclass, \"temporary_class\", (), {})\ntry:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nPYPY = hasattr(sys, \"pypy_translation_info\")\n_identity = lambda x: x\nif not PY2:\n    unichr = chr\n    range_type = range\n    text_type = str\n    string_types = (str,)\n    integer_types = (int,)\n    iterkeys = lambda d: iter(d.keys())",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "documentation": {}
    },
    {
        "label": "PYPY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "peekOfCode": "PYPY = hasattr(sys, \"pypy_translation_info\")\n_identity = lambda x: x\nif not PY2:\n    unichr = chr\n    range_type = range\n    text_type = str\n    string_types = (str,)\n    integer_types = (int,)\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "documentation": {}
    },
    {
        "label": "_identity",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "peekOfCode": "_identity = lambda x: x\nif not PY2:\n    unichr = chr\n    range_type = range\n    text_type = str\n    string_types = (str,)\n    integer_types = (int,)\n    iterkeys = lambda d: iter(d.keys())\n    itervalues = lambda d: iter(d.values())\n    iteritems = lambda d: iter(d.items())",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2._compat",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2._identifier",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2._identifier",
        "peekOfCode": "pattern = re.compile(\n    r\"[\\w·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣔ-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఃా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣංඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ູົຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-᪽ᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰℘℮⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣠-꣱ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯︳︴﹍-﹏＿𐇽𐋠𐍶-𐍺𐨁-𐨃𐨅𐨆𐨌-𐨏𐨸-𐨿𐨺𐫦𐫥𑀀-𑀂𑀸-𑁆𑁿-𑂂𑂰-𑂺𑄀-𑄂𑄧-𑅳𑄴𑆀-𑆂𑆳-𑇊𑇀-𑇌𑈬-𑈷𑈾𑋟-𑋪𑌀-𑌃𑌼𑌾-𑍄𑍇𑍈𑍋-𑍍𑍗𑍢𑍣𑍦-𑍬𑍰-𑍴𑐵-𑑆𑒰-𑓃𑖯-𑖵𑖸-𑗀𑗜𑗝𑘰-𑙀𑚫-𑚷𑜝-𑜫𑰯-𑰶𑰸-𑰿𑲒-𑲧𑲩-𑲶𖫰-𖫴𖬰-𖬶𖽑-𖽾𖾏-𖾒𛲝𛲞𝅥-𝅩𝅭-𝅲𝅻-𝆂𝆅-𝆋𝆪-𝆭𝉂-𝉄𝨀-𝨶𝨻-𝩬𝩵𝪄𝪛-𝪟𝪡-𝪯𞀀-𞀆𞀈-𞀘𞀛-𞀡𞀣𞀤𞀦-𞣐𞀪-𞣖𞥄-𞥊󠄀-󠇯]+\"  # noqa: B950\n)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2._identifier",
        "documentation": {}
    },
    {
        "label": "Bucket",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "class Bucket(object):\n    \"\"\"Buckets are used to store the bytecode for one template.  It's created\n    and initialized by the bytecode cache and passed to the loading functions.\n    The buckets get an internal checksum from the cache assigned and use this\n    to automatically reject outdated cache material.  Individual bytecode\n    cache subclasses don't have to care about cache invalidation.\n    \"\"\"\n    def __init__(self, environment, key, checksum):\n        self.environment = environment\n        self.key = key",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "BytecodeCache",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "class BytecodeCache(object):\n    \"\"\"To implement your own bytecode cache you have to subclass this class\n    and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of\n    these methods are passed a :class:`~jinja2.bccache.Bucket`.\n    A very basic bytecode cache that saves the bytecode on the file system::\n        from os import path\n        class MyCache(BytecodeCache):\n            def __init__(self, directory):\n                self.directory = directory\n            def load_bytecode(self, bucket):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "FileSystemBytecodeCache",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "class FileSystemBytecodeCache(BytecodeCache):\n    \"\"\"A bytecode cache that stores bytecode on the filesystem.  It accepts\n    two arguments: The directory where the cache items are stored and a\n    pattern string that is used to build the filename.\n    If no directory is specified a default cache directory is selected.  On\n    Windows the user's temp directory is used, on UNIX systems a directory\n    is created for the user in the system temp directory.\n    The pattern can be used to have multiple separate caches operate on the\n    same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``\n    is replaced with the cache key.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "MemcachedBytecodeCache",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "class MemcachedBytecodeCache(BytecodeCache):\n    \"\"\"This class implements a bytecode cache that uses a memcache cache for\n    storing the information.  It does not enforce a specific memcache library\n    (tummy's memcache or cmemcache) but will accept any class that provides\n    the minimal interface required.\n    Libraries compatible with this class:\n    -   `cachelib <https://github.com/pallets/cachelib>`_\n    -   `python-memcached <https://pypi.org/project/python-memcached/>`_\n    (Unfortunately the django cache interface is not compatible because it\n    does not support storing binary data, only unicode.  You can however pass",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "bc_version",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "bc_version = 4\n# Magic bytes to identify Jinja bytecode cache files. Contains the\n# Python major and minor version to avoid loading incompatible bytecode\n# if a project upgrades its Python version.\nbc_magic = (\n    b\"j2\"\n    + pickle.dumps(bc_version, 2)\n    + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)\n)\nclass Bucket(object):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "bc_magic",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "peekOfCode": "bc_magic = (\n    b\"j2\"\n    + pickle.dumps(bc_version, 2)\n    + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)\n)\nclass Bucket(object):\n    \"\"\"Buckets are used to store the bytecode for one template.  It's created\n    and initialized by the bytecode cache and passed to the loading functions.\n    The buckets get an internal checksum from the cache assigned and use this\n    to automatically reject outdated cache material.  Individual bytecode",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.bccache",
        "documentation": {}
    },
    {
        "label": "MacroRef",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class MacroRef(object):\n    def __init__(self, node):\n        self.node = node\n        self.accesses_caller = False\n        self.accesses_kwargs = False\n        self.accesses_varargs = False\nclass Frame(object):\n    \"\"\"Holds compile time information for us.\"\"\"\n    def __init__(self, eval_ctx, parent=None, level=None):\n        self.eval_ctx = eval_ctx",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "Frame",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class Frame(object):\n    \"\"\"Holds compile time information for us.\"\"\"\n    def __init__(self, eval_ctx, parent=None, level=None):\n        self.eval_ctx = eval_ctx\n        self.symbols = Symbols(parent and parent.symbols or None, level=level)\n        # a toplevel frame is the root + soft frames such as if conditions.\n        self.toplevel = False\n        # the root frame is basically just the outermost frame, so no if\n        # conditions.  This information is used to optimize inheritance\n        # situations.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "VisitorExit",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class VisitorExit(RuntimeError):\n    \"\"\"Exception used by the `UndeclaredNameVisitor` to signal a stop.\"\"\"\nclass DependencyFinderVisitor(NodeVisitor):\n    \"\"\"A visitor that collects filter and test calls.\"\"\"\n    def __init__(self):\n        self.filters = set()\n        self.tests = set()\n    def visit_Filter(self, node):\n        self.generic_visit(node)\n        self.filters.add(node.name)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "DependencyFinderVisitor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class DependencyFinderVisitor(NodeVisitor):\n    \"\"\"A visitor that collects filter and test calls.\"\"\"\n    def __init__(self):\n        self.filters = set()\n        self.tests = set()\n    def visit_Filter(self, node):\n        self.generic_visit(node)\n        self.filters.add(node.name)\n    def visit_Test(self, node):\n        self.generic_visit(node)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "UndeclaredNameVisitor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class UndeclaredNameVisitor(NodeVisitor):\n    \"\"\"A visitor that checks if a name is accessed without being\n    declared.  This is different from the frame visitor as it will\n    not stop at closure frames.\n    \"\"\"\n    def __init__(self, names):\n        self.names = set(names)\n        self.undeclared = set()\n    def visit_Name(self, node):\n        if node.ctx == \"load\" and node.name in self.names:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "CompilerExit",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class CompilerExit(Exception):\n    \"\"\"Raised if the compiler encountered a situation where it just\n    doesn't make sense to further process the code.  Any block that\n    raises such an exception is not further processed.\n    \"\"\"\nclass CodeGenerator(NodeVisitor):\n    def __init__(\n        self, environment, name, filename, stream=None, defer_init=False, optimized=True\n    ):\n        if stream is None:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "CodeGenerator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "class CodeGenerator(NodeVisitor):\n    def __init__(\n        self, environment, name, filename, stream=None, defer_init=False, optimized=True\n    ):\n        if stream is None:\n            stream = NativeStringIO()\n        self.environment = environment\n        self.name = name\n        self.filename = filename\n        self.stream = stream",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "optimizeconst",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "def optimizeconst(f):\n    def new_func(self, node, frame, **kwargs):\n        # Only optimize if the frame is not volatile\n        if self.optimized and not frame.eval_ctx.volatile:\n            new_node = self.optimizer.visit(node, frame.eval_ctx)\n            if new_node != node:\n                return self.visit(new_node, frame)\n        return f(self, node, frame, **kwargs)\n    return update_wrapper(new_func, f)\ndef generate(",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "def generate(\n    node, environment, name, filename, stream=None, defer_init=False, optimized=True\n):\n    \"\"\"Generate the python source for a node tree.\"\"\"\n    if not isinstance(node, nodes.Template):\n        raise TypeError(\"Can't compile non template nodes\")\n    generator = environment.code_generator_class(\n        environment, name, filename, stream, defer_init, optimized\n    )\n    generator.visit(node)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "has_safe_repr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "def has_safe_repr(value):\n    \"\"\"Does the node have a safe representation?\"\"\"\n    if value is None or value is NotImplemented or value is Ellipsis:\n        return True\n    if type(value) in (bool, int, float, complex, range_type, Markup) + string_types:\n        return True\n    if type(value) in (tuple, list, set, frozenset):\n        for item in value:\n            if not has_safe_repr(item):\n                return False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "find_undeclared",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "def find_undeclared(nodes, names):\n    \"\"\"Check if the names passed are accessed undeclared.  The return value\n    is a set of all the undeclared names from the sequence of names found.\n    \"\"\"\n    visitor = UndeclaredNameVisitor(names)\n    try:\n        for node in nodes:\n            visitor.visit(node)\n    except VisitorExit:\n        pass",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "operators",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "operators = {\n    \"eq\": \"==\",\n    \"ne\": \"!=\",\n    \"gt\": \">\",\n    \"gteq\": \">=\",\n    \"lt\": \"<\",\n    \"lteq\": \"<=\",\n    \"in\": \"in\",\n    \"notin\": \"not in\",\n}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "code_features",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "peekOfCode": "code_features = [\"division\"]\n# does this python version support generator stops? (PEP 0479)\ntry:\n    exec(\"from __future__ import generator_stop\")\n    code_features.append(\"generator_stop\")\nexcept SyntaxError:\n    pass\n# does this python version support yield from?\ntry:\n    exec(\"def f(): yield from x()\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.compiler",
        "documentation": {}
    },
    {
        "label": "LOREM_IPSUM_WORDS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.constants",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.constants",
        "peekOfCode": "LOREM_IPSUM_WORDS = u\"\"\"\\\na ac accumsan ad adipiscing aenean aliquam aliquet amet ante aptent arcu at\nauctor augue bibendum blandit class commodo condimentum congue consectetuer\nconsequat conubia convallis cras cubilia cum curabitur curae cursus dapibus\ndiam dictum dictumst dignissim dis dolor donec dui duis egestas eget eleifend\nelementum elit enim erat eros est et etiam eu euismod facilisi facilisis fames\nfaucibus felis fermentum feugiat fringilla fusce gravida habitant habitasse hac\nhendrerit hymenaeos iaculis id imperdiet in inceptos integer interdum ipsum\njusto lacinia lacus laoreet lectus leo libero ligula litora lobortis lorem\nluctus maecenas magna magnis malesuada massa mattis mauris metus mi molestie",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.constants",
        "documentation": {}
    },
    {
        "label": "rewrite_traceback_stack",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "peekOfCode": "def rewrite_traceback_stack(source=None):\n    \"\"\"Rewrite the current exception to replace any tracebacks from\n    within compiled template code with tracebacks that look like they\n    came from the template source.\n    This must be called within an ``except`` block.\n    :param exc_info: A :meth:`sys.exc_info` tuple. If not provided,\n        the current ``exc_info`` is used.\n    :param source: For ``TemplateSyntaxError``, the original source if\n        known.\n    :return: A :meth:`sys.exc_info` tuple that can be re-raised.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "documentation": {}
    },
    {
        "label": "fake_traceback",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "peekOfCode": "def fake_traceback(exc_value, tb, filename, lineno):\n    \"\"\"Produce a new traceback object that looks like it came from the\n    template source instead of the compiled code. The filename, line\n    number, and location name will point to the template, and the local\n    variables will be the current template context.\n    :param exc_value: The original exception to be re-raised to create\n        the new traceback.\n    :param tb: The original traceback to get the local variables and\n        code info from.\n    :param filename: The template filename.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "documentation": {}
    },
    {
        "label": "get_template_locals",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "peekOfCode": "def get_template_locals(real_locals):\n    \"\"\"Based on the runtime locals, get the context that would be\n    available at that point in the template.\n    \"\"\"\n    # Start with the current template context.\n    ctx = real_locals.get(\"context\")\n    if ctx:\n        data = ctx.get_all().copy()\n    else:\n        data = {}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.debug",
        "documentation": {}
    },
    {
        "label": "BLOCK_START_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "BLOCK_START_STRING = \"{%\"\nBLOCK_END_STRING = \"%}\"\nVARIABLE_START_STRING = \"{{\"\nVARIABLE_END_STRING = \"}}\"\nCOMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "BLOCK_END_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "BLOCK_END_STRING = \"%}\"\nVARIABLE_START_STRING = \"{{\"\nVARIABLE_END_STRING = \"}}\"\nCOMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "VARIABLE_START_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "VARIABLE_START_STRING = \"{{\"\nVARIABLE_END_STRING = \"}}\"\nCOMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "VARIABLE_END_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "VARIABLE_END_STRING = \"}}\"\nCOMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "COMMENT_START_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "COMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "COMMENT_END_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "COMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "LINE_STATEMENT_PREFIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "LINE_STATEMENT_PREFIX = None\nLINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "LINE_COMMENT_PREFIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "LINE_COMMENT_PREFIX = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "TRIM_BLOCKS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "TRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "LSTRIP_BLOCKS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "LSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,\n    \"joiner\": Joiner,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "NEWLINE_SEQUENCE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "NEWLINE_SEQUENCE = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,\n    \"joiner\": Joiner,\n    \"namespace\": Namespace,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "KEEP_TRAILING_NEWLINE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "KEEP_TRAILING_NEWLINE = False\n# default filters, tests and namespace\nDEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,\n    \"joiner\": Joiner,\n    \"namespace\": Namespace,\n}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NAMESPACE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "DEFAULT_NAMESPACE = {\n    \"range\": range_type,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,\n    \"joiner\": Joiner,\n    \"namespace\": Namespace,\n}\n# default policies\nDEFAULT_POLICIES = {",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POLICIES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "peekOfCode": "DEFAULT_POLICIES = {\n    \"compiler.ascii_str\": True,\n    \"urlize.rel\": \"noopener\",\n    \"urlize.target\": None,\n    \"truncate.leeway\": 5,\n    \"json.dumps_function\": None,\n    \"json.dumps_kwargs\": {\"sort_keys\": True},\n    \"ext.i18n.trimmed\": False,\n}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.defaults",
        "documentation": {}
    },
    {
        "label": "Environment",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "class Environment(object):\n    r\"\"\"The core component of Jinja is the `Environment`.  It contains\n    important shared variables like configuration, filters, tests,\n    globals and others.  Instances of this class may be modified if\n    they are not shared and if no template was loaded so far.\n    Modifications on environments after the first template was loaded\n    will lead to surprising effects and undefined behavior.\n    Here are the possible initialization parameters:\n        `block_start_string`\n            The string marking the beginning of a block.  Defaults to ``'{%'``.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "Template",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "class Template(object):\n    \"\"\"The central template object.  This class represents a compiled template\n    and is used to evaluate it.\n    Normally the template object is generated from an :class:`Environment` but\n    it also has a constructor that makes it possible to create a template\n    instance directly using the constructor.  It takes the same arguments as\n    the environment constructor but it's not possible to specify a loader.\n    Every template object has a few methods and members that are guaranteed\n    to exist.  However it's important that a template object should be\n    considered immutable.  Modifications on the object are not supported.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "TemplateModule",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "class TemplateModule(object):\n    \"\"\"Represents an imported template.  All the exported names of the\n    template are available as attributes on this object.  Additionally\n    converting it into an unicode- or bytestrings renders the contents.\n    \"\"\"\n    def __init__(self, template, context, body_stream=None):\n        if body_stream is None:\n            if context.environment.is_async:\n                raise RuntimeError(\n                    \"Async mode requires a body stream \"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "TemplateExpression",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "class TemplateExpression(object):\n    \"\"\"The :meth:`jinja2.Environment.compile_expression` method returns an\n    instance of this object.  It encapsulates the expression-like access\n    to the template with an expression it wraps.\n    \"\"\"\n    def __init__(self, template, undefined_to_none):\n        self._template = template\n        self._undefined_to_none = undefined_to_none\n    def __call__(self, *args, **kwargs):\n        context = self._template.new_context(dict(*args, **kwargs))",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "TemplateStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "class TemplateStream(object):\n    \"\"\"A template stream works pretty much like an ordinary python generator\n    but it can buffer multiple items to reduce the number of total iterations.\n    Per default the output is unbuffered which means that for every unbuffered\n    instruction in the template one unicode string is yielded.\n    If buffering is enabled with a buffer size of 5, five items are combined\n    into a new unicode string.  This is mainly useful if you are streaming\n    big templates to a client via WSGI which flushes after each iteration.\n    \"\"\"\n    def __init__(self, gen):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "get_spontaneous_environment",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "def get_spontaneous_environment(cls, *args):\n    \"\"\"Return a new spontaneous environment. A spontaneous environment\n    is used for templates created directly rather than through an\n    existing environment.\n    :param cls: Environment class to create.\n    :param args: Positional arguments passed to environment.\n    \"\"\"\n    key = (cls, args)\n    try:\n        return _spontaneous_environments[key]",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "create_cache",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "def create_cache(size):\n    \"\"\"Return the cache class for the given size.\"\"\"\n    if size == 0:\n        return None\n    if size < 0:\n        return {}\n    return LRUCache(size)\ndef copy_cache(cache):\n    \"\"\"Create an empty copy of the given cache.\"\"\"\n    if cache is None:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "copy_cache",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "def copy_cache(cache):\n    \"\"\"Create an empty copy of the given cache.\"\"\"\n    if cache is None:\n        return None\n    elif type(cache) is dict:\n        return {}\n    return LRUCache(cache.capacity)\ndef load_extensions(environment, extensions):\n    \"\"\"Load the extensions from the list and bind it to the environment.\n    Returns a dict of instantiated environments.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "load_extensions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "def load_extensions(environment, extensions):\n    \"\"\"Load the extensions from the list and bind it to the environment.\n    Returns a dict of instantiated environments.\n    \"\"\"\n    result = {}\n    for extension in extensions:\n        if isinstance(extension, string_types):\n            extension = import_string(extension)\n        result[extension.identifier] = extension(environment)\n    return result",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "fail_for_missing_callable",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "def fail_for_missing_callable(string, name):\n    msg = string % name\n    if isinstance(name, Undefined):\n        try:\n            name._fail_with_undefined_error()\n        except Exception as e:\n            msg = \"%s (%s; did you forget to quote the callable name?)\" % (msg, e)\n    raise TemplateRuntimeError(msg)\ndef _environment_sanity_check(environment):\n    \"\"\"Perform a sanity check on the environment.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "_spontaneous_environments",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "_spontaneous_environments = LRUCache(10)\ndef get_spontaneous_environment(cls, *args):\n    \"\"\"Return a new spontaneous environment. A spontaneous environment\n    is used for templates created directly rather than through an\n    existing environment.\n    :param cls: Environment class to create.\n    :param args: Positional arguments passed to environment.\n    \"\"\"\n    key = (cls, args)\n    try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "Environment.template_class",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "peekOfCode": "Environment.template_class = Template",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.environment",
        "documentation": {}
    },
    {
        "label": "TemplateError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplateError(Exception):\n    \"\"\"Baseclass for all template errors.\"\"\"\n    if PY2:\n        def __init__(self, message=None):\n            if message is not None:\n                message = text_type(message).encode(\"utf-8\")\n            Exception.__init__(self, message)\n        @property\n        def message(self):\n            if self.args:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "TemplateNotFound",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplateNotFound(IOError, LookupError, TemplateError):\n    \"\"\"Raised if a template does not exist.\n    .. versionchanged:: 2.11\n        If the given name is :class:`Undefined` and no message was\n        provided, an :exc:`UndefinedError` is raised.\n    \"\"\"\n    # looks weird, but removes the warning descriptor that just\n    # bogusly warns us about message being deprecated\n    message = None\n    def __init__(self, name, message=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "TemplatesNotFound",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplatesNotFound(TemplateNotFound):\n    \"\"\"Like :class:`TemplateNotFound` but raised if multiple templates\n    are selected.  This is a subclass of :class:`TemplateNotFound`\n    exception, so just catching the base exception will catch both.\n    .. versionchanged:: 2.11\n        If a name in the list of names is :class:`Undefined`, a message\n        about it being undefined is shown rather than the empty string.\n    .. versionadded:: 2.2\n    \"\"\"\n    def __init__(self, names=(), message=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "TemplateSyntaxError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplateSyntaxError(TemplateError):\n    \"\"\"Raised to tell the user that there is a problem with the template.\"\"\"\n    def __init__(self, message, lineno, name=None, filename=None):\n        TemplateError.__init__(self, message)\n        self.lineno = lineno\n        self.name = name\n        self.filename = filename\n        self.source = None\n        # this is set to True if the debug.translate_syntax_error\n        # function translated the syntax error into a new traceback",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "TemplateAssertionError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplateAssertionError(TemplateSyntaxError):\n    \"\"\"Like a template syntax error, but covers cases where something in the\n    template caused an error at compile time that wasn't necessarily caused\n    by a syntax error.  However it's a direct subclass of\n    :exc:`TemplateSyntaxError` and has the same attributes.\n    \"\"\"\nclass TemplateRuntimeError(TemplateError):\n    \"\"\"A generic runtime error in the template engine.  Under some situations\n    Jinja may raise this exception.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "TemplateRuntimeError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class TemplateRuntimeError(TemplateError):\n    \"\"\"A generic runtime error in the template engine.  Under some situations\n    Jinja may raise this exception.\n    \"\"\"\nclass UndefinedError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to operate on :class:`Undefined`.\"\"\"\nclass SecurityError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to do something insecure if the\n    sandbox is enabled.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "UndefinedError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class UndefinedError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to operate on :class:`Undefined`.\"\"\"\nclass SecurityError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to do something insecure if the\n    sandbox is enabled.\n    \"\"\"\nclass FilterArgumentError(TemplateRuntimeError):\n    \"\"\"This error is raised if a filter was called with inappropriate\n    arguments\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "SecurityError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class SecurityError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to do something insecure if the\n    sandbox is enabled.\n    \"\"\"\nclass FilterArgumentError(TemplateRuntimeError):\n    \"\"\"This error is raised if a filter was called with inappropriate\n    arguments\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "FilterArgumentError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "peekOfCode": "class FilterArgumentError(TemplateRuntimeError):\n    \"\"\"This error is raised if a filter was called with inappropriate\n    arguments\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.exceptions",
        "documentation": {}
    },
    {
        "label": "ExtensionRegistry",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class ExtensionRegistry(type):\n    \"\"\"Gives the extension an unique identifier.\"\"\"\n    def __new__(mcs, name, bases, d):\n        rv = type.__new__(mcs, name, bases, d)\n        rv.identifier = rv.__module__ + \".\" + rv.__name__\n        return rv\nclass Extension(with_metaclass(ExtensionRegistry, object)):\n    \"\"\"Extensions can be used to add extra functionality to the Jinja template\n    system at the parser level.  Custom extensions are bound to an environment\n    but may not store environment specific data on `self`.  The reason for",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "Extension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class Extension(with_metaclass(ExtensionRegistry, object)):\n    \"\"\"Extensions can be used to add extra functionality to the Jinja template\n    system at the parser level.  Custom extensions are bound to an environment\n    but may not store environment specific data on `self`.  The reason for\n    this is that an extension can be bound to another environment (for\n    overlays) by creating a copy and reassigning the `environment` attribute.\n    As extensions are created by the environment they cannot accept any\n    arguments for configuration.  One may want to work around that by using\n    a factory function, but that is not possible as extensions are identified\n    by their import name.  The correct way to configure the extension is",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "InternationalizationExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class InternationalizationExtension(Extension):\n    \"\"\"This extension adds gettext support to Jinja.\"\"\"\n    tags = {\"trans\"}\n    # TODO: the i18n extension is currently reevaluating values in a few\n    # situations.  Take this example:\n    #   {% trans count=something() %}{{ count }} foo{% pluralize\n    #     %}{{ count }} fooss{% endtrans %}\n    # something is called twice here.  One time for the gettext value and\n    # the other time for the n-parameter of the ngettext function.\n    def __init__(self, environment):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "ExprStmtExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class ExprStmtExtension(Extension):\n    \"\"\"Adds a `do` tag to Jinja that works like the print statement just\n    that it doesn't print the return value.\n    \"\"\"\n    tags = set([\"do\"])\n    def parse(self, parser):\n        node = nodes.ExprStmt(lineno=next(parser.stream).lineno)\n        node.node = parser.parse_tuple()\n        return node\nclass LoopControlExtension(Extension):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "LoopControlExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class LoopControlExtension(Extension):\n    \"\"\"Adds break and continue to the template engine.\"\"\"\n    tags = set([\"break\", \"continue\"])\n    def parse(self, parser):\n        token = next(parser.stream)\n        if token.value == \"break\":\n            return nodes.Break(lineno=token.lineno)\n        return nodes.Continue(lineno=token.lineno)\nclass WithExtension(Extension):\n    pass",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "WithExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class WithExtension(Extension):\n    pass\nclass AutoEscapeExtension(Extension):\n    pass\nclass DebugExtension(Extension):\n    \"\"\"A ``{% debug %}`` tag that dumps the available variables,\n    filters, and tests.\n    .. code-block:: html+jinja\n        <pre>{% debug %}</pre>\n    .. code-block:: text",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "AutoEscapeExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class AutoEscapeExtension(Extension):\n    pass\nclass DebugExtension(Extension):\n    \"\"\"A ``{% debug %}`` tag that dumps the available variables,\n    filters, and tests.\n    .. code-block:: html+jinja\n        <pre>{% debug %}</pre>\n    .. code-block:: text\n        {'context': {'cycler': <class 'jinja2.utils.Cycler'>,\n                     ...,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "DebugExtension",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class DebugExtension(Extension):\n    \"\"\"A ``{% debug %}`` tag that dumps the available variables,\n    filters, and tests.\n    .. code-block:: html+jinja\n        <pre>{% debug %}</pre>\n    .. code-block:: text\n        {'context': {'cycler': <class 'jinja2.utils.Cycler'>,\n                     ...,\n                     'namespace': <class 'jinja2.utils.Namespace'>},\n         'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "_CommentFinder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "class _CommentFinder(object):\n    \"\"\"Helper class to find comments in a token stream.  Can only\n    find comments for gettext calls forwards.  Once the comment\n    from line 4 is found, a comment for line 1 will not return a\n    usable value.\n    \"\"\"\n    def __init__(self, tokens, comment_tags):\n        self.tokens = tokens\n        self.comment_tags = comment_tags\n        self.offset = 0",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "extract_from_ast",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "def extract_from_ast(node, gettext_functions=GETTEXT_FUNCTIONS, babel_style=True):\n    \"\"\"Extract localizable strings from the given template node.  Per\n    default this function returns matches in babel style that means non string\n    parameters as well as keyword arguments are returned as `None`.  This\n    allows Babel to figure out what you really meant if you are using\n    gettext functions that allow keyword arguments for placeholder expansion.\n    If you don't want that behavior set the `babel_style` parameter to `False`\n    which causes only strings to be returned and parameters are always stored\n    in tuples.  As a consequence invalid gettext calls (calls without a single\n    string parameter or string parameters after non-string parameters) are",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "babel_extract",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "def babel_extract(fileobj, keywords, comment_tags, options):\n    \"\"\"Babel extraction method for Jinja templates.\n    .. versionchanged:: 2.3\n       Basic support for translation comments was added.  If `comment_tags`\n       is now set to a list of keywords for extraction, the extractor will\n       try to find the best preceding comment that begins with one of the\n       keywords.  For best results, make sure to not have more than one\n       gettext call in one line of code and the matching comment in the\n       same line or the line before.\n    .. versionchanged:: 2.5.1",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "GETTEXT_FUNCTIONS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "GETTEXT_FUNCTIONS = (\"_\", \"gettext\", \"ngettext\")\n_ws_re = re.compile(r\"\\s*\\n\\s*\")\nclass ExtensionRegistry(type):\n    \"\"\"Gives the extension an unique identifier.\"\"\"\n    def __new__(mcs, name, bases, d):\n        rv = type.__new__(mcs, name, bases, d)\n        rv.identifier = rv.__module__ + \".\" + rv.__name__\n        return rv\nclass Extension(with_metaclass(ExtensionRegistry, object)):\n    \"\"\"Extensions can be used to add extra functionality to the Jinja template",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "_ws_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "_ws_re = re.compile(r\"\\s*\\n\\s*\")\nclass ExtensionRegistry(type):\n    \"\"\"Gives the extension an unique identifier.\"\"\"\n    def __new__(mcs, name, bases, d):\n        rv = type.__new__(mcs, name, bases, d)\n        rv.identifier = rv.__module__ + \".\" + rv.__name__\n        return rv\nclass Extension(with_metaclass(ExtensionRegistry, object)):\n    \"\"\"Extensions can be used to add extra functionality to the Jinja template\n    system at the parser level.  Custom extensions are bound to an environment",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "i18n",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "i18n = InternationalizationExtension\ndo = ExprStmtExtension\nloopcontrols = LoopControlExtension\nwith_ = WithExtension\nautoescape = AutoEscapeExtension\ndebug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "do",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "do = ExprStmtExtension\nloopcontrols = LoopControlExtension\nwith_ = WithExtension\nautoescape = AutoEscapeExtension\ndebug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "loopcontrols",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "loopcontrols = LoopControlExtension\nwith_ = WithExtension\nautoescape = AutoEscapeExtension\ndebug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "with_",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "with_ = WithExtension\nautoescape = AutoEscapeExtension\ndebug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "autoescape",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "autoescape = AutoEscapeExtension\ndebug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "peekOfCode": "debug = DebugExtension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.ext",
        "documentation": {}
    },
    {
        "label": "contextfilter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def contextfilter(f):\n    \"\"\"Decorator for marking context dependent filters. The current\n    :class:`Context` will be passed as first argument.\n    \"\"\"\n    f.contextfilter = True\n    return f\ndef evalcontextfilter(f):\n    \"\"\"Decorator for marking eval-context dependent filters.  An eval\n    context object is passed as first argument.  For more information\n    about the eval context, see :ref:`eval-context`.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "evalcontextfilter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def evalcontextfilter(f):\n    \"\"\"Decorator for marking eval-context dependent filters.  An eval\n    context object is passed as first argument.  For more information\n    about the eval context, see :ref:`eval-context`.\n    .. versionadded:: 2.4\n    \"\"\"\n    f.evalcontextfilter = True\n    return f\ndef environmentfilter(f):\n    \"\"\"Decorator for marking environment dependent filters.  The current",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "environmentfilter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def environmentfilter(f):\n    \"\"\"Decorator for marking environment dependent filters.  The current\n    :class:`Environment` is passed to the filter as first argument.\n    \"\"\"\n    f.environmentfilter = True\n    return f\ndef ignore_case(value):\n    \"\"\"For use as a postprocessor for :func:`make_attrgetter`. Converts strings\n    to lowercase and returns other types as-is.\"\"\"\n    return value.lower() if isinstance(value, string_types) else value",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "ignore_case",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def ignore_case(value):\n    \"\"\"For use as a postprocessor for :func:`make_attrgetter`. Converts strings\n    to lowercase and returns other types as-is.\"\"\"\n    return value.lower() if isinstance(value, string_types) else value\ndef make_attrgetter(environment, attribute, postprocess=None, default=None):\n    \"\"\"Returns a callable that looks up the given attribute from a\n    passed object with the rules of the environment.  Dots are allowed\n    to access attributes of attributes.  Integer parts in paths are\n    looked up as integers.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "make_attrgetter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def make_attrgetter(environment, attribute, postprocess=None, default=None):\n    \"\"\"Returns a callable that looks up the given attribute from a\n    passed object with the rules of the environment.  Dots are allowed\n    to access attributes of attributes.  Integer parts in paths are\n    looked up as integers.\n    \"\"\"\n    attribute = _prepare_attribute_parts(attribute)\n    def attrgetter(item):\n        for part in attribute:\n            item = environment.getitem(item, part)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "make_multi_attrgetter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def make_multi_attrgetter(environment, attribute, postprocess=None):\n    \"\"\"Returns a callable that looks up the given comma separated\n    attributes from a passed object with the rules of the environment.\n    Dots are allowed to access attributes of each attribute.  Integer\n    parts in paths are looked up as integers.\n    The value returned by the returned callable is a list of extracted\n    attribute values.\n    Examples of attribute: \"attr1,attr2\", \"attr1.inner1.0,attr2.inner2.0\", etc.\n    \"\"\"\n    attribute_parts = (",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_forceescape",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_forceescape(value):\n    \"\"\"Enforce HTML escaping.  This will probably double escape variables.\"\"\"\n    if hasattr(value, \"__html__\"):\n        value = value.__html__()\n    return escape(text_type(value))\ndef do_urlencode(value):\n    \"\"\"Quote data for use in a URL path or query using UTF-8.\n    Basic wrapper around :func:`urllib.parse.quote` when given a\n    string, or :func:`urllib.parse.urlencode` for a dict or iterable.\n    :param value: Data to quote. A string will be quoted directly. A",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_urlencode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_urlencode(value):\n    \"\"\"Quote data for use in a URL path or query using UTF-8.\n    Basic wrapper around :func:`urllib.parse.quote` when given a\n    string, or :func:`urllib.parse.urlencode` for a dict or iterable.\n    :param value: Data to quote. A string will be quoted directly. A\n        dict or iterable of ``(key, value)`` pairs will be joined as a\n        query string.\n    When given a string, \"/\" is not quoted. HTTP servers treat \"/\" and\n    \"%2F\" equivalently in paths. If you need quoted slashes, use the\n    ``|replace(\"/\", \"%2F\")`` filter.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_replace",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_replace(eval_ctx, s, old, new, count=None):\n    \"\"\"Return a copy of the value with all occurrences of a substring\n    replaced with a new one. The first argument is the substring\n    that should be replaced, the second is the replacement string.\n    If the optional third argument ``count`` is given, only the first\n    ``count`` occurrences are replaced:\n    .. sourcecode:: jinja\n        {{ \"Hello World\"|replace(\"Hello\", \"Goodbye\") }}\n            -> Goodbye World\n        {{ \"aaaaargh\"|replace(\"a\", \"d'oh, \", 2) }}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_upper",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_upper(s):\n    \"\"\"Convert a value to uppercase.\"\"\"\n    return soft_unicode(s).upper()\ndef do_lower(s):\n    \"\"\"Convert a value to lowercase.\"\"\"\n    return soft_unicode(s).lower()\n@evalcontextfilter\ndef do_xmlattr(_eval_ctx, d, autospace=True):\n    \"\"\"Create an SGML/XML attribute string based on the items in a dict.\n    All values that are neither `none` nor `undefined` are automatically",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_lower",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_lower(s):\n    \"\"\"Convert a value to lowercase.\"\"\"\n    return soft_unicode(s).lower()\n@evalcontextfilter\ndef do_xmlattr(_eval_ctx, d, autospace=True):\n    \"\"\"Create an SGML/XML attribute string based on the items in a dict.\n    All values that are neither `none` nor `undefined` are automatically\n    escaped:\n    .. sourcecode:: html+jinja\n        <ul{{ {'class': 'my_list', 'missing': none,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_xmlattr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_xmlattr(_eval_ctx, d, autospace=True):\n    \"\"\"Create an SGML/XML attribute string based on the items in a dict.\n    All values that are neither `none` nor `undefined` are automatically\n    escaped:\n    .. sourcecode:: html+jinja\n        <ul{{ {'class': 'my_list', 'missing': none,\n                'id': 'list-%d'|format(variable)}|xmlattr }}>\n        ...\n        </ul>\n    Results in something like this:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_capitalize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_capitalize(s):\n    \"\"\"Capitalize a value. The first character will be uppercase, all others\n    lowercase.\n    \"\"\"\n    return soft_unicode(s).capitalize()\ndef do_title(s):\n    \"\"\"Return a titlecased version of the value. I.e. words will start with\n    uppercase letters, all remaining characters are lowercase.\n    \"\"\"\n    return \"\".join(",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_title",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_title(s):\n    \"\"\"Return a titlecased version of the value. I.e. words will start with\n    uppercase letters, all remaining characters are lowercase.\n    \"\"\"\n    return \"\".join(\n        [\n            item[0].upper() + item[1:].lower()\n            for item in _word_beginning_split_re.split(soft_unicode(s))\n            if item\n        ]",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_dictsort",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_dictsort(value, case_sensitive=False, by=\"key\", reverse=False):\n    \"\"\"Sort a dict and yield (key, value) pairs. Because python dicts are\n    unsorted you may want to use this function to order them by either\n    key or value:\n    .. sourcecode:: jinja\n        {% for key, value in mydict|dictsort %}\n            sort the dict by key, case insensitive\n        {% for key, value in mydict|dictsort(reverse=true) %}\n            sort the dict by key, case insensitive, reverse order\n        {% for key, value in mydict|dictsort(true) %}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_sort",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_sort(environment, value, reverse=False, case_sensitive=False, attribute=None):\n    \"\"\"Sort an iterable using Python's :func:`sorted`.\n    .. sourcecode:: jinja\n        {% for city in cities|sort %}\n            ...\n        {% endfor %}\n    :param reverse: Sort descending instead of ascending.\n    :param case_sensitive: When sorting strings, sort upper and lower\n        case separately.\n    :param attribute: When sorting objects or dicts, an attribute or",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_unique",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_unique(environment, value, case_sensitive=False, attribute=None):\n    \"\"\"Returns a list of unique items from the given iterable.\n    .. sourcecode:: jinja\n        {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}\n            -> ['foo', 'bar', 'foobar']\n    The unique items are yielded in the same order as their first occurrence in\n    the iterable passed to the filter.\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Filter objects with unique values for this attribute.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_min",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_min(environment, value, case_sensitive=False, attribute=None):\n    \"\"\"Return the smallest item from the sequence.\n    .. sourcecode:: jinja\n        {{ [1, 2, 3]|min }}\n            -> 1\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the min value of this attribute.\n    \"\"\"\n    return _min_or_max(environment, value, min, case_sensitive, attribute)\n@environmentfilter",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_max",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_max(environment, value, case_sensitive=False, attribute=None):\n    \"\"\"Return the largest item from the sequence.\n    .. sourcecode:: jinja\n        {{ [1, 2, 3]|max }}\n            -> 3\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the max value of this attribute.\n    \"\"\"\n    return _min_or_max(environment, value, max, case_sensitive, attribute)\ndef do_default(value, default_value=u\"\", boolean=False):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_default",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_default(value, default_value=u\"\", boolean=False):\n    \"\"\"If the value is undefined it will return the passed default value,\n    otherwise the value of the variable:\n    .. sourcecode:: jinja\n        {{ my_variable|default('my_variable is not defined') }}\n    This will output the value of ``my_variable`` if the variable was\n    defined, otherwise ``'my_variable is not defined'``. If you want\n    to use default with variables that evaluate to false you have to\n    set the second parameter to `true`:\n    .. sourcecode:: jinja",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_join",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_join(eval_ctx, value, d=u\"\", attribute=None):\n    \"\"\"Return a string which is the concatenation of the strings in the\n    sequence. The separator between elements is an empty string per\n    default, you can define it with the optional parameter:\n    .. sourcecode:: jinja\n        {{ [1, 2, 3]|join('|') }}\n            -> 1|2|3\n        {{ [1, 2, 3]|join }}\n            -> 123\n    It is also possible to join certain attributes of an object:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_center",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_center(value, width=80):\n    \"\"\"Centers the value in a field of a given width.\"\"\"\n    return text_type(value).center(width)\n@environmentfilter\ndef do_first(environment, seq):\n    \"\"\"Return the first item of a sequence.\"\"\"\n    try:\n        return next(iter(seq))\n    except StopIteration:\n        return environment.undefined(\"No first item, sequence was empty.\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_first",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_first(environment, seq):\n    \"\"\"Return the first item of a sequence.\"\"\"\n    try:\n        return next(iter(seq))\n    except StopIteration:\n        return environment.undefined(\"No first item, sequence was empty.\")\n@environmentfilter\ndef do_last(environment, seq):\n    \"\"\"\n    Return the last item of a sequence.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_last",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_last(environment, seq):\n    \"\"\"\n    Return the last item of a sequence.\n    Note: Does not work with generators. You may want to explicitly\n    convert it to a list:\n    .. sourcecode:: jinja\n        {{ data | selectattr('name', '==', 'Jinja') | list | last }}\n    \"\"\"\n    try:\n        return next(iter(reversed(seq)))",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_random",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_random(context, seq):\n    \"\"\"Return a random item from the sequence.\"\"\"\n    try:\n        return random.choice(seq)\n    except IndexError:\n        return context.environment.undefined(\"No random item, sequence was empty.\")\ndef do_filesizeformat(value, binary=False):\n    \"\"\"Format the value like a 'human-readable' file size (i.e. 13 kB,\n    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,\n    Giga, etc.), if the second parameter is set to `True` the binary",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_filesizeformat",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_filesizeformat(value, binary=False):\n    \"\"\"Format the value like a 'human-readable' file size (i.e. 13 kB,\n    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,\n    Giga, etc.), if the second parameter is set to `True` the binary\n    prefixes are used (Mebi, Gibi).\n    \"\"\"\n    bytes = float(value)\n    base = binary and 1024 or 1000\n    prefixes = [\n        (binary and \"KiB\" or \"kB\"),",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_pprint",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_pprint(value, verbose=False):\n    \"\"\"Pretty print a variable. Useful for debugging.\n    With Jinja 1.2 onwards you can pass it a parameter.  If this parameter\n    is truthy the output will be more verbose (this requires `pretty`)\n    \"\"\"\n    return pformat(value, verbose=verbose)\n@evalcontextfilter\ndef do_urlize(\n    eval_ctx, value, trim_url_limit=None, nofollow=False, target=None, rel=None\n):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_urlize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_urlize(\n    eval_ctx, value, trim_url_limit=None, nofollow=False, target=None, rel=None\n):\n    \"\"\"Converts URLs in plain text into clickable links.\n    If you pass the filter an additional integer it will shorten the urls\n    to that number. Also a third argument exists that makes the urls\n    \"nofollow\":\n    .. sourcecode:: jinja\n        {{ mytext|urlize(40, true) }}\n            links are shortened to 40 chars and defined with rel=\"nofollow\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_indent",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_indent(s, width=4, first=False, blank=False, indentfirst=None):\n    \"\"\"Return a copy of the string with each line indented by 4 spaces. The\n    first line and blank lines are not indented by default.\n    :param width: Number of spaces to indent by.\n    :param first: Don't skip indenting the first line.\n    :param blank: Don't skip indenting empty lines.\n    .. versionchanged:: 2.10\n        Blank lines are not indented by default.\n        Rename the ``indentfirst`` argument to ``first``.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_truncate",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_truncate(env, s, length=255, killwords=False, end=\"...\", leeway=None):\n    \"\"\"Return a truncated copy of the string. The length is specified\n    with the first parameter which defaults to ``255``. If the second\n    parameter is ``true`` the filter will cut the text at length. Otherwise\n    it will discard the last word. If the text was in fact\n    truncated it will append an ellipsis sign (``\"...\"``). If you want a\n    different ellipsis sign than ``\"...\"`` you can specify it using the\n    third parameter. Strings that only exceed the length by the tolerance\n    margin given in the fourth parameter will not be truncated.\n    .. sourcecode:: jinja",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_wordwrap",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_wordwrap(\n    environment,\n    s,\n    width=79,\n    break_long_words=True,\n    wrapstring=None,\n    break_on_hyphens=True,\n):\n    \"\"\"Wrap a string to the given width. Existing newlines are treated\n    as paragraphs to be wrapped separately.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_wordcount",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_wordcount(s):\n    \"\"\"Count the words in that string.\"\"\"\n    return len(_word_re.findall(soft_unicode(s)))\ndef do_int(value, default=0, base=10):\n    \"\"\"Convert the value into an integer. If the\n    conversion doesn't work it will return ``0``. You can\n    override this default using the first parameter. You\n    can also override the default base (10) in the second\n    parameter, which handles input with prefixes such as\n    0b, 0o and 0x for bases 2, 8 and 16 respectively.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_int",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_int(value, default=0, base=10):\n    \"\"\"Convert the value into an integer. If the\n    conversion doesn't work it will return ``0``. You can\n    override this default using the first parameter. You\n    can also override the default base (10) in the second\n    parameter, which handles input with prefixes such as\n    0b, 0o and 0x for bases 2, 8 and 16 respectively.\n    The base is ignored for decimal numbers and non-string values.\n    \"\"\"\n    try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_float",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_float(value, default=0.0):\n    \"\"\"Convert the value into a floating point number. If the\n    conversion doesn't work it will return ``0.0``. You can\n    override this default using the first parameter.\n    \"\"\"\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        return default\ndef do_format(value, *args, **kwargs):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_format",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_format(value, *args, **kwargs):\n    \"\"\"Apply the given values to a `printf-style`_ format string, like\n    ``string % values``.\n    .. sourcecode:: jinja\n        {{ \"%s, %s!\"|format(greeting, name) }}\n        Hello, World!\n    In most cases it should be more convenient and efficient to use the\n    ``%`` operator or :meth:`str.format`.\n    .. code-block:: text\n        {{ \"%s, %s!\" % (greeting, name) }}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_trim",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_trim(value, chars=None):\n    \"\"\"Strip leading and trailing characters, by default whitespace.\"\"\"\n    return soft_unicode(value).strip(chars)\ndef do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\"\"\"\n    if hasattr(value, \"__html__\"):\n        value = value.__html__()\n    return Markup(text_type(value)).striptags()\ndef do_slice(value, slices, fill_with=None):\n    \"\"\"Slice an iterator and return a list of lists containing",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_striptags",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\"\"\"\n    if hasattr(value, \"__html__\"):\n        value = value.__html__()\n    return Markup(text_type(value)).striptags()\ndef do_slice(value, slices, fill_with=None):\n    \"\"\"Slice an iterator and return a list of lists containing\n    those items. Useful if you want to create a div containing\n    three ul tags that represent columns:\n    .. sourcecode:: html+jinja",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_slice",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_slice(value, slices, fill_with=None):\n    \"\"\"Slice an iterator and return a list of lists containing\n    those items. Useful if you want to create a div containing\n    three ul tags that represent columns:\n    .. sourcecode:: html+jinja\n        <div class=\"columnwrapper\">\n          {%- for column in items|slice(3) %}\n            <ul class=\"column-{{ loop.index }}\">\n            {%- for item in column %}\n              <li>{{ item }}</li>",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_batch",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_batch(value, linecount, fill_with=None):\n    \"\"\"\n    A filter that batches items. It works pretty much like `slice`\n    just the other way round. It returns a list of lists with the\n    given number of items. If you provide a second parameter this\n    is used to fill up missing items. See this example:\n    .. sourcecode:: html+jinja\n        <table>\n        {%- for row in items|batch(3, '&nbsp;') %}\n          <tr>",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_round",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_round(value, precision=0, method=\"common\"):\n    \"\"\"Round the number to a given precision. The first\n    parameter specifies the precision (default is ``0``), the\n    second the rounding method:\n    - ``'common'`` rounds either up or down\n    - ``'ceil'`` always rounds up\n    - ``'floor'`` always rounds down\n    If you don't specify a method ``'common'`` is used.\n    .. sourcecode:: jinja\n        {{ 42.55|round }}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_groupby",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_groupby(environment, value, attribute):\n    \"\"\"Group a sequence of objects by an attribute using Python's\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``\"address.city\"``. Unlike Python's ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.\n    For example, a list of ``User`` objects with a ``city`` attribute\n    can be rendered in groups. In this example, ``grouper`` refers to\n    the ``city`` value of the group.\n    .. sourcecode:: html+jinja",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_sum",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_sum(environment, iterable, attribute=None, start=0):\n    \"\"\"Returns the sum of a sequence of numbers plus the value of parameter\n    'start' (which defaults to 0).  When the sequence is empty it returns\n    start.\n    It is also possible to sum up only certain attributes:\n    .. sourcecode:: jinja\n        Total: {{ items|sum(attribute='price') }}\n    .. versionchanged:: 2.6\n       The `attribute` parameter was added to allow suming up over\n       attributes.  Also the `start` parameter was moved on to the right.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_list",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_list(value):\n    \"\"\"Convert the value into a list.  If it was a string the returned list\n    will be a list of characters.\n    \"\"\"\n    return list(value)\ndef do_mark_safe(value):\n    \"\"\"Mark the value as safe which means that in an environment with automatic\n    escaping enabled this variable will not be escaped.\n    \"\"\"\n    return Markup(value)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_mark_safe",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_mark_safe(value):\n    \"\"\"Mark the value as safe which means that in an environment with automatic\n    escaping enabled this variable will not be escaped.\n    \"\"\"\n    return Markup(value)\ndef do_mark_unsafe(value):\n    \"\"\"Mark a value as unsafe.  This is the reverse operation for :func:`safe`.\"\"\"\n    return text_type(value)\ndef do_reverse(value):\n    \"\"\"Reverse the object or return an iterator that iterates over it the other",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_mark_unsafe",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_mark_unsafe(value):\n    \"\"\"Mark a value as unsafe.  This is the reverse operation for :func:`safe`.\"\"\"\n    return text_type(value)\ndef do_reverse(value):\n    \"\"\"Reverse the object or return an iterator that iterates over it the other\n    way round.\n    \"\"\"\n    if isinstance(value, string_types):\n        return value[::-1]\n    try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_reverse",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_reverse(value):\n    \"\"\"Reverse the object or return an iterator that iterates over it the other\n    way round.\n    \"\"\"\n    if isinstance(value, string_types):\n        return value[::-1]\n    try:\n        return reversed(value)\n    except TypeError:\n        try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_attr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_attr(environment, obj, name):\n    \"\"\"Get an attribute of an object.  ``foo|attr(\"bar\")`` works like\n    ``foo.bar`` just that always an attribute is returned and items are not\n    looked up.\n    See :ref:`Notes on subscriptions <notes-on-subscriptions>` for more details.\n    \"\"\"\n    try:\n        name = str(name)\n    except UnicodeError:\n        pass",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_map",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_map(*args, **kwargs):\n    \"\"\"Applies a filter on a sequence of objects or looks up an attribute.\n    This is useful when dealing with lists of objects but you are really\n    only interested in a certain value of it.\n    The basic usage is mapping on an attribute.  Imagine you have a list\n    of users but you are only interested in a list of usernames:\n    .. sourcecode:: jinja\n        Users on this page: {{ users|map(attribute='username')|join(', ') }}\n    You can specify a ``default`` value to use if an object in the list\n    does not have the given attribute.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_select",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_select(*args, **kwargs):\n    \"\"\"Filters a sequence of objects by applying a test to each object,\n    and only selecting the objects with the test succeeding.\n    If no test is specified, each object will be evaluated as a boolean.\n    Example usage:\n    .. sourcecode:: jinja\n        {{ numbers|select(\"odd\") }}\n        {{ numbers|select(\"odd\") }}\n        {{ numbers|select(\"divisibleby\", 3) }}\n        {{ numbers|select(\"lessthan\", 42) }}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_reject",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_reject(*args, **kwargs):\n    \"\"\"Filters a sequence of objects by applying a test to each object,\n    and rejecting the objects with the test succeeding.\n    If no test is specified, each object will be evaluated as a boolean.\n    Example usage:\n    .. sourcecode:: jinja\n        {{ numbers|reject(\"odd\") }}\n    Similar to a generator comprehension such as:\n    .. code-block:: python\n        (n for n in numbers if not test_odd(n))",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_selectattr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_selectattr(*args, **kwargs):\n    \"\"\"Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and only selecting the objects with the\n    test succeeding.\n    If no test is specified, the attribute's value will be evaluated as\n    a boolean.\n    Example usage:\n    .. sourcecode:: jinja\n        {{ users|selectattr(\"is_active\") }}\n        {{ users|selectattr(\"email\", \"none\") }}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_rejectattr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_rejectattr(*args, **kwargs):\n    \"\"\"Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and rejecting the objects with the test\n    succeeding.\n    If no test is specified, the attribute's value will be evaluated as\n    a boolean.\n    .. sourcecode:: jinja\n        {{ users|rejectattr(\"is_active\") }}\n        {{ users|rejectattr(\"email\", \"none\") }}\n    Similar to a generator comprehension such as:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "do_tojson",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def do_tojson(eval_ctx, value, indent=None):\n    \"\"\"Dumps a structure to JSON so that it's safe to use in ``<script>``\n    tags.  It accepts the same arguments and returns a JSON string.  Note that\n    this is available in templates through the ``|tojson`` filter which will\n    also mark the result as safe.  Due to how this function escapes certain\n    characters this is safe even if used outside of ``<script>`` tags.\n    The following characters are escaped in strings:\n    -   ``<``\n    -   ``>``\n    -   ``&``",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "prepare_map",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def prepare_map(args, kwargs):\n    context = args[0]\n    seq = args[1]\n    default = None\n    if len(args) == 2 and \"attribute\" in kwargs:\n        attribute = kwargs.pop(\"attribute\")\n        default = kwargs.pop(\"default\", None)\n        if kwargs:\n            raise FilterArgumentError(\n                \"Unexpected keyword argument %r\" % next(iter(kwargs))",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "prepare_select_or_reject",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def prepare_select_or_reject(args, kwargs, modfunc, lookup_attr):\n    context = args[0]\n    seq = args[1]\n    if lookup_attr:\n        try:\n            attr = args[2]\n        except LookupError:\n            raise FilterArgumentError(\"Missing parameter for attribute name\")\n        transfunc = make_attrgetter(context.environment, attr)\n        off = 1",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "select_or_reject",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "def select_or_reject(args, kwargs, modfunc, lookup_attr):\n    seq, func = prepare_select_or_reject(args, kwargs, modfunc, lookup_attr)\n    if seq:\n        for item in seq:\n            if func(item):\n                yield item\nFILTERS = {\n    \"abs\": abs,\n    \"attr\": do_attr,\n    \"batch\": do_batch,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "_word_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "_word_re = re.compile(r\"\\w+\", re.UNICODE)\n_word_beginning_split_re = re.compile(r\"([-\\s\\(\\{\\[\\<]+)\", re.UNICODE)\ndef contextfilter(f):\n    \"\"\"Decorator for marking context dependent filters. The current\n    :class:`Context` will be passed as first argument.\n    \"\"\"\n    f.contextfilter = True\n    return f\ndef evalcontextfilter(f):\n    \"\"\"Decorator for marking eval-context dependent filters.  An eval",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "_word_beginning_split_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "_word_beginning_split_re = re.compile(r\"([-\\s\\(\\{\\[\\<]+)\", re.UNICODE)\ndef contextfilter(f):\n    \"\"\"Decorator for marking context dependent filters. The current\n    :class:`Context` will be passed as first argument.\n    \"\"\"\n    f.contextfilter = True\n    return f\ndef evalcontextfilter(f):\n    \"\"\"Decorator for marking eval-context dependent filters.  An eval\n    context object is passed as first argument.  For more information",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "_GroupTuple",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "_GroupTuple = namedtuple(\"_GroupTuple\", [\"grouper\", \"list\"])\n_GroupTuple.__repr__ = tuple.__repr__\n_GroupTuple.__str__ = tuple.__str__\n@environmentfilter\ndef do_groupby(environment, value, attribute):\n    \"\"\"Group a sequence of objects by an attribute using Python's\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``\"address.city\"``. Unlike Python's ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "_GroupTuple.__repr__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "_GroupTuple.__repr__ = tuple.__repr__\n_GroupTuple.__str__ = tuple.__str__\n@environmentfilter\ndef do_groupby(environment, value, attribute):\n    \"\"\"Group a sequence of objects by an attribute using Python's\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``\"address.city\"``. Unlike Python's ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.\n    For example, a list of ``User`` objects with a ``city`` attribute",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "_GroupTuple.__str__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "_GroupTuple.__str__ = tuple.__str__\n@environmentfilter\ndef do_groupby(environment, value, attribute):\n    \"\"\"Group a sequence of objects by an attribute using Python's\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``\"address.city\"``. Unlike Python's ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.\n    For example, a list of ``User`` objects with a ``city`` attribute\n    can be rendered in groups. In this example, ``grouper`` refers to",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "FILTERS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "peekOfCode": "FILTERS = {\n    \"abs\": abs,\n    \"attr\": do_attr,\n    \"batch\": do_batch,\n    \"capitalize\": do_capitalize,\n    \"center\": do_center,\n    \"count\": len,\n    \"d\": do_default,\n    \"default\": do_default,\n    \"dictsort\": do_dictsort,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.filters",
        "documentation": {}
    },
    {
        "label": "Symbols",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "class Symbols(object):\n    def __init__(self, parent=None, level=None):\n        if level is None:\n            if parent is None:\n                level = 0\n            else:\n                level = parent.level + 1\n        self.level = level\n        self.parent = parent\n        self.refs = {}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "RootVisitor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "class RootVisitor(NodeVisitor):\n    def __init__(self, symbols):\n        self.sym_visitor = FrameSymbolVisitor(symbols)\n    def _simple_visit(self, node, **kwargs):\n        for child in node.iter_child_nodes():\n            self.sym_visitor.visit(child)\n    visit_Template = (\n        visit_Block\n    ) = (\n        visit_Macro",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "FrameSymbolVisitor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "class FrameSymbolVisitor(NodeVisitor):\n    \"\"\"A visitor for `Frame.inspect`.\"\"\"\n    def __init__(self, symbols):\n        self.symbols = symbols\n    def visit_Name(self, node, store_as_param=False, **kwargs):\n        \"\"\"All assignments to names go through this function.\"\"\"\n        if store_as_param or node.ctx == \"param\":\n            self.symbols.declare_parameter(node.name)\n        elif node.ctx == \"store\":\n            self.symbols.store(node.name)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "find_symbols",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "def find_symbols(nodes, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym\ndef symbols_for_node(node, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    sym.analyze_node(node)\n    return sym",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "symbols_for_node",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "def symbols_for_node(node, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    sym.analyze_node(node)\n    return sym\nclass Symbols(object):\n    def __init__(self, parent=None, level=None):\n        if level is None:\n            if parent is None:\n                level = 0\n            else:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "VAR_LOAD_PARAMETER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "VAR_LOAD_PARAMETER = \"param\"\nVAR_LOAD_RESOLVE = \"resolve\"\nVAR_LOAD_ALIAS = \"alias\"\nVAR_LOAD_UNDEFINED = \"undefined\"\ndef find_symbols(nodes, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "VAR_LOAD_RESOLVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "VAR_LOAD_RESOLVE = \"resolve\"\nVAR_LOAD_ALIAS = \"alias\"\nVAR_LOAD_UNDEFINED = \"undefined\"\ndef find_symbols(nodes, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym\ndef symbols_for_node(node, parent_symbols=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "VAR_LOAD_ALIAS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "VAR_LOAD_ALIAS = \"alias\"\nVAR_LOAD_UNDEFINED = \"undefined\"\ndef find_symbols(nodes, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym\ndef symbols_for_node(node, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "VAR_LOAD_UNDEFINED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "peekOfCode": "VAR_LOAD_UNDEFINED = \"undefined\"\ndef find_symbols(nodes, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym\ndef symbols_for_node(node, parent_symbols=None):\n    sym = Symbols(parent=parent_symbols)\n    sym.analyze_node(node)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.idtracking",
        "documentation": {}
    },
    {
        "label": "Failure",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class Failure(object):\n    \"\"\"Class that raises a `TemplateSyntaxError` if called.\n    Used by the `Lexer` to specify known errors.\n    \"\"\"\n    def __init__(self, message, cls=TemplateSyntaxError):\n        self.message = message\n        self.error_class = cls\n    def __call__(self, lineno, filename):\n        raise self.error_class(self.message, lineno, filename)\nclass Token(tuple):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class Token(tuple):\n    \"\"\"Token class.\"\"\"\n    __slots__ = ()\n    lineno, type, value = (property(itemgetter(x)) for x in range(3))\n    def __new__(cls, lineno, type, value):\n        return tuple.__new__(cls, (lineno, intern(str(type)), value))\n    def __str__(self):\n        if self.type in reverse_operators:\n            return reverse_operators[self.type]\n        elif self.type == \"name\":",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TokenStreamIterator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class TokenStreamIterator(object):\n    \"\"\"The iterator for tokenstreams.  Iterate over the stream\n    until the eof token is reached.\n    \"\"\"\n    def __init__(self, stream):\n        self.stream = stream\n    def __iter__(self):\n        return self\n    def __next__(self):\n        token = self.stream.current",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TokenStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class TokenStream(object):\n    \"\"\"A token stream is an iterable that yields :class:`Token`\\\\s.  The\n    parser however does not iterate over it but calls :meth:`next` to go\n    one token ahead.  The current active token is stored as :attr:`current`.\n    \"\"\"\n    def __init__(self, generator, name, filename):\n        self._iter = iter(generator)\n        self._pushed = deque()\n        self.name = name\n        self.filename = filename",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "OptionalLStrip",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class OptionalLStrip(tuple):\n    \"\"\"A special tuple for marking a point in the state that can have\n    lstrip applied.\n    \"\"\"\n    __slots__ = ()\n    # Even though it looks like a no-op, creating instances fails\n    # without this.\n    def __new__(cls, *members, **kwargs):\n        return super(OptionalLStrip, cls).__new__(cls, members)\nclass Lexer(object):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "Lexer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "class Lexer(object):\n    \"\"\"Class that implements a lexer for a given environment. Automatically\n    created by the environment class, usually you don't have to do that.\n    Note that the lexer is not automatically bound to an environment.\n    Multiple environments can share the same lexer.\n    \"\"\"\n    def __init__(self, environment):\n        # shortcuts\n        e = re.escape\n        def c(x):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "describe_token",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "def describe_token(token):\n    \"\"\"Returns a description of the token.\"\"\"\n    if token.type == TOKEN_NAME:\n        return token.value\n    return _describe_token_type(token.type)\ndef describe_token_expr(expr):\n    \"\"\"Like `describe_token` but for token expressions.\"\"\"\n    if \":\" in expr:\n        type, value = expr.split(\":\", 1)\n        if type == TOKEN_NAME:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "describe_token_expr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "def describe_token_expr(expr):\n    \"\"\"Like `describe_token` but for token expressions.\"\"\"\n    if \":\" in expr:\n        type, value = expr.split(\":\", 1)\n        if type == TOKEN_NAME:\n            return value\n    else:\n        type = expr\n    return _describe_token_type(type)\ndef count_newlines(value):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "count_newlines",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "def count_newlines(value):\n    \"\"\"Count the number of newline characters in the string.  This is\n    useful for extensions that filter a stream.\n    \"\"\"\n    return len(newline_re.findall(value))\ndef compile_rules(environment):\n    \"\"\"Compiles all the rules from the environment into a list of rules.\"\"\"\n    e = re.escape\n    rules = [\n        (",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "compile_rules",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "def compile_rules(environment):\n    \"\"\"Compiles all the rules from the environment into a list of rules.\"\"\"\n    e = re.escape\n    rules = [\n        (\n            len(environment.comment_start_string),\n            TOKEN_COMMENT_BEGIN,\n            e(environment.comment_start_string),\n        ),\n        (",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "get_lexer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "def get_lexer(environment):\n    \"\"\"Return a lexer which is probably cached.\"\"\"\n    key = (\n        environment.block_start_string,\n        environment.block_end_string,\n        environment.variable_start_string,\n        environment.variable_end_string,\n        environment.comment_start_string,\n        environment.comment_end_string,\n        environment.line_statement_prefix,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "_lexer_cache",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "_lexer_cache = LRUCache(50)\n# static regular expressions\nwhitespace_re = re.compile(r\"\\s+\", re.U)\nnewline_re = re.compile(r\"(\\r\\n|\\r|\\n)\")\nstring_re = re.compile(\n    r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S\n)\ninteger_re = re.compile(r\"(\\d+_)*\\d+\")\nfloat_re = re.compile(\n    r\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "whitespace_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "whitespace_re = re.compile(r\"\\s+\", re.U)\nnewline_re = re.compile(r\"(\\r\\n|\\r|\\n)\")\nstring_re = re.compile(\n    r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S\n)\ninteger_re = re.compile(r\"(\\d+_)*\\d+\")\nfloat_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "newline_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "newline_re = re.compile(r\"(\\r\\n|\\r|\\n)\")\nstring_re = re.compile(\n    r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S\n)\ninteger_re = re.compile(r\"(\\d+_)*\\d+\")\nfloat_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated\n    (",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "string_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "string_re = re.compile(\n    r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S\n)\ninteger_re = re.compile(r\"(\\d+_)*\\d+\")\nfloat_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated\n    (\n        (\\.(\\d+_)*\\d+)?  # optional fractional part",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "integer_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "integer_re = re.compile(r\"(\\d+_)*\\d+\")\nfloat_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated\n    (\n        (\\.(\\d+_)*\\d+)?  # optional fractional part\n        e[+\\-]?(\\d+_)*\\d+  # exponent part\n    |\n        \\.(\\d+_)*\\d+  # required fractional part",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "float_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "float_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated\n    (\n        (\\.(\\d+_)*\\d+)?  # optional fractional part\n        e[+\\-]?(\\d+_)*\\d+  # exponent part\n    |\n        \\.(\\d+_)*\\d+  # required fractional part\n    )",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_ADD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_ADD = intern(\"add\")\nTOKEN_ASSIGN = intern(\"assign\")\nTOKEN_COLON = intern(\"colon\")\nTOKEN_COMMA = intern(\"comma\")\nTOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_ASSIGN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_ASSIGN = intern(\"assign\")\nTOKEN_COLON = intern(\"colon\")\nTOKEN_COMMA = intern(\"comma\")\nTOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_COLON",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_COLON = intern(\"colon\")\nTOKEN_COMMA = intern(\"comma\")\nTOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_COMMA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_COMMA = intern(\"comma\")\nTOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_DIV",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_DOT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_EQ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_FLOORDIV",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_GT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_GTEQ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LBRACE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LBRACKET",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LPAREN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LTEQ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_MOD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_MUL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_NE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_PIPE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_POW",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_RBRACE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_RBRACKET",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_RPAREN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_SEMICOLON",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_SUB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_TILDE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_WHITESPACE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_FLOAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_INTEGER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_NAME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_STRING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_OPERATOR",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_BLOCK_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_BLOCK_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_VARIABLE_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_VARIABLE_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_RAW_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_RAW_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_COMMENT_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_COMMENT_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_COMMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LINESTATEMENT_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LINESTATEMENT_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LINECOMMENT_BEGIN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LINECOMMENT_END",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_LINECOMMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_DATA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,\n    \"*\": TOKEN_MUL,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_INITIAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,\n    \"*\": TOKEN_MUL,\n    \"%\": TOKEN_MOD,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "TOKEN_EOF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "TOKEN_EOF = intern(\"eof\")\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,\n    \"*\": TOKEN_MUL,\n    \"%\": TOKEN_MOD,\n    \"**\": TOKEN_POW,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "operators",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "operators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,\n    \"*\": TOKEN_MUL,\n    \"%\": TOKEN_MOD,\n    \"**\": TOKEN_POW,\n    \"~\": TOKEN_TILDE,\n    \"[\": TOKEN_LBRACKET,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "reverse_operators",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "reverse_operators = dict([(v, k) for k, v in iteritems(operators)])\nassert len(operators) == len(reverse_operators), \"operators dropped\"\noperator_re = re.compile(\n    \"(%s)\" % \"|\".join(re.escape(x) for x in sorted(operators, key=lambda x: -len(x)))\n)\nignored_tokens = frozenset(\n    [\n        TOKEN_COMMENT_BEGIN,\n        TOKEN_COMMENT,\n        TOKEN_COMMENT_END,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "operator_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "operator_re = re.compile(\n    \"(%s)\" % \"|\".join(re.escape(x) for x in sorted(operators, key=lambda x: -len(x)))\n)\nignored_tokens = frozenset(\n    [\n        TOKEN_COMMENT_BEGIN,\n        TOKEN_COMMENT,\n        TOKEN_COMMENT_END,\n        TOKEN_WHITESPACE,\n        TOKEN_LINECOMMENT_BEGIN,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "ignored_tokens",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "ignored_tokens = frozenset(\n    [\n        TOKEN_COMMENT_BEGIN,\n        TOKEN_COMMENT,\n        TOKEN_COMMENT_END,\n        TOKEN_WHITESPACE,\n        TOKEN_LINECOMMENT_BEGIN,\n        TOKEN_LINECOMMENT_END,\n        TOKEN_LINECOMMENT,\n    ]",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "ignore_if_empty",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "peekOfCode": "ignore_if_empty = frozenset(\n    [TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT, TOKEN_LINECOMMENT]\n)\ndef _describe_token_type(token_type):\n    if token_type in reverse_operators:\n        return reverse_operators[token_type]\n    return {\n        TOKEN_COMMENT_BEGIN: \"begin of comment\",\n        TOKEN_COMMENT_END: \"end of comment\",\n        TOKEN_COMMENT: \"comment\",",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.lexer",
        "documentation": {}
    },
    {
        "label": "BaseLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class BaseLoader(object):\n    \"\"\"Baseclass for all loaders.  Subclass this and override `get_source` to\n    implement a custom loading mechanism.  The environment provides a\n    `get_template` method that calls the loader's `load` method to get the\n    :class:`Template` object.\n    A very basic example for a loader that looks up templates on the file\n    system could look like this::\n        from jinja2 import BaseLoader, TemplateNotFound\n        from os.path import join, exists, getmtime\n        class MyLoader(BaseLoader):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "FileSystemLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class FileSystemLoader(BaseLoader):\n    \"\"\"Loads templates from the file system.  This loader can find templates\n    in folders on the file system and is the preferred way to load them.\n    The loader takes the path to the templates as string, or if multiple\n    locations are wanted a list of them which is then looked up in the\n    given order::\n    >>> loader = FileSystemLoader('/path/to/templates')\n    >>> loader = FileSystemLoader(['/path/to/templates', '/other/path'])\n    Per default the template encoding is ``'utf-8'`` which can be changed\n    by setting the `encoding` parameter to something else.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "PackageLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class PackageLoader(BaseLoader):\n    \"\"\"Load templates from python eggs or packages.  It is constructed with\n    the name of the python package and the path to the templates in that\n    package::\n        loader = PackageLoader('mypackage', 'views')\n    If the package path is not given, ``'templates'`` is assumed.\n    Per default the template encoding is ``'utf-8'`` which can be changed\n    by setting the `encoding` parameter to something else.  Due to the nature\n    of eggs it's only possible to reload templates if the package was loaded\n    from the file system and not a zip file.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "DictLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class DictLoader(BaseLoader):\n    \"\"\"Loads a template from a python dict.  It's passed a dict of unicode\n    strings bound to template names.  This loader is useful for unittesting:\n    >>> loader = DictLoader({'index.html': 'source here'})\n    Because auto reloading is rarely useful this is disabled per default.\n    \"\"\"\n    def __init__(self, mapping):\n        self.mapping = mapping\n    def get_source(self, environment, template):\n        if template in self.mapping:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "FunctionLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class FunctionLoader(BaseLoader):\n    \"\"\"A loader that is passed a function which does the loading.  The\n    function receives the name of the template and has to return either\n    an unicode string with the template source, a tuple in the form ``(source,\n    filename, uptodatefunc)`` or `None` if the template does not exist.\n    >>> def load_template(name):\n    ...     if name == 'index.html':\n    ...         return '...'\n    ...\n    >>> loader = FunctionLoader(load_template)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "PrefixLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class PrefixLoader(BaseLoader):\n    \"\"\"A loader that is passed a dict of loaders where each loader is bound\n    to a prefix.  The prefix is delimited from the template by a slash per\n    default, which can be changed by setting the `delimiter` argument to\n    something else::\n        loader = PrefixLoader({\n            'app1':     PackageLoader('mypackage.app1'),\n            'app2':     PackageLoader('mypackage.app2')\n        })\n    By loading ``'app1/index.html'`` the file from the app1 package is loaded,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "ChoiceLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class ChoiceLoader(BaseLoader):\n    \"\"\"This loader works like the `PrefixLoader` just that no prefix is\n    specified.  If a template could not be found by one loader the next one\n    is tried.\n    >>> loader = ChoiceLoader([\n    ...     FileSystemLoader('/path/to/user/templates'),\n    ...     FileSystemLoader('/path/to/system/templates')\n    ... ])\n    This is useful if you want to allow users to override builtin templates\n    from a different location.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "_TemplateModule",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class _TemplateModule(ModuleType):\n    \"\"\"Like a normal module but with support for weak references\"\"\"\nclass ModuleLoader(BaseLoader):\n    \"\"\"This loader loads templates from precompiled templates.\n    Example usage:\n    >>> loader = ChoiceLoader([\n    ...     ModuleLoader('/path/to/compiled/templates'),\n    ...     FileSystemLoader('/path/to/templates')\n    ... ])\n    Templates can be precompiled with :meth:`Environment.compile_templates`.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "ModuleLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class ModuleLoader(BaseLoader):\n    \"\"\"This loader loads templates from precompiled templates.\n    Example usage:\n    >>> loader = ChoiceLoader([\n    ...     ModuleLoader('/path/to/compiled/templates'),\n    ...     FileSystemLoader('/path/to/templates')\n    ... ])\n    Templates can be precompiled with :meth:`Environment.compile_templates`.\n    \"\"\"\n    has_source_access = False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "ResourceLoader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "class ResourceLoader(BaseLoader):\n    def __init__(self, prefix, module_loader):\n        self.prefix = prefix\n        self.module_loader = module_loader\n    def get_source(self, environment, template):\n        if self.module_loader is None:\n            raise TemplateNotFound(template)\n        try:\n            return self.module_loader.get_data(os.path.join(self.prefix, template)).decode('utf-8'), None, None\n        except IOError:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "split_template_path",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "peekOfCode": "def split_template_path(template):\n    \"\"\"Split a path into segments and perform a sanity check.  If it detects\n    '..' in the path it will raise a `TemplateNotFound` error.\n    \"\"\"\n    pieces = []\n    for piece in template.split(\"/\"):\n        if (\n            path.sep in piece\n            or (path.altsep and path.altsep in piece)\n            or piece == path.pardir",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.loaders",
        "documentation": {}
    },
    {
        "label": "TrackingCodeGenerator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "peekOfCode": "class TrackingCodeGenerator(CodeGenerator):\n    \"\"\"We abuse the code generator for introspection.\"\"\"\n    def __init__(self, environment):\n        CodeGenerator.__init__(self, environment, \"<introspection>\", \"<introspection>\")\n        self.undeclared_identifiers = set()\n    def write(self, x):\n        \"\"\"Don't write.\"\"\"\n    def enter_frame(self, frame):\n        \"\"\"Remember all undeclared identifiers.\"\"\"\n        CodeGenerator.enter_frame(self, frame)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "documentation": {}
    },
    {
        "label": "find_undeclared_variables",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "peekOfCode": "def find_undeclared_variables(ast):\n    \"\"\"Returns a set of all variables in the AST that will be looked up from\n    the context at runtime.  Because at compile time it's not known which\n    variables will be used depending on the path the execution takes at\n    runtime, all variables are returned.\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')\n    >>> meta.find_undeclared_variables(ast) == set(['bar'])\n    True",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "documentation": {}
    },
    {
        "label": "find_referenced_templates",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "peekOfCode": "def find_referenced_templates(ast):\n    \"\"\"Finds all the referenced templates from the AST.  This will return an\n    iterator over all the hardcoded template extensions, inclusions and\n    imports.  If dynamic inheritance or inclusion is used, `None` will be\n    yielded.\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% extends \"layout.html\" %}{% include helper %}')\n    >>> list(meta.find_referenced_templates(ast))\n    ['layout.html', None]",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.meta",
        "documentation": {}
    },
    {
        "label": "NativeCodeGenerator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "peekOfCode": "class NativeCodeGenerator(CodeGenerator):\n    \"\"\"A code generator which renders Python types by not adding\n    ``to_string()`` around output nodes.\n    \"\"\"\n    @staticmethod\n    def _default_finalize(value):\n        return value\n    def _output_const_repr(self, group):\n        return repr(u\"\".join([text_type(v) for v in group]))\n    def _output_child_to_const(self, node, frame, finalize):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "documentation": {}
    },
    {
        "label": "NativeEnvironment",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "peekOfCode": "class NativeEnvironment(Environment):\n    \"\"\"An environment that renders templates to native Python types.\"\"\"\n    code_generator_class = NativeCodeGenerator\nclass NativeTemplate(Template):\n    environment_class = NativeEnvironment\n    def render(self, *args, **kwargs):\n        \"\"\"Render the template to produce a native Python type. If the\n        result is a single node, its value is returned. Otherwise, the\n        nodes are concatenated as strings. If the result can be parsed\n        with :func:`ast.literal_eval`, the parsed value is returned.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "documentation": {}
    },
    {
        "label": "NativeTemplate",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "peekOfCode": "class NativeTemplate(Template):\n    environment_class = NativeEnvironment\n    def render(self, *args, **kwargs):\n        \"\"\"Render the template to produce a native Python type. If the\n        result is a single node, its value is returned. Otherwise, the\n        nodes are concatenated as strings. If the result can be parsed\n        with :func:`ast.literal_eval`, the parsed value is returned.\n        Otherwise, the string is returned.\n        \"\"\"\n        vars = dict(*args, **kwargs)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "documentation": {}
    },
    {
        "label": "native_concat",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "peekOfCode": "def native_concat(nodes):\n    \"\"\"Return a native Python type from the list of compiled nodes. If\n    the result is a single node, its value is returned. Otherwise, the\n    nodes are concatenated as strings. If the result can be parsed with\n    :func:`ast.literal_eval`, the parsed value is returned. Otherwise,\n    the string is returned.\n    :param nodes: Iterable of nodes to concatenate.\n    \"\"\"\n    head = list(islice(nodes, 2))\n    if not head:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "documentation": {}
    },
    {
        "label": "NativeEnvironment.template_class",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "peekOfCode": "NativeEnvironment.template_class = NativeTemplate  # type: ignore",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nativetypes",
        "documentation": {}
    },
    {
        "label": "Impossible",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Impossible(Exception):\n    \"\"\"Raised if the node could not perform a requested action.\"\"\"\nclass NodeType(type):\n    \"\"\"A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.\"\"\"\n    def __new__(mcs, name, bases, d):\n        for attr in \"fields\", \"attributes\":\n            storage = []\n            storage.extend(getattr(bases[0], attr, ()))",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "NodeType",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class NodeType(type):\n    \"\"\"A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.\"\"\"\n    def __new__(mcs, name, bases, d):\n        for attr in \"fields\", \"attributes\":\n            storage = []\n            storage.extend(getattr(bases[0], attr, ()))\n            storage.extend(d.get(attr, ()))\n            assert len(bases) == 1, \"multiple inheritance not allowed\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "EvalContext",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class EvalContext(object):\n    \"\"\"Holds evaluation time information.  Custom attributes can be attached\n    to it in extensions.\n    \"\"\"\n    def __init__(self, environment, template_name=None):\n        self.environment = environment\n        if callable(environment.autoescape):\n            self.autoescape = environment.autoescape(template_name)\n        else:\n            self.autoescape = environment.autoescape",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Node(with_metaclass(NodeType, object)):\n    \"\"\"Baseclass for all Jinja nodes.  There are a number of nodes available\n    of different types.  There are four major types:\n    -   :class:`Stmt`: statements\n    -   :class:`Expr`: expressions\n    -   :class:`Helper`: helper nodes\n    -   :class:`Template`: the outermost wrapper node\n    All nodes have fields and attributes.  Fields may be other nodes, lists,\n    or arbitrary values.  Fields are passed to the constructor as regular\n    positional arguments, attributes as keyword arguments.  Each node has",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Stmt",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Stmt(Node):\n    \"\"\"Base node for all statements.\"\"\"\n    abstract = True\nclass Helper(Node):\n    \"\"\"Nodes that exist in a specific context only.\"\"\"\n    abstract = True\nclass Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Helper",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Helper(Node):\n    \"\"\"Nodes that exist in a specific context only.\"\"\"\n    abstract = True\nclass Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"\n    fields = (\"body\",)\nclass Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Template",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"\n    fields = (\"body\",)\nclass Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    \"\"\"\n    fields = (\"nodes\",)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Output",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    \"\"\"\n    fields = (\"nodes\",)\nclass Extends(Stmt):\n    \"\"\"Represents an extends statement.\"\"\"\n    fields = (\"template\",)\nclass For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Extends",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Extends(Stmt):\n    \"\"\"Represents an extends statement.\"\"\"\n    fields = (\"template\",)\nclass For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "For",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    \"\"\"\n    fields = (\"target\", \"iter\", \"body\", \"else_\", \"test\", \"recursive\")\nclass If(Stmt):\n    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "If",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class If(Stmt):\n    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"\n    fields = (\"test\", \"body\", \"elif_\", \"else_\")\nclass Macro(Stmt):\n    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    \"\"\"\n    fields = (\"name\", \"args\", \"defaults\", \"body\")\nclass CallBlock(Stmt):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Macro",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Macro(Stmt):\n    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    \"\"\"\n    fields = (\"name\", \"args\", \"defaults\", \"body\")\nclass CallBlock(Stmt):\n    \"\"\"Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "CallBlock",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class CallBlock(Stmt):\n    \"\"\"Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    \"\"\"\n    fields = (\"call\", \"args\", \"defaults\", \"body\")\nclass FilterBlock(Stmt):\n    \"\"\"Node for filter sections.\"\"\"\n    fields = (\"body\", \"filter\")\nclass With(Stmt):\n    \"\"\"Specific node for with statements.  In older versions of Jinja the",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "FilterBlock",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class FilterBlock(Stmt):\n    \"\"\"Node for filter sections.\"\"\"\n    fields = (\"body\", \"filter\")\nclass With(Stmt):\n    \"\"\"Specific node for with statements.  In older versions of Jinja the\n    with statement was implemented on the base of the `Scope` node instead.\n    .. versionadded:: 2.9.3\n    \"\"\"\n    fields = (\"targets\", \"values\", \"body\")\nclass Block(Stmt):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "With",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class With(Stmt):\n    \"\"\"Specific node for with statements.  In older versions of Jinja the\n    with statement was implemented on the base of the `Scope` node instead.\n    .. versionadded:: 2.9.3\n    \"\"\"\n    fields = (\"targets\", \"values\", \"body\")\nclass Block(Stmt):\n    \"\"\"A node that represents a block.\"\"\"\n    fields = (\"name\", \"body\", \"scoped\")\nclass Include(Stmt):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Block",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Block(Stmt):\n    \"\"\"A node that represents a block.\"\"\"\n    fields = (\"name\", \"body\", \"scoped\")\nclass Include(Stmt):\n    \"\"\"A node that represents the include tag.\"\"\"\n    fields = (\"template\", \"with_context\", \"ignore_missing\")\nclass Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n    fields = (\"template\", \"target\", \"with_context\")\nclass FromImport(Stmt):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Include",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Include(Stmt):\n    \"\"\"A node that represents the include tag.\"\"\"\n    fields = (\"template\", \"with_context\", \"ignore_missing\")\nclass Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n    fields = (\"template\", \"target\", \"with_context\")\nclass FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Import",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n    fields = (\"template\", \"target\", \"with_context\")\nclass FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "FromImport",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension\n    extra care must be taken.\n    The list of names may contain tuples if aliases are wanted.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "ExprStmt",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class ExprStmt(Stmt):\n    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"\n    fields = (\"node\",)\nclass Assign(Stmt):\n    \"\"\"Assigns an expression to a target.\"\"\"\n    fields = (\"target\", \"node\")\nclass AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n    fields = (\"target\", \"filter\", \"body\")\nclass Expr(Node):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Assign",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Assign(Stmt):\n    \"\"\"Assigns an expression to a target.\"\"\"\n    fields = (\"target\", \"node\")\nclass AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n    fields = (\"target\", \"filter\", \"body\")\nclass Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n    abstract = True\n    def as_const(self, eval_ctx=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "AssignBlock",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n    fields = (\"target\", \"filter\", \"body\")\nclass Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n    abstract = True\n    def as_const(self, eval_ctx=None):\n        \"\"\"Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n        An :class:`EvalContext` can be provided, if none is given",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Expr",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n    abstract = True\n    def as_const(self, eval_ctx=None):\n        \"\"\"Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n        An :class:`EvalContext` can be provided, if none is given\n        a default context is created which requires the nodes to have\n        an attached environment.\n        .. versionchanged:: 2.4",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "BinExpr",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class BinExpr(Expr):\n    \"\"\"Baseclass for all binary expressions.\"\"\"\n    fields = (\"left\", \"right\")\n    operator = None\n    abstract = True\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if (\n            self.environment.sandboxed",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "UnaryExpr",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class UnaryExpr(Expr):\n    \"\"\"Baseclass for all unary expressions.\"\"\"\n    fields = (\"node\",)\n    operator = None\n    abstract = True\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        # intercepted operators cannot be folded at compile time\n        if (\n            self.environment.sandboxed",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Name",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Name(Expr):\n    \"\"\"Looks up a name or stores a value in a name.\n    The `ctx` of the node can be one of the following values:\n    -   `store`: store a value in the name\n    -   `load`: load that name\n    -   `param`: like `store` but if the name was defined as function parameter.\n    \"\"\"\n    fields = (\"name\", \"ctx\")\n    def can_assign(self):\n        return self.name not in (\"true\", \"false\", \"none\", \"True\", \"False\", \"None\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "NSRef",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class NSRef(Expr):\n    \"\"\"Reference to a namespace value assignment\"\"\"\n    fields = (\"name\", \"attr\")\n    def can_assign(self):\n        # We don't need any special checks here; NSRef assignments have a\n        # runtime check to ensure the target is a namespace object which will\n        # have been checked already as it is created using a normal assignment\n        # which goes through a `Name` node.\n        return True\nclass Literal(Expr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Literal",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Literal(Expr):\n    \"\"\"Baseclass for literals.\"\"\"\n    abstract = True\nclass Const(Literal):\n    \"\"\"All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``\"foo\"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    \"\"\"\n    fields = (\"value\",)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Const",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Const(Literal):\n    \"\"\"All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``\"foo\"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    \"\"\"\n    fields = (\"value\",)\n    def as_const(self, eval_ctx=None):\n        rv = self.value\n        if (",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "TemplateData",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class TemplateData(Literal):\n    \"\"\"A constant template string.\"\"\"\n    fields = (\"data\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        if eval_ctx.autoescape:\n            return Markup(self.data)\n        return self.data",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Tuple(Literal):\n    \"\"\"For loop unpacking and some other things like multiple arguments\n    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple\n    is used for loading the names or storing.\n    \"\"\"\n    fields = (\"items\", \"ctx\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return tuple(x.as_const(eval_ctx) for x in self.items)\n    def can_assign(self):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "List",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class List(Literal):\n    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"\n    fields = (\"items\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return [x.as_const(eval_ctx) for x in self.items]\nclass Dict(Literal):\n    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Dict(Literal):\n    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    \"\"\"\n    fields = (\"items\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return dict(x.as_const(eval_ctx) for x in self.items)\nclass Pair(Helper):\n    \"\"\"A key, value pair for dicts.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Pair",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Pair(Helper):\n    \"\"\"A key, value pair for dicts.\"\"\"\n    fields = (\"key\", \"value\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)\nclass Keyword(Helper):\n    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"\n    fields = (\"key\", \"value\")\n    def as_const(self, eval_ctx=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Keyword",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Keyword(Helper):\n    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"\n    fields = (\"key\", \"value\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key, self.value.as_const(eval_ctx)\nclass CondExpr(Expr):\n    \"\"\"A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "CondExpr",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class CondExpr(Expr):\n    \"\"\"A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    \"\"\"\n    fields = (\"test\", \"expr1\", \"expr2\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.test.as_const(eval_ctx):\n            return self.expr1.as_const(eval_ctx)\n        # if we evaluate to an undefined object, we better do that at runtime",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Filter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Filter(Expr):\n    \"\"\"This node applies a filter on an expression.  `name` is the name of\n    the filter, the rest of the fields are the same as for :class:`Call`.\n    If the `node` of a filter is `None` the contents of the last buffer are\n    filtered.  Buffers are created by macros and filter blocks.\n    \"\"\"\n    fields = (\"node\", \"name\", \"args\", \"kwargs\", \"dyn_args\", \"dyn_kwargs\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile or self.node is None:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Test",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Test(Expr):\n    \"\"\"Applies a test on an expression.  `name` is the name of the test, the\n    rest of the fields are the same as for :class:`Call`.\n    \"\"\"\n    fields = (\"node\", \"name\", \"args\", \"kwargs\", \"dyn_args\", \"dyn_kwargs\")\n    def as_const(self, eval_ctx=None):\n        test = self.environment.tests.get(self.name)\n        if test is None:\n            raise Impossible()\n        eval_ctx = get_eval_context(self, eval_ctx)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Call",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Call(Expr):\n    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list\n    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`\n    and `dyn_kwargs` has to be either `None` or a node that is used as\n    node for dynamic positional (``*args``) or keyword (``**kwargs``)\n    arguments.\n    \"\"\"\n    fields = (\"node\", \"args\", \"kwargs\", \"dyn_args\", \"dyn_kwargs\")\nclass Getitem(Expr):\n    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Getitem",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Getitem(Expr):\n    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"\n    fields = (\"node\", \"arg\", \"ctx\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.ctx != \"load\":\n            raise Impossible()\n        try:\n            return self.environment.getitem(\n                self.node.as_const(eval_ctx), self.arg.as_const(eval_ctx)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Getattr",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Getattr(Expr):\n    \"\"\"Get an attribute or item from an expression that is a ascii-only\n    bytestring and prefer the attribute.\n    \"\"\"\n    fields = (\"node\", \"attr\", \"ctx\")\n    def as_const(self, eval_ctx=None):\n        if self.ctx != \"load\":\n            raise Impossible()\n        try:\n            eval_ctx = get_eval_context(self, eval_ctx)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Slice",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Slice(Expr):\n    \"\"\"Represents a slice object.  This must only be used as argument for\n    :class:`Subscript`.\n    \"\"\"\n    fields = (\"start\", \"stop\", \"step\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        def const(obj):\n            if obj is None:\n                return None",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Concat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Concat(Expr):\n    \"\"\"Concatenates the list of expressions provided after converting them to\n    unicode.\n    \"\"\"\n    fields = (\"nodes\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return \"\".join(text_type(x.as_const(eval_ctx)) for x in self.nodes)\nclass Compare(Expr):\n    \"\"\"Compares an expression with some other expressions.  `ops` must be a",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Compare",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Compare(Expr):\n    \"\"\"Compares an expression with some other expressions.  `ops` must be a\n    list of :class:`Operand`\\\\s.\n    \"\"\"\n    fields = (\"expr\", \"ops\")\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        result = value = self.expr.as_const(eval_ctx)\n        try:\n            for op in self.ops:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Operand",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Operand(Helper):\n    \"\"\"Holds an operator and an expression.\"\"\"\n    fields = (\"op\", \"expr\")\nif __debug__:\n    Operand.__doc__ += \"\\nThe following operators are available: \" + \", \".join(\n        sorted(\n            \"``%s``\" % x\n            for x in set(_binop_to_func) | set(_uaop_to_func) | set(_cmpop_to_func)\n        )\n    )",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Mul",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Mul(BinExpr):\n    \"\"\"Multiplies the left with the right node.\"\"\"\n    operator = \"*\"\nclass Div(BinExpr):\n    \"\"\"Divides the left by the right node.\"\"\"\n    operator = \"/\"\nclass FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and truncates conver the\n    result into an integer by truncating.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Div",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Div(BinExpr):\n    \"\"\"Divides the left by the right node.\"\"\"\n    operator = \"/\"\nclass FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and truncates conver the\n    result into an integer by truncating.\n    \"\"\"\n    operator = \"//\"\nclass Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "FloorDiv",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and truncates conver the\n    result into an integer by truncating.\n    \"\"\"\n    operator = \"//\"\nclass Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"\n    operator = \"+\"\nclass Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Add",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"\n    operator = \"+\"\nclass Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"\n    operator = \"-\"\nclass Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n    operator = \"%\"\nclass Pow(BinExpr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Sub",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"\n    operator = \"-\"\nclass Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n    operator = \"%\"\nclass Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n    operator = \"**\"\nclass And(BinExpr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Mod",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n    operator = \"%\"\nclass Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n    operator = \"**\"\nclass And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n    operator = \"and\"\n    def as_const(self, eval_ctx=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Pow",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n    operator = \"**\"\nclass And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n    operator = \"and\"\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)\nclass Or(BinExpr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "And",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n    operator = \"and\"\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)\nclass Or(BinExpr):\n    \"\"\"Short circuited OR.\"\"\"\n    operator = \"or\"\n    def as_const(self, eval_ctx=None):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Or",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Or(BinExpr):\n    \"\"\"Short circuited OR.\"\"\"\n    operator = \"or\"\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)\nclass Not(UnaryExpr):\n    \"\"\"Negate the expression.\"\"\"\n    operator = \"not\"\nclass Neg(UnaryExpr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Not",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Not(UnaryExpr):\n    \"\"\"Negate the expression.\"\"\"\n    operator = \"not\"\nclass Neg(UnaryExpr):\n    \"\"\"Make the expression negative.\"\"\"\n    operator = \"-\"\nclass Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n    operator = \"+\"\n# Helpers for extensions",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Neg",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Neg(UnaryExpr):\n    \"\"\"Make the expression negative.\"\"\"\n    operator = \"-\"\nclass Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n    operator = \"+\"\n# Helpers for extensions\nclass EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Pos",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n    operator = \"+\"\n# Helpers for extensions\nclass EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    \"\"\"\n    fields = (\"name\",)\nclass ExtensionAttribute(Expr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "EnvironmentAttribute",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    \"\"\"\n    fields = (\"name\",)\nclass ExtensionAttribute(Expr):\n    \"\"\"Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "ExtensionAttribute",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class ExtensionAttribute(Expr):\n    \"\"\"Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.\n    \"\"\"\n    fields = (\"identifier\", \"name\")\nclass ImportedName(Expr):\n    \"\"\"If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "ImportedName",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class ImportedName(Expr):\n    \"\"\"If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`\n    function from the cgi module on evaluation.  Imports are optimized by the\n    compiler so there is no need to assign them to local variables.\n    \"\"\"\n    fields = (\"importname\",)\nclass InternalName(Expr):\n    \"\"\"An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "InternalName",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class InternalName(Expr):\n    \"\"\"An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a\n    :meth:`~jinja2.parser.Parser.free_identifier` method that creates\n    a new identifier for you.  This identifier is not available from the\n    template and is not threated specially by the compiler.\n    \"\"\"\n    fields = (\"name\",)\n    def __init__(self):\n        raise TypeError(",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "MarkSafe",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class MarkSafe(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"\n    fields = (\"expr\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return Markup(self.expr.as_const(eval_ctx))\nclass MarkSafeIfAutoescape(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n    .. versionadded:: 2.5",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "MarkSafeIfAutoescape",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class MarkSafeIfAutoescape(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n    .. versionadded:: 2.5\n    \"\"\"\n    fields = (\"expr\",)\n    def as_const(self, eval_ctx=None):\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "ContextReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class ContextReference(Expr):\n    \"\"\"Returns the current template context.  It can be used like a\n    :class:`Name` node, with a ``'load'`` ctx and will return the\n    current :class:`~jinja2.runtime.Context` object.\n    Here an example that assigns the current template name to a\n    variable named `foo`::\n        Assign(Name('foo', ctx='store'),\n               Getattr(ContextReference(), 'name'))\n    This is basically equivalent to using the\n    :func:`~jinja2.contextfunction` decorator when using the",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "DerivedContextReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class DerivedContextReference(Expr):\n    \"\"\"Return the current template context including locals. Behaves\n    exactly like :class:`ContextReference`, but includes local\n    variables, such as from a ``for`` loop.\n    .. versionadded:: 2.11\n    \"\"\"\nclass Continue(Stmt):\n    \"\"\"Continue a loop.\"\"\"\nclass Break(Stmt):\n    \"\"\"Break a loop.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Continue",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Continue(Stmt):\n    \"\"\"Continue a loop.\"\"\"\nclass Break(Stmt):\n    \"\"\"Break a loop.\"\"\"\nclass Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n    fields = (\"body\",)\nclass OverlayScope(Stmt):\n    \"\"\"An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Break",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Break(Stmt):\n    \"\"\"Break a loop.\"\"\"\nclass Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n    fields = (\"body\",)\nclass OverlayScope(Stmt):\n    \"\"\"An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into\n    a sub scope from a dictionary or dictionary like object.  The `context`\n    field has to evaluate to a dictionary object.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Scope",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n    fields = (\"body\",)\nclass OverlayScope(Stmt):\n    \"\"\"An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into\n    a sub scope from a dictionary or dictionary like object.  The `context`\n    field has to evaluate to a dictionary object.\n    Example usage::\n        OverlayScope(context=self.call_method('get_context'),",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "OverlayScope",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class OverlayScope(Stmt):\n    \"\"\"An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into\n    a sub scope from a dictionary or dictionary like object.  The `context`\n    field has to evaluate to a dictionary object.\n    Example usage::\n        OverlayScope(context=self.call_method('get_context'),\n                     body=[...])\n    .. versionadded:: 2.10\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "EvalContextModifier",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class EvalContextModifier(Stmt):\n    \"\"\"Modifies the eval context.  For each option that should be modified,\n    a :class:`Keyword` has to be added to the :attr:`options` list.\n    Example to change the `autoescape` setting::\n        EvalContextModifier(options=[Keyword('autoescape', Const(True))])\n    \"\"\"\n    fields = (\"options\",)\nclass ScopedEvalContextModifier(EvalContextModifier):\n    \"\"\"Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "ScopedEvalContextModifier",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "class ScopedEvalContextModifier(EvalContextModifier):\n    \"\"\"Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the\n    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.\n    \"\"\"\n    fields = (\"body\",)\n# make sure nobody creates custom nodes\ndef _failing_new(*args, **kwargs):\n    raise TypeError(\"can't create custom node types\")\nNodeType.__new__ = staticmethod(_failing_new)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "get_eval_context",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "def get_eval_context(node, ctx):\n    if ctx is None:\n        if node.environment is None:\n            raise RuntimeError(\n                \"if no eval context is passed, the \"\n                \"node must have an attached \"\n                \"environment.\"\n            )\n        return EvalContext(node.environment)\n    return ctx",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "args_as_const",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "def args_as_const(node, eval_ctx):\n    args = [x.as_const(eval_ctx) for x in node.args]\n    kwargs = dict(x.as_const(eval_ctx) for x in node.kwargs)\n    if node.dyn_args is not None:\n        try:\n            args.extend(node.dyn_args.as_const(eval_ctx))\n        except Exception:\n            raise Impossible()\n    if node.dyn_kwargs is not None:\n        try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "_binop_to_func",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "_binop_to_func = {\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n    \"//\": operator.floordiv,\n    \"**\": operator.pow,\n    \"%\": operator.mod,\n    \"+\": operator.add,\n    \"-\": operator.sub,\n}\n_uaop_to_func = {\"not\": operator.not_, \"+\": operator.pos, \"-\": operator.neg}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "_uaop_to_func",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "_uaop_to_func = {\"not\": operator.not_, \"+\": operator.pos, \"-\": operator.neg}\n_cmpop_to_func = {\n    \"eq\": operator.eq,\n    \"ne\": operator.ne,\n    \"gt\": operator.gt,\n    \"gteq\": operator.ge,\n    \"lt\": operator.lt,\n    \"lteq\": operator.le,\n    \"in\": lambda a, b: a in b,\n    \"notin\": lambda a, b: a not in b,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "_cmpop_to_func",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "_cmpop_to_func = {\n    \"eq\": operator.eq,\n    \"ne\": operator.ne,\n    \"gt\": operator.gt,\n    \"gteq\": operator.ge,\n    \"lt\": operator.lt,\n    \"lteq\": operator.le,\n    \"in\": lambda a, b: a in b,\n    \"notin\": lambda a, b: a not in b,\n}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "NodeType.__new__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "peekOfCode": "NodeType.__new__ = staticmethod(_failing_new)\ndel _failing_new",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.nodes",
        "documentation": {}
    },
    {
        "label": "Optimizer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "peekOfCode": "class Optimizer(NodeTransformer):\n    def __init__(self, environment):\n        self.environment = environment\n    def generic_visit(self, node, *args, **kwargs):\n        node = super(Optimizer, self).generic_visit(node, *args, **kwargs)\n        # Do constant folding. Some other nodes besides Expr have\n        # as_const, but folding them causes errors later on.\n        if isinstance(node, nodes.Expr):\n            try:\n                return nodes.Const.from_untrusted(",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "documentation": {}
    },
    {
        "label": "optimize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "peekOfCode": "def optimize(node, environment):\n    \"\"\"The context hint can be used to perform an static optimization\n    based on the context given.\"\"\"\n    optimizer = Optimizer(environment)\n    return optimizer.visit(node)\nclass Optimizer(NodeTransformer):\n    def __init__(self, environment):\n        self.environment = environment\n    def generic_visit(self, node, *args, **kwargs):\n        node = super(Optimizer, self).generic_visit(node, *args, **kwargs)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.optimizer",
        "documentation": {}
    },
    {
        "label": "Parser",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "peekOfCode": "class Parser(object):\n    \"\"\"This is the central parsing class Jinja uses.  It's passed to\n    extensions and can be used to parse expressions or statements.\n    \"\"\"\n    def __init__(self, environment, source, name=None, filename=None, state=None):\n        self.environment = environment\n        self.stream = environment._tokenize(source, name, filename, state)\n        self.name = name\n        self.filename = filename\n        self.closed = False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "documentation": {}
    },
    {
        "label": "_statement_keywords",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "peekOfCode": "_statement_keywords = frozenset(\n    [\n        \"for\",\n        \"if\",\n        \"block\",\n        \"extends\",\n        \"print\",\n        \"macro\",\n        \"include\",\n        \"from\",",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "documentation": {}
    },
    {
        "label": "_compare_operators",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "peekOfCode": "_compare_operators = frozenset([\"eq\", \"ne\", \"lt\", \"lteq\", \"gt\", \"gteq\"])\n_math_nodes = {\n    \"add\": nodes.Add,\n    \"sub\": nodes.Sub,\n    \"mul\": nodes.Mul,\n    \"div\": nodes.Div,\n    \"floordiv\": nodes.FloorDiv,\n    \"mod\": nodes.Mod,\n}\nclass Parser(object):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "documentation": {}
    },
    {
        "label": "_math_nodes",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "peekOfCode": "_math_nodes = {\n    \"add\": nodes.Add,\n    \"sub\": nodes.Sub,\n    \"mul\": nodes.Mul,\n    \"div\": nodes.Div,\n    \"floordiv\": nodes.FloorDiv,\n    \"mod\": nodes.Mod,\n}\nclass Parser(object):\n    \"\"\"This is the central parsing class Jinja uses.  It's passed to",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.parser",
        "documentation": {}
    },
    {
        "label": "TemplateReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class TemplateReference(object):\n    \"\"\"The `self` in templates.\"\"\"\n    def __init__(self, context):\n        self.__context = context\n    def __getitem__(self, name):\n        blocks = self.__context.blocks[name]\n        return BlockReference(name, self.__context, blocks, 0)\n    def __repr__(self):\n        return \"<%s %r>\" % (self.__class__.__name__, self.__context.name)\ndef _get_func(x):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "ContextMeta",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class ContextMeta(type):\n    def __new__(mcs, name, bases, d):\n        rv = type.__new__(mcs, name, bases, d)\n        if bases == ():\n            return rv\n        resolve = _get_func(rv.resolve)\n        default_resolve = _get_func(Context.resolve)\n        resolve_or_missing = _get_func(rv.resolve_or_missing)\n        default_resolve_or_missing = _get_func(Context.resolve_or_missing)\n        # If we have a changed resolve but no changed default or missing",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class Context(with_metaclass(ContextMeta)):\n    \"\"\"The template context holds the variables of a template.  It stores the\n    values passed to the template and also the names the template exports.\n    Creating instances is neither supported nor useful as it's created\n    automatically at various stages of the template evaluation and should not\n    be created by hand.\n    The context is immutable.  Modifications on :attr:`parent` **must not**\n    happen and modifications on :attr:`vars` are allowed from generated\n    template code only.  Template filters and global functions marked as\n    :func:`contextfunction`\\\\s get the active context passed as first argument",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "BlockReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class BlockReference(object):\n    \"\"\"One block on a template reference.\"\"\"\n    def __init__(self, name, context, stack, depth):\n        self.name = name\n        self._context = context\n        self._stack = stack\n        self._depth = depth\n    @property\n    def super(self):\n        \"\"\"Super the block.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "LoopContext",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class LoopContext:\n    \"\"\"A wrapper iterable for dynamic ``for`` loops, with information\n    about the loop and iteration.\n    \"\"\"\n    #: Current iteration of the loop, starting at 0.\n    index0 = -1\n    _length = None\n    _after = missing\n    _current = missing\n    _before = missing",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "Macro",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class Macro(object):\n    \"\"\"Wraps a macro function.\"\"\"\n    def __init__(\n        self,\n        environment,\n        func,\n        name,\n        arguments,\n        catch_kwargs,\n        catch_varargs,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "Undefined",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class Undefined(object):\n    \"\"\"The default undefined type.  This undefined type can be printed and\n    iterated over, but every other access will raise an :exc:`UndefinedError`:\n    >>> foo = Undefined(name='foo')\n    >>> str(foo)\n    ''\n    >>> not foo\n    True\n    >>> foo + 42\n    Traceback (most recent call last):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "ChainableUndefined",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class ChainableUndefined(Undefined):\n    \"\"\"An undefined that is chainable, where both ``__getattr__`` and\n    ``__getitem__`` return itself rather than raising an\n    :exc:`UndefinedError`.\n    >>> foo = ChainableUndefined(name='foo')\n    >>> str(foo.bar['baz'])\n    ''\n    >>> foo.bar['baz'] + 42\n    Traceback (most recent call last):\n      ...",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "DebugUndefined",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class DebugUndefined(Undefined):\n    \"\"\"An undefined that returns the debug info when printed.\n    >>> foo = DebugUndefined(name='foo')\n    >>> str(foo)\n    '{{ foo }}'\n    >>> not foo\n    True\n    >>> foo + 42\n    Traceback (most recent call last):\n      ...",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "StrictUndefined",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "class StrictUndefined(Undefined):\n    \"\"\"An undefined that barks on print and iteration as well as boolean\n    tests and all kinds of comparisons.  In other words: you can do nothing\n    with it except checking if it's defined using the `defined` test.\n    >>> foo = StrictUndefined(name='foo')\n    >>> str(foo)\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    >>> not foo",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def identity(x):\n    \"\"\"Returns its argument. Useful for certain things in the\n    environment.\n    \"\"\"\n    return x\ndef markup_join(seq):\n    \"\"\"Concatenation that escapes if necessary and converts to unicode.\"\"\"\n    buf = []\n    iterator = imap(soft_unicode, seq)\n    for arg in iterator:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "markup_join",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def markup_join(seq):\n    \"\"\"Concatenation that escapes if necessary and converts to unicode.\"\"\"\n    buf = []\n    iterator = imap(soft_unicode, seq)\n    for arg in iterator:\n        buf.append(arg)\n        if hasattr(arg, \"__html__\"):\n            return Markup(u\"\").join(chain(buf, iterator))\n    return concat(buf)\ndef unicode_join(seq):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "unicode_join",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def unicode_join(seq):\n    \"\"\"Simple args to unicode conversion and concatenation.\"\"\"\n    return concat(imap(text_type, seq))\ndef new_context(\n    environment,\n    template_name,\n    blocks,\n    vars=None,\n    shared=None,\n    globals=None,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "new_context",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def new_context(\n    environment,\n    template_name,\n    blocks,\n    vars=None,\n    shared=None,\n    globals=None,\n    locals=None,\n):\n    \"\"\"Internal helper for context creation.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "resolve_or_missing",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def resolve_or_missing(context, key, missing=missing):\n    if key in context.vars:\n        return context.vars[key]\n    if key in context.parent:\n        return context.parent[key]\n    return missing\nclass Context(with_metaclass(ContextMeta)):\n    \"\"\"The template context holds the variables of a template.  It stores the\n    values passed to the template and also the names the template exports.\n    Creating instances is neither supported nor useful as it's created",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "make_logging_undefined",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "def make_logging_undefined(logger=None, base=None):\n    \"\"\"Given a logger object this returns a new undefined class that will\n    log certain failures.  It will log iterations and printing.  If no\n    logger is given a default logger is created.\n    Example::\n        logger = logging.getLogger(__name__)\n        LoggingUndefined = make_logging_undefined(\n            logger=logger,\n            base=Undefined\n        )",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "exported",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "exported = [\n    \"LoopContext\",\n    \"TemplateReference\",\n    \"Macro\",\n    \"Markup\",\n    \"TemplateRuntimeError\",\n    \"missing\",\n    \"concat\",\n    \"escape\",\n    \"markup_join\",",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "to_string",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "peekOfCode": "to_string = text_type\ndef identity(x):\n    \"\"\"Returns its argument. Useful for certain things in the\n    environment.\n    \"\"\"\n    return x\ndef markup_join(seq):\n    \"\"\"Concatenation that escapes if necessary and converts to unicode.\"\"\"\n    buf = []\n    iterator = imap(soft_unicode, seq)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.runtime",
        "documentation": {}
    },
    {
        "label": "_MagicFormatMapping",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class _MagicFormatMapping(abc.Mapping):\n    \"\"\"This class implements a dummy wrapper to fix a bug in the Python\n    standard library for string formatting.\n    See https://bugs.python.org/issue13598 for information about why\n    this is necessary.\n    \"\"\"\n    def __init__(self, args, kwargs):\n        self._args = args\n        self._kwargs = kwargs\n        self._last_index = 0",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "SandboxedEnvironment",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class SandboxedEnvironment(Environment):\n    \"\"\"The sandboxed environment.  It works like the regular environment but\n    tells the compiler to generate sandboxed code.  Additionally subclasses of\n    this environment may override the methods that tell the runtime what\n    attributes or functions are safe to access.\n    If the template tries to access insecure code a :exc:`SecurityError` is\n    raised.  However also other exceptions may occur during the rendering so\n    the caller has to ensure that all exceptions are caught.\n    \"\"\"\n    sandboxed = True",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "ImmutableSandboxedEnvironment",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class ImmutableSandboxedEnvironment(SandboxedEnvironment):\n    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not\n    permit modifications on the builtin mutable objects `list`, `set`, and\n    `dict` by using the :func:`modifies_known_mutable` function.\n    \"\"\"\n    def is_safe_attribute(self, obj, attr, value):\n        if not SandboxedEnvironment.is_safe_attribute(self, obj, attr, value):\n            return False\n        return not modifies_known_mutable(obj, attr)\n# This really is not a public API apparently.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "SandboxedFormatterMixin",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class SandboxedFormatterMixin(object):\n    def __init__(self, env):\n        self._env = env\n    def get_field(self, field_name, args, kwargs):\n        first, rest = formatter_field_name_split(field_name)\n        obj = self.get_value(first, args, kwargs)\n        for is_attr, i in rest:\n            if is_attr:\n                obj = self._env.getattr(obj, i)\n            else:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "SandboxedFormatter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class SandboxedFormatter(SandboxedFormatterMixin, Formatter):\n    def __init__(self, env):\n        SandboxedFormatterMixin.__init__(self, env)\n        Formatter.__init__(self)\nclass SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):\n    def __init__(self, env, escape):\n        SandboxedFormatterMixin.__init__(self, env)\n        EscapeFormatter.__init__(self, escape)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "SandboxedEscapeFormatter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "class SandboxedEscapeFormatter(SandboxedFormatterMixin, EscapeFormatter):\n    def __init__(self, env, escape):\n        SandboxedFormatterMixin.__init__(self, env)\n        EscapeFormatter.__init__(self, escape)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "inspect_format_method",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "def inspect_format_method(callable):\n    if not isinstance(\n        callable, (types.MethodType, types.BuiltinMethodType)\n    ) or callable.__name__ not in (\"format\", \"format_map\"):\n        return None\n    obj = callable.__self__\n    if isinstance(obj, string_types):\n        return obj\ndef safe_range(*args):\n    \"\"\"A range that can't generate ranges with a length of more than",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "safe_range",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "def safe_range(*args):\n    \"\"\"A range that can't generate ranges with a length of more than\n    MAX_RANGE items.\n    \"\"\"\n    rng = range_type(*args)\n    if len(rng) > MAX_RANGE:\n        raise OverflowError(\n            \"Range too big. The sandbox blocks ranges larger than\"\n            \" MAX_RANGE (%d).\" % MAX_RANGE\n        )",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "unsafe",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "def unsafe(f):\n    \"\"\"Marks a function or method as unsafe.\n    ::\n        @unsafe\n        def delete(self):\n            pass\n    \"\"\"\n    f.unsafe_callable = True\n    return f\ndef is_internal_attribute(obj, attr):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "is_internal_attribute",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "def is_internal_attribute(obj, attr):\n    \"\"\"Test if the attribute given is an internal python attribute.  For\n    example this function returns `True` for the `func_code` attribute of\n    python objects.  This is useful if the environment method\n    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.\n    >>> from jinja2.sandbox import is_internal_attribute\n    >>> is_internal_attribute(str, \"mro\")\n    True\n    >>> is_internal_attribute(str, \"upper\")\n    False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "modifies_known_mutable",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "def modifies_known_mutable(obj, attr):\n    \"\"\"This function checks if an attribute on a builtin mutable object\n    (list, dict, set or deque) would modify it if called.  It also supports\n    the \"user\"-versions of the objects (`sets.Set`, `UserDict.*` etc.) and\n    with Python 2.6 onwards the abstract base classes `MutableSet`,\n    `MutableMapping`, and `MutableSequence`.\n    >>> modifies_known_mutable({}, \"clear\")\n    True\n    >>> modifies_known_mutable({}, \"keys\")\n    False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "MAX_RANGE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "MAX_RANGE = 100000\n#: attributes of function objects that are considered unsafe.\nif PY2:\n    UNSAFE_FUNCTION_ATTRIBUTES = {\n        \"func_closure\",\n        \"func_code\",\n        \"func_dict\",\n        \"func_defaults\",\n        \"func_globals\",\n    }",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "UNSAFE_METHOD_ATTRIBUTES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "UNSAFE_METHOD_ATTRIBUTES = {\"im_class\", \"im_func\", \"im_self\"}\n#: unsafe generator attributes.\nUNSAFE_GENERATOR_ATTRIBUTES = {\"gi_frame\", \"gi_code\"}\n#: unsafe attributes on coroutines\nUNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}\n#: unsafe attributes on async generators\nUNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings(\n    \"ignore\", \"the sets module\", DeprecationWarning, module=__name__",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "UNSAFE_GENERATOR_ATTRIBUTES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "UNSAFE_GENERATOR_ATTRIBUTES = {\"gi_frame\", \"gi_code\"}\n#: unsafe attributes on coroutines\nUNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}\n#: unsafe attributes on async generators\nUNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings(\n    \"ignore\", \"the sets module\", DeprecationWarning, module=__name__\n)\n_mutable_set_types = (set,)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "UNSAFE_COROUTINE_ATTRIBUTES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "UNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}\n#: unsafe attributes on async generators\nUNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings(\n    \"ignore\", \"the sets module\", DeprecationWarning, module=__name__\n)\n_mutable_set_types = (set,)\n_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "UNSAFE_ASYNC_GENERATOR_ATTRIBUTES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "UNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}\n# make sure we don't warn in python 2.6 about stuff we don't care about\nwarnings.filterwarnings(\n    \"ignore\", \"the sets module\", DeprecationWarning, module=__name__\n)\n_mutable_set_types = (set,)\n_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)\n# on python 2.x we can register the user collection types\ntry:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "_mutable_set_types",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "_mutable_set_types = (set,)\n_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)\n# on python 2.x we can register the user collection types\ntry:\n    from UserDict import UserDict, DictMixin\n    from UserList import UserList\n    _mutable_mapping_types += (UserDict, DictMixin)\n    _mutable_set_types += (UserList,)\nexcept ImportError:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "_mutable_mapping_types",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "_mutable_mapping_types = (dict,)\n_mutable_sequence_types = (list,)\n# on python 2.x we can register the user collection types\ntry:\n    from UserDict import UserDict, DictMixin\n    from UserList import UserList\n    _mutable_mapping_types += (UserDict, DictMixin)\n    _mutable_set_types += (UserList,)\nexcept ImportError:\n    pass",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "_mutable_sequence_types",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "_mutable_sequence_types = (list,)\n# on python 2.x we can register the user collection types\ntry:\n    from UserDict import UserDict, DictMixin\n    from UserList import UserList\n    _mutable_mapping_types += (UserDict, DictMixin)\n    _mutable_set_types += (UserList,)\nexcept ImportError:\n    pass\n# if sets is still available, register the mutable set from there as well",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "_mutable_spec",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "peekOfCode": "_mutable_spec = (\n    (\n        _mutable_set_types,\n        frozenset(\n            [\n                \"add\",\n                \"clear\",\n                \"difference_update\",\n                \"discard\",\n                \"pop\",",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.sandbox",
        "documentation": {}
    },
    {
        "label": "test_odd",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_odd(value):\n    \"\"\"Return true if the variable is odd.\"\"\"\n    return value % 2 == 1\ndef test_even(value):\n    \"\"\"Return true if the variable is even.\"\"\"\n    return value % 2 == 0\ndef test_divisibleby(value, num):\n    \"\"\"Check if a variable is divisible by a number.\"\"\"\n    return value % num == 0\ndef test_defined(value):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_even",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_even(value):\n    \"\"\"Return true if the variable is even.\"\"\"\n    return value % 2 == 0\ndef test_divisibleby(value, num):\n    \"\"\"Check if a variable is divisible by a number.\"\"\"\n    return value % num == 0\ndef test_defined(value):\n    \"\"\"Return true if the variable is defined:\n    .. sourcecode:: jinja\n        {% if variable is defined %}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_divisibleby",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_divisibleby(value, num):\n    \"\"\"Check if a variable is divisible by a number.\"\"\"\n    return value % num == 0\ndef test_defined(value):\n    \"\"\"Return true if the variable is defined:\n    .. sourcecode:: jinja\n        {% if variable is defined %}\n            value of variable: {{ variable }}\n        {% else %}\n            variable is not defined",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_defined",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_defined(value):\n    \"\"\"Return true if the variable is defined:\n    .. sourcecode:: jinja\n        {% if variable is defined %}\n            value of variable: {{ variable }}\n        {% else %}\n            variable is not defined\n        {% endif %}\n    See the :func:`default` filter for a simple way to set undefined\n    variables.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_undefined",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_undefined(value):\n    \"\"\"Like :func:`defined` but the other way round.\"\"\"\n    return isinstance(value, Undefined)\ndef test_none(value):\n    \"\"\"Return true if the variable is none.\"\"\"\n    return value is None\ndef test_boolean(value):\n    \"\"\"Return true if the object is a boolean value.\n    .. versionadded:: 2.11\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_none",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_none(value):\n    \"\"\"Return true if the variable is none.\"\"\"\n    return value is None\ndef test_boolean(value):\n    \"\"\"Return true if the object is a boolean value.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is True or value is False\ndef test_false(value):\n    \"\"\"Return true if the object is False.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_boolean",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_boolean(value):\n    \"\"\"Return true if the object is a boolean value.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is True or value is False\ndef test_false(value):\n    \"\"\"Return true if the object is False.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is False",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_false",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_false(value):\n    \"\"\"Return true if the object is False.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is False\ndef test_true(value):\n    \"\"\"Return true if the object is True.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is True",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_true",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_true(value):\n    \"\"\"Return true if the object is True.\n    .. versionadded:: 2.11\n    \"\"\"\n    return value is True\n# NOTE: The existing 'number' test matches booleans and floats\ndef test_integer(value):\n    \"\"\"Return true if the object is an integer.\n    .. versionadded:: 2.11\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_integer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_integer(value):\n    \"\"\"Return true if the object is an integer.\n    .. versionadded:: 2.11\n    \"\"\"\n    return isinstance(value, integer_types) and value is not True and value is not False\n# NOTE: The existing 'number' test matches booleans and integers\ndef test_float(value):\n    \"\"\"Return true if the object is a float.\n    .. versionadded:: 2.11\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_float",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_float(value):\n    \"\"\"Return true if the object is a float.\n    .. versionadded:: 2.11\n    \"\"\"\n    return isinstance(value, float)\ndef test_lower(value):\n    \"\"\"Return true if the variable is lowercased.\"\"\"\n    return text_type(value).islower()\ndef test_upper(value):\n    \"\"\"Return true if the variable is uppercased.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_lower",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_lower(value):\n    \"\"\"Return true if the variable is lowercased.\"\"\"\n    return text_type(value).islower()\ndef test_upper(value):\n    \"\"\"Return true if the variable is uppercased.\"\"\"\n    return text_type(value).isupper()\ndef test_string(value):\n    \"\"\"Return true if the object is a string.\"\"\"\n    return isinstance(value, string_types)\ndef test_mapping(value):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_upper",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_upper(value):\n    \"\"\"Return true if the variable is uppercased.\"\"\"\n    return text_type(value).isupper()\ndef test_string(value):\n    \"\"\"Return true if the object is a string.\"\"\"\n    return isinstance(value, string_types)\ndef test_mapping(value):\n    \"\"\"Return true if the object is a mapping (dict etc.).\n    .. versionadded:: 2.6\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_string",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_string(value):\n    \"\"\"Return true if the object is a string.\"\"\"\n    return isinstance(value, string_types)\ndef test_mapping(value):\n    \"\"\"Return true if the object is a mapping (dict etc.).\n    .. versionadded:: 2.6\n    \"\"\"\n    return isinstance(value, abc.Mapping)\ndef test_number(value):\n    \"\"\"Return true if the variable is a number.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_mapping",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_mapping(value):\n    \"\"\"Return true if the object is a mapping (dict etc.).\n    .. versionadded:: 2.6\n    \"\"\"\n    return isinstance(value, abc.Mapping)\ndef test_number(value):\n    \"\"\"Return true if the variable is a number.\"\"\"\n    return isinstance(value, integer_types + (float, complex, decimal.Decimal))\ndef test_sequence(value):\n    \"\"\"Return true if the variable is a sequence. Sequences are variables",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_number",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_number(value):\n    \"\"\"Return true if the variable is a number.\"\"\"\n    return isinstance(value, integer_types + (float, complex, decimal.Decimal))\ndef test_sequence(value):\n    \"\"\"Return true if the variable is a sequence. Sequences are variables\n    that are iterable.\n    \"\"\"\n    try:\n        len(value)\n        value.__getitem__",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_sequence",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_sequence(value):\n    \"\"\"Return true if the variable is a sequence. Sequences are variables\n    that are iterable.\n    \"\"\"\n    try:\n        len(value)\n        value.__getitem__\n    except Exception:\n        return False\n    return True",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_sameas",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_sameas(value, other):\n    \"\"\"Check if an object points to the same memory address than another\n    object:\n    .. sourcecode:: jinja\n        {% if foo.attribute is sameas false %}\n            the foo attribute really is the `False` singleton\n        {% endif %}\n    \"\"\"\n    return value is other\ndef test_iterable(value):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_iterable",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_iterable(value):\n    \"\"\"Check if it's possible to iterate over an object.\"\"\"\n    try:\n        iter(value)\n    except TypeError:\n        return False\n    return True\ndef test_escaped(value):\n    \"\"\"Check if the value is escaped.\"\"\"\n    return hasattr(value, \"__html__\")",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_escaped",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_escaped(value):\n    \"\"\"Check if the value is escaped.\"\"\"\n    return hasattr(value, \"__html__\")\ndef test_in(value, seq):\n    \"\"\"Check if value is in seq.\n    .. versionadded:: 2.10\n    \"\"\"\n    return value in seq\nTESTS = {\n    \"odd\": test_odd,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_in",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "def test_in(value, seq):\n    \"\"\"Check if value is in seq.\n    .. versionadded:: 2.10\n    \"\"\"\n    return value in seq\nTESTS = {\n    \"odd\": test_odd,\n    \"even\": test_even,\n    \"divisibleby\": test_divisibleby,\n    \"defined\": test_defined,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "number_re",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "number_re = re.compile(r\"^-?\\d+(\\.\\d+)?$\")\nregex_type = type(number_re)\ntest_callable = callable\ndef test_odd(value):\n    \"\"\"Return true if the variable is odd.\"\"\"\n    return value % 2 == 1\ndef test_even(value):\n    \"\"\"Return true if the variable is even.\"\"\"\n    return value % 2 == 0\ndef test_divisibleby(value, num):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "regex_type",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "regex_type = type(number_re)\ntest_callable = callable\ndef test_odd(value):\n    \"\"\"Return true if the variable is odd.\"\"\"\n    return value % 2 == 1\ndef test_even(value):\n    \"\"\"Return true if the variable is even.\"\"\"\n    return value % 2 == 0\ndef test_divisibleby(value, num):\n    \"\"\"Check if a variable is divisible by a number.\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "test_callable",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "test_callable = callable\ndef test_odd(value):\n    \"\"\"Return true if the variable is odd.\"\"\"\n    return value % 2 == 1\ndef test_even(value):\n    \"\"\"Return true if the variable is even.\"\"\"\n    return value % 2 == 0\ndef test_divisibleby(value, num):\n    \"\"\"Check if a variable is divisible by a number.\"\"\"\n    return value % num == 0",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "TESTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "peekOfCode": "TESTS = {\n    \"odd\": test_odd,\n    \"even\": test_even,\n    \"divisibleby\": test_divisibleby,\n    \"defined\": test_defined,\n    \"undefined\": test_undefined,\n    \"none\": test_none,\n    \"boolean\": test_boolean,\n    \"false\": test_false,\n    \"true\": test_true,",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.tests",
        "documentation": {}
    },
    {
        "label": "LRUCache",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "class LRUCache(object):\n    \"\"\"A simple LRU Cache implementation.\"\"\"\n    # this is fast for small capacities (something below 1000) but doesn't\n    # scale.  But as long as it's only used as storage for templates this\n    # won't do any harm.\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self._mapping = {}\n        self._queue = deque()\n        self._postinit()",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "Cycler",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "class Cycler(object):\n    \"\"\"Cycle through values by yield them one at a time, then restarting\n    once the end is reached. Available as ``cycler`` in templates.\n    Similar to ``loop.cycle``, but can be used outside loops or across\n    multiple loops. For example, render a list of folders and files in a\n    list, alternating giving them \"odd\" and \"even\" classes.\n    .. code-block:: html+jinja\n        {% set row_class = cycler(\"odd\", \"even\") %}\n        <ul class=\"browser\">\n        {% for folder in folders %}",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "Joiner",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "class Joiner(object):\n    \"\"\"A joining helper for templates.\"\"\"\n    def __init__(self, sep=u\", \"):\n        self.sep = sep\n        self.used = False\n    def __call__(self):\n        if not self.used:\n            self.used = True\n            return u\"\"\n        return self.sep",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "class Namespace(object):\n    \"\"\"A namespace object that can hold arbitrary attributes.  It may be\n    initialized from a dictionary or with keyword arguments.\"\"\"\n    def __init__(*args, **kwargs):  # noqa: B902\n        self, args = args[0], args[1:]\n        self.__attrs = dict(*args, **kwargs)\n    def __getattribute__(self, name):\n        # __class__ is needed for the awaitable check in async mode\n        if name in {\"_Namespace__attrs\", \"__class__\"}:\n            return object.__getattribute__(self, name)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "contextfunction",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def contextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method context callable.\n    A context callable is passed the active :class:`Context` as first argument when\n    called from the template.  This is useful if a function wants to get access\n    to the context or functions provided on the context object.  For example\n    a function that returns a sorted list of template variables the current\n    template exports could look like this::\n        @contextfunction\n        def get_exported_names(context):\n            return sorted(context.exported_vars)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "evalcontextfunction",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def evalcontextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method as an eval\n    context callable.  This is similar to the :func:`contextfunction`\n    but instead of passing the context, an evaluation context object is\n    passed.  For more information about the eval context, see\n    :ref:`eval-context`.\n    .. versionadded:: 2.4\n    \"\"\"\n    f.evalcontextfunction = True\n    return f",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "environmentfunction",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def environmentfunction(f):\n    \"\"\"This decorator can be used to mark a function or method as environment\n    callable.  This decorator works exactly like the :func:`contextfunction`\n    decorator just that the first argument is the active :class:`Environment`\n    and not context.\n    \"\"\"\n    f.environmentfunction = True\n    return f\ndef internalcode(f):\n    \"\"\"Marks the function as internally used\"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "internalcode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def internalcode(f):\n    \"\"\"Marks the function as internally used\"\"\"\n    internal_code.add(f.__code__)\n    return f\ndef is_undefined(obj):\n    \"\"\"Check if the object passed is undefined.  This does nothing more than\n    performing an instance check against :class:`Undefined` but looks nicer.\n    This can be used for custom filters or tests that want to react to\n    undefined variables.  For example a custom default filter can look like\n    this::",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "is_undefined",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def is_undefined(obj):\n    \"\"\"Check if the object passed is undefined.  This does nothing more than\n    performing an instance check against :class:`Undefined` but looks nicer.\n    This can be used for custom filters or tests that want to react to\n    undefined variables.  For example a custom default filter can look like\n    this::\n        def default(var, default=''):\n            if is_undefined(var):\n                return default\n            return var",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "consume",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def consume(iterable):\n    \"\"\"Consumes an iterable without doing anything with it.\"\"\"\n    for _ in iterable:\n        pass\ndef clear_caches():\n    \"\"\"Jinja keeps internal caches for environments and lexers.  These are\n    used so that Jinja doesn't have to recreate environments and lexers all\n    the time.  Normally you don't have to care about that but if you are\n    measuring memory consumption you may want to clean the caches.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "clear_caches",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def clear_caches():\n    \"\"\"Jinja keeps internal caches for environments and lexers.  These are\n    used so that Jinja doesn't have to recreate environments and lexers all\n    the time.  Normally you don't have to care about that but if you are\n    measuring memory consumption you may want to clean the caches.\n    \"\"\"\n    from .environment import _spontaneous_environments\n    from .lexer import _lexer_cache\n    _spontaneous_environments.clear()\n    _lexer_cache.clear()",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "import_string",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def import_string(import_name, silent=False):\n    \"\"\"Imports an object based on a string.  This is useful if you want to\n    use import paths as endpoints or something similar.  An import path can\n    be specified either in dotted notation (``xml.sax.saxutils.escape``)\n    or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n    If the `silent` is True the return value will be `None` if the import\n    fails.\n    :return: imported object\n    \"\"\"\n    try:",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "open_if_exists",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def open_if_exists(filename, mode=\"rb\"):\n    \"\"\"Returns a file descriptor for the filename if that file exists,\n    otherwise ``None``.\n    \"\"\"\n    if not os.path.isfile(filename):\n        return None\n    return open(filename, mode)\ndef object_type_repr(obj):\n    \"\"\"Returns the name of the object's type.  For some recognized\n    singletons the name of the object is returned instead. (For",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "object_type_repr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def object_type_repr(obj):\n    \"\"\"Returns the name of the object's type.  For some recognized\n    singletons the name of the object is returned instead. (For\n    example for `None` and `Ellipsis`).\n    \"\"\"\n    if obj is None:\n        return \"None\"\n    elif obj is Ellipsis:\n        return \"Ellipsis\"\n    cls = type(obj)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "pformat",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def pformat(obj, verbose=False):\n    \"\"\"Prettyprint an object.  Either use the `pretty` library or the\n    builtin `pprint`.\n    \"\"\"\n    try:\n        from pretty import pretty\n        return pretty(obj, verbose=verbose)\n    except ImportError:\n        from pprint import pformat\n        return pformat(obj)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "urlize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def urlize(text, trim_url_limit=None, rel=None, target=None):\n    \"\"\"Converts any URLs in text into clickable links. Works on http://,\n    https:// and www. links. Links can have trailing punctuation (periods,\n    commas, close-parens) and leading punctuation (opening parens) and\n    it'll still do the right thing.\n    If trim_url_limit is not None, the URLs in link text will be limited\n    to trim_url_limit characters.\n    If nofollow is True, the URLs in link text will get a rel=\"nofollow\"\n    attribute.\n    If target is not None, a target attribute will be added to the link.",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "generate_lorem_ipsum",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def generate_lorem_ipsum(n=5, html=True, min=20, max=100):\n    \"\"\"Generate some lorem ipsum for the template.\"\"\"\n    from .constants import LOREM_IPSUM_WORDS\n    words = LOREM_IPSUM_WORDS.split()\n    result = []\n    for _ in range(n):\n        next_capitalized = True\n        last_comma = last_fullstop = 0\n        word = None\n        last = None",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "unicode_urlencode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def unicode_urlencode(obj, charset=\"utf-8\", for_qs=False):\n    \"\"\"Quote a string for use in a URL using the given charset.\n    This function is misnamed, it is a wrapper around\n    :func:`urllib.parse.quote`.\n    :param obj: String or bytes to quote. Other types are converted to\n        string then encoded to bytes using the given charset.\n    :param charset: Encode text to bytes using this charset.\n    :param for_qs: Quote \"/\" and use \"+\" for spaces.\n    \"\"\"\n    if not isinstance(obj, string_types):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "select_autoescape",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def select_autoescape(\n    enabled_extensions=(\"html\", \"htm\", \"xml\"),\n    disabled_extensions=(),\n    default_for_string=True,\n    default=False,\n):\n    \"\"\"Intelligently sets the initial value of autoescaping based on the\n    filename of the template.  This is the recommended way to configure\n    autoescaping if you do not want to write a custom function yourself.\n    If you want to enable it for all templates created from strings or",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "htmlsafe_json_dumps",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def htmlsafe_json_dumps(obj, dumper=None, **kwargs):\n    \"\"\"Works exactly like :func:`dumps` but is safe for use in ``<script>``\n    tags.  It accepts the same arguments and returns a JSON string.  Note that\n    this is available in templates through the ``|tojson`` filter which will\n    also mark the result as safe.  Due to how this function escapes certain\n    characters this is safe even if used outside of ``<script>`` tags.\n    The following characters are escaped in strings:\n    -   ``<``\n    -   ``>``\n    -   ``&``",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "soft_unicode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "def soft_unicode(s):\n    from markupsafe import soft_unicode\n    warnings.warn(\n        \"'jinja2.utils.soft_unicode' will be removed in version 3.0.\"\n        \" Use 'markupsafe.soft_unicode' instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return soft_unicode(s)",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "missing",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "missing = type(\"MissingType\", (), {\"__repr__\": lambda x: \"missing\"})()\n# internal code\ninternal_code = set()\nconcat = u\"\".join\n_slash_escape = \"\\\\/\" not in json.dumps(\"/\")\ndef contextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method context callable.\n    A context callable is passed the active :class:`Context` as first argument when\n    called from the template.  This is useful if a function wants to get access\n    to the context or functions provided on the context object.  For example",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "internal_code",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "internal_code = set()\nconcat = u\"\".join\n_slash_escape = \"\\\\/\" not in json.dumps(\"/\")\ndef contextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method context callable.\n    A context callable is passed the active :class:`Context` as first argument when\n    called from the template.  This is useful if a function wants to get access\n    to the context or functions provided on the context object.  For example\n    a function that returns a sorted list of template variables the current\n    template exports could look like this::",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "concat",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "concat = u\"\".join\n_slash_escape = \"\\\\/\" not in json.dumps(\"/\")\ndef contextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method context callable.\n    A context callable is passed the active :class:`Context` as first argument when\n    called from the template.  This is useful if a function wants to get access\n    to the context or functions provided on the context object.  For example\n    a function that returns a sorted list of template variables the current\n    template exports could look like this::\n        @contextfunction",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "_slash_escape",
        "kind": 5,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "peekOfCode": "_slash_escape = \"\\\\/\" not in json.dumps(\"/\")\ndef contextfunction(f):\n    \"\"\"This decorator can be used to mark a function or method context callable.\n    A context callable is passed the active :class:`Context` as first argument when\n    called from the template.  This is useful if a function wants to get access\n    to the context or functions provided on the context object.  For example\n    a function that returns a sorted list of template variables the current\n    template exports could look like this::\n        @contextfunction\n        def get_exported_names(context):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.utils",
        "documentation": {}
    },
    {
        "label": "NodeVisitor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "peekOfCode": "class NodeVisitor(object):\n    \"\"\"Walks the abstract syntax tree and call visitor functions for every\n    node found.  The visitor functions may return values which will be\n    forwarded by the `visit` method.\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding\n    the `get_visitor` function.  If no visitor function exists for a node\n    (return value `None`) the `generic_visit` visitor is used instead.\n    \"\"\"",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "documentation": {}
    },
    {
        "label": "NodeTransformer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "description": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "peekOfCode": "class NodeTransformer(NodeVisitor):\n    \"\"\"Walks the abstract syntax tree and allows modifications of nodes.\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor functions to replace or remove the old node.  If the return\n    value of the visitor function is `None` the node will be removed\n    from the previous location otherwise it's replaced with the return\n    value.  The return value may be the original node in which case no\n    replacement takes place.\n    \"\"\"\n    def generic_visit(self, node, *args, **kwargs):",
        "detail": "catboost.contrib.python.Jinja2.py2.jinja2.visitor",
        "documentation": {}
    },
    {
        "label": "PY2",
        "kind": 5,
        "importPath": "catboost.contrib.python.MarkupSafe.py2.markupsafe._compat",
        "description": "catboost.contrib.python.MarkupSafe.py2.markupsafe._compat",
        "peekOfCode": "PY2 = sys.version_info[0] == 2\nif not PY2:\n    text_type = str\n    string_types = (str,)\n    unichr = chr\n    int_types = (int,)\n    def iteritems(x):\n        return iter(x.items())\n    from collections.abc import Mapping\nelse:",
        "detail": "catboost.contrib.python.MarkupSafe.py2.markupsafe._compat",
        "documentation": {}
    },
    {
        "label": "HTML_ENTITIES",
        "kind": 5,
        "importPath": "catboost.contrib.python.MarkupSafe.py2.markupsafe._constants",
        "description": "catboost.contrib.python.MarkupSafe.py2.markupsafe._constants",
        "peekOfCode": "HTML_ENTITIES = {\n    \"AElig\": 198,\n    \"Aacute\": 193,\n    \"Acirc\": 194,\n    \"Agrave\": 192,\n    \"Alpha\": 913,\n    \"Aring\": 197,\n    \"Atilde\": 195,\n    \"Auml\": 196,\n    \"Beta\": 914,",
        "detail": "catboost.contrib.python.MarkupSafe.py2.markupsafe._constants",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "description": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "peekOfCode": "def escape(s):\n    \"\"\"Replace the characters ``&``, ``<``, ``>``, ``'``, and ``\"`` in\n    the string with HTML-safe sequences. Use this if you need to display\n    text that might contain such characters in HTML.\n    If the object has an ``__html__`` method, it is called and the\n    return value is assumed to already be safe for HTML.\n    :param s: An object to be converted to a string and escaped.\n    :return: A :class:`Markup` string with the escaped text.\n    \"\"\"\n    if hasattr(s, \"__html__\"):",
        "detail": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "documentation": {}
    },
    {
        "label": "escape_silent",
        "kind": 2,
        "importPath": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "description": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "peekOfCode": "def escape_silent(s):\n    \"\"\"Like :func:`escape` but treats ``None`` as the empty string.\n    Useful with optional values, as otherwise you get the string\n    ``'None'`` when the value is ``None``.\n    >>> escape(None)\n    Markup('None')\n    >>> escape_silent(None)\n    Markup('')\n    \"\"\"\n    if s is None:",
        "detail": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "documentation": {}
    },
    {
        "label": "soft_unicode",
        "kind": 2,
        "importPath": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "description": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "peekOfCode": "def soft_unicode(s):\n    \"\"\"Convert an object to a string if it isn't already. This preserves\n    a :class:`Markup` string rather than converting it back to a basic\n    string, so it will still be marked as safe and won't be escaped\n    again.\n    >>> value = escape('<User 1>')\n    >>> value\n    Markup('&lt;User 1&gt;')\n    >>> escape(str(value))\n    Markup('&amp;lt;User 1&amp;gt;')",
        "detail": "catboost.contrib.python.MarkupSafe.py2.markupsafe._native",
        "documentation": {}
    },
    {
        "label": "BdfFontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "peekOfCode": "class BdfFontFile(FontFile.FontFile):\n    def __init__(self, fp):\n        FontFile.FontFile.__init__(self)\n        s = fp.readline()\n        if s[:13] != b\"STARTFONT 2.1\":\n            raise SyntaxError(\"not a valid BDF file\")\n        props = {}\n        comments = []\n        while True:\n            s = fp.readline()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_char",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "peekOfCode": "def bdf_char(f):\n    # skip to STARTCHAR\n    while True:\n        s = f.readline()\n        if not s:\n            return None\n        if s[:9] == b\"STARTCHAR\":\n            break\n    id = s[9:].strip().decode(\"ascii\")\n    # load symbol properties",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_slant",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "peekOfCode": "bdf_slant = {\n    \"R\": \"Roman\",\n    \"I\": \"Italic\",\n    \"O\": \"Oblique\",\n    \"RI\": \"Reverse Italic\",\n    \"RO\": \"Reverse Oblique\",\n    \"OT\": \"Other\",\n}\nbdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\ndef bdf_char(f):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_spacing",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "peekOfCode": "bdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\ndef bdf_char(f):\n    # skip to STARTCHAR\n    while True:\n        s = f.readline()\n        if not s:\n            return None\n        if s[:9] == b\"STARTCHAR\":\n            break\n    id = s[9:].strip().decode(\"ascii\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "BLPFormatError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "class BLPFormatError(NotImplementedError):\n    pass\nclass BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"\n    def _open(self):\n        self.magic = self.fp.read(4)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BlpImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "class BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"\n    def _open(self):\n        self.magic = self.fp.read(4)\n        self._read_blp_header()\n        if self.magic == b\"BLP1\":",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "_BLPBaseDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "class _BLPBaseDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        try:\n            self.fd.seek(0)\n            self.magic = self.fd.read(4)\n            self._read_blp_header()\n            self._load()\n        except struct.error:\n            raise IOError(\"Truncated Blp file\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP1Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "class BLP1Decoder(_BLPBaseDecoder):\n    def _load(self):\n        if self._blp_compression == BLP_FORMAT_JPEG:\n            self._decode_jpeg_stream()\n        elif self._blp_compression == 1:\n            if self._blp_encoding in (4, 5):\n                data = bytearray()\n                palette = self._read_palette()\n                _data = BytesIO(self.fd.read(self._blp_lengths[0]))\n                while True:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP2Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "class BLP2Decoder(_BLPBaseDecoder):\n    def _load(self):\n        palette = self._read_palette()\n        data = bytearray()\n        self.fd.seek(self._blp_offsets[0])\n        if self._blp_compression == 1:\n            # Uncompressed or DirectX compression\n            if self._blp_encoding == BLP_ENCODING_UNCOMPRESSED:\n                _data = BytesIO(self.fd.read(self._blp_lengths[0]))\n                while True:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "unpack_565",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "def unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        # Decode next 8-byte block.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt1",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        # Decode next 8-byte block.\n        idx = block * 8\n        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt3",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt3(data):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        idx = block * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt5",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt5(data):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4 * width pixels)\n    \"\"\"\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        idx = block * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_FORMAT_JPEG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_FORMAT_JPEG = 0\nBLP_ENCODING_UNCOMPRESSED = 1\nBLP_ENCODING_DXT = 2\nBLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3\nBLP_ALPHA_ENCODING_DXT1 = 0\nBLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ENCODING_UNCOMPRESSED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ENCODING_UNCOMPRESSED = 1\nBLP_ENCODING_DXT = 2\nBLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3\nBLP_ALPHA_ENCODING_DXT1 = 0\nBLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ENCODING_DXT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ENCODING_DXT = 2\nBLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3\nBLP_ALPHA_ENCODING_DXT1 = 0\nBLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ENCODING_UNCOMPRESSED_RAW_BGRA = 3\nBLP_ALPHA_ENCODING_DXT1 = 0\nBLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ALPHA_ENCODING_DXT1",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ALPHA_ENCODING_DXT1 = 0\nBLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ALPHA_ENCODING_DXT3",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ALPHA_ENCODING_DXT3 = 1\nBLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP_ALPHA_ENCODING_DXT5",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "peekOfCode": "BLP_ALPHA_ENCODING_DXT5 = 7\ndef unpack_565(i):\n    return (((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3)\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BmpImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "peekOfCode": "class BmpImageFile(ImageFile.ImageFile):\n    \"\"\" Image plugin for the Windows Bitmap format (BMP) \"\"\"\n    # ------------------------------------------------------------- Description\n    format_description = \"Windows Bitmap\"\n    format = \"BMP\"\n    # -------------------------------------------------- BMP Compression values\n    COMPRESSIONS = {\"RAW\": 0, \"RLE8\": 1, \"RLE4\": 2, \"BITFIELDS\": 3, \"JPEG\": 4, \"PNG\": 5}\n    for k, v in COMPRESSIONS.items():\n        vars()[k] = v\n    def _bitmap(self, header=0, offset=0):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "DibImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "peekOfCode": "class DibImageFile(BmpImageFile):\n    format = \"DIB\"\n    format_description = \"Windows Bitmap\"\n    def _open(self):\n        self._bitmap()\n#\n# --------------------------------------------------------------------\n# Write BMP file\nSAVE = {\n    \"1\": (\"1\", 1, 2),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "peekOfCode": "__version__ = \"0.7\"\n#\n# --------------------------------------------------------------------\n# Read BMP file\nBIT2MODE = {\n    # bits => mode, rawmode\n    1: (\"P\", \"P;1\"),\n    4: (\"P\", \"P;4\"),\n    8: (\"P\", \"P\"),\n    16: (\"RGB\", \"BGR;15\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BIT2MODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "peekOfCode": "BIT2MODE = {\n    # bits => mode, rawmode\n    1: (\"P\", \"P;1\"),\n    4: (\"P\", \"P;4\"),\n    8: (\"P\", \"P\"),\n    16: (\"RGB\", \"BGR;15\"),\n    24: (\"RGB\", \"BGR\"),\n    32: (\"RGB\", \"BGRX\"),\n}\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "peekOfCode": "SAVE = {\n    \"1\": (\"1\", 1, 2),\n    \"L\": (\"L\", 8, 256),\n    \"P\": (\"P\", 8, 256),\n    \"RGB\": (\"BGR\", 24, 0),\n    \"RGBA\": (\"BGRA\", 32, 0),\n}\ndef _dib_save(im, fp, filename):\n    _save(im, fp, filename, False)\ndef _save(im, fp, filename, bitmap_header=True):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BufrStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "peekOfCode": "class BufrStubImageFile(ImageFile.StubImageFile):\n    format = \"BUFR\"\n    format_description = \"BUFR\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(4)):\n            raise SyntaxError(\"Not a BUFR file\")\n        self.fp.seek(offset)\n        # make something up\n        self.mode = \"F\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific BUFR image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific BUFR image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "ContainerIO",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ContainerIO",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ContainerIO",
        "peekOfCode": "class ContainerIO(object):\n    def __init__(self, file, offset, length):\n        \"\"\"\n        Create file object.\n        :param file: Existing file.\n        :param offset: Start of region, in bytes.\n        :param length: Size of region, in bytes.\n        \"\"\"\n        self.fh = file\n        self.pos = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ContainerIO",
        "documentation": {}
    },
    {
        "label": "CurImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "peekOfCode": "class CurImageFile(BmpImagePlugin.BmpImageFile):\n    format = \"CUR\"\n    format_description = \"Windows Cursor\"\n    def _open(self):\n        offset = self.fp.tell()\n        # check magic\n        s = self.fp.read(6)\n        if not _accept(s):\n            raise SyntaxError(\"not a CUR file\")\n        # pick the largest cursor in the file",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# --------------------------------------------------------------------\ndef _accept(prefix):\n    return prefix[:4] == b\"\\0\\0\\2\\0\"\n##\n# Image plugin for Windows Cursor files.\nclass CurImageFile(BmpImagePlugin.BmpImageFile):\n    format = \"CUR\"\n    format_description = \"Windows Cursor\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.CurImagePlugin",
        "documentation": {}
    },
    {
        "label": "DcxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "peekOfCode": "class DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # Header\n        s = self.fp.read(4)\n        if i32(s) != MAGIC:\n            raise SyntaxError(\"not a DCX file\")\n        # Component directory",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\nMAGIC = 0x3ADE68B1  # QUIZ: what's this value, then?\ndef _accept(prefix):\n    return len(prefix) >= 4 and i32(prefix) == MAGIC\n##\n# Image plugin for the Intel DCX format.\nclass DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "peekOfCode": "MAGIC = 0x3ADE68B1  # QUIZ: what's this value, then?\ndef _accept(prefix):\n    return len(prefix) >= 4 and i32(prefix) == MAGIC\n##\n# Image plugin for the Intel DCX format.\nclass DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "DdsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "class DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        magic, header_size = struct.unpack(\"<II\", self.fp.read(8))\n        if header_size != 124:\n            raise IOError(\"Unsupported header size %r\" % (header_size))\n        header_bytes = self.fp.read(header_size - 4)\n        if len(header_bytes) != 120:\n            raise IOError(\"Incomplete header: %s bytes\" % len(header_bytes))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_MAGIC = 0x20534444\n# DDS flags\nDDSD_CAPS = 0x1\nDDSD_HEIGHT = 0x2\nDDSD_WIDTH = 0x4\nDDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_CAPS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_CAPS = 0x1\nDDSD_HEIGHT = 0x2\nDDSD_WIDTH = 0x4\nDDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_HEIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_HEIGHT = 0x2\nDDSD_WIDTH = 0x4\nDDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_WIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_WIDTH = 0x4\nDDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_PITCH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_PIXELFORMAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_MIPMAPCOUNT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_LINEARSIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD_DEPTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSD_DEPTH = 0x800000\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS_COMPLEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS_TEXTURE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS_MIPMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS_MIPMAP = 0x400000\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_POSITIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_NEGATIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_POSITIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_NEGATIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_POSITIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_CUBEMAP_NEGATIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2_VOLUME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDSCAPS2_VOLUME = 0x200000\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_ALPHAPIXELS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_ALPHA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_PALETTEINDEXED8",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_RGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF_LUMINANCE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDPF_LUMINANCE = 0x20000\n# dds.h\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_RGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_RGBA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_LUMINANCE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_LUMINANCEA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_ALPHA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_PAL8",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_PAL8 = DDPF_PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_TEXTURE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_MIPMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_VOLUME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_PITCH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_LINEARSIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_WIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_WIDTH = DDSD_WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_TEXTURE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_MIPMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_CUBEMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844\n# dxgiformat.h",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844\n# dxgiformat.h\nDXGI_FORMAT_BC7_TYPELESS = 97",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n# DXT1\nDXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844\n# dxgiformat.h\nDXGI_FORMAT_BC7_TYPELESS = 97\nDXGI_FORMAT_BC7_UNORM = 98",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT1_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXT1_FOURCC = 0x31545844\n# DXT3\nDXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844\n# dxgiformat.h\nDXGI_FORMAT_BC7_TYPELESS = 97\nDXGI_FORMAT_BC7_UNORM = 98\nDXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT3_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXT3_FOURCC = 0x33545844\n# DXT5\nDXT5_FOURCC = 0x35545844\n# dxgiformat.h\nDXGI_FORMAT_BC7_TYPELESS = 97\nDXGI_FORMAT_BC7_UNORM = 98\nDXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT5_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXT5_FOURCC = 0x35545844\n# dxgiformat.h\nDXGI_FORMAT_BC7_TYPELESS = 97\nDXGI_FORMAT_BC7_UNORM = 98\nDXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        magic, header_size = struct.unpack(\"<II\", self.fp.read(8))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_TYPELESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_TYPELESS = 97\nDXGI_FORMAT_BC7_UNORM = 98\nDXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        magic, header_size = struct.unpack(\"<II\", self.fp.read(8))\n        if header_size != 124:\n            raise IOError(\"Unsupported header size %r\" % (header_size))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_UNORM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_UNORM = 98\nDXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        magic, header_size = struct.unpack(\"<II\", self.fp.read(8))\n        if header_size != 124:\n            raise IOError(\"Unsupported header size %r\" % (header_size))\n        header_bytes = self.fp.read(header_size - 4)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_UNORM_SRGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_UNORM_SRGB = 99\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        magic, header_size = struct.unpack(\"<II\", self.fp.read(8))\n        if header_size != 124:\n            raise IOError(\"Unsupported header size %r\" % (header_size))\n        header_bytes = self.fp.read(header_size - 4)\n        if len(header_bytes) != 120:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "PSFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "class PSFile(object):\n    \"\"\"\n    Wrapper for bytesio object that treats either CR or LF as end of line.\n    \"\"\"\n    def __init__(self, fp):\n        self.fp = fp\n        self.char = None\n    def seek(self, offset, whence=io.SEEK_SET):\n        self.char = None\n        self.fp.seek(offset, whence)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "EpsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "class EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}\n    def _open(self):\n        (length, offset) = self._find_offset(self.fp)\n        # Rewrap the open file pointer in something that will\n        # convert line endings and decode to latin-1.\n        fp = PSFile(self.fp)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "has_ghostscript",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "def has_ghostscript():\n    if gs_windows_binary:\n        return True\n    if not sys.platform.startswith(\"win\"):\n        import subprocess\n        try:\n            with open(os.devnull, \"wb\") as devnull:\n                subprocess.check_call([\"gs\", \"--version\"], stdout=devnull)\n            return True\n        except OSError:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "Ghostscript",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "def Ghostscript(tile, size, fp, scale=1):\n    \"\"\"Render an image using Ghostscript\"\"\"\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n    # Hack to support hi-res rendering\n    scale = int(scale) or 1\n    # orig_size = size\n    # orig_bbox = bbox\n    size = (size[0] * scale, size[1] * scale)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "__version__ = \"0.5\"\n#\n# --------------------------------------------------------------------\nsplit = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\ngs_windows_binary = None\nif sys.platform.startswith(\"win\"):\n    import shutil\n    if hasattr(shutil, \"which\"):\n        which = shutil.which",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\ngs_windows_binary = None\nif sys.platform.startswith(\"win\"):\n    import shutil\n    if hasattr(shutil, \"which\"):\n        which = shutil.which\n    else:\n        # Python 2\n        import distutils.spawn",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\ngs_windows_binary = None\nif sys.platform.startswith(\"win\"):\n    import shutil\n    if hasattr(shutil, \"which\"):\n        which = shutil.which\n    else:\n        # Python 2\n        import distutils.spawn\n        which = distutils.spawn.find_executable",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "gs_windows_binary",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "peekOfCode": "gs_windows_binary = None\nif sys.platform.startswith(\"win\"):\n    import shutil\n    if hasattr(shutil, \"which\"):\n        which = shutil.which\n    else:\n        # Python 2\n        import distutils.spawn\n        which = distutils.spawn.find_executable\n    for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "peekOfCode": "TAGS = {\n    # possibly incomplete\n    0x000B: \"ProcessingSoftware\",\n    0x00FE: \"NewSubfileType\",\n    0x00FF: \"SubfileType\",\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageLength\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "GPSTAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "peekOfCode": "GPSTAGS = {\n    0: \"GPSVersionID\",\n    1: \"GPSLatitudeRef\",\n    2: \"GPSLatitude\",\n    3: \"GPSLongitudeRef\",\n    4: \"GPSLongitude\",\n    5: \"GPSAltitudeRef\",\n    6: \"GPSAltitude\",\n    7: \"GPSTimeStamp\",\n    8: \"GPSSatellites\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "FITSStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "peekOfCode": "class FITSStubImageFile(ImageFile.StubImageFile):\n    format = \"FITS\"\n    format_description = \"FITS\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(6)):\n            raise SyntaxError(\"Not a FITS file\")\n        # FIXME: add more sanity checks here; mandatory header items\n        # include SIMPLE, BITPIX, NAXIS, etc.\n        self.fp.seek(offset)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific FITS image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific FITS image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FitsStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "FliImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "peekOfCode": "class FliImageFile(ImageFile.ImageFile):\n    format = \"FLI\"\n    format_description = \"Autodesk FLI/FLC Animation\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # HEAD\n        s = self.fp.read(128)\n        magic = i16(s[4:6])\n        if not (\n            magic in [0xAF11, 0xAF12]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\n#\n# decoder\ndef _accept(prefix):\n    return len(prefix) >= 6 and i16(prefix[4:6]) in [0xAF11, 0xAF12]\n##\n# Image plugin for the FLI/FLC animation format.  Use the <b>seek</b>\n# method to load individual frames.\nclass FliImageFile(ImageFile.ImageFile):\n    format = \"FLI\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FliImagePlugin",
        "documentation": {}
    },
    {
        "label": "FontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "peekOfCode": "class FontFile(object):\n    bitmap = None\n    def __init__(self):\n        self.info = {}\n        self.glyph = [None] * 256\n    def __getitem__(self, ix):\n        return self.glyph[ix]\n    def compile(self):\n        \"\"\"Create metrics and bitmap\"\"\"\n        if self.bitmap:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "puti16",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "peekOfCode": "def puti16(fp, values):\n    # write network order (big-endian) 16-bit sequence\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\n##\n# Base class for raster font file handlers.\nclass FontFile(object):\n    bitmap = None",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "WIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "peekOfCode": "WIDTH = 800\ndef puti16(fp, values):\n    # write network order (big-endian) 16-bit sequence\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\n##\n# Base class for raster font file handlers.\nclass FontFile(object):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "FpxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "peekOfCode": "class FpxImageFile(ImageFile.ImageFile):\n    format = \"FPX\"\n    format_description = \"FlashPix\"\n    def _open(self):\n        #\n        # read the OLE directory and see if this is a likely\n        # to be a FlashPix file\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except IOError:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n# we map from colour field tuples to (mode, rawmode) descriptors\nMODES = {\n    # opacity\n    (0x00007FFE): (\"A\", \"L\"),\n    # monochrome\n    (0x00010000,): (\"L\", \"L\"),\n    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),\n    # photo YCC\n    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "peekOfCode": "MODES = {\n    # opacity\n    (0x00007FFE): (\"A\", \"L\"),\n    # monochrome\n    (0x00010000,): (\"L\", \"L\"),\n    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),\n    # photo YCC\n    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),\n    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),\n    # standard RGB (NIFRGB)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FpxImagePlugin",
        "documentation": {}
    },
    {
        "label": "FtexImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "class FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        struct.unpack(\"<I\", self.fp.read(4))  # magic\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))\n        self.mode = \"RGB\"\n        # Only support single-format files.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{header}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "{header} = {\n    u32:magic,\n    u32:version,\n    u32:width,\n    u32:height,\n    u32:mipmap_count,\n    u32:format_count\n}\n* The \"magic\" number is \"FTEX\".\n* \"width\" and \"height\" are the dimensions of the texture.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{format_directory}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "{format_directory} = format_count * { u32:format, u32:where }\nThe format value is 0 for DXT1 compressed textures and 1 for 24-bit RGB\nuncompressed textures.\nThe texture data for a format starts at the position \"where\" in the file.\nEach set of texture data in the file has the following structure:\n{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{data}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.\nNote: All data is stored in little-Endian (Intel) byte order.\n\"\"\"\nimport struct\nfrom io import BytesIO\nfrom . import Image, ImageFile",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "MAGIC = b\"FTEX\"\nFORMAT_DXT1 = 0\nFORMAT_UNCOMPRESSED = 1\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        struct.unpack(\"<I\", self.fp.read(4))  # magic\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "FORMAT_DXT1",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "FORMAT_DXT1 = 0\nFORMAT_UNCOMPRESSED = 1\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        struct.unpack(\"<I\", self.fp.read(4))  # magic\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "FORMAT_UNCOMPRESSED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "peekOfCode": "FORMAT_UNCOMPRESSED = 1\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        struct.unpack(\"<I\", self.fp.read(4))  # magic\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))\n        self.mode = \"RGB\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "GbrImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GbrImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GbrImagePlugin",
        "peekOfCode": "class GbrImageFile(ImageFile.ImageFile):\n    format = \"GBR\"\n    format_description = \"GIMP brush file\"\n    def _open(self):\n        header_size = i32(self.fp.read(4))\n        version = i32(self.fp.read(4))\n        if header_size < 20:\n            raise SyntaxError(\"not a GIMP brush\")\n        if version not in (1, 2):\n            raise SyntaxError(\"Unsupported GIMP brush version: %s\" % version)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GbrImagePlugin",
        "documentation": {}
    },
    {
        "label": "GdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "peekOfCode": "class GdImageFile(ImageFile.ImageFile):\n    format = \"GD\"\n    format_description = \"GD uncompressed images\"\n    def _open(self):\n        # Header\n        s = self.fp.read(1037)\n        if not i16(s[:2]) in [65534, 65535]:\n            raise SyntaxError(\"Not a valid GD 2.x .gd file\")\n        self.mode = \"L\"  # FIXME: \"P\"\n        self._size = i16(s[2:4]), i16(s[4:6])",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "peekOfCode": "def open(fp, mode=\"r\"):\n    \"\"\"\n    Load texture from a GD image file.\n    :param filename: GD file name, or an opened file handle.\n    :param mode: Optional mode.  In this version, if the mode argument\n        is given, it must be \"r\".\n    :returns: An image instance.\n    :raises IOError: If the image could not be read.\n    \"\"\"\n    if mode != \"r\":",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "peekOfCode": "__version__ = \"0.1\"\n##\n# Image plugin for the GD uncompressed format.  Note that this format\n# is not supported by the standard <b>Image.open</b> function.  To use\n# this plugin, you have to import the <b>GdImageFile</b> module and\n# use the <b>GdImageFile.open</b> function.\nclass GdImageFile(ImageFile.ImageFile):\n    format = \"GD\"\n    format_description = \"GD uncompressed images\"\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GdImageFile",
        "documentation": {}
    },
    {
        "label": "GifImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "class GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"\n    format_description = \"Compuserve GIF\"\n    _close_exclusive_fp_after_loading = False\n    global_palette = None\n    def data(self):\n        s = self.fp.read(1)\n        if s and i8(s):\n            return self.fp.read(i8(s))\n        return None",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "get_interlace",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "def get_interlace(im):\n    interlace = im.encoderinfo.get(\"interlace\", 1)\n    # workaround for @PIL153\n    if min(im.size) < 16:\n        interlace = 0\n    return interlace\ndef _write_local_header(fp, im, offset, flags):\n    transparent_color_exists = False\n    try:\n        transparency = im.encoderinfo[\"transparency\"]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "getheader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "def getheader(im, palette=None, info=None):\n    \"\"\"\n    Legacy Method to get Gif data from image.\n    Warning:: May modify image data.\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: tuple of(list of header items, optimized palette)\n    \"\"\"\n    used_palette_colors = _get_optimize(im, info)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "getdata",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "def getdata(im, offset=(0, 0), **params):\n    \"\"\"\n    Legacy Method\n    Return a list of strings representing this image.\n    The first string is a local image header, the rest contains\n    encoded image data.\n    :param im: Image object\n    :param offset: Tuple of (x, y) pixels. Defaults to (0,0)\n    :param \\\\**params: E.g. duration or other encoder info parameters\n    :returns: List of Bytes containing gif encoded frame data",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "__version__ = \"0.9\"\n# --------------------------------------------------------------------\n# Identify/read GIF files\ndef _accept(prefix):\n    return prefix[:6] in [b\"GIF87a\", b\"GIF89a\"]\n##\n# Image plugin for GIF images.  This plugin supports both GIF87 and\n# GIF89 images.\nclass GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "RAWMODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "RAWMODE = {\"1\": \"L\", \"L\": \"L\", \"P\": \"P\"}\ndef _normalize_mode(im, initial_call=False):\n    \"\"\"\n    Takes an image (or frame), returns an image in a mode that is appropriate\n    for saving in a Gif.\n    It may return the original image, or it may return an image converted to\n    palette or 'L' mode.\n    UNDONE: What is the point of mucking with the initial call palette, for\n    an image that shouldn't have a palette, or it would be a mode 'P' and\n    get returned in the RAWMODE clause.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "_FORCE_OPTIMIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "peekOfCode": "_FORCE_OPTIMIZE = False\ndef _get_optimize(im, info):\n    \"\"\"\n    Palette optimization is a potentially expensive operation.\n    This function determines if the palette should be optimized using\n    some heuristics, then returns the list of palette entries in use.\n    :param im: Image object\n    :param info: encoderinfo\n    :returns: list of indexes of palette entries in use, or None\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "GradientFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "class GradientFile(object):\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n        for i in range(entries):\n            x = i / float(entries - 1)\n            while x1 < x:\n                ix += 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "GimpGradientFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "class GimpGradientFile(GradientFile):\n    def __init__(self, fp):\n        if fp.readline()[:13] != b\"GIMP Gradient\":\n            raise SyntaxError(\"not a GIMP gradient file\")\n        line = fp.readline()\n        # GIMP 1.2 gradient files don't contain a name, but GIMP 1.3 files do\n        if line.startswith(b\"Name: \"):\n            line = fp.readline().strip()\n        count = int(line)\n        gradient = []",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "linear",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "def linear(middle, pos):\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle\n        middle = 1.0 - middle\n        if middle < EPSILON:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "curved",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "def curved(middle, pos):\n    return pos ** (log(0.5) / log(max(middle, EPSILON)))\ndef sine(middle, pos):\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\ndef sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\nclass GradientFile(object):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sine",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "def sine(middle, pos):\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\ndef sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\nclass GradientFile(object):\n    gradient = None\n    def getpalette(self, entries=256):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sphere_increasing",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "def sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\nclass GradientFile(object):\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sphere_decreasing",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "def sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\nclass GradientFile(object):\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n        for i in range(entries):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "EPSILON",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "EPSILON = 1e-10\ndef linear(middle, pos):\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle\n        middle = 1.0 - middle",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "SEGMENTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "peekOfCode": "SEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\nclass GradientFile(object):\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n        for i in range(entries):\n            x = i / float(entries - 1)\n            while x1 < x:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "GimpPaletteFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GimpPaletteFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GimpPaletteFile",
        "peekOfCode": "class GimpPaletteFile(object):\n    rawmode = \"RGB\"\n    def __init__(self, fp):\n        self.palette = [o8(i) * 3 for i in range(256)]\n        if fp.readline()[:12] != b\"GIMP Palette\":\n            raise SyntaxError(\"not a GIMP palette file\")\n        for i in range(256):\n            s = fp.readline()\n            if not s:\n                break",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GimpPaletteFile",
        "documentation": {}
    },
    {
        "label": "GribStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "peekOfCode": "class GribStubImageFile(ImageFile.StubImageFile):\n    format = \"GRIB\"\n    format_description = \"GRIB\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(8)):\n            raise SyntaxError(\"Not a GRIB file\")\n        self.fp.seek(offset)\n        # make something up\n        self.mode = \"F\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific GRIB image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific GRIB image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "HDF5StubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "class HDF5StubImageFile(ImageFile.StubImageFile):\n    format = \"HDF5\"\n    format_description = \"HDF5\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(8)):\n            raise SyntaxError(\"Not an HDF file\")\n        self.fp.seek(offset)\n        # make something up\n        self.mode = \"F\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific HDF5 image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific HDF5 image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcnsFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "class IcnsFile(object):\n    SIZES = {\n        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],\n        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],\n        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],\n        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],\n        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],\n        (128, 128, 1): [\n            (b\"ic07\", read_png_or_jpeg2000),\n            (b\"it32\", read_32t),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcnsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "class IcnsImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL image support for Mac OS .icns files.\n    Chooses the best resolution, but will possibly load\n    a different size image if you mutate the size attribute\n    before calling 'load'.\n    The info dictionary has a key 'sizes' that is a list\n    of sizes that the icns file has.\n    \"\"\"\n    format = \"ICNS\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "nextheader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "def nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        raise SyntaxError(\"Unknown signature, expecting 0x00000000\")\n    return read_32(fobj, (start + 4, length - 4), size)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_32t",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        raise SyntaxError(\"Unknown signature, expecting 0x00000000\")\n    return read_32(fobj, (start + 4, length - 4), size)\ndef read_32(fobj, start_length, size):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_32",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_32(fobj, start_length, size):\n    \"\"\"\n    Read a 32bit RGB icon resource.  Seems to be either uncompressed or\n    an RLE packbits-like scheme.\n    \"\"\"\n    (start, length) = start_length\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    if length == sizesq * 3:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_mk",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_mk(fobj, start_length, size):\n    # Alpha masks seem to be uncompressed\n    start = start_length[0]\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)\n    return {\"A\": band}\ndef read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_png_or_jpeg2000",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(12)\n    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":\n        fobj.seek(start)\n        im = PngImagePlugin.PngImageFile(fobj)\n        return {\"RGBA\": im}\n    elif (\n        sig[:4] == b\"\\xff\\x4f\\xff\\x51\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "enable_jpeg2k",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "enable_jpeg2k = hasattr(Image.core, \"jp2klib_version\")\nif enable_jpeg2k:\n    from PIL import Jpeg2KImagePlugin\nHEADERSIZE = 8\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "HEADERSIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "peekOfCode": "HEADERSIZE = 8\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        raise SyntaxError(\"Unknown signature, expecting 0x00000000\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcoFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "peekOfCode": "class IcoFile(object):\n    def __init__(self, buf):\n        \"\"\"\n        Parse image from file-like object containing ico file data\n        \"\"\"\n        # check magic\n        s = buf.read(6)\n        if not _accept(s):\n            raise SyntaxError(\"not an ICO file\")\n        self.buf = buf",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcoImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "peekOfCode": "class IcoImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL read-only image support for Microsoft Windows .ico files.\n    By default the largest resolution image in the file will be loaded. This\n    can be changed by altering the 'size' attribute before calling 'load'.\n    The info dictionary has a key 'sizes' that is a list of the sizes available\n    in the icon file.\n    Handles classic, XP and Vista icon formats.\n    When saving, PNG compression is used. Support for this was only added in\n    Windows Vista.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# --------------------------------------------------------------------\n_MAGIC = b\"\\0\\0\\1\\0\"\ndef _save(im, fp, filename):\n    fp.write(_MAGIC)  # (2+2)\n    sizes = im.encoderinfo.get(\n        \"sizes\",\n        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],\n    )",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "peekOfCode": "_MAGIC = b\"\\0\\0\\1\\0\"\ndef _save(im, fp, filename):\n    fp.write(_MAGIC)  # (2+2)\n    sizes = im.encoderinfo.get(\n        \"sizes\",\n        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],\n    )\n    width, height = im.size\n    sizes = filter(\n        lambda x: False",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "class ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # Quick rejection: if there's not an LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        if b\"\\n\" not in self.fp.read(100):\n            raise SyntaxError(\"not an IM file\")\n        self.fp.seek(0)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "number",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "def number(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n##\n# Image plugin for the IFUNC IM file format.\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "__version__ = \"0.7\"\n# --------------------------------------------------------------------\n# Standard tags\nCOMMENT = \"Comment\"\nDATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "COMMENT = \"Comment\"\nDATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "DATE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "DATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "EQUIPMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "EQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "FRAMES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "FRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "LUT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "LUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "NAME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "NAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "SCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "SIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "MODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "TAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,\n    MODE: 0,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "OPEN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "OPEN = {\n    # ifunc93/p3cfunc formats\n    \"0 1 image\": (\"1\", \"1\"),\n    \"L 1 image\": (\"1\", \"1\"),\n    \"Greyscale image\": (\"L\", \"L\"),\n    \"Grayscale image\": (\"L\", \"L\"),\n    \"RGB image\": (\"RGB\", \"RGB;L\"),\n    \"RLB image\": (\"RGB\", \"RLB\"),\n    \"RYB image\": (\"RGB\", \"RLB\"),\n    \"B1 image\": (\"1\", \"1\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "split = re.compile(br\"^([A-Za-z][^:]*):[ \\t]*(.*)[ \\t]*$\")\ndef number(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n##\n# Image plugin for the IFUNC IM file format.\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "peekOfCode": "SAVE = {\n    # mode: (im type, raw mode)\n    \"1\": (\"0 1\", \"1\"),\n    \"L\": (\"Greyscale\", \"L\"),\n    \"LA\": (\"LA\", \"LA;L\"),\n    \"P\": (\"Greyscale\", \"P\"),\n    \"PA\": (\"LA\", \"PA;L\"),\n    \"I\": (\"L 32S\", \"I;32S\"),\n    \"I;16\": (\"L 16\", \"I;16\"),\n    \"I;16L\": (\"L 16L\", \"I;16L\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "DecompressionBombWarning",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class DecompressionBombWarning(RuntimeWarning):\n    pass\nclass DecompressionBombError(Exception):\n    pass\nclass _imaging_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n# Limit to around a quarter gigabyte for a 24 bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "DecompressionBombError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class DecompressionBombError(Exception):\n    pass\nclass _imaging_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n# Limit to around a quarter gigabyte for a 24 bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_imaging_not_installed",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class _imaging_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n# Limit to around a quarter gigabyte for a 24 bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_E",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class _E(object):\n    def __init__(self, data):\n        self.data = data\n    def __add__(self, other):\n        return _E((self.data, \"__add__\", coerce_e(other).data))\n    def __mul__(self, other):\n        return _E((self.data, \"__mul__\", coerce_e(other).data))\ndef _getscaleoffset(expr):\n    stub = [\"stub\"]\n    data = expr(_E(stub)).data",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Image",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class Image(object):\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ImagePointHandler",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class ImagePointHandler(object):\n    # used as a mixin by point transforms (for use with im.point)\n    pass\nclass ImageTransformHandler(object):\n    # used as a mixin by geometry transforms (for use with im.transform)\n    pass\n# --------------------------------------------------------------------\n# Factories\n#\n# Debugging",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ImageTransformHandler",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class ImageTransformHandler(object):\n    # used as a mixin by geometry transforms (for use with im.transform)\n    pass\n# --------------------------------------------------------------------\n# Factories\n#\n# Debugging\ndef _wedge():\n    \"\"\"Create greyscale wedge (for debugging only)\"\"\"\n    return Image()._new(core.wedge(\"L\"))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Exif",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "class Exif(MutableMapping):\n    endian = \"<\"\n    def __init__(self):\n        self._data = {}\n        self._ifds = {}\n        self._info = None\n        self._loaded_exif = None\n    def _fixup(self, value):\n        try:\n            if len(value) == 1 and not isinstance(value, dict):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "isImageType",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def isImageType(t):\n    \"\"\"\n    Checks if an object is an image object.\n    .. warning::\n       This function is for internal use only.\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n#",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebase",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodetype",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def getmodetype(mode):\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\ndef getmodebandnames(mode):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebandnames",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def getmodebandnames(mode):\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebands",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def getmodebands(mode):\n    \"\"\"\n    Gets the number of individual bands for this mode.\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n# --------------------------------------------------------------------\n# Helpers",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "preinit",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def preinit():\n    \"\"\"Explicitly load standard file format drivers.\"\"\"\n    global _initialized\n    if _initialized >= 1:\n        return\n    try:\n        from . import BmpImagePlugin\n        assert BmpImagePlugin\n    except ImportError:\n        pass",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def init():\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n    \"\"\"\n    global _initialized\n    if _initialized >= 2:\n        return 0\n    for plugin in _plugins:\n        try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "coerce_e",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def coerce_e(value):\n    return value if isinstance(value, _E) else _E(value)\nclass _E(object):\n    def __init__(self, data):\n        self.data = data\n    def __add__(self, other):\n        return _E((self.data, \"__add__\", coerce_e(other).data))\n    def __mul__(self, other):\n        return _E((self.data, \"__mul__\", coerce_e(other).data))\ndef _getscaleoffset(expr):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def new(mode, size, color=0):\n    \"\"\"\n    Creates a new image with the given mode and size.\n    :param mode: The mode to use for the new image. See:\n       :ref:`concept-modes`.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB images, you can also use color",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "frombytes",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def frombytes(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n    You can also use any pixel decoder supported by PIL.  For more\n    information on available decoders, see the section\n    :ref:`Writing Your Own File Decoder <file-decoders>`.\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromstring",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def fromstring(*args, **kw):\n    raise NotImplementedError(\n        \"fromstring() has been removed. Please call frombytes() instead.\"\n    )\ndef frombuffer(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "frombuffer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def frombuffer(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    **BytesIO** object, and use :py:func:`~PIL.Image.open` to load it.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromarray",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def fromarray(obj, mode=None):\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol).\n    If **obj** is not contiguous, then the tobytes method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.\n    If you have an image in NumPy::\n      from PIL import Image\n      import numpy as np\n      im = Image.open('hopper.jpg')",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromqimage",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def fromqimage(im):\n    \"\"\"Creates an image instance from a QImage image\"\"\"\n    from . import ImageQt\n    if not ImageQt.qt_is_installed:\n        raise ImportError(\"Qt bindings are not installed\")\n    return ImageQt.fromqimage(im)\ndef fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt\n    if not ImageQt.qt_is_installed:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromqpixmap",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt\n    if not ImageQt.qt_is_installed:\n        raise ImportError(\"Qt bindings are not installed\")\n    return ImageQt.fromqpixmap(im)\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    ((1, 1), \"|b1\"): (\"1\", \"1;8\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def open(fp, mode=\"r\"):\n    \"\"\"\n    Opens and identifies the given image file.\n    This is a lazy operation; this function identifies the file, but\n    the file remains open and the actual image data is not read from\n    the file until you try to process the data (or call the\n    :py:meth:`~PIL.Image.Image.load` method).  See\n    :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n    :param fp: A filename (string), pathlib.Path object or a file object.\n       The file object must implement :py:meth:`~file.read`,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "alpha_composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def alpha_composite(im1, im2):\n    \"\"\"\n    Alpha composite im2 over im1.\n    :param im1: The first image. Must have mode RGBA.\n    :param im2: The second image.  Must have mode RGBA, and the same size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n    im1.load()\n    im2.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "blend",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def blend(im1, im2, alpha):\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha.::\n        out = image1 * (1.0 - alpha) + image2 * alpha\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def composite(image1, image2, mask):\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def merge(mode, bands):\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n    :param mode: The mode to use for the output image. See:\n        :ref:`concept-modes`.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_open(id, factory, accept=None):\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_mime",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_mime(id, mimetype):\n    \"\"\"\n    Registers an image MIME type.  This function should not be used\n    in application code.\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"\n    MIME[id.upper()] = mimetype\ndef register_save(id, driver):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_save",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_save(id, driver):\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\ndef register_save_all(id, driver):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_save_all",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_save_all(id, driver):\n    \"\"\"\n    Registers an image function to save all the frames\n    of a multiframe format.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE_ALL[id.upper()] = driver\ndef register_extension(id, extension):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_extension",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_extension(id, extension):\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\ndef register_extensions(id, extensions):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_extensions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_extensions(id, extensions):\n    \"\"\"\n    Registers image extensions.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param extensions: A list of extensions used for this format.\n    \"\"\"\n    for extension in extensions:\n        register_extension(id, extension)\ndef registered_extensions():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "registered_extensions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def registered_extensions():\n    \"\"\"\n    Returns a dictionary containing all file extensions belonging\n    to registered plugins\n    \"\"\"\n    if not EXTENSION:\n        init()\n    return EXTENSION\ndef register_decoder(name, decoder):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_decoder",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_decoder(name, decoder):\n    \"\"\"\n    Registers an image decoder.  This function should not be\n    used in application code.\n    :param name: The name of the decoder\n    :param decoder: A callable(mode, args) that returns an\n                    ImageFile.PyDecoder object\n    .. versionadded:: 4.1.0\n    \"\"\"\n    DECODERS[name] = decoder",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_encoder",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def register_encoder(name, encoder):\n    \"\"\"\n    Registers an image encoder.  This function should not be\n    used in application code.\n    :param name: The name of the encoder\n    :param encoder: A callable(mode, args) that returns an\n                    ImageFile.PyEncoder object\n    .. versionadded:: 4.1.0\n    \"\"\"\n    ENCODERS[name] = encoder",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "effect_mandelbrot",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def effect_mandelbrot(size, extent, quality):\n    \"\"\"\n    Generate a Mandelbrot set covering the given extent.\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param extent: The extent to cover, as a 4-tuple:\n       (x0, y0, x1, y2).\n    :param quality: Quality.\n    \"\"\"\n    return Image()._new(core.effect_mandelbrot(size, extent, quality))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "effect_noise",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def effect_noise(size, sigma):\n    \"\"\"\n    Generate Gaussian noise centered around 128.\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param sigma: Standard deviation of noise.\n    \"\"\"\n    return Image()._new(core.effect_noise(size, sigma))\ndef linear_gradient(mode):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "linear_gradient",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def linear_gradient(mode):\n    \"\"\"\n    Generate 256x256 linear gradient from black to white, top to bottom.\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.linear_gradient(mode))\ndef radial_gradient(mode):\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n    :param mode: Input mode.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "radial_gradient",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "def radial_gradient(mode):\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.radial_gradient(mode))\n# --------------------------------------------------------------------\n# Resources\ndef _apply_env_variables(env=None):\n    if env is None:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass DecompressionBombWarning(RuntimeWarning):\n    pass\nclass DecompressionBombError(Exception):\n    pass\nclass _imaging_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n# Limit to around a quarter gigabyte for a 24 bit (3 bpp) image",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MAX_IMAGE_PIXELS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.\n    # Also note that Image.core is not a publicly documented interface,\n    # and should be considered private and subject to change.\n    from . import _imaging as core\n    if __version__ != getattr(core, \"PILLOW_VERSION\", None):\n        raise ImportError(",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "USE_CFFI_ACCESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "USE_CFFI_ACCESS = hasattr(sys, \"pypy_version_info\")\ntry:\n    import cffi\nexcept ImportError:\n    cffi = None\ntry:\n    from pathlib import Path\n    HAS_PATHLIB = True\nexcept ImportError:\n    try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "NONE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "NONE = 0\n# transpose\nFLIP_LEFT_RIGHT = 0\nFLIP_TOP_BOTTOM = 1\nROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "FLIP_LEFT_RIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "FLIP_LEFT_RIGHT = 0\nFLIP_TOP_BOTTOM = 1\nROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "FLIP_TOP_BOTTOM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "FLIP_TOP_BOTTOM = 1\nROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ROTATE_90",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ROTATE_180",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ROTATE_180 = 3\nROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ROTATE_270",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ROTATE_270 = 4\nTRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "TRANSPOSE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "TRANSPOSE = 5\nTRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "TRANSVERSE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "TRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "AFFINE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "AFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "EXTENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "EXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "PERSPECTIVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "PERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "QUAD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "QUAD = 3\nMESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MESH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MESH = 4\n# resampling filters (also defined in Imaging.h)\nNEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "NEAREST",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "NEAREST = NONE = 0\nBOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "BOX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "BOX = 4\nBILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "BILINEAR",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "BILINEAR = LINEAR = 2\nHAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "HAMMING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "HAMMING = 5\nBICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "BICUBIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "BICUBIC = CUBIC = 3\nLANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "LANCZOS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "LANCZOS = ANTIALIAS = 1\n# dithers\nNEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "NEAREST",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "NEAREST = NONE = 0\nORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ORDERED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ORDERED = 1  # Not yet implemented\nRASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "RASTERIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "RASTERIZE = 2  # Not yet implemented\nFLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "FLOYDSTEINBERG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "FLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "WEB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "WEB = 0\nADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ADAPTIVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ADAPTIVE = 1\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MEDIANCUT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MAXCOVERAGE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MAXCOVERAGE = 1\nFASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "FASTOCTREE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "FASTOCTREE = 2\nLIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "LIBIMAGEQUANT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "LIBIMAGEQUANT = 3\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "NORMAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "NORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "SEQUENCE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "SEQUENCE = 1\nCONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n# --------------------------------------------------------------------\n# Registries",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "CONTAINER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "CONTAINER = 2\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n# --------------------------------------------------------------------\n# Registries\nID = []",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ID",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ID = []\nOPEN = {}\nMIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "OPEN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "OPEN = {}\nMIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MIME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "SAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "SAVE_ALL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "SAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n    # official modes",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "EXTENSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "EXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "DECODERS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "DECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),\n    \"L\": (\"L\", \"L\", (\"L\",)),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ENCODERS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "ENCODERS = {}\n# --------------------------------------------------------------------\n# Modes supported by this version\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),\n    \"L\": (\"L\", \"L\", (\"L\",)),\n    \"I\": (\"L\", \"I\", (\"I\",)),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_MODEINFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),\n    \"L\": (\"L\", \"L\", (\"L\",)),\n    \"I\": (\"L\", \"I\", (\"I\",)),\n    \"F\": (\"L\", \"F\", (\"F\",)),\n    \"P\": (\"P\", \"L\", (\"P\",)),\n    \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\")),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_MODE_CONV",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "_MODE_CONV = {\n    # official modes\n    \"1\": (\"|b1\", None),  # Bits need to be extended to bytes\n    \"L\": (\"|u1\", None),\n    \"LA\": (\"|u1\", 2),\n    \"I\": (_ENDIAN + \"i4\", None),\n    \"F\": (_ENDIAN + \"f4\", None),\n    \"P\": (\"|u1\", None),\n    \"RGB\": (\"|u1\", 3),\n    \"RGBX\": (\"|u1\", 4),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "MODES = sorted(_MODEINFO)\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_MAPMODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_initialized",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "_initialized = 0\ndef preinit():\n    \"\"\"Explicitly load standard file format drivers.\"\"\"\n    global _initialized\n    if _initialized >= 1:\n        return\n    try:\n        from . import BmpImagePlugin\n        assert BmpImagePlugin\n    except ImportError:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_fromarray_typemap",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "peekOfCode": "_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    ((1, 1), \"|b1\"): (\"1\", \"1;8\"),\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<u2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">u2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16S\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16BS\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Image",
        "documentation": {}
    },
    {
        "label": "constant",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def constant(image, value):\n    \"\"\"Fill a channel with a given grey level.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.new(\"L\", image.size, value)\ndef duplicate(image):\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return image.copy()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "duplicate",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def duplicate(image):\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return image.copy()\ndef invert(image):\n    \"\"\"\n    Invert an image (channel).\n    .. code-block:: python\n        out = MAX - image",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "invert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def invert(image):\n    \"\"\"\n    Invert an image (channel).\n    .. code-block:: python\n        out = MAX - image\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image.load()\n    return image._new(image.im.chop_invert())\ndef lighter(image1, image2):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "lighter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def lighter(image1, image2):\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the lighter values. At least one of the images must have mode \"1\".\n    .. code-block:: python\n        out = max(image1, image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "darker",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def darker(image1, image2):\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the darker values. At least one of the images must have mode \"1\".\n    .. code-block:: python\n        out = min(image1, image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "difference",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def difference(image1, image2):\n    \"\"\"\n    Returns the absolute value of the pixel-by-pixel difference between the two\n    images. At least one of the images must have mode \"1\".\n    .. code-block:: python\n        out = abs(image1 - image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def multiply(image1, image2):\n    \"\"\"\n    Superimposes two images on top of each other.\n    If you multiply an image with a solid black image, the result is black. If\n    you multiply with a solid white image, the image is unaffected. At least\n    one of the images must have mode \"1\".\n    .. code-block:: python\n        out = image1 * image2 / MAX\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def screen(image1, image2):\n    \"\"\"\n    Superimposes two inverted images on top of each other. At least one of the\n    images must have mode \"1\".\n    .. code-block:: python\n        out = MAX - ((MAX - image1) * (MAX - image2) / MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def add(image1, image2, scale=1.0, offset=0):\n    \"\"\"\n    Adds two images, dividing the result by scale and adding the\n    offset. If omitted, scale defaults to 1.0, and offset to 0.0.\n    At least one of the images must have mode \"1\".\n    .. code-block:: python\n        out = ((image1 + image2) / scale + offset)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "subtract",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def subtract(image1, image2, scale=1.0, offset=0):\n    \"\"\"\n    Subtracts two images, dividing the result by scale and adding the offset.\n    If omitted, scale defaults to 1.0, and offset to 0.0. At least one of the\n    images must have mode \"1\".\n    .. code-block:: python\n        out = ((image1 - image2) / scale + offset)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "add_modulo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def add_modulo(image1, image2):\n    \"\"\"Add two images, without clipping the result. At least one of the images\n    must have mode \"1\".\n    .. code-block:: python\n        out = ((image1 + image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add_modulo(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "subtract_modulo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def subtract_modulo(image1, image2):\n    \"\"\"Subtract two images, without clipping the result. At least one of the\n    images must have mode \"1\".\n    .. code-block:: python\n        out = ((image1 - image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract_modulo(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_and",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def logical_and(image1, image2):\n    \"\"\"Logical AND between two images. At least one of the images must have\n    mode \"1\".\n    .. code-block:: python\n        out = ((image1 and image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_and(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_or",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def logical_or(image1, image2):\n    \"\"\"Logical OR between two images. At least one of the images must have\n    mode \"1\".\n    .. code-block:: python\n        out = ((image1 or image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_or(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_xor",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def logical_xor(image1, image2):\n    \"\"\"Logical XOR between two images. At least one of the images must have\n    mode \"1\".\n    .. code-block:: python\n        out = ((bool(image1) != bool(image2)) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_xor(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "blend",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def blend(image1, image2, alpha):\n    \"\"\"Blend images using constant transparency weight. Alias for\n    :py:meth:`PIL.Image.Image.blend`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.blend(image1, image2, alpha)\ndef composite(image1, image2, mask):\n    \"\"\"Create composite using transparency mask. Alias for\n    :py:meth:`PIL.Image.Image.composite`.\n    :rtype: :py:class:`~PIL.Image.Image`",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def composite(image1, image2, mask):\n    \"\"\"Create composite using transparency mask. Alias for\n    :py:meth:`PIL.Image.Image.composite`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.composite(image1, image2, mask)\ndef offset(image, xoffset, yoffset=None):\n    \"\"\"Returns a copy of the image where data has been offset by the given\n    distances. Data wraps around the edges. If **yoffset** is omitted, it\n    is assumed to be equal to **xoffset**.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "offset",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "peekOfCode": "def offset(image, xoffset, yoffset=None):\n    \"\"\"Returns a copy of the image where data has been offset by the given\n    distances. Data wraps around the edges. If **yoffset** is omitted, it\n    is assumed to be equal to **xoffset**.\n    :param xoffset: The horizontal distance.\n    :param yoffset: The vertical distance.  If omitted, both\n        distances are set to the same value.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    if yoffset is None:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "ImageCmsProfile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "class ImageCmsProfile(object):\n    def __init__(self, profile):\n        \"\"\"\n        :param profile: Either a string representing a filename,\n            a file like object containing a profile or a\n            low-level profile object\n        \"\"\"\n        if isStringType(profile):\n            self._set(core.profile_open(profile), profile)\n        elif hasattr(profile, \"read\"):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "ImageCmsTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "class ImageCmsTransform(Image.ImagePointHandler):\n    \"\"\"\n    Transform.  This can be used with the procedural API, or with the standard\n    Image.point() method.\n    Will return the output profile in the output.info['icc_profile'].\n    \"\"\"\n    def __init__(\n        self,\n        input,\n        output,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "PyCMSError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "class PyCMSError(Exception):\n    \"\"\" (pyCMS) Exception class.\n    This is used for all errors in the pyCMS API. \"\"\"\n    pass\ndef profileToProfile(\n    im,\n    inputProfile,\n    outputProfile,\n    renderingIntent=INTENT_PERCEPTUAL,\n    outputMode=None,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "get_display_profile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def get_display_profile(handle=None):\n    \"\"\" (experimental) Fetches the profile for the current display device.\n    :returns: None if the profile is not known.\n    \"\"\"\n    if sys.platform == \"win32\":\n        from PIL import ImageWin\n        if isinstance(handle, ImageWin.HDC):\n            profile = core.get_display_profile_win32(handle, 1)\n        else:\n            profile = core.get_display_profile_win32(handle or 0)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "profileToProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def profileToProfile(\n    im,\n    inputProfile,\n    outputProfile,\n    renderingIntent=INTENT_PERCEPTUAL,\n    outputMode=None,\n    inPlace=False,\n    flags=0,\n):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getOpenProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getOpenProfile(profileFilename):\n    \"\"\"\n    (pyCMS) Opens an ICC profile file.\n    The PyCMSProfile object can be passed back into pyCMS for use in creating\n    transforms and such (as in ImageCms.buildTransformFromOpenProfiles()).\n    If profileFilename is not a valid filename for an ICC profile, a PyCMSError\n    will be raised.\n    :param profileFilename: String, as a valid filename path to the ICC profile\n        you wish to open, or a file-like object.\n    :returns: A CmsProfile class object.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def buildTransform(\n    inputProfile,\n    outputProfile,\n    inMode,\n    outMode,\n    renderingIntent=INTENT_PERCEPTUAL,\n    flags=0,\n):\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the inputProfile to the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildProofTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def buildProofTransform(\n    inputProfile,\n    outputProfile,\n    proofProfile,\n    inMode,\n    outMode,\n    renderingIntent=INTENT_PERCEPTUAL,\n    proofRenderingIntent=INTENT_ABSOLUTE_COLORIMETRIC,\n    flags=FLAGS[\"SOFTPROOFING\"],\n):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "applyTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If im.mode != transform.inMode, a PyCMSError is raised.\n    If inPlace is True and transform.inMode != transform.outMode, a\n    PyCMSError is raised.\n    If im.mode, transform.inMode, or transform.outMode is not supported by\n    pyCMSdll or the profiles you used for the transform, a PyCMSError is\n    raised.\n    If an error occurs while the transform is being applied, a PyCMSError",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "createProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def createProfile(colorSpace, colorTemp=-1):\n    \"\"\"\n    (pyCMS) Creates a profile.\n    If colorSpace not in [\"LAB\", \"XYZ\", \"sRGB\"], a PyCMSError is raised\n    If using LAB and colorTemp != a positive integer, a PyCMSError is raised.\n    If an error occurs while creating the profile, a PyCMSError is raised.\n    Use this function to create common profiles on-the-fly instead of\n    having to supply a profile on disk and knowing the path to it.  It\n    returns a normal CmsProfile object that can be passed to\n    ImageCms.buildTransformFromOpenProfiles() to create a transform to apply",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileName",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileName(profile):\n    \"\"\"\n    (pyCMS) Gets the internal product name for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised If an error occurs while trying to obtain the\n    name tag, a PyCMSError is raised.\n    Use this function to obtain the INTERNAL name of the profile (stored\n    in an ICC tag in the profile itself), usually the one used when the\n    profile was originally created.  Sometimes this tag also contains\n    additional information supplied by the creator.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileInfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileInfo(profile):\n    \"\"\"\n    (pyCMS) Gets the internal product information for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the info tag, a PyCMSError\n    is raised\n    Use this function to obtain the information stored in the profile's\n    info tag.  This often contains details about the profile, and how it\n    was created, as supplied by the creator.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileCopyright",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileCopyright(profile):\n    \"\"\"\n    (pyCMS) Gets the copyright for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the copyright tag, a PyCMSError\n    is raised\n    Use this function to obtain the information stored in the profile's\n    copyright tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileManufacturer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileManufacturer(profile):\n    \"\"\"\n    (pyCMS) Gets the manufacturer for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the manufacturer tag, a\n    PyCMSError is raised\n    Use this function to obtain the information stored in the profile's\n    manufacturer tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileModel",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileModel(profile):\n    \"\"\"\n    (pyCMS) Gets the model for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the model tag, a PyCMSError\n    is raised\n    Use this function to obtain the information stored in the profile's\n    model tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileDescription",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getProfileDescription(profile):\n    \"\"\"\n    (pyCMS) Gets the description for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the description tag, a PyCMSError\n    is raised\n    Use this function to obtain the information stored in the profile's\n    description tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getDefaultIntent",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def getDefaultIntent(profile):\n    \"\"\"\n    (pyCMS) Gets the default intent name for the given profile.\n    If profile isn't a valid CmsProfile object or filename to a profile,\n    a PyCMSError is raised.\n    If an error occurs while trying to obtain the default intent, a\n    PyCMSError is raised.\n    Use this function to determine the default (and usually best optimized)\n    rendering intent for this profile.  Most profiles support multiple\n    rendering intents, but are intended mostly for one type of conversion.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "isIntentSupported",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def isIntentSupported(profile, intent, direction):\n    \"\"\"\n    (pyCMS) Checks if a given intent is supported.\n    Use this function to verify that you can use your desired\n    renderingIntent with profile, and that profile can be used for the\n    input/output/proof profile as you desire.\n    Some profiles are created specifically for one \"direction\", can cannot\n    be used for others.  Some profiles can only be used for certain\n    rendering intents... so it's best to either verify this before trying\n    to create a transform with them (using this function), or catch the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "versions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "def versions():\n    \"\"\"\n    (pyCMS) Fetches versions.\n    \"\"\"\n    return (VERSION, core.littlecms_version, sys.version.split()[0], Image.__version__)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "DESCRIPTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "DESCRIPTION = \"\"\"\npyCMS\n    a Python / PIL interface to the littleCMS ICC Color Management System\n    Copyright (C) 2002-2003 Kevin Cazabon\n    kevin@cazabon.com\n    http://www.cazabon.com\n    pyCMS home page:  http://www.cazabon.com/pyCMS\n    littleCMS home page:  http://www.littlecms.com\n    (littleCMS is Copyright (C) 1998-2001 Marti Maria)\n    Originally released under LGPL.  Graciously donated to PIL in",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "VERSION = \"1.0.0 pil\"\n# --------------------------------------------------------------------.\ncore = _imagingcms\n#\n# intent/direction values\nINTENT_PERCEPTUAL = 0\nINTENT_RELATIVE_COLORIMETRIC = 1\nINTENT_SATURATION = 2\nINTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "core",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "core = _imagingcms\n#\n# intent/direction values\nINTENT_PERCEPTUAL = 0\nINTENT_RELATIVE_COLORIMETRIC = 1\nINTENT_SATURATION = 2\nINTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "INTENT_PERCEPTUAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "INTENT_PERCEPTUAL = 0\nINTENT_RELATIVE_COLORIMETRIC = 1\nINTENT_SATURATION = 2\nINTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "INTENT_RELATIVE_COLORIMETRIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "INTENT_RELATIVE_COLORIMETRIC = 1\nINTENT_SATURATION = 2\nINTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "INTENT_SATURATION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "INTENT_SATURATION = 2\nINTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "INTENT_ABSOLUTE_COLORIMETRIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "INTENT_ABSOLUTE_COLORIMETRIC = 3\nDIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "DIRECTION_INPUT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "DIRECTION_INPUT = 0\nDIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "DIRECTION_OUTPUT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "DIRECTION_OUTPUT = 1\nDIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "DIRECTION_PROOF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "DIRECTION_PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms\n    # (internal use):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "FLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms\n    # (internal use):\n    \"NOPRELINEARIZATION\": 16,\n    \"GUESSDEVICECLASS\": 32,  # Guess device class (for transform2devicelink)\n    \"NOTCACHE\": 64,  # Inhibit 1-pixel cache",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "_MAX_FLAG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "_MAX_FLAG = 0\nfor flag in FLAGS.values():\n    if isinstance(flag, int):\n        _MAX_FLAG = _MAX_FLAG | flag\n# --------------------------------------------------------------------.\n# Experimental PIL-level API\n# --------------------------------------------------------------------.\n##\n# Profile.\nclass ImageCmsProfile(object):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildTransformFromOpenProfiles",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "buildTransformFromOpenProfiles = buildTransform\nbuildProofTransformFromOpenProfiles = buildProofTransform\ndef applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If im.mode != transform.inMode, a PyCMSError is raised.\n    If inPlace is True and transform.inMode != transform.outMode, a\n    PyCMSError is raised.\n    If im.mode, transform.inMode, or transform.outMode is not supported by\n    pyCMSdll or the profiles you used for the transform, a PyCMSError is",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildProofTransformFromOpenProfiles",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "peekOfCode": "buildProofTransformFromOpenProfiles = buildProofTransform\ndef applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If im.mode != transform.inMode, a PyCMSError is raised.\n    If inPlace is True and transform.inMode != transform.outMode, a\n    PyCMSError is raised.\n    If im.mode, transform.inMode, or transform.outMode is not supported by\n    pyCMSdll or the profiles you used for the transform, a PyCMSError is\n    raised.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getrgb",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "peekOfCode": "def getrgb(color):\n    \"\"\"\n     Convert a color string to an RGB tuple. If the string cannot be parsed,\n     this function raises a :py:exc:`ValueError` exception.\n    .. versionadded:: 1.1.4\n    :param color: A color string\n    :return: ``(red, green, blue[, alpha])``\n    \"\"\"\n    color = color.lower()\n    rgb = colormap.get(color, None)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "getcolor",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "peekOfCode": "def getcolor(color, mode):\n    \"\"\"\n    Same as :py:func:`~PIL.ImageColor.getrgb`, but converts the RGB value to a\n    greyscale value if the mode is not color or a palette image. If the string\n    cannot be parsed, this function raises a :py:exc:`ValueError` exception.\n    .. versionadded:: 1.1.4\n    :param color: A color string\n    :return: ``(graylevel [, alpha]) or (red, green, blue[, alpha])``\n    \"\"\"\n    # same as getrgb, but converts the result to the given mode",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "colormap",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "peekOfCode": "colormap = {\n    # X11 colour table from https://drafts.csswg.org/css-color-4/, with\n    # gray/grey spelling issues fixed.  This is a superset of HTML 4.0\n    # colour names used in CSS 1.\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "peekOfCode": "class ImageDraw(object):\n    def __init__(self, im, mode=None):\n        \"\"\"\n        Create a drawing instance.\n        :param im: The image to draw in.\n        :param mode: Optional mode to use for color values.  For RGB\n           images, this argument can be RGB or RGBA (to blend the\n           drawing into the image).  For all other modes, this argument\n           must be the same as the image mode.  If omitted, the mode\n           defaults to the mode of the image.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "peekOfCode": "def Draw(im, mode=None):\n    \"\"\"\n    A simple 2D drawing interface for PIL images.\n    :param im: The image to draw in.\n    :param mode: Optional mode to use for color values.  For RGB\n       images, this argument can be RGB or RGBA (to blend the\n       drawing into the image).  For all other modes, this argument\n       must be the same as the image mode.  If omitted, the mode\n       defaults to the mode of the image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "getdraw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "peekOfCode": "def getdraw(im=None, hints=None):\n    \"\"\"\n    (Experimental) A more advanced 2D drawing interface for PIL images,\n    based on the WCK interface.\n    :param im: The image to draw in.\n    :param hints: An optional list of hints.\n    :returns: A (drawing context, drawing resource factory) tuple.\n    \"\"\"\n    # FIXME: this needs more work!\n    # FIXME: come up with a better 'hints' scheme.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "peekOfCode": "def floodfill(image, xy, value, border=None, thresh=0):\n    \"\"\"\n    (experimental) Fills a bounded region with a given color.\n    :param image: Target image.\n    :param xy: Seed position (a 2-item coordinate tuple). See\n        :ref:`coordinate-system`.\n    :param value: Fill color.\n    :param border: Optional border value.  If given, the region consists of\n        pixels with a color different from the border color.  If not given,\n        the region consists of pixels having the same color as the seed",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "Pen",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "peekOfCode": "class Pen(object):\n    def __init__(self, color, width=1, opacity=255):\n        self.color = ImageColor.getrgb(color)\n        self.width = width\nclass Brush(object):\n    def __init__(self, color, opacity=255):\n        self.color = ImageColor.getrgb(color)\nclass Font(object):\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Brush",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "peekOfCode": "class Brush(object):\n    def __init__(self, color, opacity=255):\n        self.color = ImageColor.getrgb(color)\nclass Font(object):\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)\nclass Draw(object):\n    def __init__(self, image, size=None, color=None):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Font",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "peekOfCode": "class Font(object):\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)\nclass Draw(object):\n    def __init__(self, image, size=None, color=None):\n        if not hasattr(image, \"im\"):\n            image = Image.new(image, size, color)\n        self.draw = ImageDraw.Draw(image)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "peekOfCode": "class Draw(object):\n    def __init__(self, image, size=None, color=None):\n        if not hasattr(image, \"im\"):\n            image = Image.new(image, size, color)\n        self.draw = ImageDraw.Draw(image)\n        self.image = image\n        self.transform = None\n    def flush(self):\n        return self.image\n    def render(self, op, xy, pen, brush=None):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "_Enhance",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "peekOfCode": "class _Enhance(object):\n    def enhance(self, factor):\n        \"\"\"\n        Returns an enhanced image.\n        :param factor: A floating point value controlling the enhancement.\n                       Factor 1.0 always returns a copy of the original image,\n                       lower factors mean less color (brightness, contrast,\n                       etc), and higher values more. There are no restrictions\n                       on this value.\n        :rtype: :py:class:`~PIL.Image.Image`",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "peekOfCode": "class Color(_Enhance):\n    \"\"\"Adjust image color balance.\n    This class can be used to adjust the colour balance of an image, in\n    a manner similar to the controls on a colour TV set. An enhancement\n    factor of 0.0 gives a black and white image. A factor of 1.0 gives\n    the original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.intermediate_mode = \"L\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Contrast",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "peekOfCode": "class Contrast(_Enhance):\n    \"\"\"Adjust image contrast.\n    This class can be used to control the contrast of an image, similar\n    to the contrast control on a TV set. An enhancement factor of 0.0\n    gives a solid grey image. A factor of 1.0 gives the original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        mean = int(ImageStat.Stat(image.convert(\"L\")).mean[0] + 0.5)\n        self.degenerate = Image.new(\"L\", image.size, mean).convert(image.mode)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Brightness",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "peekOfCode": "class Brightness(_Enhance):\n    \"\"\"Adjust image brightness.\n    This class can be used to control the brightness of an image.  An\n    enhancement factor of 0.0 gives a black image. A factor of 1.0 gives the\n    original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.degenerate = Image.new(image.mode, image.size, 0)\n        if \"A\" in image.getbands():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Sharpness",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "peekOfCode": "class Sharpness(_Enhance):\n    \"\"\"Adjust image sharpness.\n    This class can be used to adjust the sharpness of an image. An\n    enhancement factor of 0.0 gives a blurred image, a factor of 1.0 gives the\n    original image, and a factor of 2.0 gives a sharpened image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.degenerate = image.filter(ImageFilter.SMOOTH)\n        if \"A\" in image.getbands():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "ImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "class ImageFile(Image.Image):\n    \"Base class for image file format handlers.\"\n    def __init__(self, fp=None, filename=None):\n        Image.Image.__init__(self)\n        self._min_frame = 0\n        self.custom_mimetype = None\n        self.tile = None\n        self.readonly = 1  # until we know better\n        self.decoderconfig = ()\n        self.decodermaxblock = MAXBLOCK",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "StubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "class StubImageFile(ImageFile):\n    \"\"\"\n    Base class for stub image loaders.\n    A stub loader is an image loader that can identify files of a\n    certain format, but relies on external code to load the file.\n    \"\"\"\n    def _open(self):\n        raise NotImplementedError(\"StubImageFile subclass must implement _open\")\n    def load(self):\n        loader = self._load()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "Parser",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "class Parser(object):\n    \"\"\"\n    Incremental image parser.  This class implements the standard\n    feed/close consumer interface.\n    \"\"\"\n    incremental = None\n    image = None\n    data = None\n    decoder = None\n    offset = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyCodecState",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "class PyCodecState(object):\n    def __init__(self):\n        self.xsize = 0\n        self.ysize = 0\n        self.xoff = 0\n        self.yoff = 0\n    def extents(self):\n        return (self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize)\nclass PyDecoder(object):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "class PyDecoder(object):\n    \"\"\"\n    Python implementation of a format decoder. Override this class and\n    add the decoding logic in the `decode` method.\n    See :ref:`Writing Your Own File Decoder in Python<file-decoders-py>`\n    \"\"\"\n    _pulls_fd = False\n    def __init__(self, mode, *args):\n        self.im = None\n        self.state = PyCodecState()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "raise_ioerror",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "def raise_ioerror(error):\n    try:\n        message = Image.core.getcodecstatus(error)\n    except AttributeError:\n        message = ERRORS.get(error)\n    if not message:\n        message = \"decoder error %d\" % error\n    raise IOError(message + \" when reading image file\")\n#\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "MAXBLOCK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "MAXBLOCK = 65536\nSAFEBLOCK = 1024 * 1024\nLOAD_TRUNCATED_IMAGES = False\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "SAFEBLOCK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "SAFEBLOCK = 1024 * 1024\nLOAD_TRUNCATED_IMAGES = False\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\ndef raise_ioerror(error):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "LOAD_TRUNCATED_IMAGES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "LOAD_TRUNCATED_IMAGES = False\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\ndef raise_ioerror(error):\n    try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "ERRORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "peekOfCode": "ERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\ndef raise_ioerror(error):\n    try:\n        message = Image.core.getcodecstatus(error)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "Filter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class Filter(object):\n    pass\nclass MultibandFilter(Filter):\n    pass\nclass BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            raise ValueError(\"cannot filter palette images\")\n        return image.filter(*self.filterargs)\nclass Kernel(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MultibandFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class MultibandFilter(Filter):\n    pass\nclass BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            raise ValueError(\"cannot filter palette images\")\n        return image.filter(*self.filterargs)\nclass Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel.  The current version only",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BuiltinFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            raise ValueError(\"cannot filter palette images\")\n        return image.filter(*self.filterargs)\nclass Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel.  The current version only\n    supports 3x3 and 5x5 integer and floating point kernels.\n    In the current version, kernels can only be applied to",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "Kernel",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel.  The current version only\n    supports 3x3 and 5x5 integer and floating point kernels.\n    In the current version, kernels can only be applied to\n    \"L\" and \"RGB\" images.\n    :param size: Kernel size, given as (width, height). In the current\n                    version, this must be (3,3) or (5,5).\n    :param kernel: A sequence containing kernel weights.\n    :param scale: Scale factor. If given, the result for each pixel is",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "RankFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class RankFilter(Filter):\n    \"\"\"\n    Create a rank filter.  The rank filter sorts all pixels in\n    a window of the given size, and returns the **rank**'th value.\n    :param size: The kernel size, in pixels.\n    :param rank: What pixel value to pick.  Use 0 for a min filter,\n                 ``size * size / 2`` for a median filter, ``size * size - 1``\n                 for a max filter, etc.\n    \"\"\"\n    name = \"Rank\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MedianFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class MedianFilter(RankFilter):\n    \"\"\"\n    Create a median filter. Picks the median pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Median\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = size * size // 2",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MinFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class MinFilter(RankFilter):\n    \"\"\"\n    Create a min filter.  Picks the lowest pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Min\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MaxFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class MaxFilter(RankFilter):\n    \"\"\"\n    Create a max filter.  Picks the largest pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Max\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = size * size - 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "ModeFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class ModeFilter(Filter):\n    \"\"\"\n    Create a mode filter. Picks the most frequent pixel value in a box with the\n    given size.  Pixel values that occur only once or twice are ignored; if no\n    pixel value occurs more than twice, the original pixel value is preserved.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Mode\"\n    def __init__(self, size=3):\n        self.size = size",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "GaussianBlur",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class GaussianBlur(MultibandFilter):\n    \"\"\"Gaussian blur filter.\n    :param radius: Blur radius.\n    \"\"\"\n    name = \"GaussianBlur\"\n    def __init__(self, radius=2):\n        self.radius = radius\n    def filter(self, image):\n        return image.gaussian_blur(self.radius)\nclass BoxBlur(MultibandFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BoxBlur",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class BoxBlur(MultibandFilter):\n    \"\"\"Blurs the image by setting each pixel to the average value of the pixels\n    in a square box extending radius pixels in each direction.\n    Supports float radius of arbitrary size. Uses an optimized implementation\n    which runs in linear time relative to the size of the image\n    for any radius value.\n    :param radius: Size of the box in one direction. Radius 0 does not blur,\n                   returns an identical image. Radius 1 takes 1 pixel\n                   in each direction, i.e. 9 pixels in total.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "UnsharpMask",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class UnsharpMask(MultibandFilter):\n    \"\"\"Unsharp mask filter.\n    See Wikipedia's entry on `digital unsharp masking`_ for an explanation of\n    the parameters.\n    :param radius: Blur Radius\n    :param percent: Unsharp strength, in percent\n    :param threshold: Threshold controls the minimum brightness change that\n      will be sharpened\n    .. _digital unsharp masking: https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking\n    \"\"\"  # noqa: E501",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BLUR",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class BLUR(BuiltinFilter):\n    name = \"Blur\"\n    # fmt: off\n    filterargs = (5, 5), 16, 0, (\n        1, 1, 1, 1, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 1, 1, 1, 1,\n    )",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "CONTOUR",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class CONTOUR(BuiltinFilter):\n    name = \"Contour\"\n    # fmt: off\n    filterargs = (3, 3), 1, 255, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass DETAIL(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "DETAIL",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class DETAIL(BuiltinFilter):\n    name = \"Detail\"\n    # fmt: off\n    filterargs = (3, 3), 6, 0, (\n        0,  -1,  0,\n        -1, 10, -1,\n        0,  -1,  0,\n    )\n    # fmt: on\nclass EDGE_ENHANCE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EDGE_ENHANCE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class EDGE_ENHANCE(BuiltinFilter):\n    name = \"Edge-enhance\"\n    # fmt: off\n    filterargs = (3, 3), 2, 0, (\n        -1, -1, -1,\n        -1, 10, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass EDGE_ENHANCE_MORE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EDGE_ENHANCE_MORE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class EDGE_ENHANCE_MORE(BuiltinFilter):\n    name = \"Edge-enhance More\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass EMBOSS(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EMBOSS",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class EMBOSS(BuiltinFilter):\n    name = \"Emboss\"\n    # fmt: off\n    filterargs = (3, 3), 1, 128, (\n        -1, 0, 0,\n        0,  1, 0,\n        0,  0, 0,\n    )\n    # fmt: on\nclass FIND_EDGES(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "FIND_EDGES",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class FIND_EDGES(BuiltinFilter):\n    name = \"Find Edges\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass SHARPEN(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SHARPEN",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class SHARPEN(BuiltinFilter):\n    name = \"Sharpen\"\n    # fmt: off\n    filterargs = (3, 3), 16, 0, (\n        -2, -2, -2,\n        -2, 32, -2,\n        -2, -2, -2,\n    )\n    # fmt: on\nclass SMOOTH(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SMOOTH",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class SMOOTH(BuiltinFilter):\n    name = \"Smooth\"\n    # fmt: off\n    filterargs = (3, 3), 13, 0, (\n        1, 1, 1,\n        1, 5, 1,\n        1, 1, 1,\n    )\n    # fmt: on\nclass SMOOTH_MORE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SMOOTH_MORE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class SMOOTH_MORE(BuiltinFilter):\n    name = \"Smooth More\"\n    # fmt: off\n    filterargs = (5, 5), 100, 0, (\n        1, 1,  1, 1, 1,\n        1, 5,  5, 5, 1,\n        1, 5, 44, 5, 1,\n        1, 5,  5, 5, 1,\n        1, 1,  1, 1, 1,\n    )",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "Color3DLUT",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "peekOfCode": "class Color3DLUT(MultibandFilter):\n    \"\"\"Three-dimensional color lookup table.\n    Transforms 3-channel pixels using the values of the channels as coordinates\n    in the 3D lookup table and interpolating the nearest elements.\n    This method allows you to apply almost any color transformation\n    in constant time by using pre-calculated decimated tables.\n    .. versionadded:: 5.2.0\n    :param size: Size of the table. One int or tuple of (int, int, int).\n                 Minimal size in any dimension is 2, maximum is 65.\n    :param table: Flat lookup table. A list of ``channels * size**3``",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "_imagingft_not_installed",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "class _imagingft_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imagingft C module is not installed\")\ntry:\n    from . import _imagingft as core\nexcept ImportError:\n    core = _imagingft_not_installed()\n# FIXME: add support for pilfont2 format (see FontFile.py)\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "class ImageFont(object):\n    \"PIL font wrapper\"\n    def _load_pilfont(self, filename):\n        with open(filename, \"rb\") as fp:\n            for ext in (\".png\", \".gif\", \".pbm\"):\n                try:\n                    fullname = os.path.splitext(filename)[0] + ext\n                    image = Image.open(fullname)\n                except Exception:\n                    pass",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "FreeTypeFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "class FreeTypeFont(object):\n    \"FreeType font wrapper (requires _imagingft service)\"\n    def __init__(self, font=None, size=10, index=0, encoding=\"\", layout_engine=None):\n        # FIXME: use service provider instead\n        self.path = font\n        self.size = size\n        self.index = index\n        self.encoding = encoding\n        if layout_engine not in (LAYOUT_BASIC, LAYOUT_RAQM):\n            layout_engine = LAYOUT_BASIC",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "TransposedFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "class TransposedFont(object):\n    \"Wrapper for writing rotated or mirrored text\"\n    def __init__(self, font, orientation=None):\n        \"\"\"\n        Wrapper that creates a transposed font from any existing font\n        object.\n        :param font: A font object.\n        :param orientation: An optional orientation.  If given, this should\n            be one of Image.FLIP_LEFT_RIGHT, Image.FLIP_TOP_BOTTOM,\n            Image.ROTATE_90, Image.ROTATE_180, or Image.ROTATE_270.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "def load(filename):\n    \"\"\"\n    Load a font file.  This function loads a font object from the given\n    bitmap font file, and returns the corresponding font object.\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception IOError: If the file could not be read.\n    \"\"\"\n    f = ImageFont()\n    f._load_pilfont(filename)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "truetype",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "def truetype(font=None, size=10, index=0, encoding=\"\", layout_engine=None):\n    \"\"\"\n    Load a TrueType or OpenType font from a file or file-like object,\n    and create a font object.\n    This function loads a font object from the given file or file-like\n    object, and creates a font object for a font of the given size.\n    Pillow uses FreeType to open font files. If you are opening many fonts\n    simultaneously on Windows, be aware that Windows limits the number of files\n    that can be open in C at once to 512. If you approach that limit, an\n    ``OSError`` may be thrown, reporting that FreeType \"cannot open resource\".",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load_path",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "def load_path(filename):\n    \"\"\"\n    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a\n    bitmap font along the Python path.\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception IOError: If the file could not be read.\n    \"\"\"\n    for directory in sys.path:\n        if isDirectory(directory):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load_default",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "def load_default():\n    \"\"\"Load a \"better than nothing\" default font.\n    .. versionadded:: 1.1.4\n    :return: A font object.\n    \"\"\"\n    from io import BytesIO\n    import base64\n    f = ImageFont()\n    f._load_pilfont_data(\n        # courB08",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "LAYOUT_BASIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "LAYOUT_BASIC = 0\nLAYOUT_RAQM = 1\nclass _imagingft_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imagingft C module is not installed\")\ntry:\n    from . import _imagingft as core\nexcept ImportError:\n    core = _imagingft_not_installed()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "LAYOUT_RAQM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "peekOfCode": "LAYOUT_RAQM = 1\nclass _imagingft_not_installed(object):\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imagingft C module is not installed\")\ntry:\n    from . import _imagingft as core\nexcept ImportError:\n    core = _imagingft_not_installed()\n# FIXME: add support for pilfont2 format (see FontFile.py)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "grab",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "peekOfCode": "def grab(bbox=None, include_layered_windows=False, all_screens=False):\n    if sys.platform == \"darwin\":\n        fh, filepath = tempfile.mkstemp(\".png\")\n        os.close(fh)\n        subprocess.call([\"screencapture\", \"-x\", filepath])\n        im = Image.open(filepath)\n        im.load()\n        os.unlink(filepath)\n        if bbox:\n            im = im.crop(bbox)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "documentation": {}
    },
    {
        "label": "grabclipboard",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "peekOfCode": "def grabclipboard():\n    if sys.platform == \"darwin\":\n        fh, filepath = tempfile.mkstemp(\".jpg\")\n        os.close(fh)\n        commands = [\n            'set theFile to (open for access POSIX file \"'\n            + filepath\n            + '\" with write permission)',\n            \"try\",\n            \"    write (the clipboard as JPEG picture) to theFile\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageGrab",
        "documentation": {}
    },
    {
        "label": "_Operand",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "class _Operand(object):\n    \"\"\"Wraps an image operand, providing standard operators\"\"\"\n    def __init__(self, im):\n        self.im = im\n    def __fixup(self, im1):\n        # convert image to suitable mode\n        if isinstance(im1, _Operand):\n            # argument was an image.\n            if im1.im.mode in (\"1\", \"L\"):\n                return im1.im.convert(\"I\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_int",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_int(self):\n    return _Operand(self.im.convert(\"I\"))\ndef imagemath_float(self):\n    return _Operand(self.im.convert(\"F\"))\n# logical\ndef imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_float",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_float(self):\n    return _Operand(self.im.convert(\"F\"))\n# logical\ndef imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_equal",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_notequal",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_min",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_max",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_convert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "def eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "VERBOSE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "VERBOSE = 0\ndef _isconstant(v):\n    return isinstance(v, (int, float))\nclass _Operand(object):\n    \"\"\"Wraps an image operand, providing standard operators\"\"\"\n    def __init__(self, im):\n        self.im = im\n    def __fixup(self, im1):\n        # convert image to suitable mode\n        if isinstance(im1, _Operand):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "ops",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "peekOfCode": "ops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "ModeDescriptor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "peekOfCode": "class ModeDescriptor(object):\n    \"\"\"Wrapper for mode strings.\"\"\"\n    def __init__(self, mode, bands, basemode, basetype):\n        self.mode = mode\n        self.bands = bands\n        self.basemode = basemode\n        self.basetype = basetype\n    def __str__(self):\n        return self.mode\ndef getmode(mode):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "documentation": {}
    },
    {
        "label": "getmode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "peekOfCode": "def getmode(mode):\n    \"\"\"Gets a mode descriptor for the given mode.\"\"\"\n    global _modes\n    if not _modes:\n        # initialize mode cache\n        from . import Image\n        modes = {}\n        # core modes\n        for m, (basemode, basetype, bands) in Image._MODEINFO.items():\n            modes[m] = ModeDescriptor(m, bands, basemode, basetype)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "documentation": {}
    },
    {
        "label": "_modes",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "peekOfCode": "_modes = None\nclass ModeDescriptor(object):\n    \"\"\"Wrapper for mode strings.\"\"\"\n    def __init__(self, mode, bands, basemode, basetype):\n        self.mode = mode\n        self.bands = bands\n        self.basemode = basemode\n        self.basetype = basetype\n    def __str__(self):\n        return self.mode",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMode",
        "documentation": {}
    },
    {
        "label": "LutBuilder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "peekOfCode": "class LutBuilder(object):\n    \"\"\"A class for building a MorphLut from a descriptive language\n      The input patterns is a list of a strings sequences like these::\n          4:(...\n             .1.\n             111)->1\n      (whitespaces including linebreaks are ignored). The option 4\n      describes a series of symmetry operations (in this case a\n      4-rotation), the pattern is described by:\n      - . or X - Ignore",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "MorphOp",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "peekOfCode": "class MorphOp(object):\n    \"\"\"A class for binary morphological operators\"\"\"\n    def __init__(self, lut=None, op_name=None, patterns=None):\n        \"\"\"Create a binary morphological operator\"\"\"\n        self.lut = lut\n        if op_name is not None:\n            self.lut = LutBuilder(op_name=op_name).build_lut()\n        elif patterns is not None:\n            self.lut = LutBuilder(patterns=patterns).build_lut()\n    def apply(self, image):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "LUT_SIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "peekOfCode": "LUT_SIZE = 1 << 9\n# fmt: off\nROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "ROTATION_MATRIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "peekOfCode": "ROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "MIRROR_MATRIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "peekOfCode": "MIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]\n# fmt: on\nclass LutBuilder(object):\n    \"\"\"A class for building a MorphLut from a descriptive language\n      The input patterns is a list of a strings sequences like these::\n          4:(...",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "autocontrast",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def autocontrast(image, cutoff=0, ignore=None):\n    \"\"\"\n    Maximize (normalize) image contrast. This function calculates a\n    histogram of the input image, removes **cutoff** percent of the\n    lightest and darkest pixels from the histogram, and remaps the image\n    so that the darkest pixel becomes black (0), and the lightest\n    becomes white (255).\n    :param image: The image to process.\n    :param cutoff: How many percent to cut off from the histogram.\n    :param ignore: The background pixel value (use None for no background).",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def colorize(image, black, white, mid=None, blackpoint=0, whitepoint=255, midpoint=127):\n    \"\"\"\n    Colorize grayscale image.\n    This function calculates a color wedge which maps all black pixels in\n    the source image to the first color and all white pixels to the\n    second color. If **mid** is specified, it uses three-color mapping.\n    The **black** and **white** arguments should be RGB tuples or color names;\n    optionally you can use three-color mapping by also specifying **mid**.\n    Mapping positions for any of the colors can be specified\n    (e.g. **blackpoint**), where these parameters are the integer",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def pad(image, size, method=Image.NEAREST, color=None, centering=(0.5, 0.5)):\n    \"\"\"\n    Returns a sized and padded version of the image, expanded to fill the\n    requested aspect ratio and size.\n    :param image: The image to size and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: What resampling method to use. Default is\n                   :py:attr:`PIL.Image.NEAREST`.\n    :param color: The background color of the padded image.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "crop",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def crop(image, border=0):\n    \"\"\"\n    Remove border from image.  The same amount of pixels are removed\n    from all four sides.  This function works on all image modes.\n    .. seealso:: :py:meth:`~PIL.Image.Image.crop`\n    :param image: The image to crop.\n    :param border: The number of pixels to remove.\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "scale",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def scale(image, factor, resample=Image.NEAREST):\n    \"\"\"\n    Returns a rescaled image by a specific factor given in parameter.\n    A factor greater than 1 expands the image, between 0 and 1 contracts the\n    image.\n    :param image: The image to rescale.\n    :param factor: The expansion factor, as a float.\n    :param resample: An optional resampling filter. Same values possible as\n       in the PIL.Image.resize function.\n    :returns: An :py:class:`~PIL.Image.Image` object.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "deform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def deform(image, deformer, resample=Image.BILINEAR):\n    \"\"\"\n    Deform the image.\n    :param image: The image to deform.\n    :param deformer: A deformer object.  Any object that implements a\n                    **getmesh** method can be used.\n    :param resample: An optional resampling filter. Same values possible as\n       in the PIL.Image.transform function.\n    :return: An image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "equalize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def equalize(image, mask=None):\n    \"\"\"\n    Equalize the image histogram. This function applies a non-linear\n    mapping to the input image, in order to create a uniform\n    distribution of grayscale values in the output image.\n    :param image: The image to equalize.\n    :param mask: An optional mask.  If given, only the pixels selected by\n                 the mask are included in the analysis.\n    :return: An image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "expand",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def expand(image, border=0, fill=0):\n    \"\"\"\n    Add border to the image\n    :param image: The image to expand.\n    :param border: Border width, in pixels.\n    :param fill: Pixel fill value (a color value).  Default is 0 (black).\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    width = left + image.size[0] + right",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "fit",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def fit(image, size, method=Image.NEAREST, bleed=0.0, centering=(0.5, 0.5)):\n    \"\"\"\n    Returns a sized and cropped version of the image, cropped to the\n    requested aspect ratio and size.\n    This function was contributed by Kevin Cazabon.\n    :param image: The image to size and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: What resampling method to use. Default is\n                   :py:attr:`PIL.Image.NEAREST`.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "flip",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def flip(image):\n    \"\"\"\n    Flip the image vertically (top to bottom).\n    :param image: The image to flip.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.FLIP_TOP_BOTTOM)\ndef grayscale(image):\n    \"\"\"\n    Convert the image to grayscale.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "grayscale",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def grayscale(image):\n    \"\"\"\n    Convert the image to grayscale.\n    :param image: The image to convert.\n    :return: An image.\n    \"\"\"\n    return image.convert(\"L\")\ndef invert(image):\n    \"\"\"\n    Invert (negate) the image.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "invert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def invert(image):\n    \"\"\"\n    Invert (negate) the image.\n    :param image: The image to invert.\n    :return: An image.\n    \"\"\"\n    lut = []\n    for i in range(256):\n        lut.append(255 - i)\n    return _lut(image, lut)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "mirror",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def mirror(image):\n    \"\"\"\n    Flip image horizontally (left to right).\n    :param image: The image to mirror.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.FLIP_LEFT_RIGHT)\ndef posterize(image, bits):\n    \"\"\"\n    Reduce the number of bits for each color channel.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "posterize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def posterize(image, bits):\n    \"\"\"\n    Reduce the number of bits for each color channel.\n    :param image: The image to posterize.\n    :param bits: The number of bits to keep for each channel (1-8).\n    :return: An image.\n    \"\"\"\n    lut = []\n    mask = ~(2 ** (8 - bits) - 1)\n    for i in range(256):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "solarize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def solarize(image, threshold=128):\n    \"\"\"\n    Invert all pixel values above a threshold.\n    :param image: The image to solarize.\n    :param threshold: All pixels above this greyscale level are inverted.\n    :return: An image.\n    \"\"\"\n    lut = []\n    for i in range(256):\n        if i < threshold:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "exif_transpose",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "peekOfCode": "def exif_transpose(image):\n    \"\"\"\n    If an image has an EXIF Orientation tag, return a new image that is\n    transposed accordingly. Otherwise, return a copy of the image.\n    :param image: The image to transpose.\n    :return: An image.\n    \"\"\"\n    exif = image.getexif()\n    orientation = exif.get(0x0112)\n    method = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "ImagePalette",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "class ImagePalette(object):\n    \"\"\"\n    Color palette for palette mapped images\n    :param mode: The mode to use for the Palette. See:\n        :ref:`concept-modes`. Defaults to \"RGB\"\n    :param palette: An optional palette. If given, it must be a bytearray,\n        an array or a list of ints between 0-255 and of length ``size``\n        times the number of colors in ``mode``. The list must be aligned\n        by channel (All R values must be contiguous in the list before G\n        and B values.) Defaults to 0 through 255 per channel.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "raw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def raw(rawmode, data):\n    palette = ImagePalette()\n    palette.rawmode = rawmode\n    palette.palette = data\n    palette.dirty = 1\n    return palette\n# --------------------------------------------------------------------\n# Factories\ndef make_linear_lut(black, white):\n    lut = []",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "make_linear_lut",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def make_linear_lut(black, white):\n    lut = []\n    if black == 0:\n        for i in range(256):\n            lut.append(white * i // 255)\n    else:\n        raise NotImplementedError  # FIXME\n    return lut\ndef make_gamma_lut(exp):\n    lut = []",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "make_gamma_lut",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def make_gamma_lut(exp):\n    lut = []\n    for i in range(256):\n        lut.append(int(((i / 255.0) ** exp) * 255.0 + 0.5))\n    return lut\ndef negative(mode=\"RGB\"):\n    palette = list(range(256))\n    palette.reverse()\n    return ImagePalette(mode, palette * len(mode))\ndef random(mode=\"RGB\"):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "negative",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def negative(mode=\"RGB\"):\n    palette = list(range(256))\n    palette.reverse()\n    return ImagePalette(mode, palette * len(mode))\ndef random(mode=\"RGB\"):\n    from random import randint\n    palette = []\n    for i in range(256 * len(mode)):\n        palette.append(randint(0, 255))\n    return ImagePalette(mode, palette)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def random(mode=\"RGB\"):\n    from random import randint\n    palette = []\n    for i in range(256 * len(mode)):\n        palette.append(randint(0, 255))\n    return ImagePalette(mode, palette)\ndef sepia(white=\"#fff0c0\"):\n    r, g, b = ImageColor.getrgb(white)\n    r = make_linear_lut(0, r)\n    g = make_linear_lut(0, g)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "sepia",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def sepia(white=\"#fff0c0\"):\n    r, g, b = ImageColor.getrgb(white)\n    r = make_linear_lut(0, r)\n    g = make_linear_lut(0, g)\n    b = make_linear_lut(0, b)\n    return ImagePalette(\"RGB\", r + g + b)\ndef wedge(mode=\"RGB\"):\n    return ImagePalette(mode, list(range(256)) * len(mode))\ndef load(filename):\n    # FIXME: supports GIMP gradients only",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "wedge",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def wedge(mode=\"RGB\"):\n    return ImagePalette(mode, list(range(256)) * len(mode))\ndef load(filename):\n    # FIXME: supports GIMP gradients only\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,\n        ]:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "peekOfCode": "def load(filename):\n    # FIXME: supports GIMP gradients only\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,\n        ]:\n            try:\n                fp.seek(0)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImagePath",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImagePath",
        "peekOfCode": "Path = Image.core.path",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImagePath",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "peekOfCode": "class Iterator(object):\n    \"\"\"\n    This class implements an iterator object that can be used to loop\n    over an image sequence.\n    You can use the ``[]`` operator to access elements by index. This operator\n    will raise an :py:exc:`IndexError` if you try to access a nonexistent\n    frame.\n    :param im: An image object.\n    \"\"\"\n    def __init__(self, im):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "documentation": {}
    },
    {
        "label": "all_frames",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "peekOfCode": "def all_frames(im, func=None):\n    \"\"\"\n    Applies a given function to all frames in an image or a list of images.\n    The frames are returned as a list of separate images.\n    :param im: An image, or a list of images.\n    :param func: The function to apply to all of the image frames.\n    :returns: A list of images.\n    \"\"\"\n    if not isinstance(im, list):\n        im = [im]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageSequence",
        "documentation": {}
    },
    {
        "label": "Viewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "peekOfCode": "class Viewer(object):\n    \"\"\"Base class for viewers.\"\"\"\n    # main api\n    def show(self, image, **options):\n        # save temporary image to disk\n        if not (\n            image.mode in (\"1\", \"RGBA\") or (self.format == \"PNG\" and image.mode == \"LA\")\n        ):\n            base = Image.getmodebase(image.mode)\n            if image.mode != base:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "peekOfCode": "def register(viewer, order=1):\n    try:\n        if issubclass(viewer, Viewer):\n            viewer = viewer()\n    except TypeError:\n        pass  # raised if viewer wasn't a class\n    if order > 0:\n        _viewers.append(viewer)\n    elif order < 0:\n        _viewers.insert(0, viewer)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "show",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "peekOfCode": "def show(image, title=None, **options):\n    r\"\"\"\n    Display a given image.\n    :param image: An image object.\n    :param title: Optional title.  Not all viewers can display the title.\n    :param \\**options: Additional viewer options.\n    :returns: True if a suitable viewer was found, false otherwise.\n    \"\"\"\n    for viewer in _viewers:\n        if viewer.show(image, title=title, **options):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "_viewers",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "peekOfCode": "_viewers = []\ndef register(viewer, order=1):\n    try:\n        if issubclass(viewer, Viewer):\n            viewer = viewer()\n    except TypeError:\n        pass  # raised if viewer wasn't a class\n    if order > 0:\n        _viewers.append(viewer)\n    elif order < 0:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "Stat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "peekOfCode": "class Stat(object):\n    def __init__(self, image_or_list, mask=None):\n        try:\n            if mask:\n                self.h = image_or_list.histogram(mask)\n            else:\n                self.h = image_or_list.histogram()\n        except AttributeError:\n            self.h = image_or_list  # assume it to be a histogram list\n        if not isinstance(self.h, list):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "peekOfCode": "Global = Stat  # compatibility",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageStat",
        "documentation": {}
    },
    {
        "label": "Transform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "peekOfCode": "class Transform(Image.ImageTransformHandler):\n    def __init__(self, data):\n        self.data = data\n    def getdata(self):\n        return self.method, self.data\n    def transform(self, size, image, **options):\n        # can be overridden\n        method, data = self.getdata()\n        return image.transform(size, method, data, **options)\nclass AffineTransform(Transform):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "AffineTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "peekOfCode": "class AffineTransform(Transform):\n    \"\"\"\n    Define an affine image transform.\n    This function takes a 6-tuple (a, b, c, d, e, f) which contain the first\n    two rows from an affine transform matrix. For each pixel (x, y) in the\n    output image, the new value is taken from a position (a x + b y + c,\n    d x + e y + f) in the input image, rounded to nearest pixel.\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n    See :py:meth:`~PIL.Image.Image.transform`",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "ExtentTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "peekOfCode": "class ExtentTransform(Transform):\n    \"\"\"\n    Define a transform to extract a subregion from an image.\n    Maps a rectangle (defined by two corners) from the image to a rectangle of\n    the given size. The resulting image will contain data sampled from between\n    the corners, such that (x0, y0) in the input image will end up at (0,0) in\n    the output image, and (x1, y1) at size.\n    This method can be used to crop, stretch, shrink, or mirror an arbitrary\n    rectangle in the current image. It is slightly slower than crop, but about\n    as fast as a corresponding resize operation.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "QuadTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "peekOfCode": "class QuadTransform(Transform):\n    \"\"\"\n    Define a quad image transform.\n    Maps a quadrilateral (a region defined by four corners) from the image to a\n    rectangle of the given size.\n    See :py:meth:`~PIL.Image.Image.transform`\n    :param xy: An 8-tuple (x0, y0, x1, y1, x2, y2, x3, y3) which contain the\n        upper left, lower left, lower right, and upper right corner of the\n        source quadrilateral.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "MeshTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "peekOfCode": "class MeshTransform(Transform):\n    \"\"\"\n    Define a mesh image transform.  A mesh transform consists of one or more\n    individual quad transforms.\n    See :py:meth:`~PIL.Image.Image.transform`\n    :param data: A list of (bbox, quad) tuples.\n    \"\"\"\n    method = Image.MESH",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "HDC",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "peekOfCode": "class HDC(object):\n    \"\"\"\n    Wraps an HDC integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods.\n    \"\"\"\n    def __init__(self, dc):\n        self.dc = dc\n    def __int__(self):\n        return self.dc",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "HWND",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "peekOfCode": "class HWND(object):\n    \"\"\"\n    Wraps an HWND integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods, instead of a DC.\n    \"\"\"\n    def __init__(self, wnd):\n        self.wnd = wnd\n    def __int__(self):\n        return self.wnd",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "Dib",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "peekOfCode": "class Dib(object):\n    \"\"\"\n    A Windows bitmap with the given mode and size.  The mode can be one of \"1\",\n    \"L\", \"P\", or \"RGB\".\n    If the display requires a palette, this constructor creates a suitable\n    palette and associates it with the image. For an \"L\" image, 128 greylevels\n    are allocated. For an \"RGB\" image, a 6x6x6 colour cube is used, together\n    with 20 greylevels.\n    To make sure that palettes work properly under Windows, you must call the\n    **palette** method upon certain events from Windows.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "Window",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "peekOfCode": "class Window(object):\n    \"\"\"Create a Window with the given title size.\"\"\"\n    def __init__(self, title=\"PIL\", width=None, height=None):\n        self.hwnd = Image.core.createwindow(\n            title, self.__dispatcher, width or 0, height or 0\n        )\n    def __dispatcher(self, action, *args):\n        return getattr(self, \"ui_handle_\" + action)(*args)\n    def ui_handle_clear(self, dc, x0, y0, x1, y1):\n        pass",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "ImageWindow",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "peekOfCode": "class ImageWindow(Window):\n    \"\"\"Create an image window which displays the given image.\"\"\"\n    def __init__(self, image, title=\"PIL\"):\n        if not isinstance(image, Dib):\n            image = Dib(image)\n        self.image = image\n        width, height = image.size\n        Window.__init__(self, title, width=width, height=height)\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        self.image.draw(dc, (x0, y0, x1, y1))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "ImtImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "peekOfCode": "class ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n    def _open(self):\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        if b\"\\n\" not in self.fp.read(100):\n            raise SyntaxError(\"not an IM file\")\n        self.fp.seek(0)\n        xsize = ysize = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\n#\n# --------------------------------------------------------------------\nfield = re.compile(br\"([a-z]*) ([^ \\r\\n]*)\")\n##\n# Image plugin for IM Tools images.\nclass ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "peekOfCode": "field = re.compile(br\"([a-z]*) ([^ \\r\\n]*)\")\n##\n# Image plugin for IM Tools images.\nclass ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n    def _open(self):\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        if b\"\\n\" not in self.fp.read(100):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.ImtImagePlugin",
        "documentation": {}
    },
    {
        "label": "IptcImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "class IptcImageFile(ImageFile.ImageFile):\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n    def getint(self, key):\n        return i(self.info[key])\n    def field(self):\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not len(s):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "def i(c):\n    return i32((PAD + c)[-4:])\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=\" \")\n    print()\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\nclass IptcImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "def dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=\" \")\n    print()\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\nclass IptcImageFile(ImageFile.ImageFile):\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "getiptcinfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "def getiptcinfo(im):\n    \"\"\"\n    Get IPTC information from TIFF, JPEG, or IPTC file.\n    :param im: An image containing IPTC data.\n    :returns: A dictionary containing IPTC information, or None if\n        no IPTC information block was found.\n    \"\"\"\n    from . import TiffImagePlugin, JpegImagePlugin\n    import io\n    data = None",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "__version__ = \"0.3\"\nCOMPRESSION = {1: \"raw\", 5: \"jpeg\"}\nPAD = o8(0) * 4\n#\n# Helpers\ndef i(c):\n    return i32((PAD + c)[-4:])\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=\" \")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "COMPRESSION = {1: \"raw\", 5: \"jpeg\"}\nPAD = o8(0) * 4\n#\n# Helpers\ndef i(c):\n    return i32((PAD + c)[-4:])\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=\" \")\n    print()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "PAD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "peekOfCode": "PAD = o8(0) * 4\n#\n# Helpers\ndef i(c):\n    return i32((PAD + c)[-4:])\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=\" \")\n    print()\n##",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "Jpeg2KImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "peekOfCode": "class Jpeg2KImageFile(ImageFile.ImageFile):\n    format = \"JPEG2000\"\n    format_description = \"JPEG 2000 (ISO 15444)\"\n    def _open(self):\n        sig = self.fp.read(4)\n        if sig == b\"\\xff\\x4f\\xff\\x51\":\n            self.codec = \"j2k\"\n            self._size, self.mode = _parse_codestream(self.fp)\n        else:\n            sig = sig + self.fp.read(8)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\ndef _parse_codestream(fp):\n    \"\"\"Parse the JPEG 2000 codestream to extract the size and component\n    count from the SIZ marker segment, returning a PIL (size, mode) tuple.\"\"\"\n    hdr = fp.read(2)\n    lsiz = struct.unpack(\">H\", hdr)[0]\n    siz = hdr + fp.read(lsiz - 2)\n    lsiz, rsiz, xsiz, ysiz, xosiz, yosiz, _, _, _, _, csiz = struct.unpack_from(\n        \">HHIIIIIIIIH\", siz\n    )",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.Jpeg2KImagePlugin",
        "documentation": {}
    },
    {
        "label": "JpegImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "class JpegImageFile(ImageFile.ImageFile):\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n    def _open(self):\n        s = self.fp.read(1)\n        if i8(s) != 255:\n            raise SyntaxError(\"not a JPEG file\")\n        # Create attributes\n        self.bits = self.layers = 0\n        # JPEG specifics (internal)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "Skip",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def Skip(self, marker):\n    n = i16(self.fp.read(2)) - 2\n    ImageFile._safe_read(self.fp, n)\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    app = \"APP%d\" % (marker & 15)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "APP",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    app = \"APP%d\" % (marker & 15)\n    self.app[app] = s  # compatibility\n    self.applist.append((app, s))\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "COM",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def COM(self, marker):\n    #\n    # Comment marker.  Store these in the APP dictionary.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self.app[\"COM\"] = s  # compatibility\n    self.applist.append((\"COM\", s))\ndef SOF(self, marker):\n    #\n    # Start of frame marker.  Defines the size and mode of the",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "SOF",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def SOF(self, marker):\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self._size = i16(s[3:]), i16(s[1:])",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "DQT",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def DQT(self, marker):\n    #\n    # Define quantization table.  Support baseline 8-bit tables\n    # only.  Note that there might be more than one table in\n    # each marker.\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "convert_dict_qtables",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def convert_dict_qtables(qtables):\n    qtables = [qtables[key] for key in range(len(qtables)) if key in qtables]\n    for idx, table in enumerate(qtables):\n        qtables[idx] = [table[i] for i in zigzag_index]\n    return qtables\ndef get_sampling(im):\n    # There's no subsampling when image have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to default value.\n    #",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "get_sampling",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def get_sampling(im):\n    # There's no subsampling when image have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to default value.\n    #\n    # NOTE: currently Pillow can't encode JPEG to YCCK format.\n    # If YCCK support is added in the future, subsampling code will have\n    # to be updated (here and in JpegEncode.c) to deal with 4 layers.\n    if not hasattr(im, \"layers\") or im.layers in (1, 4):\n        return -1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "jpeg_factory",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "def jpeg_factory(fp=None, filename=None):\n    im = JpegImageFile(fp, filename)\n    try:\n        mpheader = im._getmp()\n        if mpheader[45057] > 1:\n            # It's actually an MPO\n            from .MpoImagePlugin import MpoImageFile\n            # Don't reload everything, just convert it.\n            im = MpoImageFile.adopt(im, mpheader)\n    except (TypeError, IndexError):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "__version__ = \"0.6\"\n#\n# Parser\ndef Skip(self, marker):\n    n = i16(self.fp.read(2)) - 2\n    ImageFile._safe_read(self.fp, n)\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MARKER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "MARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "RAWMODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "RAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\",  # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n# fmt: off\nzigzag_index = (",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "zigzag_index",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "zigzag_index = (\n    0,  1,  5,  6, 14, 15, 27, 28,\n    2,  4,  7, 13, 16, 26, 29, 42,\n    3,  8, 12, 17, 25, 30, 41, 43,\n    9, 11, 18, 24, 31, 40, 44, 53,\n    10, 19, 23, 32, 39, 45, 52, 54,\n    20, 22, 33, 38, 46, 51, 55, 60,\n    21, 34, 37, 47, 50, 56, 59, 61,\n    35, 36, 48, 49, 57, 58, 62, 63,\n)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "samplings",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "peekOfCode": "samplings = {\n    (1, 1, 1, 1, 1, 1): 0,\n    (2, 1, 1, 1, 1, 1): 1,\n    (2, 2, 1, 1, 1, 1): 2,\n}\n# fmt: on\ndef convert_dict_qtables(qtables):\n    qtables = [qtables[key] for key in range(len(qtables)) if key in qtables]\n    for idx, table in enumerate(qtables):\n        qtables[idx] = [table[i] for i in zigzag_index]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "presets",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.JpegPresets",
        "description": "catboost.contrib.python.Pillow.py2.PIL.JpegPresets",
        "peekOfCode": "presets = {  # noqa: E128\n            'web_low':      {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [20, 16, 25, 39, 50, 46, 62, 68,\n                                16, 18, 23, 38, 38, 53, 65, 68,\n                                25, 23, 31, 38, 53, 65, 68, 68,\n                                39, 38, 38, 53, 65, 68, 68, 68,\n                                50, 38, 53, 65, 68, 68, 68, 68,\n                                46, 53, 65, 68, 68, 68, 68, 68,\n                                62, 65, 68, 68, 68, 68, 68, 68,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.JpegPresets",
        "documentation": {}
    },
    {
        "label": "McIdasImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "peekOfCode": "class McIdasImageFile(ImageFile.ImageFile):\n    format = \"MCIDAS\"\n    format_description = \"McIdas area file\"\n    def _open(self):\n        # parse area file directory\n        s = self.fp.read(256)\n        if not _accept(s) or len(s) != 256:\n            raise SyntaxError(\"not an McIdas area file\")\n        self.area_descriptor_raw = s\n        self.area_descriptor = w = [0] + list(struct.unpack(\"!64i\", s))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\ndef _accept(s):\n    return s[:8] == b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\"\n##\n# Image plugin for McIdas area images.\nclass McIdasImageFile(ImageFile.ImageFile):\n    format = \"MCIDAS\"\n    format_description = \"McIdas area file\"\n    def _open(self):\n        # parse area file directory",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.McIdasImagePlugin",
        "documentation": {}
    },
    {
        "label": "MicImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "peekOfCode": "class MicImageFile(TiffImagePlugin.TiffImageFile):\n    format = \"MIC\"\n    format_description = \"Microsoft Image Composer\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # read the OLE directory and see if this is a likely\n        # to be a Microsoft Image Composer file\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except IOError:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# --------------------------------------------------------------------\ndef _accept(prefix):\n    return prefix[:8] == olefile.MAGIC\n##\n# Image plugin for Microsoft's Image Composer file format.\nclass MicImageFile(TiffImagePlugin.TiffImageFile):\n    format = \"MIC\"\n    format_description = \"Microsoft Image Composer\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MicImagePlugin",
        "documentation": {}
    },
    {
        "label": "BitStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "peekOfCode": "class BitStream(object):\n    def __init__(self, fp):\n        self.fp = fp\n        self.bits = 0\n        self.bitbuffer = 0\n    def next(self):\n        return i8(self.fp.read(1))\n    def peek(self, bits):\n        while self.bits < bits:\n            c = self.next()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MpegImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "peekOfCode": "class MpegImageFile(ImageFile.ImageFile):\n    format = \"MPEG\"\n    format_description = \"MPEG\"\n    def _open(self):\n        s = BitStream(self.fp)\n        if s.read(32) != 0x1B3:\n            raise SyntaxError(\"not an MPEG file\")\n        self.mode = \"RGB\"\n        self._size = s.read(12), s.read(12)\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# Bitstream parser\nclass BitStream(object):\n    def __init__(self, fp):\n        self.fp = fp\n        self.bits = 0\n        self.bitbuffer = 0\n    def next(self):\n        return i8(self.fp.read(1))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MpoImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "peekOfCode": "class MpoImageFile(JpegImagePlugin.JpegImageFile):\n    format = \"MPO\"\n    format_description = \"MPO (CIPA DC-007)\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        self.fp.seek(0)  # prep the fp in order to pass the JPEG test\n        JpegImagePlugin.JpegImageFile._open(self)\n        self._after_jpeg_open()\n    def _after_jpeg_open(self, mpheader=None):\n        self.mpinfo = mpheader if mpheader is not None else self._getmp()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\ndef _accept(prefix):\n    return JpegImagePlugin._accept(prefix)\ndef _save(im, fp, filename):\n    # Note that we can only save the current frame at present\n    return JpegImagePlugin._save(im, fp, filename)\n##\n# Image plugin for MPO images.\nclass MpoImageFile(JpegImagePlugin.JpegImageFile):\n    format = \"MPO\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MpoImagePlugin",
        "documentation": {}
    },
    {
        "label": "MspImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "peekOfCode": "class MspImageFile(ImageFile.ImageFile):\n    format = \"MSP\"\n    format_description = \"Windows Paint\"\n    def _open(self):\n        # Header\n        s = self.fp.read(32)\n        if s[:4] not in [b\"DanM\", b\"LinS\"]:\n            raise SyntaxError(\"not an MSP file\")\n        # Header checksum\n        checksum = 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "documentation": {}
    },
    {
        "label": "MspDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "peekOfCode": "class MspDecoder(ImageFile.PyDecoder):\n    # The algo for the MSP decoder is from\n    # http://www.fileformat.info/format/mspaint/egff.htm\n    # cc-by-attribution -- That page references is taken from the\n    # Encyclopedia of Graphics File Formats and is licensed by\n    # O'Reilly under the Creative Common/Attribution license\n    #\n    # For RLE encoded files, the 32byte header is followed by a scan\n    # line map, encoded as one 16bit word of encoded byte length per\n    # line.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# read MSP files\ndef _accept(prefix):\n    return prefix[:4] in [b\"DanM\", b\"LinS\"]\n##\n# Image plugin for Windows MSP images.  This plugin supports both\n# uncompressed (Windows 1.0).\nclass MspImageFile(ImageFile.ImageFile):\n    format = \"MSP\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.MspImagePlugin",
        "documentation": {}
    },
    {
        "label": "PSDraw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "peekOfCode": "class PSDraw(object):\n    \"\"\"\n    Sets up printing to the given file. If **fp** is omitted,\n    :py:attr:`sys.stdout` is assumed.\n    \"\"\"\n    def __init__(self, fp=None):\n        if not fp:\n            fp = sys.stdout\n        self.fp = fp\n    def _fp_write(self, to_write):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "EDROFF_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "peekOfCode": "EDROFF_PS = \"\"\"\\\n/S { show } bind def\n/P { moveto show } bind def\n/M { moveto } bind def\n/X { 0 rmoveto } bind def\n/Y { 0 exch rmoveto } bind def\n/E {    findfont\n        dup maxlength dict begin\n        {\n                1 index /FID ne { def } { pop pop } ifelse",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "VDI_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "peekOfCode": "VDI_PS = \"\"\"\\\n/Vm { moveto } bind def\n/Va { newpath arcn stroke } bind def\n/Vl { moveto lineto stroke } bind def\n/Vc { newpath 0 360 arc closepath } bind def\n/Vr {   exch dup 0 rlineto\n        exch dup neg 0 exch rlineto\n        exch neg 0 rlineto\n        0 exch rlineto\n        100 div setgray fill 0 setgray } bind def",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "ERROR_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "peekOfCode": "ERROR_PS = \"\"\"\\\n/landscape false def\n/errorBUF 200 string def\n/errorNL { currentpoint 10 sub exch pop 72 exch moveto } def\nerrordict begin /handleerror {\n    initmatrix /Courier findfont 10 scalefont setfont\n    newpath 72 720 moveto $error begin /newerror false def\n    (PostScript Error) show errorNL errorNL\n    (Error: ) show\n        /errorname load errorBUF cvs show errorNL errorNL",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "PaletteFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PaletteFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PaletteFile",
        "peekOfCode": "class PaletteFile(object):\n    rawmode = \"RGB\"\n    def __init__(self, fp):\n        self.palette = [(i, i, i) for i in range(256)]\n        while True:\n            s = fp.readline()\n            if not s:\n                break\n            if s[0:1] == b\"#\":\n                continue",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PaletteFile",
        "documentation": {}
    },
    {
        "label": "build_prototype_image",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "def build_prototype_image():\n    image = Image.new(\"L\", (1, len(_Palm8BitColormapValues)))\n    image.putdata(list(range(len(_Palm8BitColormapValues))))\n    palettedata = ()\n    for colormapValue in _Palm8BitColormapValues:\n        palettedata += colormapValue\n    palettedata += (0, 0, 0) * (256 - len(_Palm8BitColormapValues))\n    image.putpalette(palettedata)\n    return image\nPalm8BitColormapImage = build_prototype_image()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "__version__ = \"1.0\"\n# fmt: off\n_Palm8BitColormapValues = (  # noqa: E131\n    (255, 255, 255), (255, 204, 255), (255, 153, 255), (255, 102, 255),\n    (255,  51, 255), (255,   0, 255), (255, 255, 204), (255, 204, 204),\n    (255, 153, 204), (255, 102, 204), (255,  51, 204), (255,   0, 204),\n    (255, 255, 153), (255, 204, 153), (255, 153, 153), (255, 102, 153),\n    (255,  51, 153), (255,   0, 153), (204, 255, 255), (204, 204, 255),\n    (204, 153, 255), (204, 102, 255), (204,  51, 255), (204,   0, 255),\n    (204, 255, 204), (204, 204, 204), (204, 153, 204), (204, 102, 204),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_Palm8BitColormapValues",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "_Palm8BitColormapValues = (  # noqa: E131\n    (255, 255, 255), (255, 204, 255), (255, 153, 255), (255, 102, 255),\n    (255,  51, 255), (255,   0, 255), (255, 255, 204), (255, 204, 204),\n    (255, 153, 204), (255, 102, 204), (255,  51, 204), (255,   0, 204),\n    (255, 255, 153), (255, 204, 153), (255, 153, 153), (255, 102, 153),\n    (255,  51, 153), (255,   0, 153), (204, 255, 255), (204, 204, 255),\n    (204, 153, 255), (204, 102, 255), (204,  51, 255), (204,   0, 255),\n    (204, 255, 204), (204, 204, 204), (204, 153, 204), (204, 102, 204),\n    (204,  51, 204), (204,   0, 204), (204, 255, 153), (204, 204, 153),\n    (204, 153, 153), (204, 102, 153), (204,  51, 153), (204,   0, 153),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "Palm8BitColormapImage",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "Palm8BitColormapImage = build_prototype_image()\n# OK, we now have in Palm8BitColormapImage,\n# a \"P\"-mode image with the right palette\n#\n# --------------------------------------------------------------------\n_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_FLAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##\n# (Internal) Image save plugin for the Palm format.\ndef _save(im, fp, filename):\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_COMPRESSION_TYPES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "peekOfCode": "_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##\n# (Internal) Image save plugin for the Palm format.\ndef _save(im, fp, filename):\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field\n        rawmode = \"P\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PcdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "peekOfCode": "class PcdImageFile(ImageFile.ImageFile):\n    format = \"PCD\"\n    format_description = \"Kodak PhotoCD\"\n    def _open(self):\n        # rough\n        self.fp.seek(2048)\n        s = self.fp.read(2048)\n        if s[:4] != b\"PCD_\":\n            raise SyntaxError(\"not a PCD file\")\n        orientation = i8(s[1538]) & 3",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n##\n# Image plugin for PhotoCD images.  This plugin only reads the 768x512\n# image from the file; higher resolutions are encoded in a proprietary\n# encoding.\nclass PcdImageFile(ImageFile.ImageFile):\n    format = \"PCD\"\n    format_description = \"Kodak PhotoCD\"\n    def _open(self):\n        # rough",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcdImagePlugin",
        "documentation": {}
    },
    {
        "label": "PcfFontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "class PcfFontFile(FontFile.FontFile):\n    name = \"name\"\n    def __init__(self, fp):\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            raise SyntaxError(\"not a PCF file\")\n        FontFile.FontFile.__init__(self)\n        count = l32(fp.read(4))\n        self.toc = {}\n        for i in range(count):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "sz",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "def sz(s, o):\n    return s[o : s.index(b\"\\0\", o)]\n##\n# Font file plugin for the X11 PCF format.\nclass PcfFontFile(FontFile.FontFile):\n    name = \"name\"\n    def __init__(self, fp):\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            raise SyntaxError(\"not a PCF file\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_MAGIC = 0x70636601  # \"\\x01fcp\"\nPCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_PROPERTIES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_ACCELERATORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_METRICS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BITMAPS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_INK_METRICS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BDF_ENCODINGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_SWIDTHS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s, o):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_GLYPH_NAMES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s, o):\n    return s[o : s.index(b\"\\0\", o)]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BDF_ACCELERATORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "PCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s, o):\n    return s[o : s.index(b\"\\0\", o)]\n##",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "BYTES_PER_ROW",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "peekOfCode": "BYTES_PER_ROW = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s, o):\n    return s[o : s.index(b\"\\0\", o)]\n##\n# Font file plugin for the X11 PCF format.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PcxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "peekOfCode": "class PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n    def _open(self):\n        # header\n        s = self.fp.read(128)\n        if not _accept(s):\n            raise SyntaxError(\"not a PCX file\")\n        # image\n        bbox = i16(s, 4), i16(s, 6), i16(s, 8) + 1, i16(s, 10) + 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# __version__ is deprecated and will be removed in a future version. Use\n# PIL.__version__ instead.\n__version__ = \"0.6\"\ndef _accept(prefix):\n    return i8(prefix[0]) == 10 and i8(prefix[1]) in [0, 2, 3, 5]\n##\n# Image plugin for Paintbrush images.\nclass PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "peekOfCode": "__version__ = \"0.6\"\ndef _accept(prefix):\n    return i8(prefix[0]) == 10 and i8(prefix[1]) in [0, 2, 3, 5]\n##\n# Image plugin for Paintbrush images.\nclass PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n    def _open(self):\n        # header",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "peekOfCode": "SAVE = {\n    # mode: (version, bits, planes, raw mode)\n    \"1\": (2, 1, 1, \"1\"),\n    \"L\": (5, 8, 1, \"L\"),\n    \"P\": (5, 8, 1, \"P\"),\n    \"RGB\": (5, 8, 3, \"RGB;L\"),\n}\ndef _save(im, fp, filename):\n    try:\n        version, bits, planes, rawmode = SAVE[im.mode]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfImagePlugin",
        "peekOfCode": "__version__ = \"0.5\"\n#\n# --------------------------------------------------------------------\n# object ids:\n#  1. catalogue\n#  2. pages\n#  3. image\n#  4. page\n#  5. page contents\ndef _save_all(im, fp, filename):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfImagePlugin",
        "documentation": {}
    },
    {
        "label": "PdfFormatError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"\n    pass\ndef check_format_condition(condition, error_message):\n    if not condition:\n        raise PdfFormatError(error_message)\nclass IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "IndirectReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):\n    def __str__(self):\n        return \"%s %s R\" % self\n    def __bytes__(self):\n        return self.__str__().encode(\"us-ascii\")\n    def __eq__(self, other):\n        return (\n            other.__class__ is self.__class__",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "IndirectObjectDef",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class IndirectObjectDef(IndirectReference):\n    def __str__(self):\n        return \"%s %s obj\" % self\nclass XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n    def __setitem__(self, key, value):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "XrefTable",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n    def __setitem__(self, key, value):\n        if self.reading_finished:\n            self.new_entries[key] = value\n        else:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfName",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfName:\n    def __init__(self, name):\n        if isinstance(name, PdfName):\n            self.name = name.name\n        elif isinstance(name, bytes):\n            self.name = name\n        else:\n            self.name = name.encode(\"us-ascii\")\n    def name_as_str(self):\n        return self.name.decode(\"us-ascii\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfArray",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfArray(list):\n    def __bytes__(self):\n        return b\"[ \" + b\" \".join(pdf_repr(x) for x in self) + b\" ]\"\n    __str__ = __bytes__\nclass PdfDict(UserDict):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            if hasattr(UserDict, \"__setattr__\"):\n                UserDict.__setattr__(self, key, value)\n            else:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfDict",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfDict(UserDict):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            if hasattr(UserDict, \"__setattr__\"):\n                UserDict.__setattr__(self, key, value)\n            else:\n                self.__dict__[key] = value\n        else:\n            self[key.encode(\"us-ascii\")] = value\n    def __getattr__(self, key):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfBinary",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfBinary:\n    def __init__(self, data):\n        self.data = data\n    if py3:  # Python 3.x\n        def __bytes__(self):\n            return make_bytes(\"<%s>\" % \"\".join(\"%02X\" % b for b in self.data))\n    else:  # Python 2.x\n        def __str__(self):\n            return \"<%s>\" % \"\".join(\"%02X\" % ord(b) for b in self.data)\nclass PdfStream:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfStream:\n    def __init__(self, dictionary, buf):\n        self.dictionary = dictionary\n        self.buf = buf\n    def decode(self):\n        try:\n            filter = self.dictionary.Filter\n        except AttributeError:\n            return self.buf\n        if filter == b\"FlateDecode\":",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfParser",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "class PdfParser:\n    \"\"\"Based on\n    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf\n    Supports PDF up to 1.4\n    \"\"\"\n    def __init__(self, filename=None, f=None, buf=None, start_offset=0, mode=\"rb\"):\n        if buf and f:\n            raise RuntimeError(\"specify buf or f or filename, but not both buf and f\")\n        self.filename = filename\n        self.buf = buf",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "encode_text",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "def encode_text(s):\n    return codecs.BOM_UTF16_BE + s.encode(\"utf_16_be\")\nPDFDocEncoding = {\n    0x16: u\"\\u0017\",\n    0x18: u\"\\u02D8\",\n    0x19: u\"\\u02C7\",\n    0x1A: u\"\\u02C6\",\n    0x1B: u\"\\u02D9\",\n    0x1C: u\"\\u02DD\",\n    0x1D: u\"\\u02DB\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "decode_text",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "def decode_text(b):\n    if b[: len(codecs.BOM_UTF16_BE)] == codecs.BOM_UTF16_BE:\n        return b[len(codecs.BOM_UTF16_BE) :].decode(\"utf_16_be\")\n    elif py3:  # Python 3.x\n        return \"\".join(PDFDocEncoding.get(byte, chr(byte)) for byte in b)\n    else:  # Python 2.x\n        return u\"\".join(PDFDocEncoding.get(ord(byte), byte) for byte in b)\nclass PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "check_format_condition",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "def check_format_condition(condition, error_message):\n    if not condition:\n        raise PdfFormatError(error_message)\nclass IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):\n    def __str__(self):\n        return \"%s %s R\" % self\n    def __bytes__(self):\n        return self.__str__().encode(\"us-ascii\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "pdf_repr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "def pdf_repr(x):\n    if x is True:\n        return b\"true\"\n    elif x is False:\n        return b\"false\"\n    elif x is None:\n        return b\"null\"\n    elif isinstance(x, (PdfName, PdfDict, PdfArray, PdfBinary)):\n        return bytes(x)\n    elif isinstance(x, int):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PDFDocEncoding",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "peekOfCode": "PDFDocEncoding = {\n    0x16: u\"\\u0017\",\n    0x18: u\"\\u02D8\",\n    0x19: u\"\\u02C7\",\n    0x1A: u\"\\u02C6\",\n    0x1B: u\"\\u02D9\",\n    0x1C: u\"\\u02DD\",\n    0x1D: u\"\\u02DB\",\n    0x1E: u\"\\u02DA\",\n    0x1F: u\"\\u02DC\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PixarImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "peekOfCode": "class PixarImageFile(ImageFile.ImageFile):\n    format = \"PIXAR\"\n    format_description = \"PIXAR raster image\"\n    def _open(self):\n        # assuming a 4-byte magic label\n        s = self.fp.read(4)\n        if s != b\"\\200\\350\\000\\000\":\n            raise SyntaxError(\"not a PIXAR file\")\n        # read rest of header\n        s = s + self.fp.read(508)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n#\n# helpers\ndef _accept(prefix):\n    return prefix[:4] == b\"\\200\\350\\000\\000\"\n##\n# Image plugin for PIXAR raster images.\nclass PixarImageFile(ImageFile.ImageFile):\n    format = \"PIXAR\"\n    format_description = \"PIXAR raster image\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PixarImagePlugin",
        "documentation": {}
    },
    {
        "label": "ChunkStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class ChunkStream(object):\n    def __init__(self, fp):\n        self.fp = fp\n        self.queue = []\n    def read(self):\n        \"\"\"Fetch a new chunk. Returns header information.\"\"\"\n        cid = None\n        if self.queue:\n            cid, pos, length = self.queue.pop()\n            self.fp.seek(pos)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "iTXt",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class iTXt(str):\n    \"\"\"\n    Subclass of string to allow iTXt chunks to look like strings while\n    keeping their extra information\n    \"\"\"\n    @staticmethod\n    def __new__(cls, text, lang=None, tkey=None):\n        \"\"\"\n        :param cls: the class to use when creating the instance\n        :param text: value for this key",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngInfo",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class PngInfo(object):\n    \"\"\"\n    PNG chunk container (for use with save(pnginfo=))\n    \"\"\"\n    def __init__(self):\n        self.chunks = []\n    def add(self, cid, data):\n        \"\"\"Appends an arbitrary chunk. Use with caution.\n        :param cid: a byte string, 4 bytes long.\n        :param data: a byte string of the encoded data",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class PngStream(ChunkStream):\n    def __init__(self, fp):\n        ChunkStream.__init__(self, fp)\n        # local copies of Image attributes\n        self.im_info = {}\n        self.im_text = {}\n        self.im_size = (0, 0)\n        self.im_mode = None\n        self.im_tile = None\n        self.im_palette = None",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class PngImageFile(ImageFile.ImageFile):\n    format = \"PNG\"\n    format_description = \"Portable network graphics\"\n    def _open(self):\n        if self.fp.read(8) != _MAGIC:\n            raise SyntaxError(\"not a PNG file\")\n        #\n        # Parse headers up to the first IDAT chunk\n        self.png = PngStream(self.fp)\n        while True:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_idat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "class _idat(object):\n    # wrap output from the encoder in IDAT chunks\n    def __init__(self, fp, chunk):\n        self.fp = fp\n        self.chunk = chunk\n    def write(self, data):\n        self.chunk(self.fp, b\"IDAT\", data)\ndef _save(im, fp, filename, chunk=putchunk):\n    # save an image to disk (called by the save method)\n    mode = im.mode",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "putchunk",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "def putchunk(fp, cid, *data):\n    \"\"\"Write a PNG chunk (including CRC field)\"\"\"\n    data = b\"\".join(data)\n    fp.write(o32(len(data)) + cid)\n    fp.write(data)\n    crc = _crc32(data, _crc32(cid))\n    fp.write(o32(crc))\nclass _idat(object):\n    # wrap output from the encoder in IDAT chunks\n    def __init__(self, fp, chunk):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "getchunks",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "def getchunks(im, **params):\n    \"\"\"Return a list of PNG chunks representing this image.\"\"\"\n    class collector(object):\n        data = []\n        def write(self, data):\n            pass\n        def append(self, chunk):\n            self.data.append(chunk)\n    def append(fp, cid, *data):\n        data = b\"\".join(data)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "__version__ = \"0.9\"\nlogger = logging.getLogger(__name__)\nis_cid = re.compile(br\"\\w\\w\\w\\w\").match\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Greyscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "logger = logging.getLogger(__name__)\nis_cid = re.compile(br\"\\w\\w\\w\\w\").match\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Greyscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "is_cid",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "is_cid = re.compile(br\"\\w\\w\\w\\w\").match\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Greyscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Greyscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),\n    # Truecolour",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Greyscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),\n    # Truecolour\n    (8, 2): (\"RGB\", \"RGB\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_simple_palette",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "_simple_palette = re.compile(b\"^\\xff*\\x00\\xff*$\")\n# Maximum decompressed size for a iTXt or zTXt chunk.\n# Eliminates decompression bombs where compressed chunks can expand 1000x\nMAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n# Set the maximum total text chunk size.\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\ndef _safe_zlib_decompress(s):\n    dobj = zlib.decompressobj()\n    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)\n    if dobj.unconsumed_tail:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAX_TEXT_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "MAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n# Set the maximum total text chunk size.\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\ndef _safe_zlib_decompress(s):\n    dobj = zlib.decompressobj()\n    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)\n    if dobj.unconsumed_tail:\n        raise ValueError(\"Decompressed Data Too Large\")\n    return plaintext\ndef _crc32(data, seed=0):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAX_TEXT_MEMORY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "MAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\ndef _safe_zlib_decompress(s):\n    dobj = zlib.decompressobj()\n    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)\n    if dobj.unconsumed_tail:\n        raise ValueError(\"Decompressed Data Too Large\")\n    return plaintext\ndef _crc32(data, seed=0):\n    return zlib.crc32(data, seed) & 0xFFFFFFFF\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_OUTMODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "peekOfCode": "_OUTMODES = {\n    # supported PIL modes, and corresponding rawmodes/bits/color combinations\n    \"1\": (\"1\", b\"\\x01\\x00\"),\n    \"L;1\": (\"L;1\", b\"\\x01\\x00\"),\n    \"L;2\": (\"L;2\", b\"\\x02\\x00\"),\n    \"L;4\": (\"L;4\", b\"\\x04\\x00\"),\n    \"L\": (\"L\", b\"\\x08\\x00\"),\n    \"LA\": (\"LA\", b\"\\x08\\x04\"),\n    \"I\": (\"I;16B\", b\"\\x10\\x00\"),\n    \"I;16\": (\"I;16B\", b\"\\x10\\x00\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PpmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "peekOfCode": "class PpmImageFile(ImageFile.ImageFile):\n    format = \"PPM\"\n    format_description = \"Pbmplus image\"\n    def _token(self, s=b\"\"):\n        while True:  # read until next whitespace\n            c = self.fp.read(1)\n            if not c or c in b_whitespace:\n                break\n            if c > b\"\\x79\":\n                raise ValueError(\"Expected ASCII value, found binary\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\n#\n# --------------------------------------------------------------------\nb_whitespace = b\"\\x20\\x09\\x0a\\x0b\\x0c\\x0d\"\nMODES = {\n    # standard\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "b_whitespace",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "peekOfCode": "b_whitespace = b\"\\x20\\x09\\x0a\\x0b\\x0c\\x0d\"\nMODES = {\n    # standard\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions\n    b\"P0CMYK\": \"CMYK\",\n    # PIL extensions (for test purposes only)\n    b\"PyP\": \"P\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "peekOfCode": "MODES = {\n    # standard\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions\n    b\"P0CMYK\": \"CMYK\",\n    # PIL extensions (for test purposes only)\n    b\"PyP\": \"P\",\n    b\"PyRGBA\": \"RGBA\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PsdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "peekOfCode": "class PsdImageFile(ImageFile.ImageFile):\n    format = \"PSD\"\n    format_description = \"Adobe Photoshop\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        read = self.fp.read\n        #\n        # header\n        s = read(26)\n        if s[:4] != b\"8BPS\" or i16(s[4:]) != 1:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "peekOfCode": "__version__ = \"0.4\"\nimport io\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i8, i16be as i16, i32be as i32\nMODES = {\n    # (photoshop mode, bits) -> (pil mode, required channels)\n    (0, 1): (\"1\", 1),\n    (0, 8): (\"L\", 1),\n    (1, 8): (\"L\", 1),\n    (2, 8): (\"P\", 1),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "peekOfCode": "MODES = {\n    # (photoshop mode, bits) -> (pil mode, required channels)\n    (0, 1): (\"1\", 1),\n    (0, 8): (\"L\", 1),\n    (1, 8): (\"L\", 1),\n    (2, 8): (\"P\", 1),\n    (3, 8): (\"RGB\", 3),\n    (4, 8): (\"CMYK\", 4),\n    (7, 8): (\"L\", 1),  # FIXME: multilayer\n    (8, 8): (\"L\", 1),  # duotone",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PsdImagePlugin",
        "documentation": {}
    },
    {
        "label": "PyAccess",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class PyAccess(object):\n    def __init__(self, img, readonly=False):\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size\n        # Keep pointer to im object to prevent dereferencing.\n        self._im = img.im",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_2",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_2(PyAccess):\n    \"\"\" PA, LA, stored in first and last bytes of a 32 bit word \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return (pixel.r, pixel.a)\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_3",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_3(PyAccess):\n    \"\"\" RGB and friends, stored in the first three bytes of a 32 bit word \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return (pixel.r, pixel.g, pixel.b)\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_4",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_4(PyAccess):\n    \"\"\" RGBA etc, all 4 bytes of a 32 bit word \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return (pixel.r, pixel.g, pixel.b, pixel.a)\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess8",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccess8(PyAccess):\n    \"\"\" 1, L, P, 8 bit images stored as uint8 \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image8\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 255)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_N",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_N(PyAccess):\n    \"\"\" I;16 access, native bitendian without conversion \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"unsigned short **\", self.image)\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 65535)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_L",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_L(PyAccess):\n    \"\"\" I;16L access, with conversion \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.l + pixel.r * 256\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_B",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_B(PyAccess):\n    \"\"\" I;16B access, with conversion \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.l * 256 + pixel.r\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI32_N",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI32_N(PyAccess):\n    \"\"\" Signed Int32 access, native endian \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = color\nclass _PyAccessI32_Swap(PyAccess):\n    \"\"\" I;32L/B access, with byteswapping conversion \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI32_Swap",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI32_Swap(PyAccess):\n    \"\"\" I;32L/B access, with byteswapping conversion \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n    def reverse(self, i):\n        orig = ffi.new(\"int *\", i)\n        chars = ffi.cast(\"unsigned char *\", orig)\n        chars[0], chars[1], chars[2], chars[3] = chars[3], chars[2], chars[1], chars[0]\n        return ffi.cast(\"int *\", chars)[0]\n    def get_pixel(self, x, y):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessF",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "class _PyAccessF(PyAccess):\n    \"\"\" 32 bit float access \"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"float **\", self.image32)\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # not a tuple\n            self.pixels[y][x] = color",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "def new(img, readonly=False):\n    access_type = mode_map.get(img.mode, None)\n    if not access_type:\n        logger.debug(\"PyAccess Not Implemented: %s\", img.mode)\n        return None\n    return access_type(img, readonly)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndefs = \"\"\"\nstruct Pixel_RGBA {\n    unsigned char r,g,b,a;\n};\nstruct Pixel_I16 {\n    unsigned char l,r;\n};\n\"\"\"\nffi = FFI()",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "defs",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "defs = \"\"\"\nstruct Pixel_RGBA {\n    unsigned char r,g,b,a;\n};\nstruct Pixel_I16 {\n    unsigned char l,r;\n};\n\"\"\"\nffi = FFI()\nffi.cdef(defs)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "ffi",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "ffi = FFI()\nffi.cdef(defs)\nclass PyAccess(object):\n    def __init__(self, img, readonly=False):\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "mode_map",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "peekOfCode": "mode_map = {\n    \"1\": _PyAccess8,\n    \"L\": _PyAccess8,\n    \"P\": _PyAccess8,\n    \"LA\": _PyAccess32_2,\n    \"La\": _PyAccess32_2,\n    \"PA\": _PyAccess32_2,\n    \"RGB\": _PyAccess32_3,\n    \"LAB\": _PyAccess32_3,\n    \"HSV\": _PyAccess32_3,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "SgiImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "peekOfCode": "class SgiImageFile(ImageFile.ImageFile):\n    format = \"SGI\"\n    format_description = \"SGI Image File Format\"\n    def _open(self):\n        # HEAD\n        headlen = 512\n        s = self.fp.read(headlen)\n        # magic number : 474\n        if i16(s) != 474:\n            raise ValueError(\"Not an SGI image file\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "SGI16Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "peekOfCode": "class SGI16Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        rawmode, stride, orientation = self.args\n        pagesize = self.state.xsize * self.state.ysize\n        zsize = len(self.mode)\n        self.fd.seek(512)\n        for band in range(zsize):\n            channel = Image.new(\"L\", (self.state.xsize, self.state.ysize))\n            channel.frombytes(",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "peekOfCode": "__version__ = \"0.3\"\ndef _accept(prefix):\n    return len(prefix) >= 2 and i16(prefix) == 474\nMODES = {\n    (1, 1, 1): \"L\",\n    (1, 2, 1): \"L\",\n    (2, 1, 1): \"L;16B\",\n    (2, 2, 1): \"L;16B\",\n    (1, 3, 3): \"RGB\",\n    (2, 3, 3): \"RGB;16B\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "peekOfCode": "MODES = {\n    (1, 1, 1): \"L\",\n    (1, 2, 1): \"L\",\n    (2, 1, 1): \"L;16B\",\n    (2, 2, 1): \"L;16B\",\n    (1, 3, 3): \"RGB\",\n    (2, 3, 3): \"RGB;16B\",\n    (1, 3, 4): \"RGBA\",\n    (2, 3, 4): \"RGBA;16B\",\n}",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "SpiderImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "class SpiderImageFile(ImageFile.ImageFile):\n    format = \"SPIDER\"\n    format_description = \"Spider 2D image\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # check header\n        n = 27 * 4  # read 27 float values\n        f = self.fp.read(n)\n        try:\n            self.bigendian = 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isInt",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "def isInt(f):\n    try:\n        i = int(f)\n        if f - i == 0:\n            return 1\n        else:\n            return 0\n    except (ValueError, OverflowError):\n        return 0\niforms = [1, 3, -11, -12, -21, -22]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isSpiderHeader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "def isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):\n            return 0\n    # check iform\n    iform = int(h[5])\n    if iform not in iforms:\n        return 0",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isSpiderImage",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "def isSpiderImage(filename):\n    with open(filename, \"rb\") as fp:\n        f = fp.read(92)  # read 23 * 4 bytes\n    t = struct.unpack(\">23f\", f)  # try big-endian first\n    hdrlen = isSpiderHeader(t)\n    if hdrlen == 0:\n        t = struct.unpack(\"<23f\", f)  # little-endian\n        hdrlen = isSpiderHeader(t)\n    return hdrlen\nclass SpiderImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "loadImageSeries",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "def loadImageSeries(filelist=None):\n    \"\"\"create a list of :py:class:`~PIL.Image.Image` objects for use in a montage\"\"\"\n    if filelist is None or len(filelist) < 1:\n        return\n    imglist = []\n    for img in filelist:\n        if not os.path.exists(img):\n            print(\"unable to find %s\" % img)\n            continue\n        try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "makeSpiderHeader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "def makeSpiderHeader(im):\n    nsam, nrow = im.size\n    lenbyt = nsam * 4  # There are labrec records in the header\n    labrec = int(1024 / lenbyt)\n    if 1024 % lenbyt != 0:\n        labrec += 1\n    labbyt = labrec * lenbyt\n    hdr = []\n    nvalues = int(labbyt / 4)\n    for i in range(nvalues):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "iforms",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "peekOfCode": "iforms = [1, 3, -11, -12, -21, -22]\n# There is no magic number to identify Spider files, so just check a\n# series of header locations to see if they have reasonable values.\n# Returns no. of bytes in the header, if it is a valid Spider header,\n# otherwise returns 0\ndef isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "SunImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "peekOfCode": "class SunImageFile(ImageFile.ImageFile):\n    format = \"SUN\"\n    format_description = \"Sun Raster File\"\n    def _open(self):\n        # The Sun Raster file header is 32 bytes in length\n        # and has the following format:\n        #     typedef struct _SunRaster\n        #     {\n        #         DWORD MagicNumber;      /* Magic (identification) number */\n        #         DWORD Width;            /* Width of image in pixels */",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "peekOfCode": "__version__ = \"0.3\"\ndef _accept(prefix):\n    return len(prefix) >= 4 and i32(prefix) == 0x59A66A95\n##\n# Image plugin for Sun raster files.\nclass SunImageFile(ImageFile.ImageFile):\n    format = \"SUN\"\n    format_description = \"Sun Raster File\"\n    def _open(self):\n        # The Sun Raster file header is 32 bytes in length",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.SunImagePlugin",
        "documentation": {}
    },
    {
        "label": "TarIO",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TarIO",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TarIO",
        "peekOfCode": "class TarIO(ContainerIO.ContainerIO):\n    def __init__(self, tarfile, file):\n        \"\"\"\n        Create file object.\n        :param tarfile: Name of TAR file.\n        :param file: Name of member file.\n        \"\"\"\n        self.fh = open(tarfile, \"rb\")\n        while True:\n            s = self.fh.read(512)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TarIO",
        "documentation": {}
    },
    {
        "label": "TgaImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "peekOfCode": "class TgaImageFile(ImageFile.ImageFile):\n    format = \"TGA\"\n    format_description = \"Targa\"\n    def _open(self):\n        # process header\n        s = self.fp.read(18)\n        id_len = i8(s[0])\n        colormaptype = i8(s[1])\n        imagetype = i8(s[2])\n        depth = i8(s[16])",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "peekOfCode": "__version__ = \"0.3\"\n#\n# --------------------------------------------------------------------\n# Read RGA file\nMODES = {\n    # map imagetype/depth to rawmode\n    (1, 8): \"P\",\n    (3, 1): \"1\",\n    (3, 8): \"L\",\n    (3, 16): \"LA\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "peekOfCode": "MODES = {\n    # map imagetype/depth to rawmode\n    (1, 8): \"P\",\n    (3, 1): \"1\",\n    (3, 8): \"L\",\n    (3, 16): \"LA\",\n    (2, 16): \"BGR;5\",\n    (2, 24): \"BGR\",\n    (2, 32): \"BGRA\",\n}",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "peekOfCode": "SAVE = {\n    \"1\": (\"1\", 1, 0, 3),\n    \"L\": (\"L\", 8, 0, 3),\n    \"LA\": (\"LA\", 16, 0, 3),\n    \"P\": (\"P\", 8, 1, 1),\n    \"RGB\": (\"BGR\", 24, 0, 2),\n    \"RGBA\": (\"BGRA\", 32, 0, 2),\n}\ndef _save(im, fp, filename):\n    try:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "IFDRational",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "class IFDRational(Rational):\n    \"\"\" Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")\n    def __init__(self, value, denominator=1):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "class ImageFileDirectory_v2(MutableMapping):\n    \"\"\"This class represents a TIFF tag directory.  To speed things up, we\n    don't decode tags unless they're asked for.\n    Exposes a dictionary interface of the tags in the directory::\n        ifd = ImageFileDirectory_v2()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        'Some Data'\n    Individual values are returned as the strings or numbers, sequences are",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v1",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "class ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n    Exposes a dictionary interface of the tags in the directory::\n        ifd = ImageFileDirectory_v1()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        ('Some Data',)\n    Also contains a dictionary of tag types as read from the tiff image file,\n    `~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TiffImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "class TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        \"\"\"Open the first image in a TIFF file\"\"\"\n        # Header\n        ifh = self.fp.read(8)\n        # image file directory (tag dictionary)\n        self.tag_v2 = ImageFileDirectory_v2(ifh)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "AppendingTiffWriter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "class AppendingTiffWriter:\n    fieldSizes = [\n        0,  # None\n        1,  # byte\n        1,  # ascii\n        2,  # short\n        4,  # long\n        8,  # rational\n        1,  # sbyte\n        1,  # undefined",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "__version__ = \"1.3.5\"\nDEBUG = False  # Needs to be merged with the new logging approach.\n# Set these to true to force use of libtiff for reading or writing.\nREAD_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "DEBUG = False  # Needs to be merged with the new logging approach.\n# Set these to true to force use of libtiff for reading or writing.\nREAD_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "READ_LIBTIFF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "READ_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "WRITE_LIBTIFF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "WRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IFD_LEGACY_API",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IFD_LEGACY_API = True\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "II",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "II = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "MM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "MM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEWIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGELENGTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "BITSPERSAMPLE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "BITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PHOTOMETRIC_INTERPRETATION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "PHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "FILLORDER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "FILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEDESCRIPTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "STRIPOFFSETS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "STRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAMPLESPERPIXEL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "SAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ROWSPERSTRIP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "STRIPBYTECOUNTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "STRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "X_RESOLUTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "X_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "Y_RESOLUTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "Y_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PLANAR_CONFIGURATION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "PLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "RESOLUTION_UNIT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "RESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TRANSFERFUNCTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "TRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SOFTWARE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "SOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "DATE_TIME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "DATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ARTIST",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PREDICTOR",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "PREDICTOR = 317\nCOLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COLORMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "COLORMAP = 320\nTILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TILEOFFSETS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "TILEOFFSETS = 324\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "EXTRASAMPLES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "EXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAMPLEFORMAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "SAMPLEFORMAT = 339\nJPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "JPEGTABLES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "JPEGTABLES = 347\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "REFERENCEBLACKWHITE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "REFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COPYRIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "COPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IPTC_NAA_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PHOTOSHOP_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "PHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ICCPROFILE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "EXIFIFD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "EXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "XMP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "XMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "JPEGQUALITY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "JPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEJ_META_DATA_BYTE_COUNTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEJ_META_DATA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",\n    8: \"tiff_adobe_deflate\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION_INFO_REV",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION_INFO_REV = {v: k for k, v in COMPRESSION_INFO.items()}\nOPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "OPEN_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "OPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (II, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PREFIXES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "PREFIXES = [\n    b\"MM\\x00\\x2A\",  # Valid TIFF header with big-endian byte order\n    b\"II\\x2A\\x00\",  # Valid TIFF header with little-endian byte order\n    b\"MM\\x2A\\x00\",  # Invalid TIFF header, assume big-endian\n    b\"II\\x00\\x2A\",  # Invalid TIFF header, assume little-endian\n]\ndef _accept(prefix):\n    return prefix[:4] in PREFIXES\ndef _limit_rational(val, max_val):\n    inv = abs(val) > 1",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "_load_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "_load_dispatch = {}\n_write_dispatch = {}\nclass IFDRational(Rational):\n    \"\"\" Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "_write_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "_write_dispatch = {}\nclass IFDRational(Rational):\n    \"\"\" Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2._load_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory_v2._load_dispatch = _load_dispatch\nImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, \"load_\" + name, _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, \"write_\" + name, _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2._write_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, \"load_\" + name, _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, \"write_\" + name, _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n    Exposes a dictionary interface of the tags in the directory::",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory = ImageFileDirectory_v1\n##\n# Image plugin for TIFF files.\nclass TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        \"\"\"Open the first image in a TIFF file\"\"\"\n        # Header",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "peekOfCode": "SAVE_INFO = {\n    # mode => rawmode, byteorder, photometrics,\n    #           sampleformat, bitspersample, extra\n    \"1\": (\"1\", II, 1, 1, (1,), None),\n    \"L\": (\"L\", II, 1, 1, (8,), None),\n    \"LA\": (\"LA\", II, 1, 1, (8, 8), 2),\n    \"P\": (\"P\", II, 3, 1, (8,), None),\n    \"PA\": (\"PA\", II, 3, 1, (8, 8), 2),\n    \"I\": (\"I;32S\", II, 1, 2, (32,), None),\n    \"I;16\": (\"I;16\", II, 1, 1, (16,), None),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TagInfo",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "class TagInfo(namedtuple(\"_TagInfo\", \"value name type length enum\")):\n    __slots__ = []\n    def __new__(cls, value=None, name=\"unknown\", type=None, length=None, enum=None):\n        return super(TagInfo, cls).__new__(cls, value, name, type, length, enum or {})\n    def cvt_enum(self, value):\n        # Using get will call hash(value), which can be expensive\n        # for some types (e.g. Fraction). Since self.enum is rarely\n        # used, it's usually better to test it first.\n        return self.enum.get(value, value) if self.enum else value\ndef lookup(tag):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "def lookup(tag):\n    \"\"\"\n    :param tag: Integer tag number\n    :returns: Taginfo namedtuple, From the TAGS_V2 info if possible,\n        otherwise just populating the value and name from TAGS.\n        If the tag is not recognized, \"unknown\" is returned for the name\n    \"\"\"\n    return TAGS_V2.get(tag, TagInfo(tag, TAGS.get(tag, \"unknown\")))\n##\n# Map tag numbers to tag info.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "BYTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "BYTE = 1\nASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "ASCII",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "ASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SHORT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "SHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "LONG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "LONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "RATIONAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "RATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_BYTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "SIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "UNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_SHORT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "SIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_LONG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "SIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_RATIONAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "SIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "FLOAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "FLOAT = 11\nDOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "DOUBLE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "DOUBLE = 12\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TAGS_V2",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "TAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,\n        1,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "TAGS = {\n    347: \"JPEGTables\",\n    700: \"XMP\",\n    # Additional Exif Info\n    32932: \"Wang Annotation\",\n    33434: \"ExposureTime\",\n    33437: \"FNumber\",\n    33445: \"MD FileTag\",\n    33446: \"MD ScalePixel\",\n    33447: \"MD ColorTable\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TYPES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "TYPES = {}\n# was:\n# TYPES = {\n#     1: \"byte\",\n#     2: \"ascii\",\n#     3: \"short\",\n#     4: \"long\",\n#     5: \"rational\",\n#     6: \"signed byte\",\n#     7: \"undefined\",",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "LIBTIFF_CORE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "peekOfCode": "LIBTIFF_CORE = {\n    255,\n    256,\n    257,\n    258,\n    259,\n    262,\n    263,\n    266,\n    274,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "peekOfCode": "def open(filename):\n    \"\"\"\n    Load texture from a Quake2 WAL texture file.\n    By default, a Quake2 standard palette is attached to the texture.\n    To override the palette, use the <b>putpalette</b> method.\n    :param filename: WAL file name, or an opened file handle.\n    :returns: An image instance.\n    \"\"\"\n    # FIXME: modify to return a WalImageFile instance instead of\n    # plain Image object ?",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "documentation": {}
    },
    {
        "label": "quake2palette",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "peekOfCode": "quake2palette = (\n    # default palette taken from piffo 0.93 by Hans Häggström\n    b\"\\x01\\x01\\x01\\x0b\\x0b\\x0b\\x12\\x12\\x12\\x17\\x17\\x17\\x1b\\x1b\\x1b\\x1e\"\n    b\"\\x1e\\x1e\\x22\\x22\\x22\\x26\\x26\\x26\\x29\\x29\\x29\\x2c\\x2c\\x2c\\x2f\\x2f\"\n    b\"\\x2f\\x32\\x32\\x32\\x35\\x35\\x35\\x37\\x37\\x37\\x3a\\x3a\\x3a\\x3c\\x3c\\x3c\"\n    b\"\\x24\\x1e\\x13\\x22\\x1c\\x12\\x20\\x1b\\x12\\x1f\\x1a\\x10\\x1d\\x19\\x10\\x1b\"\n    b\"\\x17\\x0f\\x1a\\x16\\x0f\\x18\\x14\\x0d\\x17\\x13\\x0d\\x16\\x12\\x0d\\x14\\x10\"\n    b\"\\x0b\\x13\\x0f\\x0b\\x10\\x0d\\x0a\\x0f\\x0b\\x0a\\x0d\\x0b\\x07\\x0b\\x0a\\x07\"\n    b\"\\x23\\x23\\x26\\x22\\x22\\x25\\x22\\x20\\x23\\x21\\x1f\\x22\\x20\\x1e\\x20\\x1f\"\n    b\"\\x1d\\x1e\\x1d\\x1b\\x1c\\x1b\\x1a\\x1a\\x1a\\x19\\x19\\x18\\x17\\x17\\x17\\x16\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WalImageFile",
        "documentation": {}
    },
    {
        "label": "WebPImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "peekOfCode": "class WebPImageFile(ImageFile.ImageFile):\n    format = \"WEBP\"\n    format_description = \"WebP image\"\n    def _open(self):\n        if not _webp.HAVE_WEBPANIM:\n            # Legacy mode\n            data, width, height, self.mode, icc_profile, exif = _webp.WebPDecode(\n                self.fp.read()\n            )\n            if icc_profile:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VALID_WEBP_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "peekOfCode": "_VALID_WEBP_MODES = {\"RGBX\": True, \"RGBA\": True, \"RGB\": True}\n_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VALID_WEBP_LEGACY_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "peekOfCode": "_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VP8_MODES_BY_IDENTIFIER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "peekOfCode": "_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER\n    if is_riff_file_format and is_webp_file and is_valid_vp8_mode:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "WmfStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "peekOfCode": "class WmfStubImageFile(ImageFile.StubImageFile):\n    format = \"WMF\"\n    format_description = \"Windows Metafile\"\n    def _open(self):\n        # check placable header\n        s = self.fp.read(80)\n        if s[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\":\n            # placeable windows metafile\n            # get units per inch\n            inch = word(s, 14)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific WMF image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\nif hasattr(Image.core, \"drawwmf\"):\n    # install default handler (windows only)\n    class WmfHandler(object):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\n_handler = None\nif py3:\n    long = int\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific WMF image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "peekOfCode": "_handler = None\nif py3:\n    long = int\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific WMF image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "XVThumbImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "peekOfCode": "class XVThumbImageFile(ImageFile.ImageFile):\n    format = \"XVThumb\"\n    format_description = \"XV thumbnail image\"\n    def _open(self):\n        # check magic\n        if not _accept(self.fp.read(6)):\n            raise SyntaxError(\"not an XV thumbnail file\")\n        # Skip to beginning of next line\n        self.fp.readline()\n        # skip info comments",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "peekOfCode": "__version__ = \"0.1\"\n_MAGIC = b\"P7 332\"\n# standard color palette for thumbnails (RGB332)\nPALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "peekOfCode": "_MAGIC = b\"P7 332\"\n# standard color palette for thumbnails (RGB332)\nPALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "PALETTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "peekOfCode": "PALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\ndef _accept(prefix):\n    return prefix[:6] == _MAGIC\n##",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "XbmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "peekOfCode": "class XbmImageFile(ImageFile.ImageFile):\n    format = \"XBM\"\n    format_description = \"X11 Bitmap\"\n    def _open(self):\n        m = xbm_head.match(self.fp.read(512))\n        if m:\n            xsize = int(m.group(\"width\"))\n            ysize = int(m.group(\"height\"))\n            if m.group(\"hotspot\"):\n                self.info[\"hotspot\"] = (int(m.group(\"xhot\")), int(m.group(\"yhot\")))",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "peekOfCode": "__version__ = \"0.6\"\n# XBM header\nxbm_head = re.compile(\n    br\"\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+.*_height[ \\t]+(?P<height>[0-9]+)[\\r\\n]+\"\n    b\"(?P<hotspot>\"\n    b\"#define[ \\t]+[^_]*_x_hot[ \\t]+(?P<xhot>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+[^_]*_y_hot[ \\t]+(?P<yhot>[0-9]+)[\\r\\n]+\"\n    b\")?\"\n    b\"[\\\\000-\\\\377]*_bits\\\\[\\\\]\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "documentation": {}
    },
    {
        "label": "xbm_head",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "peekOfCode": "xbm_head = re.compile(\n    br\"\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+.*_height[ \\t]+(?P<height>[0-9]+)[\\r\\n]+\"\n    b\"(?P<hotspot>\"\n    b\"#define[ \\t]+[^_]*_x_hot[ \\t]+(?P<xhot>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+[^_]*_y_hot[ \\t]+(?P<yhot>[0-9]+)[\\r\\n]+\"\n    b\")?\"\n    b\"[\\\\000-\\\\377]*_bits\\\\[\\\\]\"\n)\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XbmImagePlugin",
        "documentation": {}
    },
    {
        "label": "XpmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "peekOfCode": "class XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n    def _open(self):\n        if not _accept(self.fp.read(9)):\n            raise SyntaxError(\"not an XPM file\")\n        # skip forward to next string\n        while True:\n            s = self.fp.readline()\n            if not s:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "peekOfCode": "__version__ = \"0.2\"\n# XPM header\nxpm_head = re.compile(b'\"([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)')\ndef _accept(prefix):\n    return prefix[:9] == b\"/* XPM */\"\n##\n# Image plugin for X11 pixel maps.\nclass XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "xpm_head",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "peekOfCode": "xpm_head = re.compile(b'\"([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)')\ndef _accept(prefix):\n    return prefix[:9] == b\"/* XPM */\"\n##\n# Image plugin for X11 pixel maps.\nclass XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n    def _open(self):\n        if not _accept(self.fp.read(9)):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.XpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "i16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def i16le(c, o=0):\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<H\", c, o)[0]\ndef si16le(c, o=0):\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "si16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def si16le(c, o=0):\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<h\", c, o)[0]\ndef i32le(c, o=0):\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def i32le(c, o=0):\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<I\", c, o)[0]\ndef si32le(c, o=0):\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "si32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def si32le(c, o=0):\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<i\", c, o)[0]\ndef i16be(c, o=0):\n    return unpack_from(\">H\", c, o)[0]\ndef i32be(c, o=0):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i16be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def i16be(c, o=0):\n    return unpack_from(\">H\", c, o)[0]\ndef i32be(c, o=0):\n    return unpack_from(\">I\", c, o)[0]\n# Output, le = little endian, be = big endian\ndef o16le(i):\n    return pack(\"<H\", i)\ndef o32le(i):\n    return pack(\"<I\", i)\ndef o16be(i):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i32be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def i32be(c, o=0):\n    return unpack_from(\">I\", c, o)[0]\n# Output, le = little endian, be = big endian\ndef o16le(i):\n    return pack(\"<H\", i)\ndef o32le(i):\n    return pack(\"<I\", i)\ndef o16be(i):\n    return pack(\">H\", i)\ndef o32be(i):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def o16le(i):\n    return pack(\"<H\", i)\ndef o32le(i):\n    return pack(\"<I\", i)\ndef o16be(i):\n    return pack(\">H\", i)\ndef o32be(i):\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def o32le(i):\n    return pack(\"<I\", i)\ndef o16be(i):\n    return pack(\">H\", i)\ndef o32be(i):\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o16be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def o16be(i):\n    return pack(\">H\", i)\ndef o32be(i):\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o32be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "peekOfCode": "def o32be(i):\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._binary",
        "documentation": {}
    },
    {
        "label": "deferred_error",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._util",
        "description": "catboost.contrib.python.Pillow.py2.PIL._util",
        "peekOfCode": "class deferred_error(object):\n    def __init__(self, ex):\n        self.ex = ex\n    def __getattr__(self, elt):\n        raise self.ex",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._util",
        "documentation": {}
    },
    {
        "label": "isDirectory",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._util",
        "description": "catboost.contrib.python.Pillow.py2.PIL._util",
        "peekOfCode": "def isDirectory(f):\n    return isPath(f) and os.path.isdir(f)\nclass deferred_error(object):\n    def __init__(self, ex):\n        self.ex = ex\n    def __getattr__(self, elt):\n        raise self.ex",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._util",
        "documentation": {}
    },
    {
        "label": "py3",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._util",
        "description": "catboost.contrib.python.Pillow.py2.PIL._util",
        "peekOfCode": "py3 = sys.version_info.major >= 3\npy36 = sys.version_info[0:2] >= (3, 6)\nif py3:\n    def isStringType(t):\n        return isinstance(t, str)\n    if py36:\n        from pathlib import Path\n        def isPath(f):\n            return isinstance(f, (bytes, str, Path))\n    else:",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._util",
        "documentation": {}
    },
    {
        "label": "py36",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._util",
        "description": "catboost.contrib.python.Pillow.py2.PIL._util",
        "peekOfCode": "py36 = sys.version_info[0:2] >= (3, 6)\nif py3:\n    def isStringType(t):\n        return isinstance(t, str)\n    if py36:\n        from pathlib import Path\n        def isPath(f):\n            return isinstance(f, (bytes, str, Path))\n    else:\n        def isPath(f):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._util",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL._version",
        "description": "catboost.contrib.python.Pillow.py2.PIL._version",
        "peekOfCode": "__version__ = \"6.2.2\"",
        "detail": "catboost.contrib.python.Pillow.py2.PIL._version",
        "documentation": {}
    },
    {
        "label": "check_module",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def check_module(feature):\n    if not (feature in modules):\n        raise ValueError(\"Unknown module %s\" % feature)\n    module = modules[feature]\n    try:\n        __import__(module)\n        return True\n    except ImportError:\n        return False\ndef get_supported_modules():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_modules",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def get_supported_modules():\n    return [f for f in modules if check_module(f)]\ncodecs = {\"jpg\": \"jpeg\", \"jpg_2000\": \"jpeg2k\", \"zlib\": \"zip\", \"libtiff\": \"libtiff\"}\ndef check_codec(feature):\n    if feature not in codecs:\n        raise ValueError(\"Unknown codec %s\" % feature)\n    codec = codecs[feature]\n    return codec + \"_encoder\" in dir(Image.core)\ndef get_supported_codecs():\n    return [f for f in codecs if check_codec(f)]",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "check_codec",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def check_codec(feature):\n    if feature not in codecs:\n        raise ValueError(\"Unknown codec %s\" % feature)\n    codec = codecs[feature]\n    return codec + \"_encoder\" in dir(Image.core)\ndef get_supported_codecs():\n    return [f for f in codecs if check_codec(f)]\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\"),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_codecs",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def get_supported_codecs():\n    return [f for f in codecs if check_codec(f)]\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\"),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\"),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\"),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\"),\n    \"libjpeg_turbo\": (\"PIL._imaging\", \"HAVE_LIBJPEGTURBO\"),\n}\ndef check_feature(feature):",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "check_feature",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def check_feature(feature):\n    if feature not in features:\n        raise ValueError(\"Unknown feature %s\" % feature)\n    module, flag = features[feature]\n    try:\n        imported_module = __import__(module, fromlist=[\"PIL\"])\n        return getattr(imported_module, flag)\n    except ImportError:\n        return None\ndef get_supported_features():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_features",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def get_supported_features():\n    return [f for f in features if check_feature(f)]\ndef check(feature):\n    return (\n        feature in modules\n        and check_module(feature)\n        or feature in codecs\n        and check_codec(feature)\n        or feature in features\n        and check_feature(feature)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def check(feature):\n    return (\n        feature in modules\n        and check_module(feature)\n        or feature in codecs\n        and check_codec(feature)\n        or feature in features\n        and check_feature(feature)\n    )\ndef get_supported():",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def get_supported():\n    ret = get_supported_modules()\n    ret.extend(get_supported_features())\n    ret.extend(get_supported_codecs())\n    return ret\ndef pilinfo(out=None):\n    if out is None:\n        out = sys.stdout\n    Image.init()\n    print(\"-\" * 68, file=out)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "pilinfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "def pilinfo(out=None):\n    if out is None:\n        out = sys.stdout\n    Image.init()\n    print(\"-\" * 68, file=out)\n    print(\"Pillow {}\".format(PIL.__version__), file=out)\n    print(\"-\" * 68, file=out)\n    print(\n        \"Python modules loaded from {}\".format(os.path.dirname(Image.__file__)),\n        file=out,",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "modules",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "modules = {\n    \"pil\": \"PIL._imaging\",\n    \"tkinter\": \"PIL._tkinter_finder\",\n    \"freetype2\": \"PIL._imagingft\",\n    \"littlecms2\": \"PIL._imagingcms\",\n    \"webp\": \"PIL._webp\",\n}\ndef check_module(feature):\n    if not (feature in modules):\n        raise ValueError(\"Unknown module %s\" % feature)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "codecs = {\"jpg\": \"jpeg\", \"jpg_2000\": \"jpeg2k\", \"zlib\": \"zip\", \"libtiff\": \"libtiff\"}\ndef check_codec(feature):\n    if feature not in codecs:\n        raise ValueError(\"Unknown codec %s\" % feature)\n    codec = codecs[feature]\n    return codec + \"_encoder\" in dir(Image.core)\ndef get_supported_codecs():\n    return [f for f in codecs if check_codec(f)]\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\"),",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "features",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py2.PIL.features",
        "description": "catboost.contrib.python.Pillow.py2.PIL.features",
        "peekOfCode": "features = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\"),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\"),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\"),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\"),\n    \"libjpeg_turbo\": (\"PIL._imaging\", \"HAVE_LIBJPEGTURBO\"),\n}\ndef check_feature(feature):\n    if feature not in features:\n        raise ValueError(\"Unknown feature %s\" % feature)",
        "detail": "catboost.contrib.python.Pillow.py2.PIL.features",
        "documentation": {}
    },
    {
        "label": "BdfFontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "peekOfCode": "class BdfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 BDF format.\"\"\"\n    def __init__(self, fp: BinaryIO):\n        super().__init__()\n        s = fp.readline()\n        if s[:13] != b\"STARTFONT 2.1\":\n            msg = \"not a valid BDF file\"\n            raise SyntaxError(msg)\n        props = {}\n        comments = []",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_char",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "peekOfCode": "def bdf_char(\n    f: BinaryIO,\n) -> (\n    tuple[\n        str,\n        int,\n        tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]],\n        Image.Image,\n    ]\n    | None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_slant",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "peekOfCode": "bdf_slant = {\n    \"R\": \"Roman\",\n    \"I\": \"Italic\",\n    \"O\": \"Oblique\",\n    \"RI\": \"Reverse Italic\",\n    \"RO\": \"Reverse Oblique\",\n    \"OT\": \"Other\",\n}\nbdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\ndef bdf_char(",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "bdf_spacing",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "peekOfCode": "bdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\ndef bdf_char(\n    f: BinaryIO,\n) -> (\n    tuple[\n        str,\n        int,\n        tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]],\n        Image.Image,\n    ]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BdfFontFile",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class Format(IntEnum):\n    JPEG = 0\nclass Encoding(IntEnum):\n    UNCOMPRESSED = 1\n    DXT = 2\n    UNCOMPRESSED_RAW_BGRA = 3\nclass AlphaEncoding(IntEnum):\n    DXT1 = 0\n    DXT3 = 1\n    DXT5 = 7",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "Encoding",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class Encoding(IntEnum):\n    UNCOMPRESSED = 1\n    DXT = 2\n    UNCOMPRESSED_RAW_BGRA = 3\nclass AlphaEncoding(IntEnum):\n    DXT1 = 0\n    DXT3 = 1\n    DXT5 = 7\ndef unpack_565(i):\n    return ((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "AlphaEncoding",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class AlphaEncoding(IntEnum):\n    DXT1 = 0\n    DXT3 = 1\n    DXT5 = 7\ndef unpack_565(i):\n    return ((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLPFormatError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class BLPFormatError(NotImplementedError):\n    pass\ndef _accept(prefix):\n    return prefix[:4] in (b\"BLP1\", b\"BLP2\")\nclass BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BlpImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"\n    def _open(self):\n        self.magic = self.fp.read(4)\n        self.fp.seek(5, os.SEEK_CUR)\n        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "_BLPBaseDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class _BLPBaseDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        try:\n            self._read_blp_header()\n            self._load()\n        except struct.error as e:\n            msg = \"Truncated BLP file\"\n            raise OSError(msg) from e\n        return -1, 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP1Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class BLP1Decoder(_BLPBaseDecoder):\n    def _load(self):\n        if self._blp_compression == Format.JPEG:\n            self._decode_jpeg_stream()\n        elif self._blp_compression == 1:\n            if self._blp_encoding in (4, 5):\n                palette = self._read_palette()\n                data = self._read_bgra(palette)\n                self.set_as_raw(bytes(data))\n            else:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLP2Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class BLP2Decoder(_BLPBaseDecoder):\n    def _load(self):\n        palette = self._read_palette()\n        self.fd.seek(self._blp_offsets[0])\n        if self._blp_compression == 1:\n            # Uncompressed or DirectX compression\n            if self._blp_encoding == Encoding.UNCOMPRESSED:\n                data = self._read_bgra(palette)\n            elif self._blp_encoding == Encoding.DXT:\n                data = bytearray()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BLPEncoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "class BLPEncoder(ImageFile.PyEncoder):\n    _pushes_fd = True\n    def _write_palette(self):\n        data = b\"\"\n        palette = self.im.getpalette(\"RGBA\", \"RGBA\")\n        for i in range(len(palette) // 4):\n            r, g, b, a = palette[i * 4 : (i + 1) * 4]\n            data += struct.pack(\"<4B\", b, g, r, a)\n        while len(data) < 256 * 4:\n            data += b\"\\x00\" * 4",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "unpack_565",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "def unpack_565(i):\n    return ((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3\ndef decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        # Decode next 8-byte block.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt1",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt1(data, alpha=False):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        # Decode next 8-byte block.\n        idx = block * 8\n        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt3",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt3(data):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        idx = block * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "decode_dxt5",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "peekOfCode": "def decode_dxt5(data):\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4 * width pixels)\n    \"\"\"\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n    for block in range(blocks):\n        idx = block * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BlpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BmpImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "peekOfCode": "class BmpImageFile(ImageFile.ImageFile):\n    \"\"\"Image plugin for the Windows Bitmap format (BMP)\"\"\"\n    # ------------------------------------------------------------- Description\n    format_description = \"Windows Bitmap\"\n    format = \"BMP\"\n    # -------------------------------------------------- BMP Compression values\n    COMPRESSIONS = {\"RAW\": 0, \"RLE8\": 1, \"RLE4\": 2, \"BITFIELDS\": 3, \"JPEG\": 4, \"PNG\": 5}\n    for k, v in COMPRESSIONS.items():\n        vars()[k] = v\n    def _bitmap(self, header=0, offset=0):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BmpRleDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "peekOfCode": "class BmpRleDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        rle4 = self.args[1]\n        data = bytearray()\n        x = 0\n        while len(data) < self.state.xsize * self.state.ysize:\n            pixels = self.fd.read(1)\n            byte = self.fd.read(1)\n            if not pixels or not byte:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "DibImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "peekOfCode": "class DibImageFile(BmpImageFile):\n    format = \"DIB\"\n    format_description = \"Windows Bitmap\"\n    def _open(self):\n        self._bitmap()\n#\n# --------------------------------------------------------------------\n# Write BMP file\nSAVE = {\n    \"1\": (\"1\", 1, 2),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BIT2MODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "peekOfCode": "BIT2MODE = {\n    # bits => mode, rawmode\n    1: (\"P\", \"P;1\"),\n    4: (\"P\", \"P;4\"),\n    8: (\"P\", \"P\"),\n    16: (\"RGB\", \"BGR;15\"),\n    24: (\"RGB\", \"BGR\"),\n    32: (\"RGB\", \"BGRX\"),\n}\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "peekOfCode": "SAVE = {\n    \"1\": (\"1\", 1, 2),\n    \"L\": (\"L\", 8, 256),\n    \"P\": (\"P\", 8, 256),\n    \"RGB\": (\"BGR\", 24, 0),\n    \"RGBA\": (\"BGRA\", 32, 0),\n}\ndef _dib_save(im, fp, filename):\n    _save(im, fp, filename, False)\ndef _save(im, fp, filename, bitmap_header=True):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BmpImagePlugin",
        "documentation": {}
    },
    {
        "label": "BufrStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "peekOfCode": "class BufrStubImageFile(ImageFile.StubImageFile):\n    format = \"BUFR\"\n    format_description = \"BUFR\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(4)):\n            msg = \"Not a BUFR file\"\n            raise SyntaxError(msg)\n        self.fp.seek(offset)\n        # make something up",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific BUFR image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific BUFR image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.BufrStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "ContainerIO",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ContainerIO",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ContainerIO",
        "peekOfCode": "class ContainerIO(Generic[AnyStr]):\n    \"\"\"\n    A file object that provides read access to a part of an existing\n    file (for example a TAR file).\n    \"\"\"\n    def __init__(self, file: IO[AnyStr], offset: int, length: int) -> None:\n        \"\"\"\n        Create file object.\n        :param file: Existing file.\n        :param offset: Start of region, in bytes.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ContainerIO",
        "documentation": {}
    },
    {
        "label": "CurImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.CurImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.CurImagePlugin",
        "peekOfCode": "class CurImageFile(BmpImagePlugin.BmpImageFile):\n    format = \"CUR\"\n    format_description = \"Windows Cursor\"\n    def _open(self):\n        offset = self.fp.tell()\n        # check magic\n        s = self.fp.read(6)\n        if not _accept(s):\n            msg = \"not a CUR file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.CurImagePlugin",
        "documentation": {}
    },
    {
        "label": "DcxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "peekOfCode": "class DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # Header\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a DCX file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "peekOfCode": "MAGIC = 0x3ADE68B1  # QUIZ: what's this value, then?\ndef _accept(prefix):\n    return len(prefix) >= 4 and i32(prefix) == MAGIC\n##\n# Image plugin for the Intel DCX format.\nclass DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSD",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DDSD(IntFlag):\n    CAPS = 0x1\n    HEIGHT = 0x2\n    WIDTH = 0x4\n    PITCH = 0x8\n    PIXELFORMAT = 0x1000\n    MIPMAPCOUNT = 0x20000\n    LINEARSIZE = 0x80000\n    DEPTH = 0x800000\n# DDS caps",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DDSCAPS(IntFlag):\n    COMPLEX = 0x8\n    TEXTURE = 0x1000\n    MIPMAP = 0x400000\nclass DDSCAPS2(IntFlag):\n    CUBEMAP = 0x200\n    CUBEMAP_POSITIVEX = 0x400\n    CUBEMAP_NEGATIVEX = 0x800\n    CUBEMAP_POSITIVEY = 0x1000\n    CUBEMAP_NEGATIVEY = 0x2000",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDSCAPS2",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DDSCAPS2(IntFlag):\n    CUBEMAP = 0x200\n    CUBEMAP_POSITIVEX = 0x400\n    CUBEMAP_NEGATIVEX = 0x800\n    CUBEMAP_POSITIVEY = 0x1000\n    CUBEMAP_NEGATIVEY = 0x2000\n    CUBEMAP_POSITIVEZ = 0x4000\n    CUBEMAP_NEGATIVEZ = 0x8000\n    VOLUME = 0x200000\n# Pixel Format",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDPF",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DDPF(IntFlag):\n    ALPHAPIXELS = 0x1\n    ALPHA = 0x2\n    FOURCC = 0x4\n    PALETTEINDEXED8 = 0x20\n    RGB = 0x40\n    LUMINANCE = 0x20000\n# dxgiformat.h\nclass DXGI_FORMAT(IntEnum):\n    UNKNOWN = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DXGI_FORMAT(IntEnum):\n    UNKNOWN = 0\n    R32G32B32A32_TYPELESS = 1\n    R32G32B32A32_FLOAT = 2\n    R32G32B32A32_UINT = 3\n    R32G32B32A32_SINT = 4\n    R32G32B32_TYPELESS = 5\n    R32G32B32_FLOAT = 6\n    R32G32B32_UINT = 7\n    R32G32B32_SINT = 8",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "D3DFMT",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class D3DFMT(IntEnum):\n    UNKNOWN = 0\n    R8G8B8 = 20\n    A8R8G8B8 = 21\n    X8R8G8B8 = 22\n    R5G6B5 = 23\n    X1R5G5B5 = 24\n    A1R5G5B5 = 25\n    A4R4G4B4 = 26\n    R3G3B2 = 27",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DdsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))\n        if header_size != 124:\n            msg = f\"Unsupported header size {repr(header_size)}\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DdsRgbDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "class DdsRgbDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        bitcount, masks = self.args\n        # Some masks will be padded with zeros, e.g. R 0b11 G 0b1100\n        # Calculate how many zeros each mask is padded with\n        mask_offsets = []\n        # And the maximum value of each channel without the padding\n        mask_totals = []\n        for mask in masks:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_MAGIC = 0x20534444\n# DDS flags\nclass DDSD(IntFlag):\n    CAPS = 0x1\n    HEIGHT = 0x2\n    WIDTH = 0x4\n    PITCH = 0x8\n    PIXELFORMAT = 0x1000\n    MIPMAPCOUNT = 0x20000\n    LINEARSIZE = 0x80000",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "module",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "module = sys.modules[__name__]\nfor item in DDSD:\n    setattr(module, \"DDSD_\" + item.name, item.value)\nfor item in DDSCAPS:\n    setattr(module, \"DDSCAPS_\" + item.name, item.value)\nfor item in DDSCAPS2:\n    setattr(module, \"DDSCAPS2_\" + item.name, item.value)\nfor item in DDPF:\n    setattr(module, \"DDPF_\" + item.name, item.value)\nDDS_FOURCC = DDPF.FOURCC",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_FOURCC = DDPF.FOURCC\nDDS_RGB = DDPF.RGB\nDDS_RGBA = DDPF.RGB | DDPF.ALPHAPIXELS\nDDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_RGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_RGB = DDPF.RGB\nDDS_RGBA = DDPF.RGB | DDPF.ALPHAPIXELS\nDDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_RGBA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_RGBA = DDPF.RGB | DDPF.ALPHAPIXELS\nDDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_LUMINANCE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_LUMINANCEA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_ALPHA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_PAL8",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_PAL8 = DDPF.PALETTEINDEXED8\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_TEXTURE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_MIPMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_VOLUME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_PITCH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEADER_FLAGS_LINEARSIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_HEIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_WIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_WIDTH = DDSD.WIDTH\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_TEXTURE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_MIPMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_SURFACE_FLAGS_CUBEMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_POSITIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DDS_CUBEMAP_NEGATIVEZ",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT1_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT3_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXT5_FOURCC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXT5_FOURCC = D3DFMT.DXT5\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_R8G8B8A8_TYPELESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_R8G8B8A8_UNORM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC5_TYPELESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC5_UNORM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC5_SNORM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC6H_UF16",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC6H_SF16",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_TYPELESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_UNORM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "DXGI_FORMAT_BC7_UNORM_SRGB",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "peekOfCode": "DXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))\n        if header_size != 124:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.DdsImagePlugin",
        "documentation": {}
    },
    {
        "label": "PSFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "class PSFile:\n    \"\"\"\n    Wrapper for bytesio object that treats either CR or LF as end of line.\n    This class is no longer used internally, but kept for backwards compatibility.\n    \"\"\"\n    def __init__(self, fp):\n        deprecate(\n            \"PSFile\",\n            11,\n            action=\"If you need the functionality of this class \"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "EpsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "class EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}\n    def _open(self):\n        (length, offset) = self._find_offset(self.fp)\n        # go to offset - start of \"%!PS\"\n        self.fp.seek(offset)\n        self._mode = \"RGB\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "has_ghostscript",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "def has_ghostscript():\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):\n                    if shutil.which(binary) is not None:\n                        gs_windows_binary = binary\n                        break",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "Ghostscript",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "def Ghostscript(tile, size, fp, scale=1, transparency=False):\n    \"\"\"Render an image using Ghostscript\"\"\"\n    global gs_binary\n    if not has_ghostscript():\n        msg = \"Unable to locate Ghostscript on paths\"\n        raise OSError(msg)\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n    # Hack to support hi-res rendering",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\ngs_binary = None\ngs_windows_binary = None\ndef has_ghostscript():\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\ngs_binary = None\ngs_windows_binary = None\ndef has_ghostscript():\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "gs_binary",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "gs_binary = None\ngs_windows_binary = None\ndef has_ghostscript():\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):\n                    if shutil.which(binary) is not None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "gs_windows_binary",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "peekOfCode": "gs_windows_binary = None\ndef has_ghostscript():\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):\n                    if shutil.which(binary) is not None:\n                        gs_windows_binary = binary",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.EpsImagePlugin",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "class Base(IntEnum):\n    # possibly incomplete\n    InteropIndex = 0x0001\n    ProcessingSoftware = 0x000B\n    NewSubfileType = 0x00FE\n    SubfileType = 0x00FF\n    ImageWidth = 0x0100\n    ImageLength = 0x0101\n    BitsPerSample = 0x0102\n    Compression = 0x0103",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "GPS",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "class GPS(IntEnum):\n    GPSVersionID = 0\n    GPSLatitudeRef = 1\n    GPSLatitude = 2\n    GPSLongitudeRef = 3\n    GPSLongitude = 4\n    GPSAltitudeRef = 5\n    GPSAltitude = 6\n    GPSTimeStamp = 7\n    GPSSatellites = 8",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "Interop",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "class Interop(IntEnum):\n    InteropIndex = 1\n    InteropVersion = 2\n    RelatedImageFileFormat = 4096\n    RelatedImageWidth = 4097\n    RleatedImageHeight = 4098\nclass IFD(IntEnum):\n    Exif = 34665\n    GPSInfo = 34853\n    Makernote = 37500",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "IFD",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "class IFD(IntEnum):\n    Exif = 34665\n    GPSInfo = 34853\n    Makernote = 37500\n    Interop = 40965\n    IFD1 = -1\nclass LightSource(IntEnum):\n    Unknown = 0\n    Daylight = 1\n    Fluorescent = 2",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "LightSource",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "class LightSource(IntEnum):\n    Unknown = 0\n    Daylight = 1\n    Fluorescent = 2\n    Tungsten = 3\n    Flash = 4\n    Fine = 9\n    Cloudy = 10\n    Shade = 11\n    DaylightFluorescent = 12",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "TAGS = {\n    **{i.value: i.name for i in Base},\n    0x920C: \"SpatialFrequencyResponse\",\n    0x9214: \"SubjectLocation\",\n    0x9215: \"ExposureIndex\",\n    0x828E: \"CFAPattern\",\n    0x920B: \"FlashEnergy\",\n    0x9216: \"TIFF/EPStandardID\",\n}\nclass GPS(IntEnum):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "GPSTAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "peekOfCode": "GPSTAGS = {i.value: i.name for i in GPS}\nclass Interop(IntEnum):\n    InteropIndex = 1\n    InteropVersion = 2\n    RelatedImageFileFormat = 4096\n    RelatedImageWidth = 4097\n    RleatedImageHeight = 4098\nclass IFD(IntEnum):\n    Exif = 34665\n    GPSInfo = 34853",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ExifTags",
        "documentation": {}
    },
    {
        "label": "FitsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FitsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FitsImagePlugin",
        "peekOfCode": "class FitsImageFile(ImageFile.ImageFile):\n    format = \"FITS\"\n    format_description = \"FITS\"\n    def _open(self):\n        headers = {}\n        while True:\n            header = self.fp.read(80)\n            if not header:\n                msg = \"Truncated FITS file\"\n                raise OSError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FitsImagePlugin",
        "documentation": {}
    },
    {
        "label": "FliImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FliImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FliImagePlugin",
        "peekOfCode": "class FliImageFile(ImageFile.ImageFile):\n    format = \"FLI\"\n    format_description = \"Autodesk FLI/FLC Animation\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # HEAD\n        s = self.fp.read(128)\n        if not (_accept(s) and s[20:22] == b\"\\x00\\x00\"):\n            msg = \"not an FLI/FLC file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FliImagePlugin",
        "documentation": {}
    },
    {
        "label": "FontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "peekOfCode": "class FontFile:\n    \"\"\"Base class for raster font file handlers.\"\"\"\n    bitmap: Image.Image | None = None\n    def __init__(self) -> None:\n        self.info: dict[bytes, bytes | int] = {}\n        self.glyph: list[\n            tuple[\n                tuple[int, int],\n                tuple[int, int, int, int],\n                tuple[int, int, int, int],",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "puti16",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "peekOfCode": "def puti16(\n    fp: BinaryIO, values: tuple[int, int, int, int, int, int, int, int, int, int]\n) -> None:\n    \"\"\"Write network order (big-endian) 16-bit sequence\"\"\"\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\nclass FontFile:\n    \"\"\"Base class for raster font file handlers.\"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "WIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "peekOfCode": "WIDTH = 800\ndef puti16(\n    fp: BinaryIO, values: tuple[int, int, int, int, int, int, int, int, int, int]\n) -> None:\n    \"\"\"Write network order (big-endian) 16-bit sequence\"\"\"\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\nclass FontFile:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FontFile",
        "documentation": {}
    },
    {
        "label": "FpxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "peekOfCode": "class FpxImageFile(ImageFile.ImageFile):\n    format = \"FPX\"\n    format_description = \"FlashPix\"\n    def _open(self):\n        #\n        # read the OLE directory and see if this is a likely\n        # to be a FlashPix file\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "peekOfCode": "MODES = {\n    # opacity\n    (0x00007FFE,): (\"A\", \"L\"),\n    # monochrome\n    (0x00010000,): (\"L\", \"L\"),\n    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),\n    # photo YCC\n    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),\n    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),\n    # standard RGB (NIFRGB)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FpxImagePlugin",
        "documentation": {}
    },
    {
        "label": "Format",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "class Format(IntEnum):\n    DXT1 = 0\n    UNCOMPRESSED = 1\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not an FTEX file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "FtexImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "class FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not an FTEX file\"\n            raise SyntaxError(msg)\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{header}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "{header} = {\n    u32:magic,\n    u32:version,\n    u32:width,\n    u32:height,\n    u32:mipmap_count,\n    u32:format_count\n}\n* The \"magic\" number is \"FTEX\".\n* \"width\" and \"height\" are the dimensions of the texture.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{format_directory}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "{format_directory} = format_count * { u32:format, u32:where }\nThe format value is 0 for DXT1 compressed textures and 1 for 24-bit RGB\nuncompressed textures.\nThe texture data for a format starts at the position \"where\" in the file.\nEach set of texture data in the file has the following structure:\n{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "{data}",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.\nNote: All data is stored in little-Endian (Intel) byte order.\n\"\"\"\nfrom __future__ import annotations\nimport struct\nfrom enum import IntEnum",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "peekOfCode": "MAGIC = b\"FTEX\"\nclass Format(IntEnum):\n    DXT1 = 0\n    UNCOMPRESSED = 1\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not an FTEX file\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.FtexImagePlugin",
        "documentation": {}
    },
    {
        "label": "GbrImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GbrImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GbrImagePlugin",
        "peekOfCode": "class GbrImageFile(ImageFile.ImageFile):\n    format = \"GBR\"\n    format_description = \"GIMP brush file\"\n    def _open(self):\n        header_size = i32(self.fp.read(4))\n        if header_size < 20:\n            msg = \"not a GIMP brush\"\n            raise SyntaxError(msg)\n        version = i32(self.fp.read(4))\n        if version not in (1, 2):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GbrImagePlugin",
        "documentation": {}
    },
    {
        "label": "GdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "peekOfCode": "class GdImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Image plugin for the GD uncompressed format.  Note that this format\n    is not supported by the standard :py:func:`PIL.Image.open()` function.  To use\n    this plugin, you have to import the :py:mod:`PIL.GdImageFile` module and\n    use the :py:func:`PIL.GdImageFile.open()` function.\n    \"\"\"\n    format = \"GD\"\n    format_description = \"GD uncompressed images\"\n    def _open(self):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "peekOfCode": "def open(fp, mode=\"r\"):\n    \"\"\"\n    Load texture from a GD image file.\n    :param fp: GD file name, or an opened file handle.\n    :param mode: Optional mode.  In this version, if the mode argument\n        is given, it must be \"r\".\n    :returns: An image instance.\n    :raises OSError: If the image could not be read.\n    \"\"\"\n    if mode != \"r\":",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GdImageFile",
        "documentation": {}
    },
    {
        "label": "LoadingStrategy",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "class LoadingStrategy(IntEnum):\n    \"\"\".. versionadded:: 9.1.0\"\"\"\n    RGB_AFTER_FIRST = 0\n    RGB_AFTER_DIFFERENT_PALETTE_ONLY = 1\n    RGB_ALWAYS = 2\n#: .. versionadded:: 9.1.0\nLOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST\n# --------------------------------------------------------------------\n# Identify/read GIF files\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "GifImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "class GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"\n    format_description = \"Compuserve GIF\"\n    _close_exclusive_fp_after_loading = False\n    global_palette = None\n    def data(self):\n        s = self.fp.read(1)\n        if s and s[0]:\n            return self.fp.read(s[0])\n        return None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "get_interlace",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "def get_interlace(im):\n    interlace = im.encoderinfo.get(\"interlace\", 1)\n    # workaround for @PIL153\n    if min(im.size) < 16:\n        interlace = 0\n    return interlace\ndef _write_local_header(fp, im, offset, flags):\n    try:\n        transparency = im.encoderinfo[\"transparency\"]\n    except KeyError:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "getheader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "def getheader(im, palette=None, info=None):\n    \"\"\"\n    Legacy Method to get Gif data from image.\n    Warning:: May modify image data.\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: tuple of(list of header items, optimized palette)\n    \"\"\"\n    used_palette_colors = _get_optimize(im, info)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "getdata",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "def getdata(im, offset=(0, 0), **params):\n    \"\"\"\n    Legacy Method\n    Return a list of strings representing this image.\n    The first string is a local image header, the rest contains\n    encoded image data.\n    To specify duration, add the time in milliseconds,\n    e.g. ``getdata(im_frame, duration=1000)``\n    :param im: Image object\n    :param offset: Tuple of (x, y) pixels. Defaults to (0, 0)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "LOADING_STRATEGY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "LOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST\n# --------------------------------------------------------------------\n# Identify/read GIF files\ndef _accept(prefix):\n    return prefix[:6] in [b\"GIF87a\", b\"GIF89a\"]\n##\n# Image plugin for GIF images.  This plugin supports both GIF87 and\n# GIF89 images.\nclass GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "RAWMODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "RAWMODE = {\"1\": \"L\", \"L\": \"L\", \"P\": \"P\"}\ndef _normalize_mode(im):\n    \"\"\"\n    Takes an image (or frame), returns an image in a mode that is appropriate\n    for saving in a Gif.\n    It may return the original image, or it may return an image converted to\n    palette or 'L' mode.\n    :param im: Image object\n    :returns: Image object\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "_FORCE_OPTIMIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "peekOfCode": "_FORCE_OPTIMIZE = False\ndef _get_optimize(im, info):\n    \"\"\"\n    Palette optimization is a potentially expensive operation.\n    This function determines if the palette should be optimized using\n    some heuristics, then returns the list of palette entries in use.\n    :param im: Image object\n    :param info: encoderinfo\n    :returns: list of indexes of palette entries in use, or None\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GifImagePlugin",
        "documentation": {}
    },
    {
        "label": "GradientFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "class GradientFile:\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n        for i in range(entries):\n            x = i / (entries - 1)\n            while x1 < x:\n                ix += 1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "GimpGradientFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "class GimpGradientFile(GradientFile):\n    \"\"\"File handler for GIMP's gradient format.\"\"\"\n    def __init__(self, fp):\n        if fp.readline()[:13] != b\"GIMP Gradient\":\n            msg = \"not a GIMP gradient file\"\n            raise SyntaxError(msg)\n        line = fp.readline()\n        # GIMP 1.2 gradient files don't contain a name, but GIMP 1.3 files do\n        if line.startswith(b\"Name: \"):\n            line = fp.readline().strip()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "linear",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "def linear(middle, pos):\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle\n        middle = 1.0 - middle\n        if middle < EPSILON:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "curved",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "def curved(middle, pos):\n    return pos ** (log(0.5) / log(max(middle, EPSILON)))\ndef sine(middle, pos):\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\ndef sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sine",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "def sine(middle, pos):\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\ndef sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\nclass GradientFile:\n    gradient = None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sphere_increasing",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "def sphere_increasing(middle, pos):\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\ndef sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\nclass GradientFile:\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "sphere_decreasing",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "def sphere_decreasing(middle, pos):\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\nclass GradientFile:\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "EPSILON",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "EPSILON = 1e-10\n\"\"\"\"\"\"  # Enable auto-doc for data member\ndef linear(middle, pos):\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "SEGMENTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "peekOfCode": "SEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\nclass GradientFile:\n    gradient = None\n    def getpalette(self, entries=256):\n        palette = []\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n        for i in range(entries):\n            x = i / (entries - 1)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpGradientFile",
        "documentation": {}
    },
    {
        "label": "GimpPaletteFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GimpPaletteFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GimpPaletteFile",
        "peekOfCode": "class GimpPaletteFile:\n    \"\"\"File handler for GIMP's palette format.\"\"\"\n    rawmode = \"RGB\"\n    def __init__(self, fp):\n        self.palette = [o8(i) * 3 for i in range(256)]\n        if fp.readline()[:12] != b\"GIMP Palette\":\n            msg = \"not a GIMP palette file\"\n            raise SyntaxError(msg)\n        for i in range(256):\n            s = fp.readline()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GimpPaletteFile",
        "documentation": {}
    },
    {
        "label": "GribStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "peekOfCode": "class GribStubImageFile(ImageFile.StubImageFile):\n    format = \"GRIB\"\n    format_description = \"GRIB\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(8)):\n            msg = \"Not a GRIB file\"\n            raise SyntaxError(msg)\n        self.fp.seek(offset)\n        # make something up",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific GRIB image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific GRIB image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.GribStubImagePlugin",
        "documentation": {}
    },
    {
        "label": "HDF5StubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "class HDF5StubImageFile(ImageFile.StubImageFile):\n    format = \"HDF5\"\n    format_description = \"HDF5\"\n    def _open(self):\n        offset = self.fp.tell()\n        if not _accept(self.fp.read(8)):\n            msg = \"Not an HDF file\"\n            raise SyntaxError(msg)\n        self.fp.seek(offset)\n        # make something up",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific HDF5 image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific HDF5 image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n# --------------------------------------------------------------------\n# Image adapter",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Hdf5StubImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcnsFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "class IcnsFile:\n    SIZES = {\n        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],\n        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],\n        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],\n        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],\n        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],\n        (128, 128, 1): [\n            (b\"ic07\", read_png_or_jpeg2000),\n            (b\"it32\", read_32t),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcnsImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "class IcnsImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL image support for Mac OS .icns files.\n    Chooses the best resolution, but will possibly load\n    a different size image if you mutate the size attribute\n    before calling 'load'.\n    The info dictionary has a key 'sizes' that is a list\n    of sizes that the icns file has.\n    \"\"\"\n    format = \"ICNS\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "nextheader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "def nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        msg = \"Unknown signature, expecting 0x00000000\"\n        raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_32t",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        msg = \"Unknown signature, expecting 0x00000000\"\n        raise SyntaxError(msg)\n    return read_32(fobj, (start + 4, length - 4), size)\ndef read_32(fobj, start_length, size):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_32",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_32(fobj, start_length, size):\n    \"\"\"\n    Read a 32bit RGB icon resource.  Seems to be either uncompressed or\n    an RLE packbits-like scheme.\n    \"\"\"\n    (start, length) = start_length\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    if length == sizesq * 3:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_mk",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_mk(fobj, start_length, size):\n    # Alpha masks seem to be uncompressed\n    start = start_length[0]\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)\n    return {\"A\": band}\ndef read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "read_png_or_jpeg2000",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "def read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(12)\n    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":\n        fobj.seek(start)\n        im = PngImagePlugin.PngImageFile(fobj)\n        Image._decompression_bomb_check(im.size)\n        return {\"RGBA\": im}\n    elif (",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "enable_jpeg2k",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "enable_jpeg2k = features.check_codec(\"jpg_2000\")\nif enable_jpeg2k:\n    from . import Jpeg2KImagePlugin\nMAGIC = b\"icns\"\nHEADERSIZE = 8\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "MAGIC = b\"icns\"\nHEADERSIZE = 8\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "HEADERSIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "peekOfCode": "HEADERSIZE = 8\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        msg = \"Unknown signature, expecting 0x00000000\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcnsImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcoFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "peekOfCode": "class IcoFile:\n    def __init__(self, buf):\n        \"\"\"\n        Parse image from file-like object containing ico file data\n        \"\"\"\n        # check magic\n        s = buf.read(6)\n        if not _accept(s):\n            msg = \"not an ICO file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "IcoImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "peekOfCode": "class IcoImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL read-only image support for Microsoft Windows .ico files.\n    By default the largest resolution image in the file will be loaded. This\n    can be changed by altering the 'size' attribute before calling 'load'.\n    The info dictionary has a key 'sizes' that is a list of the sizes available\n    in the icon file.\n    Handles classic, XP and Vista icon formats.\n    When saving, PNG compression is used. Support for this was only added in\n    Windows Vista. If you are unable to view the icon in Windows, convert the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "peekOfCode": "_MAGIC = b\"\\0\\0\\1\\0\"\ndef _save(im, fp, filename):\n    fp.write(_MAGIC)  # (2+2)\n    bmp = im.encoderinfo.get(\"bitmap_format\") == \"bmp\"\n    sizes = im.encoderinfo.get(\n        \"sizes\",\n        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],\n    )\n    frames = []\n    provided_ims = [im] + im.encoderinfo.get(\"append_images\", [])",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IcoImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "class ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # Quick rejection: if there's not an LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        if b\"\\n\" not in self.fp.read(100):\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "number",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "def number(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n##\n# Image plugin for the IFUNC IM file format.\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "COMMENT = \"Comment\"\nDATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "DATE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "DATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "EQUIPMENT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "EQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "FRAMES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "FRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "LUT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "LUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "NAME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "NAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SCALE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "SCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "SIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "MODE = \"Image type\"\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "TAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,\n    MODE: 0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "OPEN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "OPEN = {\n    # ifunc93/p3cfunc formats\n    \"0 1 image\": (\"1\", \"1\"),\n    \"L 1 image\": (\"1\", \"1\"),\n    \"Greyscale image\": (\"L\", \"L\"),\n    \"Grayscale image\": (\"L\", \"L\"),\n    \"RGB image\": (\"RGB\", \"RGB;L\"),\n    \"RLB image\": (\"RGB\", \"RLB\"),\n    \"RYB image\": (\"RGB\", \"RLB\"),\n    \"B1 image\": (\"1\", \"1\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "split = re.compile(rb\"^([A-Za-z][^:]*):[ \\t]*(.*)[ \\t]*$\")\ndef number(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n##\n# Image plugin for the IFUNC IM file format.\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "peekOfCode": "SAVE = {\n    # mode: (im type, raw mode)\n    \"1\": (\"0 1\", \"1\"),\n    \"L\": (\"Greyscale\", \"L\"),\n    \"LA\": (\"LA\", \"LA;L\"),\n    \"P\": (\"Greyscale\", \"P\"),\n    \"PA\": (\"LA\", \"PA;L\"),\n    \"I\": (\"L 32S\", \"I;32S\"),\n    \"I;16\": (\"L 16\", \"I;16\"),\n    \"I;16L\": (\"L 16L\", \"I;16L\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImImagePlugin",
        "documentation": {}
    },
    {
        "label": "DecompressionBombWarning",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class DecompressionBombWarning(RuntimeWarning):\n    pass\nclass DecompressionBombError(Exception):\n    pass\n# Limit to around a quarter gigabyte for a 24-bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "DecompressionBombError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class DecompressionBombError(Exception):\n    pass\n# Limit to around a quarter gigabyte for a 24-bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.\n    # Also note that Image.core is not a publicly documented interface,\n    # and should be considered private and subject to change.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Transpose",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Transpose(IntEnum):\n    FLIP_LEFT_RIGHT = 0\n    FLIP_TOP_BOTTOM = 1\n    ROTATE_90 = 2\n    ROTATE_180 = 3\n    ROTATE_270 = 4\n    TRANSPOSE = 5\n    TRANSVERSE = 6\n# transforms (also defined in Imaging.h)\nclass Transform(IntEnum):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Transform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Transform(IntEnum):\n    AFFINE = 0\n    EXTENT = 1\n    PERSPECTIVE = 2\n    QUAD = 3\n    MESH = 4\n# resampling filters (also defined in Imaging.h)\nclass Resampling(IntEnum):\n    NEAREST = 0\n    BOX = 4",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Resampling",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Resampling(IntEnum):\n    NEAREST = 0\n    BOX = 4\n    BILINEAR = 2\n    HAMMING = 5\n    BICUBIC = 3\n    LANCZOS = 1\n_filters_support = {\n    Resampling.BOX: 0.5,\n    Resampling.BILINEAR: 1.0,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Dither",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Dither(IntEnum):\n    NONE = 0\n    ORDERED = 1  # Not yet implemented\n    RASTERIZE = 2  # Not yet implemented\n    FLOYDSTEINBERG = 3  # default\n# palettes/quantizers\nclass Palette(IntEnum):\n    WEB = 0\n    ADAPTIVE = 1\nclass Quantize(IntEnum):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Palette",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Palette(IntEnum):\n    WEB = 0\n    ADAPTIVE = 1\nclass Quantize(IntEnum):\n    MEDIANCUT = 0\n    MAXCOVERAGE = 1\n    FASTOCTREE = 2\n    LIBIMAGEQUANT = 3\nmodule = sys.modules[__name__]\nfor enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Quantize",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Quantize(IntEnum):\n    MEDIANCUT = 0\n    MAXCOVERAGE = 1\n    FASTOCTREE = 2\n    LIBIMAGEQUANT = 3\nmodule = sys.modules[__name__]\nfor enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):\n    for item in enum:\n        setattr(module, item.name, item.value)\nif hasattr(core, \"DEFAULT_STRATEGY\"):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_E",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class _E:\n    def __init__(self, scale, offset):\n        self.scale = scale\n        self.offset = offset\n    def __neg__(self):\n        return _E(-self.scale, -self.offset)\n    def __add__(self, other):\n        if isinstance(other, _E):\n            return _E(self.scale + other.scale, self.offset + other.offset)\n        return _E(self.scale, self.offset + other)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Image",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Image:\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ImagePointHandler",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class ImagePointHandler:\n    \"\"\"\n    Used as a mixin by point transforms\n    (for use with :py:meth:`~PIL.Image.Image.point`)\n    \"\"\"\n    pass\nclass ImageTransformHandler:\n    \"\"\"\n    Used as a mixin by geometry transforms\n    (for use with :py:meth:`~PIL.Image.Image.transform`)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ImageTransformHandler",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class ImageTransformHandler:\n    \"\"\"\n    Used as a mixin by geometry transforms\n    (for use with :py:meth:`~PIL.Image.Image.transform`)\n    \"\"\"\n    pass\n# --------------------------------------------------------------------\n# Factories\n#\n# Debugging",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "Exif",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "class Exif(MutableMapping):\n    \"\"\"\n    This class provides read and write access to EXIF image data::\n      from PIL import Image\n      im = Image.open(\"exif.png\")\n      exif = im.getexif()  # Returns an instance of this class\n    Information can be read and written, iterated over or deleted::\n      print(exif[274])  # 1\n      exif[274] = 2\n      for k, v in exif.items():",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "isImageType",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def isImageType(t):\n    \"\"\"\n    Checks if an object is an image object.\n    .. warning::\n       This function is for internal use only.\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n#",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebase",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodetype",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def getmodetype(mode):\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\ndef getmodebandnames(mode):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebandnames",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def getmodebandnames(mode):\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "getmodebands",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def getmodebands(mode):\n    \"\"\"\n    Gets the number of individual bands for this mode.\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n# --------------------------------------------------------------------\n# Helpers",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "preinit",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def preinit():\n    \"\"\"\n    Explicitly loads BMP, GIF, JPEG, PPM and PPM file format drivers.\n    It is called when opening or saving images.\n    \"\"\"\n    global _initialized\n    if _initialized >= 1:\n        return\n    try:\n        from . import BmpImagePlugin",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def init():\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n    It is called when opening or saving images if :py:meth:`~preinit()` is\n    insufficient, and by :py:meth:`~PIL.features.pilinfo`.\n    \"\"\"\n    global _initialized\n    if _initialized >= 2:\n        return 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def new(mode, size, color=0) -> Image:\n    \"\"\"\n    Creates a new image with the given mode and size.\n    :param mode: The mode to use for the new image. See:\n       :ref:`concept-modes`.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB or HSV images, you can also use color",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "frombytes",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def frombytes(mode, size, data, decoder_name=\"raw\", *args) -> Image:\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n    You can also use any pixel decoder supported by PIL. For more\n    information on available decoders, see the section\n    :ref:`Writing Your Own File Codec <file-codecs>`.\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "frombuffer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def frombuffer(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load it.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromarray",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def fromarray(obj, mode=None):\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol)::\n      from PIL import Image\n      import numpy as np\n      a = np.zeros((5, 5))\n      im = Image.fromarray(a)\n    If ``obj`` is not contiguous, then the ``tobytes`` method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromqimage",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def fromqimage(im):\n    \"\"\"Creates an image instance from a QImage image\"\"\"\n    from . import ImageQt\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqimage(im)\ndef fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "fromqpixmap",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqpixmap(im)\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def open(fp, mode=\"r\", formats=None) -> Image:\n    \"\"\"\n    Opens and identifies the given image file.\n    This is a lazy operation; this function identifies the file, but\n    the file remains open and the actual image data is not read from\n    the file until you try to process the data (or call the\n    :py:meth:`~PIL.Image.Image.load` method).  See\n    :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n    :param fp: A filename (string), pathlib.Path object or a file object.\n       The file object must implement ``file.read``,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "alpha_composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def alpha_composite(im1, im2):\n    \"\"\"\n    Alpha composite im2 over im1.\n    :param im1: The first image. Must have mode RGBA.\n    :param im2: The second image.  Must have mode RGBA, and the same size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n    im1.load()\n    im2.load()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "blend",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def blend(im1, im2, alpha):\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha::\n        out = image1 * (1.0 - alpha) + image2 * alpha\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def composite(image1, image2, mask):\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def merge(mode, bands):\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n    :param mode: The mode to use for the output image. See:\n        :ref:`concept-modes`.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_open(id, factory, accept=None) -> None:\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_mime",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_mime(id, mimetype):\n    \"\"\"\n    Registers an image MIME type by populating ``Image.MIME``. This function\n    should not be used in application code.\n    ``Image.MIME`` provides a mapping from image format identifiers to mime\n    formats, but :py:meth:`~PIL.ImageFile.ImageFile.get_format_mimetype` can\n    provide a different result for specific images.\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_save",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_save(id, driver):\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\ndef register_save_all(id, driver):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_save_all",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_save_all(id, driver):\n    \"\"\"\n    Registers an image function to save all the frames\n    of a multiframe format.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE_ALL[id.upper()] = driver\ndef register_extension(id, extension) -> None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_extension",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_extension(id, extension) -> None:\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\ndef register_extensions(id, extensions):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_extensions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_extensions(id, extensions):\n    \"\"\"\n    Registers image extensions.  This function should not be\n    used in application code.\n    :param id: An image format identifier.\n    :param extensions: A list of extensions used for this format.\n    \"\"\"\n    for extension in extensions:\n        register_extension(id, extension)\ndef registered_extensions():",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "registered_extensions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def registered_extensions():\n    \"\"\"\n    Returns a dictionary containing all file extensions belonging\n    to registered plugins\n    \"\"\"\n    init()\n    return EXTENSION\ndef register_decoder(name, decoder):\n    \"\"\"\n    Registers an image decoder.  This function should not be",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_decoder",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_decoder(name, decoder):\n    \"\"\"\n    Registers an image decoder.  This function should not be\n    used in application code.\n    :param name: The name of the decoder\n    :param decoder: A callable(mode, args) that returns an\n                    ImageFile.PyDecoder object\n    .. versionadded:: 4.1.0\n    \"\"\"\n    DECODERS[name] = decoder",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "register_encoder",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def register_encoder(name, encoder):\n    \"\"\"\n    Registers an image encoder.  This function should not be\n    used in application code.\n    :param name: The name of the encoder\n    :param encoder: A callable(mode, args) that returns an\n                    ImageFile.PyEncoder object\n    .. versionadded:: 4.1.0\n    \"\"\"\n    ENCODERS[name] = encoder",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "effect_mandelbrot",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def effect_mandelbrot(size, extent, quality):\n    \"\"\"\n    Generate a Mandelbrot set covering the given extent.\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param extent: The extent to cover, as a 4-tuple:\n       (x0, y0, x1, y1).\n    :param quality: Quality.\n    \"\"\"\n    return Image()._new(core.effect_mandelbrot(size, extent, quality))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "effect_noise",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def effect_noise(size, sigma):\n    \"\"\"\n    Generate Gaussian noise centered around 128.\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param sigma: Standard deviation of noise.\n    \"\"\"\n    return Image()._new(core.effect_noise(size, sigma))\ndef linear_gradient(mode):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "linear_gradient",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def linear_gradient(mode):\n    \"\"\"\n    Generate 256x256 linear gradient from black to white, top to bottom.\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.linear_gradient(mode))\ndef radial_gradient(mode):\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n    :param mode: Input mode.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "radial_gradient",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "def radial_gradient(mode):\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.radial_gradient(mode))\n# --------------------------------------------------------------------\n# Resources\ndef _apply_env_variables(env=None):\n    if env is None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass DecompressionBombWarning(RuntimeWarning):\n    pass\nclass DecompressionBombError(Exception):\n    pass\n# Limit to around a quarter gigabyte for a 24-bit (3 bpp) image\nMAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MAX_IMAGE_PIXELS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "MAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3)\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.\n    # Also note that Image.core is not a publicly documented interface,\n    # and should be considered private and subject to change.\n    from . import _imaging as core\n    if __version__ != getattr(core, \"PILLOW_VERSION\", None):\n        msg = (",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "USE_CFFI_ACCESS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "USE_CFFI_ACCESS = False\ntry:\n    import cffi\nexcept ImportError:\n    cffi = None\ndef isImageType(t):\n    \"\"\"\n    Checks if an object is an image object.\n    .. warning::\n       This function is for internal use only.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_filters_support",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "_filters_support = {\n    Resampling.BOX: 0.5,\n    Resampling.BILINEAR: 1.0,\n    Resampling.HAMMING: 1.0,\n    Resampling.BICUBIC: 2.0,\n    Resampling.LANCZOS: 3.0,\n}\n# dithers\nclass Dither(IntEnum):\n    NONE = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "module",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "module = sys.modules[__name__]\nfor enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):\n    for item in enum:\n        setattr(module, item.name, item.value)\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ID",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "ID = []\nOPEN = {}\nMIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "OPEN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "OPEN = {}\nMIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MIME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "MIME = {}\nSAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "SAVE = {}\nSAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "SAVE_ALL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "SAVE_ALL = {}\nEXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "EXTENSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "EXTENSION = {}\nDECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "DECODERS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "DECODERS = {}\nENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)\n    if extra != 1:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "ENCODERS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "ENCODERS = {}\n# --------------------------------------------------------------------\n# Modes\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)\n    if extra != 1:\n        shape += (extra,)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_ENDIAN",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)\n    if extra != 1:\n        shape += (extra,)\n    return shape, m.typestr\nMODES = [\"1\", \"CMYK\", \"F\", \"HSV\", \"I\", \"L\", \"LAB\", \"P\", \"RGB\", \"RGBA\", \"RGBX\", \"YCbCr\"]\n# raw modes that may be memory mapped.  NOTE: if you change this, you",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "MODES = [\"1\", \"CMYK\", \"F\", \"HSV\", \"I\", \"L\", \"LAB\", \"P\", \"RGB\", \"RGBA\", \"RGBX\", \"YCbCr\"]\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_MAPMODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_initialized",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "_initialized = 0\ndef preinit():\n    \"\"\"\n    Explicitly loads BMP, GIF, JPEG, PPM and PPM file format drivers.\n    It is called when opening or saving images.\n    \"\"\"\n    global _initialized\n    if _initialized >= 1:\n        return\n    try:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "_fromarray_typemap",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "peekOfCode": "_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    ((1, 1), \"|b1\"): (\"1\", \"1;8\"),\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<u2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">u2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16S\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16BS\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Image",
        "documentation": {}
    },
    {
        "label": "constant",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def constant(image: Image.Image, value: int) -> Image.Image:\n    \"\"\"Fill a channel with a given gray level.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.new(\"L\", image.size, value)\ndef duplicate(image: Image.Image) -> Image.Image:\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return image.copy()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "duplicate",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def duplicate(image: Image.Image) -> Image.Image:\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return image.copy()\ndef invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert an image (channel). ::\n        out = MAX - image\n    :rtype: :py:class:`~PIL.Image.Image`",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "invert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert an image (channel). ::\n        out = MAX - image\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image.load()\n    return image._new(image.im.chop_invert())\ndef lighter(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "lighter",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def lighter(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the lighter values. ::\n        out = max(image1, image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_lighter(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "darker",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def darker(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the darker values. ::\n        out = min(image1, image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_darker(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "difference",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def difference(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Returns the absolute value of the pixel-by-pixel difference between the two\n    images. ::\n        out = abs(image1 - image2)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_difference(image2.im))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def multiply(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other.\n    If you multiply an image with a solid black image, the result is black. If\n    you multiply with a solid white image, the image is unaffected. ::\n        out = image1 * image2 / MAX\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def screen(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two inverted images on top of each other. ::\n        out = MAX - ((MAX - image1) * (MAX - image2) / MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_screen(image2.im))\ndef soft_light(image1: Image.Image, image2: Image.Image) -> Image.Image:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "soft_light",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def soft_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Soft Light algorithm\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_soft_light(image2.im))\ndef hard_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "hard_light",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def hard_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Hard Light algorithm\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_hard_light(image2.im))\ndef overlay(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "overlay",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def overlay(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Overlay algorithm\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_overlay(image2.im))\ndef add(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def add(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Adds two images, dividing the result by scale and adding the\n    offset. If omitted, scale defaults to 1.0, and offset to 0.0. ::\n        out = ((image1 + image2) / scale + offset)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "subtract",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def subtract(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Subtracts two images, dividing the result by scale and adding the offset.\n    If omitted, scale defaults to 1.0, and offset to 0.0. ::\n        out = ((image1 - image2) / scale + offset)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "add_modulo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def add_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Add two images, without clipping the result. ::\n        out = ((image1 + image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add_modulo(image2.im))\ndef subtract_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Subtract two images, without clipping the result. ::",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "subtract_modulo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def subtract_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Subtract two images, without clipping the result. ::\n        out = ((image1 - image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract_modulo(image2.im))\ndef logical_and(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical AND between two images.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_and",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def logical_and(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical AND between two images.\n    Both of the images must have mode \"1\". If you would like to perform a\n    logical AND on an image with a mode other than \"1\", try\n    :py:meth:`~PIL.ImageChops.multiply` instead, using a black-and-white mask\n    as the second image. ::\n        out = ((image1 and image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_or",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def logical_or(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical OR between two images.\n    Both of the images must have mode \"1\". ::\n        out = ((image1 or image2) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_or(image2.im))\ndef logical_xor(image1: Image.Image, image2: Image.Image) -> Image.Image:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "logical_xor",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def logical_xor(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical XOR between two images.\n    Both of the images must have mode \"1\". ::\n        out = ((bool(image1) != bool(image2)) % MAX)\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_xor(image2.im))\ndef blend(image1: Image.Image, image2: Image.Image, alpha: float) -> Image.Image:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "blend",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def blend(image1: Image.Image, image2: Image.Image, alpha: float) -> Image.Image:\n    \"\"\"Blend images using constant transparency weight. Alias for\n    :py:func:`PIL.Image.blend`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.blend(image1, image2, alpha)\ndef composite(\n    image1: Image.Image, image2: Image.Image, mask: Image.Image\n) -> Image.Image:\n    \"\"\"Create composite using transparency mask. Alias for",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "composite",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def composite(\n    image1: Image.Image, image2: Image.Image, mask: Image.Image\n) -> Image.Image:\n    \"\"\"Create composite using transparency mask. Alias for\n    :py:func:`PIL.Image.composite`.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n    return Image.composite(image1, image2, mask)\ndef offset(image: Image.Image, xoffset: int, yoffset: int | None = None) -> Image.Image:\n    \"\"\"Returns a copy of the image where data has been offset by the given",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "offset",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "peekOfCode": "def offset(image: Image.Image, xoffset: int, yoffset: int | None = None) -> Image.Image:\n    \"\"\"Returns a copy of the image where data has been offset by the given\n    distances. Data wraps around the edges. If ``yoffset`` is omitted, it\n    is assumed to be equal to ``xoffset``.\n    :param image: Input image.\n    :param xoffset: The horizontal distance.\n    :param yoffset: The vertical distance.  If omitted, both\n        distances are set to the same value.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageChops",
        "documentation": {}
    },
    {
        "label": "Intent",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "class Intent(IntEnum):\n    PERCEPTUAL = 0\n    RELATIVE_COLORIMETRIC = 1\n    SATURATION = 2\n    ABSOLUTE_COLORIMETRIC = 3\nclass Direction(IntEnum):\n    INPUT = 0\n    OUTPUT = 1\n    PROOF = 2\n#",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "Direction",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "class Direction(IntEnum):\n    INPUT = 0\n    OUTPUT = 1\n    PROOF = 2\n#\n# flags\nFLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "ImageCmsProfile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "class ImageCmsProfile:\n    def __init__(self, profile):\n        \"\"\"\n        :param profile: Either a string representing a filename,\n            a file like object containing a profile or a\n            low-level profile object\n        \"\"\"\n        if isinstance(profile, str):\n            if sys.platform == \"win32\":\n                profile_bytes_path = profile.encode()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "ImageCmsTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "class ImageCmsTransform(Image.ImagePointHandler):\n    \"\"\"\n    Transform.  This can be used with the procedural API, or with the standard\n    :py:func:`~PIL.Image.Image.point` method.\n    Will return the output profile in the ``output.info['icc_profile']``.\n    \"\"\"\n    def __init__(\n        self,\n        input,\n        output,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "PyCMSError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "class PyCMSError(Exception):\n    \"\"\"(pyCMS) Exception class.\n    This is used for all errors in the pyCMS API.\"\"\"\n    pass\ndef profileToProfile(\n    im,\n    inputProfile,\n    outputProfile,\n    renderingIntent=Intent.PERCEPTUAL,\n    outputMode=None,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "get_display_profile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def get_display_profile(handle=None):\n    \"\"\"\n    (experimental) Fetches the profile for the current display device.\n    :returns: ``None`` if the profile is not known.\n    \"\"\"\n    if sys.platform != \"win32\":\n        return None\n    from . import ImageWin\n    if isinstance(handle, ImageWin.HDC):\n        profile = core.get_display_profile_win32(handle, 1)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "profileToProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def profileToProfile(\n    im,\n    inputProfile,\n    outputProfile,\n    renderingIntent=Intent.PERCEPTUAL,\n    outputMode=None,\n    inPlace=False,\n    flags=0,\n):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getOpenProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getOpenProfile(profileFilename):\n    \"\"\"\n    (pyCMS) Opens an ICC profile file.\n    The PyCMSProfile object can be passed back into pyCMS for use in creating\n    transforms and such (as in ImageCms.buildTransformFromOpenProfiles()).\n    If ``profileFilename`` is not a valid filename for an ICC profile,\n    a :exc:`PyCMSError` will be raised.\n    :param profileFilename: String, as a valid filename path to the ICC profile\n        you wish to open, or a file-like object.\n    :returns: A CmsProfile class object.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def buildTransform(\n    inputProfile,\n    outputProfile,\n    inMode,\n    outMode,\n    renderingIntent=Intent.PERCEPTUAL,\n    flags=0,\n):\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the ``inputProfile`` to the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildProofTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def buildProofTransform(\n    inputProfile,\n    outputProfile,\n    proofProfile,\n    inMode,\n    outMode,\n    renderingIntent=Intent.PERCEPTUAL,\n    proofRenderingIntent=Intent.ABSOLUTE_COLORIMETRIC,\n    flags=FLAGS[\"SOFTPROOFING\"],\n):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "applyTransform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If ``im.mode != transform.inMode``, a :exc:`PyCMSError` is raised.\n    If ``inPlace`` is ``True`` and ``transform.inMode != transform.outMode``, a\n    :exc:`PyCMSError` is raised.\n    If ``im.mode``, ``transform.inMode`` or ``transform.outMode`` is not\n    supported by pyCMSdll or the profiles you used for the transform, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while the transform is being applied,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "createProfile",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def createProfile(colorSpace, colorTemp=-1):\n    \"\"\"\n    (pyCMS) Creates a profile.\n    If colorSpace not in ``[\"LAB\", \"XYZ\", \"sRGB\"]``,\n    a :exc:`PyCMSError` is raised.\n    If using LAB and ``colorTemp`` is not a positive integer,\n    a :exc:`PyCMSError` is raised.\n    If an error occurs while creating the profile,\n    a :exc:`PyCMSError` is raised.\n    Use this function to create common profiles on-the-fly instead of",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileName",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileName(profile):\n    \"\"\"\n    (pyCMS) Gets the internal product name for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised If an error occurs while trying\n    to obtain the name tag, a :exc:`PyCMSError` is raised.\n    Use this function to obtain the INTERNAL name of the profile (stored\n    in an ICC tag in the profile itself), usually the one used when the\n    profile was originally created.  Sometimes this tag also contains\n    additional information supplied by the creator.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileInfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileInfo(profile):\n    \"\"\"\n    (pyCMS) Gets the internal product information for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the info tag,\n    a :exc:`PyCMSError` is raised.\n    Use this function to obtain the information stored in the profile's\n    info tag.  This often contains details about the profile, and how it\n    was created, as supplied by the creator.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileCopyright",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileCopyright(profile):\n    \"\"\"\n    (pyCMS) Gets the copyright for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the copyright tag,\n    a :exc:`PyCMSError` is raised.\n    Use this function to obtain the information stored in the profile's\n    copyright tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileManufacturer",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileManufacturer(profile):\n    \"\"\"\n    (pyCMS) Gets the manufacturer for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the manufacturer tag, a\n    :exc:`PyCMSError` is raised.\n    Use this function to obtain the information stored in the profile's\n    manufacturer tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileModel",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileModel(profile):\n    \"\"\"\n    (pyCMS) Gets the model for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the model tag,\n    a :exc:`PyCMSError` is raised.\n    Use this function to obtain the information stored in the profile's\n    model tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getProfileDescription",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getProfileDescription(profile):\n    \"\"\"\n    (pyCMS) Gets the description for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the description tag,\n    a :exc:`PyCMSError` is raised.\n    Use this function to obtain the information stored in the profile's\n    description tag.\n    :param profile: EITHER a valid CmsProfile object, OR a string of the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getDefaultIntent",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def getDefaultIntent(profile):\n    \"\"\"\n    (pyCMS) Gets the default intent name for the given profile.\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n    If an error occurs while trying to obtain the default intent, a\n    :exc:`PyCMSError` is raised.\n    Use this function to determine the default (and usually best optimized)\n    rendering intent for this profile.  Most profiles support multiple\n    rendering intents, but are intended mostly for one type of conversion.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "isIntentSupported",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def isIntentSupported(profile, intent, direction):\n    \"\"\"\n    (pyCMS) Checks if a given intent is supported.\n    Use this function to verify that you can use your desired\n    ``intent`` with ``profile``, and that ``profile`` can be used for the\n    input/output/proof profile as you desire.\n    Some profiles are created specifically for one \"direction\", can cannot\n    be used for others. Some profiles can only be used for certain\n    rendering intents, so it's best to either verify this before trying\n    to create a transform with them (using this function), or catch the",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "versions",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "def versions():\n    \"\"\"\n    (pyCMS) Fetches versions.\n    \"\"\"\n    return VERSION, core.littlecms_version, sys.version.split()[0], Image.__version__",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "DESCRIPTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "DESCRIPTION = \"\"\"\npyCMS\n    a Python / PIL interface to the littleCMS ICC Color Management System\n    Copyright (C) 2002-2003 Kevin Cazabon\n    kevin@cazabon.com\n    https://www.cazabon.com\n    pyCMS home page:  https://www.cazabon.com/pyCMS\n    littleCMS home page:  https://www.littlecms.com\n    (littleCMS is Copyright (C) 1998-2001 Marti Maria)\n    Originally released under LGPL.  Graciously donated to PIL in",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "VERSION = \"1.0.0 pil\"\n# --------------------------------------------------------------------.\ncore = _imagingcms\n#\n# intent/direction values\nclass Intent(IntEnum):\n    PERCEPTUAL = 0\n    RELATIVE_COLORIMETRIC = 1\n    SATURATION = 2\n    ABSOLUTE_COLORIMETRIC = 3",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "core",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "core = _imagingcms\n#\n# intent/direction values\nclass Intent(IntEnum):\n    PERCEPTUAL = 0\n    RELATIVE_COLORIMETRIC = 1\n    SATURATION = 2\n    ABSOLUTE_COLORIMETRIC = 3\nclass Direction(IntEnum):\n    INPUT = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "FLAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "FLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms\n    # (internal use):\n    \"NOPRELINEARIZATION\": 16,\n    \"GUESSDEVICECLASS\": 32,  # Guess device class (for transform2devicelink)\n    \"NOTCACHE\": 64,  # Inhibit 1-pixel cache",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "_MAX_FLAG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "_MAX_FLAG = 0\nfor flag in FLAGS.values():\n    if isinstance(flag, int):\n        _MAX_FLAG = _MAX_FLAG | flag\n# --------------------------------------------------------------------.\n# Experimental PIL-level API\n# --------------------------------------------------------------------.\n##\n# Profile.\nclass ImageCmsProfile:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildTransformFromOpenProfiles",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "buildTransformFromOpenProfiles = buildTransform\nbuildProofTransformFromOpenProfiles = buildProofTransform\ndef applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If ``im.mode != transform.inMode``, a :exc:`PyCMSError` is raised.\n    If ``inPlace`` is ``True`` and ``transform.inMode != transform.outMode``, a\n    :exc:`PyCMSError` is raised.\n    If ``im.mode``, ``transform.inMode`` or ``transform.outMode`` is not\n    supported by pyCMSdll or the profiles you used for the transform, a",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "buildProofTransformFromOpenProfiles",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "peekOfCode": "buildProofTransformFromOpenProfiles = buildProofTransform\ndef applyTransform(im, transform, inPlace=False):\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n    If ``im.mode != transform.inMode``, a :exc:`PyCMSError` is raised.\n    If ``inPlace`` is ``True`` and ``transform.inMode != transform.outMode``, a\n    :exc:`PyCMSError` is raised.\n    If ``im.mode``, ``transform.inMode`` or ``transform.outMode`` is not\n    supported by pyCMSdll or the profiles you used for the transform, a\n    :exc:`PyCMSError` is raised.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageCms",
        "documentation": {}
    },
    {
        "label": "getrgb",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "peekOfCode": "def getrgb(color):\n    \"\"\"\n     Convert a color string to an RGB or RGBA tuple. If the string cannot be\n     parsed, this function raises a :py:exc:`ValueError` exception.\n    .. versionadded:: 1.1.4\n    :param color: A color string\n    :return: ``(red, green, blue[, alpha])``\n    \"\"\"\n    if len(color) > 100:\n        msg = \"color specifier is too long\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "getcolor",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "peekOfCode": "def getcolor(color, mode):\n    \"\"\"\n    Same as :py:func:`~PIL.ImageColor.getrgb` for most modes. However, if\n    ``mode`` is HSV, converts the RGB value to a HSV value, or if ``mode`` is\n    not color or a palette image, converts the RGB value to a grayscale value.\n    If the string cannot be parsed, this function raises a :py:exc:`ValueError`\n    exception.\n    .. versionadded:: 1.1.4\n    :param color: A color string\n    :param mode: Convert result to this mode",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "colormap",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "peekOfCode": "colormap = {\n    # X11 colour table from https://drafts.csswg.org/css-color-4/, with\n    # gray/grey spelling issues fixed.  This is a superset of HTML 4.0\n    # colour names used in CSS 1.\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageColor",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "peekOfCode": "class ImageDraw:\n    font = None\n    def __init__(self, im, mode=None):\n        \"\"\"\n        Create a drawing instance.\n        :param im: The image to draw in.\n        :param mode: Optional mode to use for color values.  For RGB\n           images, this argument can be RGB or RGBA (to blend the\n           drawing into the image).  For all other modes, this argument\n           must be the same as the image mode.  If omitted, the mode",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "peekOfCode": "def Draw(im, mode=None):\n    \"\"\"\n    A simple 2D drawing interface for PIL images.\n    :param im: The image to draw in.\n    :param mode: Optional mode to use for color values.  For RGB\n       images, this argument can be RGB or RGBA (to blend the\n       drawing into the image).  For all other modes, this argument\n       must be the same as the image mode.  If omitted, the mode\n       defaults to the mode of the image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "getdraw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "peekOfCode": "def getdraw(im=None, hints=None):\n    \"\"\"\n    (Experimental) A more advanced 2D drawing interface for PIL images,\n    based on the WCK interface.\n    :param im: The image to draw in.\n    :param hints: An optional list of hints.\n    :returns: A (drawing context, drawing resource factory) tuple.\n    \"\"\"\n    # FIXME: this needs more work!\n    # FIXME: come up with a better 'hints' scheme.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "peekOfCode": "def floodfill(image, xy, value, border=None, thresh=0):\n    \"\"\"\n    (experimental) Fills a bounded region with a given color.\n    :param image: Target image.\n    :param xy: Seed position (a 2-item coordinate tuple). See\n        :ref:`coordinate-system`.\n    :param value: Fill color.\n    :param border: Optional border value.  If given, the region consists of\n        pixels with a color different from the border color.  If not given,\n        the region consists of pixels having the same color as the seed",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw",
        "documentation": {}
    },
    {
        "label": "Pen",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "peekOfCode": "class Pen:\n    \"\"\"Stores an outline color and width.\"\"\"\n    def __init__(self, color, width=1, opacity=255):\n        self.color = ImageColor.getrgb(color)\n        self.width = width\nclass Brush:\n    \"\"\"Stores a fill color\"\"\"\n    def __init__(self, color, opacity=255):\n        self.color = ImageColor.getrgb(color)\nclass Font:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Brush",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "peekOfCode": "class Brush:\n    \"\"\"Stores a fill color\"\"\"\n    def __init__(self, color, opacity=255):\n        self.color = ImageColor.getrgb(color)\nclass Font:\n    \"\"\"Stores a TrueType font and color\"\"\"\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Font",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "peekOfCode": "class Font:\n    \"\"\"Stores a TrueType font and color\"\"\"\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)\nclass Draw:\n    \"\"\"\n    (Experimental) WCK-style drawing interface\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "Draw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "peekOfCode": "class Draw:\n    \"\"\"\n    (Experimental) WCK-style drawing interface\n    \"\"\"\n    def __init__(self, image, size=None, color=None):\n        if not hasattr(image, \"im\"):\n            image = Image.new(image, size, color)\n        self.draw = ImageDraw.Draw(image)\n        self.image = image\n        self.transform = None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageDraw2",
        "documentation": {}
    },
    {
        "label": "_Enhance",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "peekOfCode": "class _Enhance:\n    def enhance(self, factor):\n        \"\"\"\n        Returns an enhanced image.\n        :param factor: A floating point value controlling the enhancement.\n                       Factor 1.0 always returns a copy of the original image,\n                       lower factors mean less color (brightness, contrast,\n                       etc), and higher values more. There are no restrictions\n                       on this value.\n        :rtype: :py:class:`~PIL.Image.Image`",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "peekOfCode": "class Color(_Enhance):\n    \"\"\"Adjust image color balance.\n    This class can be used to adjust the colour balance of an image, in\n    a manner similar to the controls on a colour TV set. An enhancement\n    factor of 0.0 gives a black and white image. A factor of 1.0 gives\n    the original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.intermediate_mode = \"L\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Contrast",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "peekOfCode": "class Contrast(_Enhance):\n    \"\"\"Adjust image contrast.\n    This class can be used to control the contrast of an image, similar\n    to the contrast control on a TV set. An enhancement factor of 0.0\n    gives a solid gray image. A factor of 1.0 gives the original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        mean = int(ImageStat.Stat(image.convert(\"L\")).mean[0] + 0.5)\n        self.degenerate = Image.new(\"L\", image.size, mean).convert(image.mode)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Brightness",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "peekOfCode": "class Brightness(_Enhance):\n    \"\"\"Adjust image brightness.\n    This class can be used to control the brightness of an image.  An\n    enhancement factor of 0.0 gives a black image. A factor of 1.0 gives the\n    original image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.degenerate = Image.new(image.mode, image.size, 0)\n        if \"A\" in image.getbands():",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "Sharpness",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "peekOfCode": "class Sharpness(_Enhance):\n    \"\"\"Adjust image sharpness.\n    This class can be used to adjust the sharpness of an image. An\n    enhancement factor of 0.0 gives a blurred image, a factor of 1.0 gives the\n    original image, and a factor of 2.0 gives a sharpened image.\n    \"\"\"\n    def __init__(self, image):\n        self.image = image\n        self.degenerate = image.filter(ImageFilter.SMOOTH)\n        if \"A\" in image.getbands():",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageEnhance",
        "documentation": {}
    },
    {
        "label": "_Tile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class _Tile(NamedTuple):\n    encoder_name: str\n    extents: tuple[int, int, int, int]\n    offset: int\n    args: tuple[Any, ...] | str | None\n#\n# --------------------------------------------------------------------\n# ImageFile base class\nclass ImageFile(Image.Image):\n    \"\"\"Base class for image file format handlers.\"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "ImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class ImageFile(Image.Image):\n    \"\"\"Base class for image file format handlers.\"\"\"\n    def __init__(self, fp=None, filename=None):\n        super().__init__()\n        self._min_frame = 0\n        self.custom_mimetype = None\n        self.tile = None\n        \"\"\" A list of tile descriptors, or ``None`` \"\"\"\n        self.readonly = 1  # until we know better\n        self.decoderconfig = ()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "StubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class StubImageFile(ImageFile):\n    \"\"\"\n    Base class for stub image loaders.\n    A stub loader is an image loader that can identify files of a\n    certain format, but relies on external code to load the file.\n    \"\"\"\n    def _open(self):\n        msg = \"StubImageFile subclass must implement _open\"\n        raise NotImplementedError(msg)\n    def load(self):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "Parser",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class Parser:\n    \"\"\"\n    Incremental image parser.  This class implements the standard\n    feed/close consumer interface.\n    \"\"\"\n    incremental = None\n    image = None\n    data = None\n    decoder = None\n    offset = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyCodecState",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class PyCodecState:\n    def __init__(self):\n        self.xsize = 0\n        self.ysize = 0\n        self.xoff = 0\n        self.yoff = 0\n    def extents(self):\n        return self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize\nclass PyCodec:\n    def __init__(self, mode, *args):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyCodec",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class PyCodec:\n    def __init__(self, mode, *args):\n        self.im = None\n        self.state = PyCodecState()\n        self.fd = None\n        self.mode = mode\n        self.init(args)\n    def init(self, args):\n        \"\"\"\n        Override to perform codec specific initialization",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class PyDecoder(PyCodec):\n    \"\"\"\n    Python implementation of a format decoder. Override this class and\n    add the decoding logic in the :meth:`decode` method.\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n    _pulls_fd = False\n    @property\n    def pulls_fd(self):\n        return self._pulls_fd",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "PyEncoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "class PyEncoder(PyCodec):\n    \"\"\"\n    Python implementation of a format encoder. Override this class and\n    add the decoding logic in the :meth:`encode` method.\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n    _pushes_fd = False\n    @property\n    def pushes_fd(self):\n        return self._pushes_fd",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "raise_oserror",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "def raise_oserror(error):\n    deprecate(\n        \"raise_oserror\",\n        12,\n        action=\"It is only useful for translating error codes returned by a codec's \"\n        \"decode() method, which ImageFile already does automatically.\",\n    )\n    raise _get_oserror(error, encoder=False)\ndef _tilesort(t):\n    # sort on offset",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "MAXBLOCK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "MAXBLOCK = 65536\nSAFEBLOCK = 1024 * 1024\nLOAD_TRUNCATED_IMAGES = False\n\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "SAFEBLOCK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "SAFEBLOCK = 1024 * 1024\nLOAD_TRUNCATED_IMAGES = False\n\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "LOAD_TRUNCATED_IMAGES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "LOAD_TRUNCATED_IMAGES = False\n\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\n\"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "ERRORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "peekOfCode": "ERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\n\"\"\"\nDict of known error codes returned from :meth:`.PyDecoder.decode`,\n:meth:`.PyEncoder.encode` :meth:`.PyEncoder.encode_to_pyfd` and",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFile",
        "documentation": {}
    },
    {
        "label": "Filter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class Filter:\n    pass\nclass MultibandFilter(Filter):\n    pass\nclass BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        return image.filter(*self.filterargs)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MultibandFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class MultibandFilter(Filter):\n    pass\nclass BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        return image.filter(*self.filterargs)\nclass Kernel(BuiltinFilter):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BuiltinFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class BuiltinFilter(MultibandFilter):\n    def filter(self, image):\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        return image.filter(*self.filterargs)\nclass Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel. The current version only\n    supports 3x3 and 5x5 integer and floating point kernels.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "Kernel",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel. The current version only\n    supports 3x3 and 5x5 integer and floating point kernels.\n    In the current version, kernels can only be applied to\n    \"L\" and \"RGB\" images.\n    :param size: Kernel size, given as (width, height). In the current\n                    version, this must be (3,3) or (5,5).\n    :param kernel: A sequence containing kernel weights. The kernel will\n                   be flipped vertically before being applied to the image.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "RankFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class RankFilter(Filter):\n    \"\"\"\n    Create a rank filter.  The rank filter sorts all pixels in\n    a window of the given size, and returns the ``rank``'th value.\n    :param size: The kernel size, in pixels.\n    :param rank: What pixel value to pick.  Use 0 for a min filter,\n                 ``size * size / 2`` for a median filter, ``size * size - 1``\n                 for a max filter, etc.\n    \"\"\"\n    name = \"Rank\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MedianFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class MedianFilter(RankFilter):\n    \"\"\"\n    Create a median filter. Picks the median pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Median\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = size * size // 2",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MinFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class MinFilter(RankFilter):\n    \"\"\"\n    Create a min filter.  Picks the lowest pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Min\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "MaxFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class MaxFilter(RankFilter):\n    \"\"\"\n    Create a max filter.  Picks the largest pixel value in a window with the\n    given size.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Max\"\n    def __init__(self, size=3):\n        self.size = size\n        self.rank = size * size - 1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "ModeFilter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class ModeFilter(Filter):\n    \"\"\"\n    Create a mode filter. Picks the most frequent pixel value in a box with the\n    given size.  Pixel values that occur only once or twice are ignored; if no\n    pixel value occurs more than twice, the original pixel value is preserved.\n    :param size: The kernel size, in pixels.\n    \"\"\"\n    name = \"Mode\"\n    def __init__(self, size=3):\n        self.size = size",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "GaussianBlur",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class GaussianBlur(MultibandFilter):\n    \"\"\"Blurs the image with a sequence of extended box filters, which\n    approximates a Gaussian kernel. For details on accuracy see\n    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>\n    :param radius: Standard deviation of the Gaussian kernel. Either a sequence of two\n                   numbers for x and y, or a single number for both.\n    \"\"\"\n    name = \"GaussianBlur\"\n    def __init__(self, radius=2):\n        self.radius = radius",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BoxBlur",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class BoxBlur(MultibandFilter):\n    \"\"\"Blurs the image by setting each pixel to the average value of the pixels\n    in a square box extending radius pixels in each direction.\n    Supports float radius of arbitrary size. Uses an optimized implementation\n    which runs in linear time relative to the size of the image\n    for any radius value.\n    :param radius: Size of the box in a direction. Either a sequence of two numbers for\n                   x and y, or a single number for both.\n                   Radius 0 does not blur, returns an identical image.\n                   Radius 1 takes 1 pixel in each direction, i.e. 9 pixels in total.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "UnsharpMask",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class UnsharpMask(MultibandFilter):\n    \"\"\"Unsharp mask filter.\n    See Wikipedia's entry on `digital unsharp masking`_ for an explanation of\n    the parameters.\n    :param radius: Blur Radius\n    :param percent: Unsharp strength, in percent\n    :param threshold: Threshold controls the minimum brightness change that\n      will be sharpened\n    .. _digital unsharp masking: https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "BLUR",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class BLUR(BuiltinFilter):\n    name = \"Blur\"\n    # fmt: off\n    filterargs = (5, 5), 16, 0, (\n        1, 1, 1, 1, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 1, 1, 1, 1,\n    )",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "CONTOUR",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class CONTOUR(BuiltinFilter):\n    name = \"Contour\"\n    # fmt: off\n    filterargs = (3, 3), 1, 255, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass DETAIL(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "DETAIL",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class DETAIL(BuiltinFilter):\n    name = \"Detail\"\n    # fmt: off\n    filterargs = (3, 3), 6, 0, (\n        0,  -1,  0,\n        -1, 10, -1,\n        0,  -1,  0,\n    )\n    # fmt: on\nclass EDGE_ENHANCE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EDGE_ENHANCE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class EDGE_ENHANCE(BuiltinFilter):\n    name = \"Edge-enhance\"\n    # fmt: off\n    filterargs = (3, 3), 2, 0, (\n        -1, -1, -1,\n        -1, 10, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass EDGE_ENHANCE_MORE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EDGE_ENHANCE_MORE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class EDGE_ENHANCE_MORE(BuiltinFilter):\n    name = \"Edge-enhance More\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass EMBOSS(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "EMBOSS",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class EMBOSS(BuiltinFilter):\n    name = \"Emboss\"\n    # fmt: off\n    filterargs = (3, 3), 1, 128, (\n        -1, 0, 0,\n        0,  1, 0,\n        0,  0, 0,\n    )\n    # fmt: on\nclass FIND_EDGES(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "FIND_EDGES",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class FIND_EDGES(BuiltinFilter):\n    name = \"Find Edges\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\nclass SHARPEN(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SHARPEN",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class SHARPEN(BuiltinFilter):\n    name = \"Sharpen\"\n    # fmt: off\n    filterargs = (3, 3), 16, 0, (\n        -2, -2, -2,\n        -2, 32, -2,\n        -2, -2, -2,\n    )\n    # fmt: on\nclass SMOOTH(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SMOOTH",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class SMOOTH(BuiltinFilter):\n    name = \"Smooth\"\n    # fmt: off\n    filterargs = (3, 3), 13, 0, (\n        1, 1, 1,\n        1, 5, 1,\n        1, 1, 1,\n    )\n    # fmt: on\nclass SMOOTH_MORE(BuiltinFilter):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "SMOOTH_MORE",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class SMOOTH_MORE(BuiltinFilter):\n    name = \"Smooth More\"\n    # fmt: off\n    filterargs = (5, 5), 100, 0, (\n        1, 1,  1, 1, 1,\n        1, 5,  5, 5, 1,\n        1, 5, 44, 5, 1,\n        1, 5,  5, 5, 1,\n        1, 1,  1, 1, 1,\n    )",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "Color3DLUT",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "peekOfCode": "class Color3DLUT(MultibandFilter):\n    \"\"\"Three-dimensional color lookup table.\n    Transforms 3-channel pixels using the values of the channels as coordinates\n    in the 3D lookup table and interpolating the nearest elements.\n    This method allows you to apply almost any color transformation\n    in constant time by using pre-calculated decimated tables.\n    .. versionadded:: 5.2.0\n    :param size: Size of the table. One int or tuple of (int, int, int).\n                 Minimal size in any dimension is 2, maximum is 65.\n    :param table: Flat lookup table. A list of ``channels * size**3``",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFilter",
        "documentation": {}
    },
    {
        "label": "Layout",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "class Layout(IntEnum):\n    BASIC = 0\n    RAQM = 1\nMAX_STRING_LENGTH = 1_000_000\ntry:\n    from . import _imagingft as core\nexcept ImportError as ex:\n    from ._util import DeferredError\n    core = DeferredError.new(ex)\ndef _string_length_check(text):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "class ImageFont:\n    \"\"\"PIL font wrapper\"\"\"\n    def _load_pilfont(self, filename):\n        with open(filename, \"rb\") as fp:\n            image = None\n            for ext in (\".png\", \".gif\", \".pbm\"):\n                if image:\n                    image.close()\n                try:\n                    fullname = os.path.splitext(filename)[0] + ext",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "FreeTypeFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "class FreeTypeFont:\n    \"\"\"FreeType font wrapper (requires _imagingft service)\"\"\"\n    def __init__(\n        self,\n        font: bytes | str | Path | BinaryIO | None = None,\n        size: float = 10,\n        index: int = 0,\n        encoding: str = \"\",\n        layout_engine: Layout | None = None,\n    ) -> None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "TransposedFont",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "class TransposedFont:\n    \"\"\"Wrapper for writing rotated or mirrored text\"\"\"\n    def __init__(self, font, orientation=None):\n        \"\"\"\n        Wrapper that creates a transposed font from any existing font\n        object.\n        :param font: A font object.\n        :param orientation: An optional orientation.  If given, this should\n            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,\n            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "def load(filename):\n    \"\"\"\n    Load a font file.  This function loads a font object from the given\n    bitmap font file, and returns the corresponding font object.\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    f = ImageFont()\n    f._load_pilfont(filename)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "truetype",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "def truetype(font=None, size=10, index=0, encoding=\"\", layout_engine=None):\n    \"\"\"\n    Load a TrueType or OpenType font from a file or file-like object,\n    and create a font object.\n    This function loads a font object from the given file or file-like\n    object, and creates a font object for a font of the given size.\n    Pillow uses FreeType to open font files. On Windows, be aware that FreeType\n    will keep the file open as long as the FreeTypeFont object exists. Windows\n    limits the number of files that can be open in C at once to 512, so if many\n    fonts are opened simultaneously and that limit is approached, an",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load_path",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "def load_path(filename):\n    \"\"\"\n    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a\n    bitmap font along the Python path.\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    for directory in sys.path:\n        if is_directory(directory):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "load_default",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "def load_default(size=None):\n    \"\"\"If FreeType support is available, load a version of Aileron Regular,\n    https://dotcolon.net/font/aileron, with a more limited character set.\n    Otherwise, load a \"better than nothing\" font.\n    .. versionadded:: 1.1.4\n    :param size: The font size of Aileron Regular.\n        .. versionadded:: 10.1.0\n    :return: A font object.\n    \"\"\"\n    if core.__class__.__name__ == \"module\" or size is not None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "MAX_STRING_LENGTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "peekOfCode": "MAX_STRING_LENGTH = 1_000_000\ntry:\n    from . import _imagingft as core\nexcept ImportError as ex:\n    from ._util import DeferredError\n    core = DeferredError.new(ex)\ndef _string_length_check(text):\n    if MAX_STRING_LENGTH is not None and len(text) > MAX_STRING_LENGTH:\n        msg = \"too many characters in string\"\n        raise ValueError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageFont",
        "documentation": {}
    },
    {
        "label": "grab",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "peekOfCode": "def grab(bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None):\n    if xdisplay is None:\n        if sys.platform == \"darwin\":\n            fh, filepath = tempfile.mkstemp(\".png\")\n            os.close(fh)\n            args = [\"screencapture\"]\n            if bbox:\n                left, top, right, bottom = bbox\n                args += [\"-R\", f\"{left},{top},{right-left},{bottom-top}\"]\n            subprocess.call(args + [\"-x\", filepath])",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "documentation": {}
    },
    {
        "label": "grabclipboard",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "peekOfCode": "def grabclipboard():\n    if sys.platform == \"darwin\":\n        fh, filepath = tempfile.mkstemp(\".png\")\n        os.close(fh)\n        commands = [\n            'set theFile to (open for access POSIX file \"'\n            + filepath\n            + '\" with write permission)',\n            \"try\",\n            \"    write (the clipboard as «class PNGf») to theFile\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageGrab",
        "documentation": {}
    },
    {
        "label": "_Operand",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "class _Operand:\n    \"\"\"Wraps an image operand, providing standard operators\"\"\"\n    def __init__(self, im):\n        self.im = im\n    def __fixup(self, im1):\n        # convert image to suitable mode\n        if isinstance(im1, _Operand):\n            # argument was an image.\n            if im1.im.mode in (\"1\", \"L\"):\n                return im1.im.convert(\"I\")",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_int",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_int(self):\n    return _Operand(self.im.convert(\"I\"))\ndef imagemath_float(self):\n    return _Operand(self.im.convert(\"F\"))\n# logical\ndef imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_float",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_float(self):\n    return _Operand(self.im.convert(\"F\"))\n# logical\ndef imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_equal",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_equal(self, other):\n    return self.apply(\"eq\", self, other, mode=\"I\")\ndef imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_notequal",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_notequal(self, other):\n    return self.apply(\"ne\", self, other, mode=\"I\")\ndef imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_min",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_min(self, other):\n    return self.apply(\"min\", self, other)\ndef imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_max",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_max(self, other):\n    return self.apply(\"max\", self, other)\ndef imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "imagemath_convert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def imagemath_convert(self, mode):\n    return _Operand(self.im.convert(mode))\nops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "eval",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "def eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "ops",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "peekOfCode": "ops = {}\nfor k, v in list(globals().items()):\n    if k[:10] == \"imagemath_\":\n        ops[k[10:]] = v\ndef eval(expression, _dict={}, **kw):\n    \"\"\"\n    Evaluates an image expression.\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMath",
        "documentation": {}
    },
    {
        "label": "ModeDescriptor",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "peekOfCode": "class ModeDescriptor:\n    \"\"\"Wrapper for mode strings.\"\"\"\n    def __init__(\n        self,\n        mode: str,\n        bands: tuple[str, ...],\n        basemode: str,\n        basetype: str,\n        typestr: str,\n    ) -> None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "documentation": {}
    },
    {
        "label": "getmode",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "peekOfCode": "def getmode(mode: str) -> ModeDescriptor:\n    \"\"\"Gets a mode descriptor for the given mode.\"\"\"\n    # initialize mode cache\n    endian = \"<\" if sys.byteorder == \"little\" else \">\"\n    modes = {\n        # core modes\n        # Bits need to be extended to bytes\n        \"1\": (\"L\", \"L\", (\"1\",), \"|b1\"),\n        \"L\": (\"L\", \"L\", (\"L\",), \"|u1\"),\n        \"I\": (\"L\", \"I\", (\"I\",), endian + \"i4\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMode",
        "documentation": {}
    },
    {
        "label": "LutBuilder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "peekOfCode": "class LutBuilder:\n    \"\"\"A class for building a MorphLut from a descriptive language\n    The input patterns is a list of a strings sequences like these::\n        4:(...\n           .1.\n           111)->1\n    (whitespaces including linebreaks are ignored). The option 4\n    describes a series of symmetry operations (in this case a\n    4-rotation), the pattern is described by:\n    - . or X - Ignore",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "MorphOp",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "peekOfCode": "class MorphOp:\n    \"\"\"A class for binary morphological operators\"\"\"\n    def __init__(self, lut=None, op_name=None, patterns=None):\n        \"\"\"Create a binary morphological operator\"\"\"\n        self.lut = lut\n        if op_name is not None:\n            self.lut = LutBuilder(op_name=op_name).build_lut()\n        elif patterns is not None:\n            self.lut = LutBuilder(patterns=patterns).build_lut()\n    def apply(self, image):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "LUT_SIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "peekOfCode": "LUT_SIZE = 1 << 9\n# fmt: off\nROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "ROTATION_MATRIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "peekOfCode": "ROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "MIRROR_MATRIX",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "peekOfCode": "MIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]\n# fmt: on\nclass LutBuilder:\n    \"\"\"A class for building a MorphLut from a descriptive language\n    The input patterns is a list of a strings sequences like these::\n        4:(...",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageMorph",
        "documentation": {}
    },
    {
        "label": "autocontrast",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def autocontrast(image, cutoff=0, ignore=None, mask=None, preserve_tone=False):\n    \"\"\"\n    Maximize (normalize) image contrast. This function calculates a\n    histogram of the input image (or mask region), removes ``cutoff`` percent of the\n    lightest and darkest pixels from the histogram, and remaps the image\n    so that the darkest pixel becomes black (0), and the lightest\n    becomes white (255).\n    :param image: The image to process.\n    :param cutoff: The percent to cut off from the histogram on the low and\n                   high ends. Either a tuple of (low, high), or a single",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def colorize(image, black, white, mid=None, blackpoint=0, whitepoint=255, midpoint=127):\n    \"\"\"\n    Colorize grayscale image.\n    This function calculates a color wedge which maps all black pixels in\n    the source image to the first color and all white pixels to the\n    second color. If ``mid`` is specified, it uses three-color mapping.\n    The ``black`` and ``white`` arguments should be RGB tuples or color names;\n    optionally you can use three-color mapping by also specifying ``mid``.\n    Mapping positions for any of the colors can be specified\n    (e.g. ``blackpoint``), where these parameters are the integer",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "contain",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def contain(image, size, method=Image.Resampling.BICUBIC):\n    \"\"\"\n    Returns a resized version of the image, set to the maximum width and height\n    within the requested size, while maintaining the original aspect ratio.\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "cover",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def cover(image, size, method=Image.Resampling.BICUBIC):\n    \"\"\"\n    Returns a resized version of the image, so that the requested size is\n    covered, while maintaining the original aspect ratio.\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def pad(image, size, method=Image.Resampling.BICUBIC, color=None, centering=(0.5, 0.5)):\n    \"\"\"\n    Returns a resized and padded version of the image, expanded to fill the\n    requested aspect ratio and size.\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "crop",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def crop(image, border=0):\n    \"\"\"\n    Remove border from image.  The same amount of pixels are removed\n    from all four sides.  This function works on all image modes.\n    .. seealso:: :py:meth:`~PIL.Image.Image.crop`\n    :param image: The image to crop.\n    :param border: The number of pixels to remove.\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "scale",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def scale(image, factor, resample=Image.Resampling.BICUBIC):\n    \"\"\"\n    Returns a rescaled image by a specific factor given in parameter.\n    A factor greater than 1 expands the image, between 0 and 1 contracts the\n    image.\n    :param image: The image to rescale.\n    :param factor: The expansion factor, as a float.\n    :param resample: Resampling method to use. Default is\n                     :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                     See :ref:`concept-filters`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "deform",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def deform(image, deformer, resample=Image.Resampling.BILINEAR):\n    \"\"\"\n    Deform the image.\n    :param image: The image to deform.\n    :param deformer: A deformer object.  Any object that implements a\n                    ``getmesh`` method can be used.\n    :param resample: An optional resampling filter. Same values possible as\n       in the PIL.Image.transform function.\n    :return: An image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "equalize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def equalize(image, mask=None):\n    \"\"\"\n    Equalize the image histogram. This function applies a non-linear\n    mapping to the input image, in order to create a uniform\n    distribution of grayscale values in the output image.\n    :param image: The image to equalize.\n    :param mask: An optional mask.  If given, only the pixels selected by\n                 the mask are included in the analysis.\n    :return: An image.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "expand",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def expand(image, border=0, fill=0):\n    \"\"\"\n    Add border to the image\n    :param image: The image to expand.\n    :param border: Border width, in pixels.\n    :param fill: Pixel fill value (a color value).  Default is 0 (black).\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    width = left + image.size[0] + right",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "fit",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def fit(image, size, method=Image.Resampling.BICUBIC, bleed=0.0, centering=(0.5, 0.5)):\n    \"\"\"\n    Returns a resized and cropped version of the image, cropped to the\n    requested aspect ratio and size.\n    This function was contributed by Kevin Cazabon.\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "flip",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def flip(image):\n    \"\"\"\n    Flip the image vertically (top to bottom).\n    :param image: The image to flip.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_TOP_BOTTOM)\ndef grayscale(image):\n    \"\"\"\n    Convert the image to grayscale.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "grayscale",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def grayscale(image):\n    \"\"\"\n    Convert the image to grayscale.\n    :param image: The image to convert.\n    :return: An image.\n    \"\"\"\n    return image.convert(\"L\")\ndef invert(image):\n    \"\"\"\n    Invert (negate) the image.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "invert",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def invert(image):\n    \"\"\"\n    Invert (negate) the image.\n    :param image: The image to invert.\n    :return: An image.\n    \"\"\"\n    lut = list(range(255, -1, -1))\n    return image.point(lut) if image.mode == \"1\" else _lut(image, lut)\ndef mirror(image):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "mirror",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def mirror(image):\n    \"\"\"\n    Flip image horizontally (left to right).\n    :param image: The image to mirror.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\ndef posterize(image, bits):\n    \"\"\"\n    Reduce the number of bits for each color channel.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "posterize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def posterize(image, bits):\n    \"\"\"\n    Reduce the number of bits for each color channel.\n    :param image: The image to posterize.\n    :param bits: The number of bits to keep for each channel (1-8).\n    :return: An image.\n    \"\"\"\n    mask = ~(2 ** (8 - bits) - 1)\n    lut = [i & mask for i in range(256)]\n    return _lut(image, lut)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "solarize",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def solarize(image, threshold=128):\n    \"\"\"\n    Invert all pixel values above a threshold.\n    :param image: The image to solarize.\n    :param threshold: All pixels above this grayscale level are inverted.\n    :return: An image.\n    \"\"\"\n    lut = []\n    for i in range(256):\n        if i < threshold:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "exif_transpose",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "peekOfCode": "def exif_transpose(image, *, in_place=False):\n    \"\"\"\n    If an image has an EXIF Orientation tag, other than 1, transpose the image\n    accordingly, and remove the orientation data.\n    :param image: The image to transpose.\n    :param in_place: Boolean. Keyword-only argument.\n        If ``True``, the original image is modified in-place, and ``None`` is returned.\n        If ``False`` (default), a new :py:class:`~PIL.Image.Image` object is returned\n        with the transposition applied. If there is no transposition, a copy of the\n        image will be returned.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageOps",
        "documentation": {}
    },
    {
        "label": "ImagePalette",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "class ImagePalette:\n    \"\"\"\n    Color palette for palette mapped images\n    :param mode: The mode to use for the palette. See:\n        :ref:`concept-modes`. Defaults to \"RGB\"\n    :param palette: An optional palette. If given, it must be a bytearray,\n        an array or a list of ints between 0-255. The list must consist of\n        all channels for one color followed by the next color (e.g. RGBRGBRGB).\n        Defaults to an empty palette.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "raw",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def raw(rawmode, data):\n    palette = ImagePalette()\n    palette.rawmode = rawmode\n    palette.palette = data\n    palette.dirty = 1\n    return palette\n# --------------------------------------------------------------------\n# Factories\ndef make_linear_lut(black, white):\n    if black == 0:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "make_linear_lut",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def make_linear_lut(black, white):\n    if black == 0:\n        return [white * i // 255 for i in range(256)]\n    msg = \"unavailable when black is non-zero\"\n    raise NotImplementedError(msg)  # FIXME\ndef make_gamma_lut(exp):\n    return [int(((i / 255.0) ** exp) * 255.0 + 0.5) for i in range(256)]\ndef negative(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    palette.reverse()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "make_gamma_lut",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def make_gamma_lut(exp):\n    return [int(((i / 255.0) ** exp) * 255.0 + 0.5) for i in range(256)]\ndef negative(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    palette.reverse()\n    return ImagePalette(mode, [i // len(mode) for i in palette])\ndef random(mode=\"RGB\"):\n    from random import randint\n    palette = [randint(0, 255) for _ in range(256 * len(mode))]\n    return ImagePalette(mode, palette)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "negative",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def negative(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    palette.reverse()\n    return ImagePalette(mode, [i // len(mode) for i in palette])\ndef random(mode=\"RGB\"):\n    from random import randint\n    palette = [randint(0, 255) for _ in range(256 * len(mode))]\n    return ImagePalette(mode, palette)\ndef sepia(white=\"#fff0c0\"):\n    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def random(mode=\"RGB\"):\n    from random import randint\n    palette = [randint(0, 255) for _ in range(256 * len(mode))]\n    return ImagePalette(mode, palette)\ndef sepia(white=\"#fff0c0\"):\n    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]\n    return ImagePalette(\"RGB\", [bands[i % 3][i // 3] for i in range(256 * 3)])\ndef wedge(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    return ImagePalette(mode, [i // len(mode) for i in palette])",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "sepia",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def sepia(white=\"#fff0c0\"):\n    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]\n    return ImagePalette(\"RGB\", [bands[i % 3][i // 3] for i in range(256 * 3)])\ndef wedge(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    return ImagePalette(mode, [i // len(mode) for i in palette])\ndef load(filename):\n    # FIXME: supports GIMP gradients only\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "wedge",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def wedge(mode=\"RGB\"):\n    palette = list(range(256 * len(mode)))\n    return ImagePalette(mode, [i // len(mode) for i in palette])\ndef load(filename):\n    # FIXME: supports GIMP gradients only\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "peekOfCode": "def load(filename):\n    # FIXME: supports GIMP gradients only\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,\n        ]:\n            try:\n                fp.seek(0)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePalette",
        "documentation": {}
    },
    {
        "label": "Path",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImagePath",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImagePath",
        "peekOfCode": "Path = Image.core.path",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImagePath",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "peekOfCode": "class Iterator:\n    \"\"\"\n    This class implements an iterator object that can be used to loop\n    over an image sequence.\n    You can use the ``[]`` operator to access elements by index. This operator\n    will raise an :py:exc:`IndexError` if you try to access a nonexistent\n    frame.\n    :param im: An image object.\n    \"\"\"\n    def __init__(self, im: Image.Image):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "documentation": {}
    },
    {
        "label": "all_frames",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "peekOfCode": "def all_frames(\n    im: Image.Image | list[Image.Image],\n    func: Callable[[Image.Image], Image.Image] | None = None,\n) -> list[Image.Image]:\n    \"\"\"\n    Applies a given function to all frames in an image or a list of images.\n    The frames are returned as a list of separate images.\n    :param im: An image, or a list of images.\n    :param func: The function to apply to all of the image frames.\n    :returns: A list of images.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageSequence",
        "documentation": {}
    },
    {
        "label": "Viewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class Viewer:\n    \"\"\"Base class for viewers.\"\"\"\n    # main api\n    def show(self, image, **options):\n        \"\"\"\n        The main function for displaying an image.\n        Converts the given image to the target format and displays it.\n        \"\"\"\n        if not (\n            image.mode in (\"1\", \"RGBA\")",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "WindowsViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class WindowsViewer(Viewer):\n    \"\"\"The default viewer on Windows is the default system application for PNG files.\"\"\"\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n    def get_command(self, file, **options):\n        return (\n            f'start \"Pillow\" /WAIT \"{file}\" '\n            \"&& ping -n 4 127.0.0.1 >NUL \"\n            f'&& del /f \"{file}\"'\n        )",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "MacViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class MacViewer(Viewer):\n    \"\"\"The default viewer on macOS using ``Preview.app``.\"\"\"\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n    def get_command(self, file, **options):\n        # on darwin open returns immediately resulting in the temp\n        # file removal while app is opening\n        command = \"open -a Preview.app\"\n        command = f\"({command} {quote(file)}; sleep 20; rm -f {quote(file)})&\"\n        return command",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "UnixViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class UnixViewer(Viewer):\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n    def get_command(self, file, **options):\n        command = self.get_command_ex(file, **options)[0]\n        return f\"({command} {quote(file)}\"\nclass XDGViewer(UnixViewer):\n    \"\"\"\n    The freedesktop.org ``xdg-open`` command.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "XDGViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class XDGViewer(UnixViewer):\n    \"\"\"\n    The freedesktop.org ``xdg-open`` command.\n    \"\"\"\n    def get_command_ex(self, file, **options):\n        command = executable = \"xdg-open\"\n        return command, executable\n    def show_file(self, path, **options):\n        \"\"\"\n        Display given file.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "DisplayViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class DisplayViewer(UnixViewer):\n    \"\"\"\n    The ImageMagick ``display`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n    def get_command_ex(self, file, title=None, **options):\n        command = executable = \"display\"\n        if title:\n            command += f\" -title {quote(title)}\"\n        return command, executable",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "GmDisplayViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class GmDisplayViewer(UnixViewer):\n    \"\"\"The GraphicsMagick ``gm display`` command.\"\"\"\n    def get_command_ex(self, file, **options):\n        executable = \"gm\"\n        command = \"gm display\"\n        return command, executable\n    def show_file(self, path, **options):\n        \"\"\"\n        Display given file.\n        \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "EogViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class EogViewer(UnixViewer):\n    \"\"\"The GNOME Image Viewer ``eog`` command.\"\"\"\n    def get_command_ex(self, file, **options):\n        executable = \"eog\"\n        command = \"eog -n\"\n        return command, executable\n    def show_file(self, path, **options):\n        \"\"\"\n        Display given file.\n        \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "XVViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class XVViewer(UnixViewer):\n    \"\"\"\n    The X Viewer ``xv`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n    def get_command_ex(self, file, title=None, **options):\n        # note: xv is pretty outdated.  most modern systems have\n        # imagemagick's display command instead.\n        command = executable = \"xv\"\n        if title:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "IPythonViewer",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "class IPythonViewer(Viewer):\n    \"\"\"The viewer for IPython frontends.\"\"\"\n    def show_image(self, image, **options):\n        ipython_display(image)\n        return 1\ntry:\n    from IPython.display import display as ipython_display\nexcept ImportError:\n    pass\nelse:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "def register(viewer, order=1):\n    \"\"\"\n    The :py:func:`register` function is used to register additional viewers::\n        from PIL import ImageShow\n        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort\n        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised\n        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised\n    :param viewer: The viewer to be registered.\n    :param order:\n        Zero or a negative integer to prepend this viewer to the list,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "show",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "def show(image, title=None, **options):\n    r\"\"\"\n    Display a given image.\n    :param image: An image object.\n    :param title: Optional title. Not all viewers can display the title.\n    :param \\**options: Additional viewer options.\n    :returns: ``True`` if a suitable viewer was found, ``False`` otherwise.\n    \"\"\"\n    for viewer in _viewers:\n        if viewer.show(image, title=title, **options):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "_viewers",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "peekOfCode": "_viewers = []\ndef register(viewer, order=1):\n    \"\"\"\n    The :py:func:`register` function is used to register additional viewers::\n        from PIL import ImageShow\n        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort\n        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised\n        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised\n    :param viewer: The viewer to be registered.\n    :param order:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageShow",
        "documentation": {}
    },
    {
        "label": "Stat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "peekOfCode": "class Stat:\n    def __init__(self, image_or_list, mask=None):\n        try:\n            if mask:\n                self.h = image_or_list.histogram(mask)\n            else:\n                self.h = image_or_list.histogram()\n        except AttributeError:\n            self.h = image_or_list  # assume it to be a histogram list\n        if not isinstance(self.h, list):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "peekOfCode": "Global = Stat  # compatibility",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageStat",
        "documentation": {}
    },
    {
        "label": "Transform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "peekOfCode": "class Transform(Image.ImageTransformHandler):\n    method: Image.Transform\n    def __init__(self, data: Sequence[int]) -> None:\n        self.data = data\n    def getdata(self) -> tuple[int, Sequence[int]]:\n        return self.method, self.data\n    def transform(\n        self,\n        size: tuple[int, int],\n        image: Image.Image,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "AffineTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "peekOfCode": "class AffineTransform(Transform):\n    \"\"\"\n    Define an affine image transform.\n    This function takes a 6-tuple (a, b, c, d, e, f) which contain the first\n    two rows from an affine transform matrix. For each pixel (x, y) in the\n    output image, the new value is taken from a position (a x + b y + c,\n    d x + e y + f) in the input image, rounded to nearest pixel.\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n    See :py:meth:`~PIL.Image.Image.transform`",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "ExtentTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "peekOfCode": "class ExtentTransform(Transform):\n    \"\"\"\n    Define a transform to extract a subregion from an image.\n    Maps a rectangle (defined by two corners) from the image to a rectangle of\n    the given size. The resulting image will contain data sampled from between\n    the corners, such that (x0, y0) in the input image will end up at (0,0) in\n    the output image, and (x1, y1) at size.\n    This method can be used to crop, stretch, shrink, or mirror an arbitrary\n    rectangle in the current image. It is slightly slower than crop, but about\n    as fast as a corresponding resize operation.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "QuadTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "peekOfCode": "class QuadTransform(Transform):\n    \"\"\"\n    Define a quad image transform.\n    Maps a quadrilateral (a region defined by four corners) from the image to a\n    rectangle of the given size.\n    See :py:meth:`~PIL.Image.Image.transform`\n    :param xy: An 8-tuple (x0, y0, x1, y1, x2, y2, x3, y3) which contain the\n        upper left, lower left, lower right, and upper right corner of the\n        source quadrilateral.\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "MeshTransform",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "peekOfCode": "class MeshTransform(Transform):\n    \"\"\"\n    Define a mesh image transform.  A mesh transform consists of one or more\n    individual quad transforms.\n    See :py:meth:`~PIL.Image.Image.transform`\n    :param data: A list of (bbox, quad) tuples.\n    \"\"\"\n    method = Image.Transform.MESH",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageTransform",
        "documentation": {}
    },
    {
        "label": "HDC",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "peekOfCode": "class HDC:\n    \"\"\"\n    Wraps an HDC integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods.\n    \"\"\"\n    def __init__(self, dc):\n        self.dc = dc\n    def __int__(self):\n        return self.dc",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "HWND",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "peekOfCode": "class HWND:\n    \"\"\"\n    Wraps an HWND integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods, instead of a DC.\n    \"\"\"\n    def __init__(self, wnd):\n        self.wnd = wnd\n    def __int__(self):\n        return self.wnd",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "Dib",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "peekOfCode": "class Dib:\n    \"\"\"\n    A Windows bitmap with the given mode and size.  The mode can be one of \"1\",\n    \"L\", \"P\", or \"RGB\".\n    If the display requires a palette, this constructor creates a suitable\n    palette and associates it with the image. For an \"L\" image, 128 graylevels\n    are allocated. For an \"RGB\" image, a 6x6x6 colour cube is used, together\n    with 20 graylevels.\n    To make sure that palettes work properly under Windows, you must call the\n    ``palette`` method upon certain events from Windows.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "Window",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "peekOfCode": "class Window:\n    \"\"\"Create a Window with the given title size.\"\"\"\n    def __init__(self, title=\"PIL\", width=None, height=None):\n        self.hwnd = Image.core.createwindow(\n            title, self.__dispatcher, width or 0, height or 0\n        )\n    def __dispatcher(self, action, *args):\n        return getattr(self, \"ui_handle_\" + action)(*args)\n    def ui_handle_clear(self, dc, x0, y0, x1, y1):\n        pass",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "ImageWindow",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "peekOfCode": "class ImageWindow(Window):\n    \"\"\"Create an image window which displays the given image.\"\"\"\n    def __init__(self, image, title=\"PIL\"):\n        if not isinstance(image, Dib):\n            image = Dib(image)\n        self.image = image\n        width, height = image.size\n        super().__init__(title, width=width, height=height)\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        self.image.draw(dc, (x0, y0, x1, y1))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImageWin",
        "documentation": {}
    },
    {
        "label": "ImtImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "peekOfCode": "class ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n    def _open(self):\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        buffer = self.fp.read(100)\n        if b\"\\n\" not in buffer:\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "peekOfCode": "field = re.compile(rb\"([a-z]*) ([^ \\r\\n]*)\")\n##\n# Image plugin for IM Tools images.\nclass ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n    def _open(self):\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n        buffer = self.fp.read(100)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.ImtImagePlugin",
        "documentation": {}
    },
    {
        "label": "IptcImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "peekOfCode": "class IptcImageFile(ImageFile.ImageFile):\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n    def getint(self, key: tuple[int, int]) -> int:\n        return _i(self.info[key])\n    def field(self) -> tuple[tuple[int, int] | None, int]:\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not s.strip(b\"\\x00\"):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "peekOfCode": "def i(c: bytes) -> int:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.i\", 12)\n    return _i(c)\ndef dump(c: Sequence[int | bytes]) -> None:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.dump\", 12)\n    for i in c:\n        print(\"%02x\" % _i8(i), end=\" \")\n    print()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "peekOfCode": "def dump(c: Sequence[int | bytes]) -> None:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.dump\", 12)\n    for i in c:\n        print(\"%02x\" % _i8(i), end=\" \")\n    print()\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\nclass IptcImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "getiptcinfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "peekOfCode": "def getiptcinfo(im):\n    \"\"\"\n    Get IPTC information from TIFF, JPEG, or IPTC file.\n    :param im: An image containing IPTC data.\n    :returns: A dictionary containing IPTC information, or None if\n        no IPTC information block was found.\n    \"\"\"\n    from . import JpegImagePlugin, TiffImagePlugin\n    data = None\n    if isinstance(im, IptcImageFile):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "peekOfCode": "COMPRESSION = {1: \"raw\", 5: \"jpeg\"}\ndef __getattr__(name: str) -> bytes:\n    if name == \"PAD\":\n        deprecate(\"IptcImagePlugin.PAD\", 12)\n        return b\"\\0\\0\\0\\0\"\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n#\n# Helpers\ndef _i(c: bytes) -> int:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.IptcImagePlugin",
        "documentation": {}
    },
    {
        "label": "BoxReader",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "peekOfCode": "class BoxReader:\n    \"\"\"\n    A small helper class to read fields stored in JPEG2000 header boxes\n    and to easily step into and read sub-boxes.\n    \"\"\"\n    def __init__(self, fp, length=-1):\n        self.fp = fp\n        self.has_length = length >= 0\n        self.length = length\n        self.remaining_in_box = -1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "documentation": {}
    },
    {
        "label": "Jpeg2KImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "peekOfCode": "class Jpeg2KImageFile(ImageFile.ImageFile):\n    format = \"JPEG2000\"\n    format_description = \"JPEG 2000 (ISO 15444)\"\n    def _open(self):\n        sig = self.fp.read(4)\n        if sig == b\"\\xff\\x4f\\xff\\x51\":\n            self.codec = \"j2k\"\n            self._size, self._mode = _parse_codestream(self.fp)\n        else:\n            sig = sig + self.fp.read(8)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.Jpeg2KImagePlugin",
        "documentation": {}
    },
    {
        "label": "JpegImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "class JpegImageFile(ImageFile.ImageFile):\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n    def _open(self):\n        s = self.fp.read(3)\n        if not _accept(s):\n            msg = \"not a JPEG file\"\n            raise SyntaxError(msg)\n        s = b\"\\xFF\"\n        # Create attributes",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "Skip",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def Skip(self, marker):\n    n = i16(self.fp.read(2)) - 2\n    ImageFile._safe_read(self.fp, n)\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    app = \"APP%d\" % (marker & 15)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "APP",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    app = \"APP%d\" % (marker & 15)\n    self.app[app] = s  # compatibility\n    self.applist.append((app, s))\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "COM",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def COM(self, marker):\n    #\n    # Comment marker.  Store these in the APP dictionary.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self.info[\"comment\"] = s\n    self.app[\"COM\"] = s  # compatibility\n    self.applist.append((\"COM\", s))\ndef SOF(self, marker):\n    #",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "SOF",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def SOF(self, marker):\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self._size = i16(s, 3), i16(s, 1)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "DQT",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def DQT(self, marker):\n    #\n    # Define quantization table.  Note that there might be more\n    # than one table in each marker.\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):\n        v = s[0]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "get_sampling",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def get_sampling(im):\n    # There's no subsampling when images have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to the default value.\n    #\n    # NOTE: currently Pillow can't encode JPEG to YCCK format.\n    # If YCCK support is added in the future, subsampling code will have\n    # to be updated (here and in JpegEncode.c) to deal with 4 layers.\n    if not hasattr(im, \"layers\") or im.layers in (1, 4):\n        return -1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "jpeg_factory",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "def jpeg_factory(fp=None, filename=None):\n    im = JpegImageFile(fp, filename)\n    try:\n        mpheader = im._getmp()\n        if mpheader[45057] > 1:\n            # It's actually an MPO\n            from .MpoImagePlugin import MpoImageFile\n            # Don't reload everything, just convert it.\n            im = MpoImageFile.adopt(im, mpheader)\n    except (TypeError, IndexError):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MARKER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "MARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "RAWMODE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "RAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\",  # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n# fmt: off\nzigzag_index = (",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "zigzag_index",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "zigzag_index = (\n    0,  1,  5,  6, 14, 15, 27, 28,\n    2,  4,  7, 13, 16, 26, 29, 42,\n    3,  8, 12, 17, 25, 30, 41, 43,\n    9, 11, 18, 24, 31, 40, 44, 53,\n    10, 19, 23, 32, 39, 45, 52, 54,\n    20, 22, 33, 38, 46, 51, 55, 60,\n    21, 34, 37, 47, 50, 56, 59, 61,\n    35, 36, 48, 49, 57, 58, 62, 63,\n)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "samplings",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "peekOfCode": "samplings = {\n    (1, 1, 1, 1, 1, 1): 0,\n    (2, 1, 1, 1, 1, 1): 1,\n    (2, 2, 1, 1, 1, 1): 2,\n}\n# fmt: on\ndef get_sampling(im):\n    # There's no subsampling when images have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to the default value.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "presets",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.JpegPresets",
        "description": "catboost.contrib.python.Pillow.py3.PIL.JpegPresets",
        "peekOfCode": "presets = {\n            'web_low':      {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [20, 16, 25, 39, 50, 46, 62, 68,\n                                16, 18, 23, 38, 38, 53, 65, 68,\n                                25, 23, 31, 38, 53, 65, 68, 68,\n                                39, 38, 38, 53, 65, 68, 68, 68,\n                                50, 38, 53, 65, 68, 68, 68, 68,\n                                46, 53, 65, 68, 68, 68, 68, 68,\n                                62, 65, 68, 68, 68, 68, 68, 68,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.JpegPresets",
        "documentation": {}
    },
    {
        "label": "McIdasImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.McIdasImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.McIdasImagePlugin",
        "peekOfCode": "class McIdasImageFile(ImageFile.ImageFile):\n    format = \"MCIDAS\"\n    format_description = \"McIdas area file\"\n    def _open(self):\n        # parse area file directory\n        s = self.fp.read(256)\n        if not _accept(s) or len(s) != 256:\n            msg = \"not an McIdas area file\"\n            raise SyntaxError(msg)\n        self.area_descriptor_raw = s",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.McIdasImagePlugin",
        "documentation": {}
    },
    {
        "label": "MicImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MicImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MicImagePlugin",
        "peekOfCode": "class MicImageFile(TiffImagePlugin.TiffImageFile):\n    format = \"MIC\"\n    format_description = \"Microsoft Image Composer\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # read the OLE directory and see if this is a likely\n        # to be a Microsoft Image Composer file\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MicImagePlugin",
        "documentation": {}
    },
    {
        "label": "BitStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "peekOfCode": "class BitStream:\n    def __init__(self, fp):\n        self.fp = fp\n        self.bits = 0\n        self.bitbuffer = 0\n    def next(self):\n        return i8(self.fp.read(1))\n    def peek(self, bits):\n        while self.bits < bits:\n            c = self.next()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MpegImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "peekOfCode": "class MpegImageFile(ImageFile.ImageFile):\n    format = \"MPEG\"\n    format_description = \"MPEG\"\n    def _open(self):\n        s = BitStream(self.fp)\n        if s.read(32) != 0x1B3:\n            msg = \"not an MPEG file\"\n            raise SyntaxError(msg)\n        self._mode = \"RGB\"\n        self._size = s.read(12), s.read(12)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MpegImagePlugin",
        "documentation": {}
    },
    {
        "label": "MpoImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MpoImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MpoImagePlugin",
        "peekOfCode": "class MpoImageFile(JpegImagePlugin.JpegImageFile):\n    format = \"MPO\"\n    format_description = \"MPO (CIPA DC-007)\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        self.fp.seek(0)  # prep the fp in order to pass the JPEG test\n        JpegImagePlugin.JpegImageFile._open(self)\n        self._after_jpeg_open()\n    def _after_jpeg_open(self, mpheader=None):\n        self._initial_size = self.size",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MpoImagePlugin",
        "documentation": {}
    },
    {
        "label": "MspImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "peekOfCode": "class MspImageFile(ImageFile.ImageFile):\n    format = \"MSP\"\n    format_description = \"Windows Paint\"\n    def _open(self):\n        # Header\n        s = self.fp.read(32)\n        if not _accept(s):\n            msg = \"not an MSP file\"\n            raise SyntaxError(msg)\n        # Header checksum",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "documentation": {}
    },
    {
        "label": "MspDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "peekOfCode": "class MspDecoder(ImageFile.PyDecoder):\n    # The algo for the MSP decoder is from\n    # https://www.fileformat.info/format/mspaint/egff.htm\n    # cc-by-attribution -- That page references is taken from the\n    # Encyclopedia of Graphics File Formats and is licensed by\n    # O'Reilly under the Creative Common/Attribution license\n    #\n    # For RLE encoded files, the 32byte header is followed by a scan\n    # line map, encoded as one 16bit word of encoded byte length per\n    # line.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.MspImagePlugin",
        "documentation": {}
    },
    {
        "label": "PSDraw",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "peekOfCode": "class PSDraw:\n    \"\"\"\n    Sets up printing to the given file. If ``fp`` is omitted,\n    ``sys.stdout.buffer`` or ``sys.stdout`` is assumed.\n    \"\"\"\n    def __init__(self, fp=None):\n        if not fp:\n            try:\n                fp = sys.stdout.buffer\n            except AttributeError:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "EDROFF_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "peekOfCode": "EDROFF_PS = b\"\"\"\\\n/S { show } bind def\n/P { moveto show } bind def\n/M { moveto } bind def\n/X { 0 rmoveto } bind def\n/Y { 0 exch rmoveto } bind def\n/E {    findfont\n        dup maxlength dict begin\n        {\n                1 index /FID ne { def } { pop pop } ifelse",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "VDI_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "peekOfCode": "VDI_PS = b\"\"\"\\\n/Vm { moveto } bind def\n/Va { newpath arcn stroke } bind def\n/Vl { moveto lineto stroke } bind def\n/Vc { newpath 0 360 arc closepath } bind def\n/Vr {   exch dup 0 rlineto\n        exch dup 0 exch rlineto\n        exch neg 0 rlineto\n        0 exch neg rlineto\n        setgray fill } bind def",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "ERROR_PS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "peekOfCode": "ERROR_PS = b\"\"\"\\\n/landscape false def\n/errorBUF 200 string def\n/errorNL { currentpoint 10 sub exch pop 72 exch moveto } def\nerrordict begin /handleerror {\n    initmatrix /Courier findfont 10 scalefont setfont\n    newpath 72 720 moveto $error begin /newerror false def\n    (PostScript Error) show errorNL errorNL\n    (Error: ) show\n        /errorname load errorBUF cvs show errorNL errorNL",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PSDraw",
        "documentation": {}
    },
    {
        "label": "PaletteFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PaletteFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PaletteFile",
        "peekOfCode": "class PaletteFile:\n    \"\"\"File handler for Teragon-style palette files.\"\"\"\n    rawmode = \"RGB\"\n    def __init__(self, fp):\n        self.palette = [(i, i, i) for i in range(256)]\n        while True:\n            s = fp.readline()\n            if not s:\n                break\n            if s[:1] == b\"#\":",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PaletteFile",
        "documentation": {}
    },
    {
        "label": "build_prototype_image",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "peekOfCode": "def build_prototype_image():\n    image = Image.new(\"L\", (1, len(_Palm8BitColormapValues)))\n    image.putdata(list(range(len(_Palm8BitColormapValues))))\n    palettedata = ()\n    for colormapValue in _Palm8BitColormapValues:\n        palettedata += colormapValue\n    palettedata += (0, 0, 0) * (256 - len(_Palm8BitColormapValues))\n    image.putpalette(palettedata)\n    return image\nPalm8BitColormapImage = build_prototype_image()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_Palm8BitColormapValues",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "peekOfCode": "_Palm8BitColormapValues = (\n    (255, 255, 255), (255, 204, 255), (255, 153, 255), (255, 102, 255),\n    (255,  51, 255), (255,   0, 255), (255, 255, 204), (255, 204, 204),\n    (255, 153, 204), (255, 102, 204), (255,  51, 204), (255,   0, 204),\n    (255, 255, 153), (255, 204, 153), (255, 153, 153), (255, 102, 153),\n    (255,  51, 153), (255,   0, 153), (204, 255, 255), (204, 204, 255),\n    (204, 153, 255), (204, 102, 255), (204,  51, 255), (204,   0, 255),\n    (204, 255, 204), (204, 204, 204), (204, 153, 204), (204, 102, 204),\n    (204,  51, 204), (204,   0, 204), (204, 255, 153), (204, 204, 153),\n    (204, 153, 153), (204, 102, 153), (204,  51, 153), (204,   0, 153),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "Palm8BitColormapImage",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "peekOfCode": "Palm8BitColormapImage = build_prototype_image()\n# OK, we now have in Palm8BitColormapImage,\n# a \"P\"-mode image with the right palette\n#\n# --------------------------------------------------------------------\n_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_FLAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "peekOfCode": "_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##\n# (Internal) Image save plugin for the Palm format.\ndef _save(im, fp, filename):\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "_COMPRESSION_TYPES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "peekOfCode": "_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n#\n# --------------------------------------------------------------------\n##\n# (Internal) Image save plugin for the Palm format.\ndef _save(im, fp, filename):\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field\n        rawmode = \"P\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PalmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PcdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcdImagePlugin",
        "peekOfCode": "class PcdImageFile(ImageFile.ImageFile):\n    format = \"PCD\"\n    format_description = \"Kodak PhotoCD\"\n    def _open(self):\n        # rough\n        self.fp.seek(2048)\n        s = self.fp.read(2048)\n        if s[:4] != b\"PCD_\":\n            msg = \"not a PCD file\"\n            raise SyntaxError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcdImagePlugin",
        "documentation": {}
    },
    {
        "label": "PcfFontFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "class PcfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 PCF format.\"\"\"\n    name = \"name\"\n    def __init__(self, fp: BinaryIO, charset_encoding: str = \"iso8859-1\"):\n        self.charset_encoding = charset_encoding\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            msg = \"not a PCF file\"\n            raise SyntaxError(msg)\n        super().__init__()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "sz",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "def sz(s: bytes, o: int) -> bytes:\n    return s[o : s.index(b\"\\0\", o)]\nclass PcfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 PCF format.\"\"\"\n    name = \"name\"\n    def __init__(self, fp: BinaryIO, charset_encoding: str = \"iso8859-1\"):\n        self.charset_encoding = charset_encoding\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            msg = \"not a PCF file\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_MAGIC = 0x70636601  # \"\\x01fcp\"\nPCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_PROPERTIES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_ACCELERATORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_METRICS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BITMAPS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_INK_METRICS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BDF_ENCODINGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_SWIDTHS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s: bytes, o: int) -> bytes:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_GLYPH_NAMES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s: bytes, o: int) -> bytes:\n    return s[o : s.index(b\"\\0\", o)]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PCF_BDF_ACCELERATORS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "peekOfCode": "PCF_BDF_ACCELERATORS = 1 << 8\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\ndef sz(s: bytes, o: int) -> bytes:\n    return s[o : s.index(b\"\\0\", o)]\nclass PcfFontFile(FontFile.FontFile):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcfFontFile",
        "documentation": {}
    },
    {
        "label": "PcxImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "peekOfCode": "class PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n    def _open(self):\n        # header\n        s = self.fp.read(128)\n        if not _accept(s):\n            msg = \"not a PCX file\"\n            raise SyntaxError(msg)\n        # image",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef _accept(prefix):\n    return prefix[0] == 10 and prefix[1] in [0, 2, 3, 5]\n##\n# Image plugin for Paintbrush images.\nclass PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n    def _open(self):\n        # header",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "peekOfCode": "SAVE = {\n    # mode: (version, bits, planes, raw mode)\n    \"1\": (2, 1, 1, \"1\"),\n    \"L\": (5, 8, 1, \"L\"),\n    \"P\": (5, 8, 1, \"P\"),\n    \"RGB\": (5, 8, 3, \"RGB;L\"),\n}\ndef _save(im, fp, filename):\n    try:\n        version, bits, planes, rawmode = SAVE[im.mode]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PcxImagePlugin",
        "documentation": {}
    },
    {
        "label": "PdfFormatError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"\n    pass\ndef check_format_condition(condition, error_message):\n    if not condition:\n        raise PdfFormatError(error_message)\nclass IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "IndirectReference",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):\n    def __str__(self):\n        return f\"{self.object_id} {self.generation} R\"\n    def __bytes__(self):\n        return self.__str__().encode(\"us-ascii\")\n    def __eq__(self, other):\n        return (\n            other.__class__ is self.__class__",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "IndirectObjectDef",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class IndirectObjectDef(IndirectReference):\n    def __str__(self):\n        return f\"{self.object_id} {self.generation} obj\"\nclass XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n    def __setitem__(self, key, value):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "XrefTable",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n    def __setitem__(self, key, value):\n        if self.reading_finished:\n            self.new_entries[key] = value\n        else:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfName",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfName:\n    def __init__(self, name):\n        if isinstance(name, PdfName):\n            self.name = name.name\n        elif isinstance(name, bytes):\n            self.name = name\n        else:\n            self.name = name.encode(\"us-ascii\")\n    def name_as_str(self):\n        return self.name.decode(\"us-ascii\")",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfArray",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfArray(list):\n    def __bytes__(self):\n        return b\"[ \" + b\" \".join(pdf_repr(x) for x in self) + b\" ]\"\nclass PdfDict(collections.UserDict):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            collections.UserDict.__setattr__(self, key, value)\n        else:\n            self[key.encode(\"us-ascii\")] = value\n    def __getattr__(self, key):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfDict",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfDict(collections.UserDict):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            collections.UserDict.__setattr__(self, key, value)\n        else:\n            self[key.encode(\"us-ascii\")] = value\n    def __getattr__(self, key):\n        try:\n            value = self[key.encode(\"us-ascii\")]\n        except KeyError as e:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfBinary",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfBinary:\n    def __init__(self, data):\n        self.data = data\n    def __bytes__(self):\n        return b\"<%s>\" % b\"\".join(b\"%02X\" % b for b in self.data)\nclass PdfStream:\n    def __init__(self, dictionary, buf):\n        self.dictionary = dictionary\n        self.buf = buf\n    def decode(self):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfStream:\n    def __init__(self, dictionary, buf):\n        self.dictionary = dictionary\n        self.buf = buf\n    def decode(self):\n        try:\n            filter = self.dictionary.Filter\n        except AttributeError:\n            return self.buf\n        if filter == b\"FlateDecode\":",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PdfParser",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "class PdfParser:\n    \"\"\"Based on\n    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf\n    Supports PDF up to 1.4\n    \"\"\"\n    def __init__(self, filename=None, f=None, buf=None, start_offset=0, mode=\"rb\"):\n        if buf and f:\n            msg = \"specify buf or f or filename, but not both buf and f\"\n            raise RuntimeError(msg)\n        self.filename = filename",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "encode_text",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "def encode_text(s):\n    return codecs.BOM_UTF16_BE + s.encode(\"utf_16_be\")\nPDFDocEncoding = {\n    0x16: \"\\u0017\",\n    0x18: \"\\u02D8\",\n    0x19: \"\\u02C7\",\n    0x1A: \"\\u02C6\",\n    0x1B: \"\\u02D9\",\n    0x1C: \"\\u02DD\",\n    0x1D: \"\\u02DB\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "decode_text",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "def decode_text(b):\n    if b[: len(codecs.BOM_UTF16_BE)] == codecs.BOM_UTF16_BE:\n        return b[len(codecs.BOM_UTF16_BE) :].decode(\"utf_16_be\")\n    else:\n        return \"\".join(PDFDocEncoding.get(byte, chr(byte)) for byte in b)\nclass PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"\n    pass\ndef check_format_condition(condition, error_message):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "check_format_condition",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "def check_format_condition(condition, error_message):\n    if not condition:\n        raise PdfFormatError(error_message)\nclass IndirectReference(\n    collections.namedtuple(\"IndirectReferenceTuple\", [\"object_id\", \"generation\"])\n):\n    def __str__(self):\n        return f\"{self.object_id} {self.generation} R\"\n    def __bytes__(self):\n        return self.__str__().encode(\"us-ascii\")",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "pdf_repr",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "def pdf_repr(x):\n    if x is True:\n        return b\"true\"\n    elif x is False:\n        return b\"false\"\n    elif x is None:\n        return b\"null\"\n    elif isinstance(x, (PdfName, PdfDict, PdfArray, PdfBinary)):\n        return bytes(x)\n    elif isinstance(x, (int, float)):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PDFDocEncoding",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "peekOfCode": "PDFDocEncoding = {\n    0x16: \"\\u0017\",\n    0x18: \"\\u02D8\",\n    0x19: \"\\u02C7\",\n    0x1A: \"\\u02C6\",\n    0x1B: \"\\u02D9\",\n    0x1C: \"\\u02DD\",\n    0x1D: \"\\u02DB\",\n    0x1E: \"\\u02DA\",\n    0x1F: \"\\u02DC\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PdfParser",
        "documentation": {}
    },
    {
        "label": "PixarImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PixarImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PixarImagePlugin",
        "peekOfCode": "class PixarImageFile(ImageFile.ImageFile):\n    format = \"PIXAR\"\n    format_description = \"PIXAR raster image\"\n    def _open(self):\n        # assuming a 4-byte magic label\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a PIXAR file\"\n            raise SyntaxError(msg)\n        # read rest of header",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PixarImagePlugin",
        "documentation": {}
    },
    {
        "label": "Disposal",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class Disposal(IntEnum):\n    OP_NONE = 0\n    \"\"\"\n    No disposal is done on this frame before rendering the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_BACKGROUND = 1\n    \"\"\"\n    This frame’s modified region is cleared to fully transparent black before rendering\n    the next frame.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "Blend",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class Blend(IntEnum):\n    OP_SOURCE = 0\n    \"\"\"\n    All color components of this frame, including alpha, overwrite the previous output\n    image contents.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_OVER = 1\n    \"\"\"\n    This frame should be alpha composited with the previous output image contents.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "ChunkStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class ChunkStream:\n    def __init__(self, fp):\n        self.fp = fp\n        self.queue = []\n    def read(self):\n        \"\"\"Fetch a new chunk. Returns header information.\"\"\"\n        cid = None\n        if self.queue:\n            cid, pos, length = self.queue.pop()\n            self.fp.seek(pos)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "iTXt",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class iTXt(str):\n    \"\"\"\n    Subclass of string to allow iTXt chunks to look like strings while\n    keeping their extra information\n    \"\"\"\n    @staticmethod\n    def __new__(cls, text, lang=None, tkey=None):\n        \"\"\"\n        :param cls: the class to use when creating the instance\n        :param text: value for this key",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngInfo",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class PngInfo:\n    \"\"\"\n    PNG chunk container (for use with save(pnginfo=))\n    \"\"\"\n    def __init__(self):\n        self.chunks = []\n    def add(self, cid, data, after_idat=False):\n        \"\"\"Appends an arbitrary chunk. Use with caution.\n        :param cid: a byte string, 4 bytes long.\n        :param data: a byte string of the encoded data",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngStream",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class PngStream(ChunkStream):\n    def __init__(self, fp):\n        super().__init__(fp)\n        # local copies of Image attributes\n        self.im_info = {}\n        self.im_text = {}\n        self.im_size = (0, 0)\n        self.im_mode = None\n        self.im_tile = None\n        self.im_palette = None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PngImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class PngImageFile(ImageFile.ImageFile):\n    format = \"PNG\"\n    format_description = \"Portable network graphics\"\n    def _open(self):\n        if not _accept(self.fp.read(8)):\n            msg = \"not a PNG file\"\n            raise SyntaxError(msg)\n        self._fp = self.fp\n        self.__frame = 0\n        #",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_idat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class _idat:\n    # wrap output from the encoder in IDAT chunks\n    def __init__(self, fp, chunk):\n        self.fp = fp\n        self.chunk = chunk\n    def write(self, data):\n        self.chunk(self.fp, b\"IDAT\", data)\nclass _fdat:\n    # wrap encoder output in fdAT chunks\n    def __init__(self, fp, chunk, seq_num):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_fdat",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "class _fdat:\n    # wrap encoder output in fdAT chunks\n    def __init__(self, fp, chunk, seq_num):\n        self.fp = fp\n        self.chunk = chunk\n        self.seq_num = seq_num\n    def write(self, data):\n        self.chunk(self.fp, b\"fdAT\", o32(self.seq_num), data)\n        self.seq_num += 1\ndef _write_multiple_frames(im, fp, chunk, rawmode, default_image, append_images):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "putchunk",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "def putchunk(fp, cid, *data):\n    \"\"\"Write a PNG chunk (including CRC field)\"\"\"\n    data = b\"\".join(data)\n    fp.write(o32(len(data)) + cid)\n    fp.write(data)\n    crc = _crc32(data, _crc32(cid))\n    fp.write(o32(crc))\nclass _idat:\n    # wrap output from the encoder in IDAT chunks\n    def __init__(self, fp, chunk):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "getchunks",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "def getchunks(im, **params):\n    \"\"\"Return a list of PNG chunks representing this image.\"\"\"\n    class collector:\n        data = []\n        def write(self, data):\n            pass\n        def append(self, chunk):\n            self.data.append(chunk)\n    def append(fp, cid, *data):\n        data = b\"\".join(data)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "logger = logging.getLogger(__name__)\nis_cid = re.compile(rb\"\\w\\w\\w\\w\").match\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "is_cid",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "is_cid = re.compile(rb\"\\w\\w\\w\\w\").match\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),\n    # Truecolour",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I\", \"I;16B\"),\n    # Truecolour\n    (8, 2): (\"RGB\", \"RGB\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_simple_palette",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "_simple_palette = re.compile(b\"^\\xff*\\x00\\xff*$\")\nMAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n\"\"\"\nMaximum decompressed size for a iTXt or zTXt chunk.\nEliminates decompression bombs where compressed chunks can expand 1000x.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\n\"\"\"\nSet the maximum total text chunk size.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAX_TEXT_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "MAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n\"\"\"\nMaximum decompressed size for a iTXt or zTXt chunk.\nEliminates decompression bombs where compressed chunks can expand 1000x.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\n\"\"\"\nSet the maximum total text chunk size.\nSee :ref:`Text in PNG File Format<png-text>`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAX_TEXT_MEMORY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "MAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\n\"\"\"\nSet the maximum total text chunk size.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\n# APNG frame disposal modes\nclass Disposal(IntEnum):\n    OP_NONE = 0\n    \"\"\"\n    No disposal is done on this frame before rendering the next frame.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "_OUTMODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "peekOfCode": "_OUTMODES = {\n    # supported PIL modes, and corresponding rawmodes/bits/color combinations\n    \"1\": (\"1\", b\"\\x01\\x00\"),\n    \"L;1\": (\"L;1\", b\"\\x01\\x00\"),\n    \"L;2\": (\"L;2\", b\"\\x02\\x00\"),\n    \"L;4\": (\"L;4\", b\"\\x04\\x00\"),\n    \"L\": (\"L\", b\"\\x08\\x00\"),\n    \"LA\": (\"LA\", b\"\\x08\\x04\"),\n    \"I\": (\"I;16B\", b\"\\x10\\x00\"),\n    \"I;16\": (\"I;16B\", b\"\\x10\\x00\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PngImagePlugin",
        "documentation": {}
    },
    {
        "label": "PpmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "peekOfCode": "class PpmImageFile(ImageFile.ImageFile):\n    format = \"PPM\"\n    format_description = \"Pbmplus image\"\n    def _read_magic(self):\n        magic = b\"\"\n        # read until whitespace or longest available magic number\n        for _ in range(6):\n            c = self.fp.read(1)\n            if not c or c in b_whitespace:\n                break",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PpmPlainDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "peekOfCode": "class PpmPlainDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def _read_block(self):\n        return self.fd.read(ImageFile.SAFEBLOCK)\n    def _find_comment_end(self, block, start=0):\n        a = block.find(b\"\\n\", start)\n        b = block.find(b\"\\r\", start)\n        return min(a, b) if a * b > 0 else max(a, b)  # lowest nonnegative index (or -1)\n    def _ignore_comments(self, block):\n        if self._comment_spans:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PpmDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "peekOfCode": "class PpmDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        data = bytearray()\n        maxval = self.args[-1]\n        in_byte_count = 1 if maxval < 256 else 2\n        out_byte_count = 4 if self.mode == \"I\" else 1\n        out_max = 65535 if self.mode == \"I\" else 255\n        bands = Image.getmodebands(self.mode)\n        while len(data) < self.state.xsize * self.state.ysize * bands * out_byte_count:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "b_whitespace",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "peekOfCode": "b_whitespace = b\"\\x20\\x09\\x0a\\x0b\\x0c\\x0d\"\nMODES = {\n    # standard\n    b\"P1\": \"1\",\n    b\"P2\": \"L\",\n    b\"P3\": \"RGB\",\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "peekOfCode": "MODES = {\n    # standard\n    b\"P1\": \"1\",\n    b\"P2\": \"L\",\n    b\"P3\": \"RGB\",\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions\n    b\"P0CMYK\": \"CMYK\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "PsdImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "peekOfCode": "class PsdImageFile(ImageFile.ImageFile):\n    format = \"PSD\"\n    format_description = \"Adobe Photoshop\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        read = self.fp.read\n        #\n        # header\n        s = read(26)\n        if not _accept(s) or i16(s, 4) != 1:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "peekOfCode": "MODES = {\n    # (photoshop mode, bits) -> (pil mode, required channels)\n    (0, 1): (\"1\", 1),\n    (0, 8): (\"L\", 1),\n    (1, 8): (\"L\", 1),\n    (2, 8): (\"P\", 1),\n    (3, 8): (\"RGB\", 3),\n    (4, 8): (\"CMYK\", 4),\n    (7, 8): (\"L\", 1),  # FIXME: multilayer\n    (8, 8): (\"L\", 1),  # duotone",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PsdImagePlugin",
        "documentation": {}
    },
    {
        "label": "PyAccess",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class PyAccess:\n    def __init__(self, img, readonly=False):\n        deprecate(\"PyAccess\", 11)\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size\n        self._img = img",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_2",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_2(PyAccess):\n    \"\"\"PA, LA, stored in first and last bytes of a 32 bit word\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.a\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_3",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_3(PyAccess):\n    \"\"\"RGB and friends, stored in the first three bytes of a 32 bit word\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess32_4",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccess32_4(PyAccess):\n    \"\"\"RGBA etc, all 4 bytes of a 32 bit word\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b, pixel.a\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccess8",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccess8(PyAccess):\n    \"\"\"1, L, P, 8 bit images stored as uint8\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image8\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 255)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_N",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_N(PyAccess):\n    \"\"\"I;16 access, native bitendian without conversion\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"unsigned short **\", self.image)\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 65535)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_L",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_L(PyAccess):\n    \"\"\"I;16L access, with conversion\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.l + pixel.r * 256\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI16_B",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI16_B(PyAccess):\n    \"\"\"I;16B access, with conversion\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n    def get_pixel(self, x, y):\n        pixel = self.pixels[y][x]\n        return pixel.l * 256 + pixel.r\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI32_N",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI32_N(PyAccess):\n    \"\"\"Signed Int32 access, native endian\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = color\nclass _PyAccessI32_Swap(PyAccess):\n    \"\"\"I;32L/B access, with byteswapping conversion\"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessI32_Swap",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessI32_Swap(PyAccess):\n    \"\"\"I;32L/B access, with byteswapping conversion\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n    def reverse(self, i):\n        orig = ffi.new(\"int *\", i)\n        chars = ffi.cast(\"unsigned char *\", orig)\n        chars[0], chars[1], chars[2], chars[3] = chars[3], chars[2], chars[1], chars[0]\n        return ffi.cast(\"int *\", chars)[0]\n    def get_pixel(self, x, y):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "_PyAccessF",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "class _PyAccessF(PyAccess):\n    \"\"\"32 bit float access\"\"\"\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"float **\", self.image32)\n    def get_pixel(self, x, y):\n        return self.pixels[y][x]\n    def set_pixel(self, x, y, color):\n        try:\n            # not a tuple\n            self.pixels[y][x] = color",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "new",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "def new(img, readonly=False):\n    access_type = mode_map.get(img.mode, None)\n    if not access_type:\n        logger.debug(\"PyAccess Not Implemented: %s\", img.mode)\n        return None\n    return access_type(img, readonly)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass PyAccess:\n    def __init__(self, img, readonly=False):\n        deprecate(\"PyAccess\", 11)\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "mode_map",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "description": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "peekOfCode": "mode_map = {\n    \"1\": _PyAccess8,\n    \"L\": _PyAccess8,\n    \"P\": _PyAccess8,\n    \"I;16N\": _PyAccessI16_N,\n    \"LA\": _PyAccess32_2,\n    \"La\": _PyAccess32_2,\n    \"PA\": _PyAccess32_2,\n    \"RGB\": _PyAccess32_3,\n    \"LAB\": _PyAccess32_3,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.PyAccess",
        "documentation": {}
    },
    {
        "label": "QoiImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "peekOfCode": "class QoiImageFile(ImageFile.ImageFile):\n    format = \"QOI\"\n    format_description = \"Quite OK Image\"\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a QOI file\"\n            raise SyntaxError(msg)\n        self._size = tuple(i32(self.fp.read(4)) for i in range(2))\n        channels = self.fp.read(1)[0]\n        self._mode = \"RGB\" if channels == 3 else \"RGBA\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "documentation": {}
    },
    {
        "label": "QoiDecoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "peekOfCode": "class QoiDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def _add_to_previous_pixels(self, value):\n        self._previous_pixel = value\n        r, g, b, a = value\n        hash_value = (r * 3 + g * 5 + b * 7 + a * 11) % 64\n        self._previously_seen_pixels[hash_value] = value\n    def decode(self, buffer):\n        self._previously_seen_pixels = {}\n        self._previous_pixel = None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.QoiImagePlugin",
        "documentation": {}
    },
    {
        "label": "SgiImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "peekOfCode": "class SgiImageFile(ImageFile.ImageFile):\n    format = \"SGI\"\n    format_description = \"SGI Image File Format\"\n    def _open(self):\n        # HEAD\n        headlen = 512\n        s = self.fp.read(headlen)\n        if not _accept(s):\n            msg = \"Not an SGI image file\"\n            raise ValueError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "SGI16Decoder",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "peekOfCode": "class SGI16Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    def decode(self, buffer):\n        rawmode, stride, orientation = self.args\n        pagesize = self.state.xsize * self.state.ysize\n        zsize = len(self.mode)\n        self.fd.seek(512)\n        for band in range(zsize):\n            channel = Image.new(\"L\", (self.state.xsize, self.state.ysize))\n            channel.frombytes(",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "peekOfCode": "MODES = {\n    (1, 1, 1): \"L\",\n    (1, 2, 1): \"L\",\n    (2, 1, 1): \"L;16B\",\n    (2, 2, 1): \"L;16B\",\n    (1, 3, 3): \"RGB\",\n    (2, 3, 3): \"RGB;16B\",\n    (1, 3, 4): \"RGBA\",\n    (2, 3, 4): \"RGBA;16B\",\n}",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SgiImagePlugin",
        "documentation": {}
    },
    {
        "label": "SpiderImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "class SpiderImageFile(ImageFile.ImageFile):\n    format = \"SPIDER\"\n    format_description = \"Spider 2D image\"\n    _close_exclusive_fp_after_loading = False\n    def _open(self):\n        # check header\n        n = 27 * 4  # read 27 float values\n        f = self.fp.read(n)\n        try:\n            self.bigendian = 1",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isInt",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "def isInt(f):\n    try:\n        i = int(f)\n        if f - i == 0:\n            return 1\n        else:\n            return 0\n    except (ValueError, OverflowError):\n        return 0\niforms = [1, 3, -11, -12, -21, -22]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isSpiderHeader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "def isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):\n            return 0\n    # check iform\n    iform = int(h[5])\n    if iform not in iforms:\n        return 0",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "isSpiderImage",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "def isSpiderImage(filename):\n    with open(filename, \"rb\") as fp:\n        f = fp.read(92)  # read 23 * 4 bytes\n    t = struct.unpack(\">23f\", f)  # try big-endian first\n    hdrlen = isSpiderHeader(t)\n    if hdrlen == 0:\n        t = struct.unpack(\"<23f\", f)  # little-endian\n        hdrlen = isSpiderHeader(t)\n    return hdrlen\nclass SpiderImageFile(ImageFile.ImageFile):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "loadImageSeries",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "def loadImageSeries(filelist=None):\n    \"\"\"create a list of :py:class:`~PIL.Image.Image` objects for use in a montage\"\"\"\n    if filelist is None or len(filelist) < 1:\n        return\n    imglist = []\n    for img in filelist:\n        if not os.path.exists(img):\n            print(f\"unable to find {img}\")\n            continue\n        try:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "makeSpiderHeader",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "def makeSpiderHeader(im):\n    nsam, nrow = im.size\n    lenbyt = nsam * 4  # There are labrec records in the header\n    labrec = int(1024 / lenbyt)\n    if 1024 % lenbyt != 0:\n        labrec += 1\n    labbyt = labrec * lenbyt\n    nvalues = int(labbyt / 4)\n    if nvalues < 23:\n        return []",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "iforms",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "peekOfCode": "iforms = [1, 3, -11, -12, -21, -22]\n# There is no magic number to identify Spider files, so just check a\n# series of header locations to see if they have reasonable values.\n# Returns no. of bytes in the header, if it is a valid Spider header,\n# otherwise returns 0\ndef isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SpiderImagePlugin",
        "documentation": {}
    },
    {
        "label": "SunImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.SunImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.SunImagePlugin",
        "peekOfCode": "class SunImageFile(ImageFile.ImageFile):\n    format = \"SUN\"\n    format_description = \"Sun Raster File\"\n    def _open(self):\n        # The Sun Raster file header is 32 bytes in length\n        # and has the following format:\n        #     typedef struct _SunRaster\n        #     {\n        #         DWORD MagicNumber;      /* Magic (identification) number */\n        #         DWORD Width;            /* Width of image in pixels */",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.SunImagePlugin",
        "documentation": {}
    },
    {
        "label": "TarIO",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TarIO",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TarIO",
        "peekOfCode": "class TarIO(ContainerIO.ContainerIO[bytes]):\n    \"\"\"A file object that provides read access to a given member of a TAR file.\"\"\"\n    def __init__(self, tarfile: str, file: str) -> None:\n        \"\"\"\n        Create file object.\n        :param tarfile: Name of TAR file.\n        :param file: Name of member file.\n        \"\"\"\n        self.fh = open(tarfile, \"rb\")\n        while True:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TarIO",
        "documentation": {}
    },
    {
        "label": "TgaImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "peekOfCode": "class TgaImageFile(ImageFile.ImageFile):\n    format = \"TGA\"\n    format_description = \"Targa\"\n    def _open(self):\n        # process header\n        s = self.fp.read(18)\n        id_len = s[0]\n        colormaptype = s[1]\n        imagetype = s[2]\n        depth = s[16]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "peekOfCode": "MODES = {\n    # map imagetype/depth to rawmode\n    (1, 8): \"P\",\n    (3, 1): \"1\",\n    (3, 8): \"L\",\n    (3, 16): \"LA\",\n    (2, 16): \"BGR;5\",\n    (2, 24): \"BGR\",\n    (2, 32): \"BGRA\",\n}",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "peekOfCode": "SAVE = {\n    \"1\": (\"1\", 1, 0, 3),\n    \"L\": (\"L\", 8, 0, 3),\n    \"LA\": (\"LA\", 16, 0, 3),\n    \"P\": (\"P\", 8, 1, 1),\n    \"RGB\": (\"BGR\", 24, 0, 2),\n    \"RGBA\": (\"BGRA\", 32, 0, 2),\n}\ndef _save(im, fp, filename):\n    try:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TgaImagePlugin",
        "documentation": {}
    },
    {
        "label": "IFDRational",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "class IFDRational(Rational):\n    \"\"\"Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")\n    def __init__(self, value, denominator=1):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "class ImageFileDirectory_v2(MutableMapping):\n    \"\"\"This class represents a TIFF tag directory.  To speed things up, we\n    don't decode tags unless they're asked for.\n    Exposes a dictionary interface of the tags in the directory::\n        ifd = ImageFileDirectory_v2()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        'Some Data'\n    Individual values are returned as the strings or numbers, sequences are",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v1",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "class ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n    Exposes a dictionary interface of the tags in the directory::\n        ifd = ImageFileDirectory_v1()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        ('Some Data',)\n    Also contains a dictionary of tag types as read from the tiff image file,\n    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TiffImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "class TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n    def __init__(self, fp=None, filename=None):\n        self.tag_v2 = None\n        \"\"\" Image file directory (tag dictionary) \"\"\"\n        self.tag = None\n        \"\"\" Legacy tag entries \"\"\"\n        super().__init__(fp, filename)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "AppendingTiffWriter",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "class AppendingTiffWriter:\n    fieldSizes = [\n        0,  # None\n        1,  # byte\n        1,  # ascii\n        2,  # short\n        4,  # long\n        8,  # rational\n        1,  # sbyte\n        1,  # undefined",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Set these to true to force use of libtiff for reading or writing.\nREAD_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nSTRIP_SIZE = 65536\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "READ_LIBTIFF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "READ_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nSTRIP_SIZE = 65536\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "WRITE_LIBTIFF",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "WRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nSTRIP_SIZE = 65536\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IFD_LEGACY_API",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IFD_LEGACY_API = True\nSTRIP_SIZE = 65536\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "STRIP_SIZE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "STRIP_SIZE = 65536\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "II",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "II = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "MM",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "MM = b\"MM\"  # big-endian (Motorola style)\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n# a few tag names, just to make the code below a bit more readable\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEWIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGELENGTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "BITSPERSAMPLE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "BITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PHOTOMETRIC_INTERPRETATION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "PHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "FILLORDER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "FILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEDESCRIPTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "STRIPOFFSETS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "STRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAMPLESPERPIXEL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "SAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ROWSPERSTRIP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "STRIPBYTECOUNTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "STRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "X_RESOLUTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "X_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "Y_RESOLUTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "Y_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PLANAR_CONFIGURATION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "PLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "RESOLUTION_UNIT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "RESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TRANSFERFUNCTION",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "TRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SOFTWARE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "SOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "DATE_TIME",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "DATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ARTIST",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PREDICTOR",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "PREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COLORMAP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "COLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TILEWIDTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "TILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TILELENGTH",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "TILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TILEOFFSETS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "TILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TILEBYTECOUNTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "TILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SUBIFD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "SUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "EXTRASAMPLES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "EXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAMPLEFORMAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "SAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "JPEGTABLES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "JPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "YCBCRSUBSAMPLING",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "YCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "REFERENCEBLACKWHITE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "REFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COPYRIGHT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "COPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IPTC_NAA_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PHOTOSHOP_CHUNK",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "PHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ICCPROFILE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "EXIFIFD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "EXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "XMP",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "XMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "JPEGQUALITY",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "JPEGQUALITY = 65537  # pseudo-tag by libtiff\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEJ_META_DATA_BYTE_COUNTS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "IMAGEJ_META_DATA",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "IMAGEJ_META_DATA = 50839\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",\n    8: \"tiff_adobe_deflate\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "COMPRESSION_INFO_REV",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "COMPRESSION_INFO_REV = {v: k for k, v in COMPRESSION_INFO.items()}\nOPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "OPEN_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "OPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (II, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "MAX_SAMPLESPERPIXEL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "MAX_SAMPLESPERPIXEL = max(len(key_tp[4]) for key_tp in OPEN_INFO)\nPREFIXES = [\n    b\"MM\\x00\\x2A\",  # Valid TIFF header with big-endian byte order\n    b\"II\\x2A\\x00\",  # Valid TIFF header with little-endian byte order\n    b\"MM\\x2A\\x00\",  # Invalid TIFF header, assume big-endian\n    b\"II\\x00\\x2A\",  # Invalid TIFF header, assume little-endian\n    b\"MM\\x00\\x2B\",  # BigTIFF with big-endian byte order\n    b\"II\\x2B\\x00\",  # BigTIFF with little-endian byte order\n]\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "PREFIXES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "PREFIXES = [\n    b\"MM\\x00\\x2A\",  # Valid TIFF header with big-endian byte order\n    b\"II\\x2A\\x00\",  # Valid TIFF header with little-endian byte order\n    b\"MM\\x2A\\x00\",  # Invalid TIFF header, assume big-endian\n    b\"II\\x00\\x2A\",  # Invalid TIFF header, assume little-endian\n    b\"MM\\x00\\x2B\",  # BigTIFF with big-endian byte order\n    b\"II\\x2B\\x00\",  # BigTIFF with little-endian byte order\n]\ndef _accept(prefix):\n    return prefix[:4] in PREFIXES",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "_load_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "_load_dispatch = {}\n_write_dispatch = {}\nclass IFDRational(Rational):\n    \"\"\"Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "_write_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "_write_dispatch = {}\nclass IFDRational(Rational):\n    \"\"\"Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n    \"\"\"\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2._load_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory_v2._load_dispatch = _load_dispatch\nImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, \"load_\" + name, _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, \"write_\" + name, _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory_v2._write_dispatch",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, \"load_\" + name, _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, \"write_\" + name, _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n    Exposes a dictionary interface of the tags in the directory::",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "ImageFileDirectory",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "ImageFileDirectory = ImageFileDirectory_v1\n##\n# Image plugin for TIFF files.\nclass TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n    def __init__(self, fp=None, filename=None):\n        self.tag_v2 = None\n        \"\"\" Image file directory (tag dictionary) \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "SAVE_INFO",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "peekOfCode": "SAVE_INFO = {\n    # mode => rawmode, byteorder, photometrics,\n    #           sampleformat, bitspersample, extra\n    \"1\": (\"1\", II, 1, 1, (1,), None),\n    \"L\": (\"L\", II, 1, 1, (8,), None),\n    \"LA\": (\"LA\", II, 1, 1, (8, 8), 2),\n    \"P\": (\"P\", II, 3, 1, (8,), None),\n    \"PA\": (\"PA\", II, 3, 1, (8, 8), 2),\n    \"I\": (\"I;32S\", II, 1, 2, (32,), None),\n    \"I;16\": (\"I;16\", II, 1, 1, (16,), None),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffImagePlugin",
        "documentation": {}
    },
    {
        "label": "TagInfo",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "class TagInfo(namedtuple(\"_TagInfo\", \"value name type length enum\")):\n    __slots__ = []\n    def __new__(cls, value=None, name=\"unknown\", type=None, length=None, enum=None):\n        return super().__new__(cls, value, name, type, length, enum or {})\n    def cvt_enum(self, value):\n        # Using get will call hash(value), which can be expensive\n        # for some types (e.g. Fraction). Since self.enum is rarely\n        # used, it's usually better to test it first.\n        return self.enum.get(value, value) if self.enum else value\ndef lookup(tag, group=None):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "def lookup(tag, group=None):\n    \"\"\"\n    :param tag: Integer tag number\n    :param group: Which :py:data:`~PIL.TiffTags.TAGS_V2_GROUPS` to look in\n    .. versionadded:: 8.3.0\n    :returns: Taginfo namedtuple, From the ``TAGS_V2`` info if possible,\n        otherwise just populating the value and name from ``TAGS``.\n        If the tag is not recognized, \"unknown\" is returned for the name\n    \"\"\"\n    if group is not None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "BYTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "BYTE = 1\nASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "ASCII",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "ASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SHORT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "SHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "LONG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "LONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "RATIONAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "RATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_BYTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "SIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "UNDEFINED",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "UNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_SHORT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "SIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_LONG",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "SIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "SIGNED_RATIONAL",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "SIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "FLOAT",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "FLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "DOUBLE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "DOUBLE = 12\nIFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "IFD",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "IFD = 13\nLONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "LONG8",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "LONG8 = 16\nTAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TAGS_V2",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "TAGS_V2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,\n        1,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TAGS_V2_GROUPS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "TAGS_V2_GROUPS = {\n    # ExifIFD\n    34665: {\n        36864: (\"ExifVersion\", UNDEFINED, 1),\n        40960: (\"FlashPixVersion\", UNDEFINED, 1),\n        40965: (\"InteroperabilityIFD\", LONG, 1),\n        41730: (\"CFAPattern\", UNDEFINED, 1),\n    },\n    # GPSInfoIFD\n    34853: {",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TAGS",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "TAGS = {\n    347: \"JPEGTables\",\n    700: \"XMP\",\n    # Additional Exif Info\n    32932: \"Wang Annotation\",\n    33434: \"ExposureTime\",\n    33437: \"FNumber\",\n    33445: \"MD FileTag\",\n    33446: \"MD ScalePixel\",\n    33447: \"MD ColorTable\",",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "TYPES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "TYPES = {}\n#\n# These tags are handled by default in libtiff, without\n# adding to the custom dictionary. From tif_dir.c, searching for\n# case TIFFTAG in the _TIFFVSetField function:\n# Line: item.\n# 148: case TIFFTAG_SUBFILETYPE:\n# 151: case TIFFTAG_IMAGEWIDTH:\n# 154: case TIFFTAG_IMAGELENGTH:\n# 157: case TIFFTAG_BITSPERSAMPLE:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "LIBTIFF_CORE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "description": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "peekOfCode": "LIBTIFF_CORE = {\n    255,\n    256,\n    257,\n    258,\n    259,\n    262,\n    263,\n    266,\n    274,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.TiffTags",
        "documentation": {}
    },
    {
        "label": "WalImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "peekOfCode": "class WalImageFile(ImageFile.ImageFile):\n    format = \"WAL\"\n    format_description = \"Quake2 Texture\"\n    def _open(self):\n        self._mode = \"P\"\n        # read header fields\n        header = self.fp.read(32 + 24 + 32 + 12)\n        self._size = i32(header, 32), i32(header, 36)\n        Image._decompression_bomb_check(self.size)\n        # load pixel data",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "documentation": {}
    },
    {
        "label": "open",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "peekOfCode": "def open(filename):\n    \"\"\"\n    Load texture from a Quake2 WAL texture file.\n    By default, a Quake2 standard palette is attached to the texture.\n    To override the palette, use the :py:func:`PIL.Image.Image.putpalette()` method.\n    :param filename: WAL file name, or an opened file handle.\n    :returns: An image instance.\n    \"\"\"\n    return WalImageFile(filename)\nquake2palette = (",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "documentation": {}
    },
    {
        "label": "quake2palette",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "peekOfCode": "quake2palette = (\n    # default palette taken from piffo 0.93 by Hans Häggström\n    b\"\\x01\\x01\\x01\\x0b\\x0b\\x0b\\x12\\x12\\x12\\x17\\x17\\x17\\x1b\\x1b\\x1b\\x1e\"\n    b\"\\x1e\\x1e\\x22\\x22\\x22\\x26\\x26\\x26\\x29\\x29\\x29\\x2c\\x2c\\x2c\\x2f\\x2f\"\n    b\"\\x2f\\x32\\x32\\x32\\x35\\x35\\x35\\x37\\x37\\x37\\x3a\\x3a\\x3a\\x3c\\x3c\\x3c\"\n    b\"\\x24\\x1e\\x13\\x22\\x1c\\x12\\x20\\x1b\\x12\\x1f\\x1a\\x10\\x1d\\x19\\x10\\x1b\"\n    b\"\\x17\\x0f\\x1a\\x16\\x0f\\x18\\x14\\x0d\\x17\\x13\\x0d\\x16\\x12\\x0d\\x14\\x10\"\n    b\"\\x0b\\x13\\x0f\\x0b\\x10\\x0d\\x0a\\x0f\\x0b\\x0a\\x0d\\x0b\\x07\\x0b\\x0a\\x07\"\n    b\"\\x23\\x23\\x26\\x22\\x22\\x25\\x22\\x20\\x23\\x21\\x1f\\x22\\x20\\x1e\\x20\\x1f\"\n    b\"\\x1d\\x1e\\x1d\\x1b\\x1c\\x1b\\x1a\\x1a\\x1a\\x19\\x19\\x18\\x17\\x17\\x17\\x16\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WalImageFile",
        "documentation": {}
    },
    {
        "label": "WebPImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "peekOfCode": "class WebPImageFile(ImageFile.ImageFile):\n    format = \"WEBP\"\n    format_description = \"WebP image\"\n    __loaded = 0\n    __logical_frame = 0\n    def _open(self):\n        if not _webp.HAVE_WEBPANIM:\n            # Legacy mode\n            data, width, height, self._mode, icc_profile, exif = _webp.WebPDecode(\n                self.fp.read()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VALID_WEBP_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "peekOfCode": "_VALID_WEBP_MODES = {\"RGBX\": True, \"RGBA\": True, \"RGB\": True}\n_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VALID_WEBP_LEGACY_MODES",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "peekOfCode": "_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "_VP8_MODES_BY_IDENTIFIER",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "peekOfCode": "_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\ndef _accept(prefix):\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER\n    if is_riff_file_format and is_webp_file and is_valid_vp8_mode:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WebPImagePlugin",
        "documentation": {}
    },
    {
        "label": "WmfStubImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "peekOfCode": "class WmfStubImageFile(ImageFile.StubImageFile):\n    format = \"WMF\"\n    format_description = \"Windows Metafile\"\n    def _open(self):\n        self._inch = None\n        # check placable header\n        s = self.fp.read(80)\n        if s[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\":\n            # placeable windows metafile\n            # get units per inch",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "register_handler",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "peekOfCode": "def register_handler(handler):\n    \"\"\"\n    Install application-specific WMF image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\nif hasattr(Image.core, \"drawwmf\"):\n    # install default handler (windows only)\n    class WmfHandler:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "_handler",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "peekOfCode": "_handler = None\ndef register_handler(handler):\n    \"\"\"\n    Install application-specific WMF image handler.\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\nif hasattr(Image.core, \"drawwmf\"):\n    # install default handler (windows only)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.WmfImagePlugin",
        "documentation": {}
    },
    {
        "label": "XVThumbImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "peekOfCode": "class XVThumbImageFile(ImageFile.ImageFile):\n    format = \"XVThumb\"\n    format_description = \"XV thumbnail image\"\n    def _open(self):\n        # check magic\n        if not _accept(self.fp.read(6)):\n            msg = \"not an XV thumbnail file\"\n            raise SyntaxError(msg)\n        # Skip to beginning of next line\n        self.fp.readline()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "_MAGIC",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "peekOfCode": "_MAGIC = b\"P7 332\"\n# standard color palette for thumbnails (RGB332)\nPALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "PALETTE",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "peekOfCode": "PALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\ndef _accept(prefix):\n    return prefix[:6] == _MAGIC\n##",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XVThumbImagePlugin",
        "documentation": {}
    },
    {
        "label": "XbmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "peekOfCode": "class XbmImageFile(ImageFile.ImageFile):\n    format = \"XBM\"\n    format_description = \"X11 Bitmap\"\n    def _open(self):\n        m = xbm_head.match(self.fp.read(512))\n        if not m:\n            msg = \"not a XBM file\"\n            raise SyntaxError(msg)\n        xsize = int(m.group(\"width\"))\n        ysize = int(m.group(\"height\"))",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "documentation": {}
    },
    {
        "label": "xbm_head",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "peekOfCode": "xbm_head = re.compile(\n    rb\"\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+.*_height[ \\t]+(?P<height>[0-9]+)[\\r\\n]+\"\n    b\"(?P<hotspot>\"\n    b\"#define[ \\t]+[^_]*_x_hot[ \\t]+(?P<xhot>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+[^_]*_y_hot[ \\t]+(?P<yhot>[0-9]+)[\\r\\n]+\"\n    b\")?\"\n    rb\"[\\000-\\377]*_bits\\[]\"\n)\ndef _accept(prefix):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XbmImagePlugin",
        "documentation": {}
    },
    {
        "label": "XpmImageFile",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "peekOfCode": "class XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n    def _open(self):\n        if not _accept(self.fp.read(9)):\n            msg = \"not an XPM file\"\n            raise SyntaxError(msg)\n        # skip forward to next string\n        while True:\n            s = self.fp.readline()",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "xpm_head",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "description": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "peekOfCode": "xpm_head = re.compile(b'\"([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)')\ndef _accept(prefix):\n    return prefix[:9] == b\"/* XPM */\"\n##\n# Image plugin for X11 pixel maps.\nclass XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n    def _open(self):\n        if not _accept(self.fp.read(9)):",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.XpmImagePlugin",
        "documentation": {}
    },
    {
        "label": "i8",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def i8(c: bytes) -> int:\n    return c[0]\ndef o8(i: int) -> bytes:\n    return bytes((i & 255,))\n# Input, le = little endian, be = big endian\ndef i16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o8",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def o8(i: int) -> bytes:\n    return bytes((i & 255,))\n# Input, le = little endian, be = big endian\ndef i16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<H\", c, o)[0]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def i16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<H\", c, o)[0]\ndef si16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "si16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def si16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<h\", c, o)[0]\ndef si16be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer, big endian.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "si16be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def si16be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer, big endian.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\">h\", c, o)[0]\ndef i32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def i32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<I\", c, o)[0]\ndef si32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "si32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def si32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<i\", c, o)[0]\ndef i16be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">H\", c, o)[0]\ndef i32be(c: bytes, o: int = 0) -> int:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i16be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def i16be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">H\", c, o)[0]\ndef i32be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">I\", c, o)[0]\n# Output, le = little endian, be = big endian\ndef o16le(i: int) -> bytes:\n    return pack(\"<H\", i)\ndef o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\ndef o16be(i: int) -> bytes:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "i32be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def i32be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">I\", c, o)[0]\n# Output, le = little endian, be = big endian\ndef o16le(i: int) -> bytes:\n    return pack(\"<H\", i)\ndef o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\ndef o16be(i: int) -> bytes:\n    return pack(\">H\", i)\ndef o32be(i: int) -> bytes:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o16le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def o16le(i: int) -> bytes:\n    return pack(\"<H\", i)\ndef o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\ndef o16be(i: int) -> bytes:\n    return pack(\">H\", i)\ndef o32be(i: int) -> bytes:\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o32le",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\ndef o16be(i: int) -> bytes:\n    return pack(\">H\", i)\ndef o32be(i: int) -> bytes:\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o16be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def o16be(i: int) -> bytes:\n    return pack(\">H\", i)\ndef o32be(i: int) -> bytes:\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "o32be",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "description": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "peekOfCode": "def o32be(i: int) -> bytes:\n    return pack(\">I\", i)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._binary",
        "documentation": {}
    },
    {
        "label": "deprecate",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._deprecate",
        "description": "catboost.contrib.python.Pillow.py3.PIL._deprecate",
        "peekOfCode": "def deprecate(\n    deprecated: str,\n    when: int | None,\n    replacement: str | None = None,\n    *,\n    action: str | None = None,\n    plural: bool = False,\n) -> None:\n    \"\"\"\n    Deprecations helper.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._deprecate",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._typing",
        "description": "catboost.contrib.python.Pillow.py3.PIL._typing",
        "peekOfCode": "__all__ = [\"TypeGuard\"]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._typing",
        "documentation": {}
    },
    {
        "label": "DeferredError",
        "kind": 6,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._util",
        "description": "catboost.contrib.python.Pillow.py3.PIL._util",
        "peekOfCode": "class DeferredError:\n    def __init__(self, ex: BaseException):\n        self.ex = ex\n    def __getattr__(self, elt: str) -> NoReturn:\n        raise self.ex\n    @staticmethod\n    def new(ex: BaseException) -> Any:\n        \"\"\"\n        Creates an object that raises the wrapped exception ``ex`` when used,\n        and casts it to :py:obj:`~typing.Any` type.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._util",
        "documentation": {}
    },
    {
        "label": "is_path",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._util",
        "description": "catboost.contrib.python.Pillow.py3.PIL._util",
        "peekOfCode": "def is_path(f: Any) -> TypeGuard[bytes | str | Path]:\n    return isinstance(f, (bytes, str, Path))\ndef is_directory(f: Any) -> TypeGuard[bytes | str | Path]:\n    \"\"\"Checks if an object is a string, and that it points to a directory.\"\"\"\n    return is_path(f) and os.path.isdir(f)\nclass DeferredError:\n    def __init__(self, ex: BaseException):\n        self.ex = ex\n    def __getattr__(self, elt: str) -> NoReturn:\n        raise self.ex",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._util",
        "documentation": {}
    },
    {
        "label": "is_directory",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._util",
        "description": "catboost.contrib.python.Pillow.py3.PIL._util",
        "peekOfCode": "def is_directory(f: Any) -> TypeGuard[bytes | str | Path]:\n    \"\"\"Checks if an object is a string, and that it points to a directory.\"\"\"\n    return is_path(f) and os.path.isdir(f)\nclass DeferredError:\n    def __init__(self, ex: BaseException):\n        self.ex = ex\n    def __getattr__(self, elt: str) -> NoReturn:\n        raise self.ex\n    @staticmethod\n    def new(ex: BaseException) -> Any:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._util",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL._version",
        "description": "catboost.contrib.python.Pillow.py3.PIL._version",
        "peekOfCode": "__version__ = \"10.2.0\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL._version",
        "documentation": {}
    },
    {
        "label": "check_module",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def check_module(feature):\n    \"\"\"\n    Checks if a module is available.\n    :param feature: The module to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in modules:\n        msg = f\"Unknown module {feature}\"\n        raise ValueError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "version_module",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def version_module(feature):\n    \"\"\"\n    :param feature: The module to check for.\n    :returns:\n        The loaded version number as a string, or ``None`` if unknown or not available.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if not check_module(feature):\n        return None\n    module, ver = modules[feature]",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_modules",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def get_supported_modules():\n    \"\"\"\n    :returns: A list of all supported modules.\n    \"\"\"\n    return [f for f in modules if check_module(f)]\ncodecs = {\n    \"jpg\": (\"jpeg\", \"jpeglib\"),\n    \"jpg_2000\": (\"jpeg2k\", \"jp2klib\"),\n    \"zlib\": (\"zip\", \"zlib\"),\n    \"libtiff\": (\"libtiff\", \"libtiff\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "check_codec",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def check_codec(feature):\n    \"\"\"\n    Checks if a codec is available.\n    :param feature: The codec to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in codecs:\n        msg = f\"Unknown codec {feature}\"\n        raise ValueError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "version_codec",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def version_codec(feature):\n    \"\"\"\n    :param feature: The codec to check for.\n    :returns:\n        The version number as a string, or ``None`` if not available.\n        Checked at compile time for ``jpg``, run-time otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if not check_codec(feature):\n        return None",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_codecs",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def get_supported_codecs():\n    \"\"\"\n    :returns: A list of all supported codecs.\n    \"\"\"\n    return [f for f in codecs if check_codec(f)]\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\", None),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\", None),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\", None),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\", \"raqm_version\"),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "check_feature",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def check_feature(feature):\n    \"\"\"\n    Checks if a feature is available.\n    :param feature: The feature to check for.\n    :returns: ``True`` if available, ``False`` if unavailable, ``None`` if unknown.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in features:\n        msg = f\"Unknown feature {feature}\"\n        raise ValueError(msg)",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "version_feature",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def version_feature(feature):\n    \"\"\"\n    :param feature: The feature to check for.\n    :returns: The version number as a string, or ``None`` if not available.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if not check_feature(feature):\n        return None\n    module, flag, ver = features[feature]\n    if ver is None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported_features",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def get_supported_features():\n    \"\"\"\n    :returns: A list of all supported features.\n    \"\"\"\n    return [f for f in features if check_feature(f)]\ndef check(feature):\n    \"\"\"\n    :param feature: A module, codec, or feature name.\n    :returns:\n        ``True`` if the module, codec, or feature is available,",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def check(feature):\n    \"\"\"\n    :param feature: A module, codec, or feature name.\n    :returns:\n        ``True`` if the module, codec, or feature is available,\n        ``False`` or ``None`` otherwise.\n    \"\"\"\n    if feature in modules:\n        return check_module(feature)\n    if feature in codecs:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def version(feature):\n    \"\"\"\n    :param feature:\n        The module, codec, or feature to check for.\n    :returns:\n        The version number as a string, or ``None`` if unknown or not available.\n    \"\"\"\n    if feature in modules:\n        return version_module(feature)\n    if feature in codecs:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "get_supported",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def get_supported():\n    \"\"\"\n    :returns: A list of all supported modules, features, and codecs.\n    \"\"\"\n    ret = get_supported_modules()\n    ret.extend(get_supported_features())\n    ret.extend(get_supported_codecs())\n    return ret\ndef pilinfo(out=None, supported_formats=True):\n    \"\"\"",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "pilinfo",
        "kind": 2,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "def pilinfo(out=None, supported_formats=True):\n    \"\"\"\n    Prints information about this installation of Pillow.\n    This function can be called with ``python3 -m PIL``.\n    :param out:\n        The output stream to print to. Defaults to ``sys.stdout`` if ``None``.\n    :param supported_formats:\n        If ``True``, a list of all supported image file formats will be printed.\n    \"\"\"\n    if out is None:",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "modules",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "modules = {\n    \"pil\": (\"PIL._imaging\", \"PILLOW_VERSION\"),\n    \"tkinter\": (\"PIL._tkinter_finder\", \"tk_version\"),\n    \"freetype2\": (\"PIL._imagingft\", \"freetype2_version\"),\n    \"littlecms2\": (\"PIL._imagingcms\", \"littlecms_version\"),\n    \"webp\": (\"PIL._webp\", \"webpdecoder_version\"),\n}\ndef check_module(feature):\n    \"\"\"\n    Checks if a module is available.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "codecs = {\n    \"jpg\": (\"jpeg\", \"jpeglib\"),\n    \"jpg_2000\": (\"jpeg2k\", \"jp2klib\"),\n    \"zlib\": (\"zip\", \"zlib\"),\n    \"libtiff\": (\"libtiff\", \"libtiff\"),\n}\ndef check_codec(feature):\n    \"\"\"\n    Checks if a codec is available.\n    :param feature: The codec to check for.",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "features",
        "kind": 5,
        "importPath": "catboost.contrib.python.Pillow.py3.PIL.features",
        "description": "catboost.contrib.python.Pillow.py3.PIL.features",
        "peekOfCode": "features = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\", None),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\", None),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\", None),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\", \"raqm_version\"),\n    \"fribidi\": (\"PIL._imagingft\", \"HAVE_FRIBIDI\", \"fribidi_version\"),\n    \"harfbuzz\": (\"PIL._imagingft\", \"HAVE_HARFBUZZ\", \"harfbuzz_version\"),\n    \"libjpeg_turbo\": (\"PIL._imaging\", \"HAVE_LIBJPEGTURBO\", \"libjpeg_turbo_version\"),\n    \"libimagequant\": (\"PIL._imaging\", \"HAVE_LIBIMAGEQUANT\", \"imagequant_version\"),\n    \"xcb\": (\"PIL._imaging\", \"HAVE_XCB\", None),",
        "detail": "catboost.contrib.python.Pillow.py3.PIL.features",
        "documentation": {}
    },
    {
        "label": "ComposerError",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "peekOfCode": "class ComposerError(MarkedYAMLError):\n    pass\nclass Composer(object):\n    def __init__(self):\n        self.anchors = {}\n    def check_node(self):\n        # Drop the STREAM-START event.\n        if self.check_event(StreamStartEvent):\n            self.get_event()\n        # If there are more documents available?",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "documentation": {}
    },
    {
        "label": "Composer",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "peekOfCode": "class Composer(object):\n    def __init__(self):\n        self.anchors = {}\n    def check_node(self):\n        # Drop the STREAM-START event.\n        if self.check_event(StreamStartEvent):\n            self.get_event()\n        # If there are more documents available?\n        return not self.check_event(StreamEndEvent)\n    def get_node(self):",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "peekOfCode": "__all__ = ['Composer', 'ComposerError']\nfrom error import MarkedYAMLError\nfrom events import *\nfrom nodes import *\nclass ComposerError(MarkedYAMLError):\n    pass\nclass Composer(object):\n    def __init__(self):\n        self.anchors = {}\n    def check_node(self):",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.composer",
        "documentation": {}
    },
    {
        "label": "ConstructorError",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class ConstructorError(MarkedYAMLError):\n    pass\nclass timezone(datetime.tzinfo):\n    def __init__(self, offset):\n        self._offset = offset\n        seconds = abs(offset).total_seconds()\n        self._name = 'UTC%s%02d:%02d' % (\n            '-' if offset.days < 0 else '+',\n            seconds // 3600,\n            seconds % 3600 // 60",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "timezone",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class timezone(datetime.tzinfo):\n    def __init__(self, offset):\n        self._offset = offset\n        seconds = abs(offset).total_seconds()\n        self._name = 'UTC%s%02d:%02d' % (\n            '-' if offset.days < 0 else '+',\n            seconds // 3600,\n            seconds % 3600 // 60\n        )\n    def tzname(self, dt=None):",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "BaseConstructor",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class BaseConstructor(object):\n    yaml_constructors = {}\n    yaml_multi_constructors = {}\n    def __init__(self):\n        self.constructed_objects = {}\n        self.recursive_objects = {}\n        self.state_generators = []\n        self.deep_construct = False\n    def check_data(self):\n        # If there are more documents available?",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "SafeConstructor",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class SafeConstructor(BaseConstructor):\n    def construct_scalar(self, node):\n        if isinstance(node, MappingNode):\n            for key_node, value_node in node.value:\n                if key_node.tag == u'tag:yaml.org,2002:value':\n                    return self.construct_scalar(value_node)\n        return BaseConstructor.construct_scalar(self, node)\n    def flatten_mapping(self, node):\n        merge = []\n        index = 0",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "FullConstructor",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class FullConstructor(SafeConstructor):\n    # 'extend' is blacklisted because it is used by\n    # construct_python_object_apply to add `listitems` to a newly generate\n    # python instance\n    def get_state_keys_blacklist(self):\n        return ['^extend$', '^__.*__$']\n    def get_state_keys_blacklist_regexp(self):\n        if not hasattr(self, 'state_keys_blacklist_regexp'):\n            self.state_keys_blacklist_regexp = re.compile('(' + '|'.join(self.get_state_keys_blacklist()) + ')')\n        return self.state_keys_blacklist_regexp",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "UnsafeConstructor",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class UnsafeConstructor(FullConstructor):\n    def find_python_module(self, name, mark):\n        return super(UnsafeConstructor, self).find_python_module(name, mark, unsafe=True)\n    def find_python_name(self, name, mark):\n        return super(UnsafeConstructor, self).find_python_name(name, mark, unsafe=True)\n    def make_python_instance(self, suffix, node, args=None, kwds=None, newobj=False):\n        return super(UnsafeConstructor, self).make_python_instance(\n            suffix, node, args, kwds, newobj, unsafe=True)\n    def set_python_instance_state(self, instance, state):\n        return super(UnsafeConstructor, self).set_python_instance_state(",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "Constructor",
        "kind": 6,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "class Constructor(UnsafeConstructor):\n    pass",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "description": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "peekOfCode": "__all__ = [\n    'BaseConstructor',\n    'SafeConstructor',\n    'FullConstructor',\n    'UnsafeConstructor',\n    'Constructor',\n    'ConstructorError'\n]\nfrom error import *\nfrom nodes import *",
        "detail": "catboost.contrib.python.PyYAML.py2.yaml.constructor",
        "documentation": {}
    }
]